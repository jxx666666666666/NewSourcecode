!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).TGApp = {}) }(this, (function (exports) {
   "use strict"; class About { constructor() { this.version = "3.3.3", this.buildDateTime = "2022/7/14 GMT+8 18:13:39" } print() { console.log(`TGApp SDK ${this.version}, built at ${this.buildDateTime}, Copyright Digital Hail.`) } } class TGInterface { constructor(e, t) { if (2 !== arguments.length) throw new Error("接口构造器参数必须是两个。"); this.name = e, this.methods = []; for (var i = 0; i < t.length; i++) { if ("string" != typeof t[i]) throw new Error("接口实现的函数名称必须是字符串。"); this.methods.push(t[i]) } } } TGInterface.ensureImplements = function (e) { if (arguments.length < 2) throw new Error("接口检查失败：参数必须多于 2 个。"); for (var t = 1, i = arguments.length; t < i; t++) { var r = arguments[t]; if (r.constructor !== TGInterface) throw new Error("接口检查失败：必须传入接口对象。"); for (var n = [], a = 0; a < r.methods.length; a++) { var o = r.methods[a]; e[o] && "function" == typeof e[o] || n.push(o) } if (n.length > 0) throw new Error(`接口检查失败：以下接口方法未被实现（${n.join(", ")}）。`) } }; var TGRendererInterface = new TGInterface("TGRendererInterface", []), commonjsGlobal$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function getDefaultExportFromCjs(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } function commonjsRequire$1(e) { throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.') } var adapterLatest = { exports: {} }; !function (e, t) { e.exports = function () { function e(t, i, r) { function n(o, s) { if (!i[o]) { if (!t[o]) { var l = "function" == typeof commonjsRequire$1 && commonjsRequire$1; if (!s && l) return l(o, !0); if (a) return a(o, !0); var c = new Error("Cannot find module '" + o + "'"); throw c.code = "MODULE_NOT_FOUND", c } var h = i[o] = { exports: {} }; t[o][0].call(h.exports, (function (e) { return n(t[o][1][e] || e) }), h, h.exports, e, t, i, r) } return i[o].exports } for (var a = "function" == typeof commonjsRequire$1 && commonjsRequire$1, o = 0; o < r.length; o++)n(r[o]); return n } return e }()({ 1: [function (e, t, i) { var r = (0, e("./adapter_factory.js").adapterFactory)({ window: "undefined" == typeof window ? void 0 : window }); t.exports = r }, { "./adapter_factory.js": 2 }], 2: [function (e, t, i) { Object.defineProperty(i, "__esModule", { value: !0 }), i.adapterFactory = h; var r = c(e("./utils")), n = c(e("./chrome/chrome_shim")), a = c(e("./firefox/firefox_shim")), o = c(e("./safari/safari_shim")), s = c(e("./common_shim")), l = c(e("sdp")); function c(e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t.default = e, t } function h() { var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).window, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: !0, shimFirefox: !0, shimSafari: !0 }, i = r.log, c = r.detectBrowser(e), h = { browserDetails: c, commonShim: s, extractVersion: r.extractVersion, disableLog: r.disableLog, disableWarnings: r.disableWarnings, sdp: l }; switch (c.browser) { case "chrome": if (!n || !n.shimPeerConnection || !t.shimChrome) return i("Chrome shim is not included in this adapter release."), h; if (null === c.version) return i("Chrome shim can not determine version, not shimming."), h; i("adapter.js shimming chrome."), h.browserShim = n, s.shimAddIceCandidateNullOrEmpty(e, c), s.shimParameterlessSetLocalDescription(e, c), n.shimGetUserMedia(e, c), n.shimMediaStream(e, c), n.shimPeerConnection(e, c), n.shimOnTrack(e, c), n.shimAddTrackRemoveTrack(e, c), n.shimGetSendersWithDtmf(e, c), n.shimGetStats(e, c), n.shimSenderReceiverGetStats(e, c), n.fixNegotiationNeeded(e, c), s.shimRTCIceCandidate(e, c), s.shimConnectionState(e, c), s.shimMaxMessageSize(e, c), s.shimSendThrowTypeError(e, c), s.removeExtmapAllowMixed(e, c); break; case "firefox": if (!a || !a.shimPeerConnection || !t.shimFirefox) return i("Firefox shim is not included in this adapter release."), h; i("adapter.js shimming firefox."), h.browserShim = a, s.shimAddIceCandidateNullOrEmpty(e, c), s.shimParameterlessSetLocalDescription(e, c), a.shimGetUserMedia(e, c), a.shimPeerConnection(e, c), a.shimOnTrack(e, c), a.shimRemoveStream(e, c), a.shimSenderGetStats(e, c), a.shimReceiverGetStats(e, c), a.shimRTCDataChannel(e, c), a.shimAddTransceiver(e, c), a.shimGetParameters(e, c), a.shimCreateOffer(e, c), a.shimCreateAnswer(e, c), s.shimRTCIceCandidate(e, c), s.shimConnectionState(e, c), s.shimMaxMessageSize(e, c), s.shimSendThrowTypeError(e, c); break; case "safari": if (!o || !t.shimSafari) return i("Safari shim is not included in this adapter release."), h; i("adapter.js shimming safari."), h.browserShim = o, s.shimAddIceCandidateNullOrEmpty(e, c), s.shimParameterlessSetLocalDescription(e, c), o.shimRTCIceServerUrls(e, c), o.shimCreateOfferLegacy(e, c), o.shimCallbacksAPI(e, c), o.shimLocalStreamsAPI(e, c), o.shimRemoteStreamsAPI(e, c), o.shimTrackEventTransceiver(e, c), o.shimGetUserMedia(e, c), o.shimAudioContext(e, c), s.shimRTCIceCandidate(e, c), s.shimMaxMessageSize(e, c), s.shimSendThrowTypeError(e, c), s.removeExtmapAllowMixed(e, c); break; default: i("Unsupported browser!") }return h } }, { "./chrome/chrome_shim": 3, "./common_shim": 6, "./firefox/firefox_shim": 7, "./safari/safari_shim": 10, "./utils": 11, sdp: 12 }], 3: [function (e, t, i) { Object.defineProperty(i, "__esModule", { value: !0 }), i.shimGetDisplayMedia = i.shimGetUserMedia = void 0; var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, n = e("./getusermedia"); Object.defineProperty(i, "shimGetUserMedia", { enumerable: !0, get: function () { return n.shimGetUserMedia } }); var a = e("./getdisplaymedia"); Object.defineProperty(i, "shimGetDisplayMedia", { enumerable: !0, get: function () { return a.shimGetDisplayMedia } }), i.shimMediaStream = c, i.shimOnTrack = h, i.shimGetSendersWithDtmf = u, i.shimGetStats = d, i.shimSenderReceiverGetStats = p, i.shimAddTrackRemoveTrackWithNative = f, i.shimAddTrackRemoveTrack = m, i.shimPeerConnection = g, i.fixNegotiationNeeded = y; var o = s(e("../utils.js")); function s(e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t.default = e, t } function l(e, t, i) { return t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } function c(e) { e.MediaStream = e.MediaStream || e.webkitMediaStream } function h(e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) { Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", { get: function () { return this._ontrack }, set: function (e) { this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e) }, enumerable: !0, configurable: !0 }); var t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { var i = this; return this._ontrackpoly || (this._ontrackpoly = function (t) { t.stream.addEventListener("addtrack", (function (r) { var n = void 0; n = e.RTCPeerConnection.prototype.getReceivers ? i.getReceivers().find((function (e) { return e.track && e.track.id === r.track.id })) : { track: r.track }; var a = new Event("track"); a.track = r.track, a.receiver = n, a.transceiver = { receiver: n }, a.streams = [t.stream], i.dispatchEvent(a) })), t.stream.getTracks().forEach((function (r) { var n = void 0; n = e.RTCPeerConnection.prototype.getReceivers ? i.getReceivers().find((function (e) { return e.track && e.track.id === r.id })) : { track: r }; var a = new Event("track"); a.track = r, a.receiver = n, a.transceiver = { receiver: n }, a.streams = [t.stream], i.dispatchEvent(a) })) }, this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments) } } else o.wrapPeerConnectionEvent(e, "track", (function (e) { return e.transceiver || Object.defineProperty(e, "transceiver", { value: { receiver: e.receiver } }), e })) } function u(e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) { var t = function (e, t) { return { track: t, get dtmf() { return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf }, _pc: e } }; if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders = function () { return this._senders = this._senders || [], this._senders.slice() }; var i = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, r) { var n = i.apply(this, arguments); return n || (n = t(this, e), this._senders.push(n)), n }; var n = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { n.apply(this, arguments); var t = this._senders.indexOf(e); -1 !== t && this._senders.splice(t, 1) } } var a = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { var i = this; this._senders = this._senders || [], a.apply(this, [e]), e.getTracks().forEach((function (e) { i._senders.push(t(i, e)) })) }; var o = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { var t = this; this._senders = this._senders || [], o.apply(this, [e]), e.getTracks().forEach((function (e) { var i = t._senders.find((function (t) { return t.track === e })); i && t._senders.splice(t._senders.indexOf(i), 1) })) } } else if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) { var s = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { var e = this, t = s.apply(this, []); return t.forEach((function (t) { return t._pc = e })), t }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get: function () { return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf } }) } } function d(e) { if (e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { var e = this, i = Array.prototype.slice.call(arguments), r = i[0], n = i[1], a = i[2]; if (arguments.length > 0 && "function" == typeof r) return t.apply(this, arguments); if (0 === t.length && (0 === arguments.length || "function" != typeof r)) return t.apply(this, []); var o = function (e) { var t = {}; return e.result().forEach((function (e) { var i = { id: e.id, timestamp: e.timestamp, type: { localcandidate: "local-candidate", remotecandidate: "remote-candidate" }[e.type] || e.type }; e.names().forEach((function (t) { i[t] = e.stat(t) })), t[i.id] = i })), t }, s = function (e) { return new Map(Object.keys(e).map((function (t) { return [t, e[t]] }))) }; if (arguments.length >= 2) { var l = function (e) { n(s(o(e))) }; return t.apply(this, [l, r]) } return new Promise((function (i, r) { t.apply(e, [function (e) { i(s(o(e))) }, r]) })).then(n, a) } } } function p(e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver) { if (!("getStats" in e.RTCRtpSender.prototype)) { var t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { var e = this, i = t.apply(this, []); return i.forEach((function (t) { return t._pc = e })), i }); var i = e.RTCPeerConnection.prototype.addTrack; i && (e.RTCPeerConnection.prototype.addTrack = function () { var e = i.apply(this, arguments); return e._pc = this, e }), e.RTCRtpSender.prototype.getStats = function () { var e = this; return this._pc.getStats().then((function (t) { return o.filterStats(t, e.track, !0) })) } } if (!("getStats" in e.RTCRtpReceiver.prototype)) { var n = e.RTCPeerConnection.prototype.getReceivers; n && (e.RTCPeerConnection.prototype.getReceivers = function () { var e = this, t = n.apply(this, []); return t.forEach((function (t) { return t._pc = e })), t }), o.wrapPeerConnectionEvent(e, "track", (function (e) { return e.receiver._pc = e.srcElement, e })), e.RTCRtpReceiver.prototype.getStats = function () { var e = this; return this._pc.getStats().then((function (t) { return o.filterStats(t, e.track, !1) })) } } if ("getStats" in e.RTCRtpSender.prototype && "getStats" in e.RTCRtpReceiver.prototype) { var a = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) { var t = arguments[0], i = void 0, r = void 0, n = void 0; return this.getSenders().forEach((function (e) { e.track === t && (i ? n = !0 : i = e) })), this.getReceivers().forEach((function (e) { return e.track === t && (r ? n = !0 : r = e), e.track === t })), n || i && r ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : i ? i.getStats() : r ? r.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError")) } return a.apply(this, arguments) } } } } function f(e) { e.RTCPeerConnection.prototype.getLocalStreams = function () { var e = this; return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((function (t) { return e._shimmedLocalStreams[t][0] })) }; var t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack = function (e, i) { if (!i) return t.apply(this, arguments); this._shimmedLocalStreams = this._shimmedLocalStreams || {}; var r = t.apply(this, arguments); return this._shimmedLocalStreams[i.id] ? -1 === this._shimmedLocalStreams[i.id].indexOf(r) && this._shimmedLocalStreams[i.id].push(r) : this._shimmedLocalStreams[i.id] = [i, r], r }; var i = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (e) { var t = this; this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach((function (e) { if (t.getSenders().find((function (t) { return t.track === e }))) throw new DOMException("Track already exists.", "InvalidAccessError") })); var r = this.getSenders(); i.apply(this, arguments); var n = this.getSenders().filter((function (e) { return -1 === r.indexOf(e) })); this._shimmedLocalStreams[e.id] = [e].concat(n) }; var r = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], r.apply(this, arguments) }; var n = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = function (e) { var t = this; return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach((function (i) { var r = t._shimmedLocalStreams[i].indexOf(e); -1 !== r && t._shimmedLocalStreams[i].splice(r, 1), 1 === t._shimmedLocalStreams[i].length && delete t._shimmedLocalStreams[i] })), n.apply(this, arguments) } } function m(e, t) { if (e.RTCPeerConnection) { if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return f(e); var i = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams = function () { var e = this, t = i.apply(this); return this._reverseStreams = this._reverseStreams || {}, t.map((function (t) { return e._reverseStreams[t.id] })) }; var r = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream = function (t) { var i = this; if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach((function (e) { if (i.getSenders().find((function (t) { return t.track === e }))) throw new DOMException("Track already exists.", "InvalidAccessError") })), !this._reverseStreams[t.id]) { var n = new e.MediaStream(t.getTracks()); this._streams[t.id] = n, this._reverseStreams[n.id] = t, t = n } r.apply(this, [t]) }; var n = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = function (e) { this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, n.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id] }, e.RTCPeerConnection.prototype.addTrack = function (t, i) { var r = this; if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); var n = [].slice.call(arguments, 1); if (1 !== n.length || !n[0].getTracks().find((function (e) { return e === t }))) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError"); if (this.getSenders().find((function (e) { return e.track === t }))) throw new DOMException("Track already exists.", "InvalidAccessError"); this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}; var a = this._streams[i.id]; if (a) a.addTrack(t), Promise.resolve().then((function () { r.dispatchEvent(new Event("negotiationneeded")) })); else { var o = new e.MediaStream([t]); this._streams[i.id] = o, this._reverseStreams[o.id] = i, this.addStream(o) } return this.getSenders().find((function (e) { return e.track === t })) }, ["createOffer", "createAnswer"].forEach((function (t) { var i = e.RTCPeerConnection.prototype[t], r = l({}, t, (function () { var e = this, t = arguments; return arguments.length && "function" == typeof arguments[0] ? i.apply(this, [function (i) { var r = s(e, i); t[0].apply(null, [r]) }, function (e) { t[1] && t[1].apply(null, e) }, arguments[2]]) : i.apply(this, arguments).then((function (t) { return s(e, t) })) })); e.RTCPeerConnection.prototype[t] = r[t] })); var a = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription = function () { return arguments.length && arguments[0].type ? (arguments[0] = c(this, arguments[0]), a.apply(this, arguments)) : a.apply(this, arguments) }; var o = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription"); Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", { get: function () { var e = o.get.apply(this); return "" === e.type ? e : s(this, e) } }), e.RTCPeerConnection.prototype.removeTrack = function (e) { var t = this; if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError"); if (e._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError"); this._streams = this._streams || {}; var i = void 0; Object.keys(this._streams).forEach((function (r) { t._streams[r].getTracks().find((function (t) { return e.track === t })) && (i = t._streams[r]) })), i && (1 === i.getTracks().length ? this.removeStream(this._reverseStreams[i.id]) : i.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded"))) } } function s(e, t) { var i = t.sdp; return Object.keys(e._reverseStreams || []).forEach((function (t) { var r = e._reverseStreams[t], n = e._streams[r.id]; i = i.replace(new RegExp(n.id, "g"), r.id) })), new RTCSessionDescription({ type: t.type, sdp: i }) } function c(e, t) { var i = t.sdp; return Object.keys(e._reverseStreams || []).forEach((function (t) { var r = e._reverseStreams[t], n = e._streams[r.id]; i = i.replace(new RegExp(r.id, "g"), n.id) })), new RTCSessionDescription({ type: t.type, sdp: i }) } } function g(e, t) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function (t) { var i = e.RTCPeerConnection.prototype[t], r = l({}, t, (function () { return arguments[0] = new ("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), i.apply(this, arguments) })); e.RTCPeerConnection.prototype[t] = r[t] })) } function y(e, t) { o.wrapPeerConnectionEvent(e, "negotiationneeded", (function (e) { var i = e.target; if (!(t.version < 72 || i.getConfiguration && "plan-b" === i.getConfiguration().sdpSemantics) || "stable" === i.signalingState) return e })) } }, { "../utils.js": 11, "./getdisplaymedia": 4, "./getusermedia": 5 }], 4: [function (e, t, i) { function r(e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && ("function" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function (i) { return t(i).then((function (t) { var r = i.video && i.video.width, n = i.video && i.video.height, a = i.video && i.video.frameRate; return i.video = { mandatory: { chromeMediaSource: "desktop", chromeMediaSourceId: t, maxFrameRate: a || 3 } }, r && (i.video.mandatory.maxWidth = r), n && (i.video.mandatory.maxHeight = n), e.navigator.mediaDevices.getUserMedia(i) })) } : console.error("shimGetDisplayMedia: getSourceId argument is not a function")) } Object.defineProperty(i, "__esModule", { value: !0 }), i.shimGetDisplayMedia = r }, {}], 5: [function (e, t, i) { Object.defineProperty(i, "__esModule", { value: !0 }); var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; function n(e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t.default = e, t } i.shimGetUserMedia = o; var a = n(e("../utils.js")).log; function o(e, t) { var i = e && e.navigator; if (i.mediaDevices) { var n = function (e) { if ("object" !== (void 0 === e ? "undefined" : r(e)) || e.mandatory || e.optional) return e; var t = {}; return Object.keys(e).forEach((function (i) { if ("require" !== i && "advanced" !== i && "mediaSource" !== i) { var n = "object" === r(e[i]) ? e[i] : { ideal: e[i] }; void 0 !== n.exact && "number" == typeof n.exact && (n.min = n.max = n.exact); var a = function (e, t) { return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t }; if (void 0 !== n.ideal) { t.optional = t.optional || []; var o = {}; "number" == typeof n.ideal ? (o[a("min", i)] = n.ideal, t.optional.push(o), (o = {})[a("max", i)] = n.ideal, t.optional.push(o)) : (o[a("", i)] = n.ideal, t.optional.push(o)) } void 0 !== n.exact && "number" != typeof n.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[a("", i)] = n.exact) : ["min", "max"].forEach((function (e) { void 0 !== n[e] && (t.mandatory = t.mandatory || {}, t.mandatory[a(e, i)] = n[e]) })) } })), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t }, o = function (e, o) { if (t.version >= 61) return o(e); if ((e = JSON.parse(JSON.stringify(e))) && "object" === r(e.audio)) { var s = function (e, t, i) { t in e && !(i in e) && (e[i] = e[t], delete e[t]) }; s((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), s(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = n(e.audio) } if (e && "object" === r(e.video)) { var l = e.video.facingMode; l = l && ("object" === (void 0 === l ? "undefined" : r(l)) ? l : { ideal: l }); var c = t.version < 66; if (l && ("user" === l.exact || "environment" === l.exact || "user" === l.ideal || "environment" === l.ideal) && (!i.mediaDevices.getSupportedConstraints || !i.mediaDevices.getSupportedConstraints().facingMode || c)) { delete e.video.facingMode; var h = void 0; if ("environment" === l.exact || "environment" === l.ideal ? h = ["back", "rear"] : "user" !== l.exact && "user" !== l.ideal || (h = ["front"]), h) return i.mediaDevices.enumerateDevices().then((function (t) { var i = (t = t.filter((function (e) { return "videoinput" === e.kind }))).find((function (e) { return h.some((function (t) { return e.label.toLowerCase().includes(t) })) })); return !i && t.length && h.includes("back") && (i = t[t.length - 1]), i && (e.video.deviceId = l.exact ? { exact: i.deviceId } : { ideal: i.deviceId }), e.video = n(e.video), a("chrome: " + JSON.stringify(e)), o(e) })) } e.video = n(e.video) } return a("chrome: " + JSON.stringify(e)), o(e) }, s = function (e) { return t.version >= 64 ? e : { name: { PermissionDeniedError: "NotAllowedError", PermissionDismissedError: "NotAllowedError", InvalidStateError: "NotAllowedError", DevicesNotFoundError: "NotFoundError", ConstraintNotSatisfiedError: "OverconstrainedError", TrackStartError: "NotReadableError", MediaDeviceFailedDueToShutdown: "NotAllowedError", MediaDeviceKillSwitchOn: "NotAllowedError", TabCaptureError: "AbortError", ScreenCaptureError: "AbortError", DeviceCaptureError: "AbortError" }[e.name] || e.name, message: e.message, constraint: e.constraint || e.constraintName, toString: function () { return this.name + (this.message && ": ") + this.message } } }, l = function (e, t, r) { o(e, (function (e) { i.webkitGetUserMedia(e, t, (function (e) { r && r(s(e)) })) })) }; if (i.getUserMedia = l.bind(i), i.mediaDevices.getUserMedia) { var c = i.mediaDevices.getUserMedia.bind(i.mediaDevices); i.mediaDevices.getUserMedia = function (e) { return o(e, (function (e) { return c(e).then((function (t) { if (e.audio && !t.getAudioTracks().length || e.video && !t.getVideoTracks().length) throw t.getTracks().forEach((function (e) { e.stop() })), new DOMException("", "NotFoundError"); return t }), (function (e) { return Promise.reject(s(e)) })) })) } } } } }, { "../utils.js": 11 }], 6: [function (e, t, i) { Object.defineProperty(i, "__esModule", { value: !0 }); var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; i.shimRTCIceCandidate = l, i.shimMaxMessageSize = c, i.shimSendThrowTypeError = h, i.shimConnectionState = u, i.removeExtmapAllowMixed = d, i.shimAddIceCandidateNullOrEmpty = p, i.shimParameterlessSetLocalDescription = f; var n = s(e("sdp")), a = o(e("./utils")); function o(e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t.default = e, t } function s(e) { return e && e.__esModule ? e : { default: e } } function l(e) { if (!(!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype)) { var t = e.RTCIceCandidate; e.RTCIceCandidate = function (e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) { var i = new t(e), a = n.default.parseCandidate(e.candidate), o = Object.assign(i, a); return o.toJSON = function () { return { candidate: o.candidate, sdpMid: o.sdpMid, sdpMLineIndex: o.sdpMLineIndex, usernameFragment: o.usernameFragment } }, o } return new t(e) }, e.RTCIceCandidate.prototype = t.prototype, a.wrapPeerConnectionEvent(e, "icecandidate", (function (t) { return t.candidate && Object.defineProperty(t, "candidate", { value: new e.RTCIceCandidate(t.candidate), writable: "false" }), t })) } } function c(e, t) { if (e.RTCPeerConnection) { "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", { get: function () { return void 0 === this._sctp ? null : this._sctp } }); var i = function (e) { if (!e || !e.sdp) return !1; var t = n.default.splitSections(e.sdp); return t.shift(), t.some((function (e) { var t = n.default.parseMLine(e); return t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP") })) }, r = function (e) { var t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/); if (null === t || t.length < 2) return -1; var i = parseInt(t[1], 10); return i != i ? -1 : i }, a = function (e) { var i = 65536; return "firefox" === t.browser && (i = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), i }, o = function (e, i) { var r = 65536; "firefox" === t.browser && 57 === t.version && (r = 65535); var a = n.default.matchPrefix(e.sdp, "a=max-message-size:"); return a.length > 0 ? r = parseInt(a[0].substr(19), 10) : "firefox" === t.browser && -1 !== i && (r = 2147483637), r }, s = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, "chrome" === t.browser && t.version >= 76 && "plan-b" === this.getConfiguration().sdpSemantics && Object.defineProperty(this, "sctp", { get: function () { return void 0 === this._sctp ? null : this._sctp }, enumerable: !0, configurable: !0 }), i(arguments[0])) { var e = r(arguments[0]), n = a(e), l = o(arguments[0], e), c = void 0; c = 0 === n && 0 === l ? Number.POSITIVE_INFINITY : 0 === n || 0 === l ? Math.max(n, l) : Math.min(n, l); var h = {}; Object.defineProperty(h, "maxMessageSize", { get: function () { return c } }), this._sctp = h } return s.apply(this, arguments) } } } function h(e) { if (e.RTCPeerConnection && "createDataChannel" in e.RTCPeerConnection.prototype) { var t = e.RTCPeerConnection.prototype.createDataChannel; e.RTCPeerConnection.prototype.createDataChannel = function () { var e = t.apply(this, arguments); return i(e, this), e }, a.wrapPeerConnectionEvent(e, "datachannel", (function (e) { return i(e.channel, e.target), e })) } function i(e, t) { var i = e.send; e.send = function () { var r = arguments[0], n = r.length || r.size || r.byteLength; if ("open" === e.readyState && t.sctp && n > t.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)"); return i.apply(e, arguments) } } } function u(e) { if (e.RTCPeerConnection && !("connectionState" in e.RTCPeerConnection.prototype)) { var t = e.RTCPeerConnection.prototype; Object.defineProperty(t, "connectionState", { get: function () { return { completed: "connected", checking: "connecting" }[this.iceConnectionState] || this.iceConnectionState }, enumerable: !0, configurable: !0 }), Object.defineProperty(t, "onconnectionstatechange", { get: function () { return this._onconnectionstatechange || null }, set: function (e) { this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e) }, enumerable: !0, configurable: !0 }), ["setLocalDescription", "setRemoteDescription"].forEach((function (e) { var i = t[e]; t[e] = function () { return this._connectionstatechangepoly || (this._connectionstatechangepoly = function (e) { var t = e.target; if (t._lastConnectionState !== t.connectionState) { t._lastConnectionState = t.connectionState; var i = new Event("connectionstatechange", e); t.dispatchEvent(i) } return e }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), i.apply(this, arguments) } })) } } function d(e, t) { if (e.RTCPeerConnection && !("chrome" === t.browser && t.version >= 71 || "safari" === t.browser && t.version >= 605)) { var i = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function (t) { if (t && t.sdp && -1 !== t.sdp.indexOf("\na=extmap-allow-mixed")) { var r = t.sdp.split("\n").filter((function (e) { return "a=extmap-allow-mixed" !== e.trim() })).join("\n"); e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({ type: t.type, sdp: r }) : t.sdp = r } return i.apply(this, arguments) } } } function p(e, t) { if (e.RTCPeerConnection && e.RTCPeerConnection.prototype) { var i = e.RTCPeerConnection.prototype.addIceCandidate; i && 0 !== i.length && (e.RTCPeerConnection.prototype.addIceCandidate = function () { return arguments[0] ? ("chrome" === t.browser && t.version < 78 || "firefox" === t.browser && t.version < 68 || "safari" === t.browser) && arguments[0] && "" === arguments[0].candidate ? Promise.resolve() : i.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve()) }) } } function f(e, t) { if (e.RTCPeerConnection && e.RTCPeerConnection.prototype) { var i = e.RTCPeerConnection.prototype.setLocalDescription; i && 0 !== i.length && (e.RTCPeerConnection.prototype.setLocalDescription = function () { var e = this, t = arguments[0] || {}; if ("object" !== (void 0 === t ? "undefined" : r(t)) || t.type && t.sdp) return i.apply(this, arguments); if (!(t = { type: t.type, sdp: t.sdp }).type) switch (this.signalingState) { case "stable": case "have-local-offer": case "have-remote-pranswer": t.type = "offer"; break; default: t.type = "answer" }return t.sdp || "offer" !== t.type && "answer" !== t.type ? i.apply(this, [t]) : ("offer" === t.type ? this.createOffer : this.createAnswer).apply(this).then((function (t) { return i.apply(e, [t]) })) }) } } }, { "./utils": 11, sdp: 12 }], 7: [function (e, t, i) { Object.defineProperty(i, "__esModule", { value: !0 }), i.shimGetDisplayMedia = i.shimGetUserMedia = void 0; var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, n = e("./getusermedia"); Object.defineProperty(i, "shimGetUserMedia", { enumerable: !0, get: function () { return n.shimGetUserMedia } }); var a = e("./getdisplaymedia"); Object.defineProperty(i, "shimGetDisplayMedia", { enumerable: !0, get: function () { return a.shimGetDisplayMedia } }), i.shimOnTrack = c, i.shimPeerConnection = h, i.shimSenderGetStats = u, i.shimReceiverGetStats = d, i.shimRemoveStream = p, i.shimRTCDataChannel = f, i.shimAddTransceiver = m, i.shimGetParameters = g, i.shimCreateOffer = y, i.shimCreateAnswer = v; var o = s(e("../utils")); function s(e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t.default = e, t } function l(e, t, i) { return t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } function c(e) { "object" === (void 0 === e ? "undefined" : r(e)) && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get: function () { return { receiver: this.receiver } } }) } function h(e, t) { if ("object" === (void 0 === e ? "undefined" : r(e)) && (e.RTCPeerConnection || e.mozRTCPeerConnection)) { !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function (t) { var i = e.RTCPeerConnection.prototype[t], r = l({}, t, (function () { return arguments[0] = new ("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), i.apply(this, arguments) })); e.RTCPeerConnection.prototype[t] = r[t] })); var i = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = function () { var e = Array.prototype.slice.call(arguments), r = e[0], a = e[1], o = e[2]; return n.apply(this, [r || null]).then((function (e) { if (t.version < 53 && !a) try { e.forEach((function (e) { e.type = i[e.type] || e.type })) } catch (t) { if ("TypeError" !== t.name) throw t; e.forEach((function (t, r) { e.set(r, Object.assign({}, t, { type: i[t.type] || t.type })) })) } return e })).then(a, o) } } } function u(e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCPeerConnection && e.RTCRtpSender && (!e.RTCRtpSender || !("getStats" in e.RTCRtpSender.prototype))) { var t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { var e = this, i = t.apply(this, []); return i.forEach((function (t) { return t._pc = e })), i }); var i = e.RTCPeerConnection.prototype.addTrack; i && (e.RTCPeerConnection.prototype.addTrack = function () { var e = i.apply(this, arguments); return e._pc = this, e }), e.RTCRtpSender.prototype.getStats = function () { return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map) } } } function d(e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCPeerConnection && e.RTCRtpSender && (!e.RTCRtpSender || !("getStats" in e.RTCRtpReceiver.prototype))) { var t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { var e = this, i = t.apply(this, []); return i.forEach((function (t) { return t._pc = e })), i }), o.wrapPeerConnectionEvent(e, "track", (function (e) { return e.receiver._pc = e.srcElement, e })), e.RTCRtpReceiver.prototype.getStats = function () { return this._pc.getStats(this.track) } } } function p(e) { e.RTCPeerConnection && !("removeStream" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function (e) { var t = this; o.deprecated("removeStream", "removeTrack"), this.getSenders().forEach((function (i) { i.track && e.getTracks().includes(i.track) && t.removeTrack(i) })) }) } function f(e) { e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel) } function m(e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; var e = arguments[1], i = e && "sendEncodings" in e; i && e.sendEncodings.forEach((function (e) { if ("rid" in e && !/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError("Invalid RID value provided."); if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0"); if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0") })); var r = t.apply(this, arguments); if (i) { var n = r.sender, a = n.getParameters(); (!("encodings" in a) || 1 === a.encodings.length && 0 === Object.keys(a.encodings[0]).length) && (a.encodings = e.sendEncodings, n.sendEncodings = e.sendEncodings, this.setParametersPromises.push(n.setParameters(a).then((function () { delete n.sendEncodings })).catch((function () { delete n.sendEncodings })))) } return r }) } } function g(e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCRtpSender) { var t = e.RTCRtpSender.prototype.getParameters; t && (e.RTCRtpSender.prototype.getParameters = function () { var e = t.apply(this, arguments); return "encodings" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e }) } } function y(e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function () { var e = this, i = arguments; return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((function () { return t.apply(e, i) })).finally((function () { e.setParametersPromises = [] })) : t.apply(this, arguments) } } } function v(e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { var e = this, i = arguments; return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((function () { return t.apply(e, i) })).finally((function () { e.setParametersPromises = [] })) : t.apply(this, arguments) } } } }, { "../utils": 11, "./getdisplaymedia": 8, "./getusermedia": 9 }], 8: [function (e, t, i) { function r(e, t) { e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function (i) { if (!i || !i.video) { var r = new DOMException("getDisplayMedia without video constraints is undefined"); return r.name = "NotFoundError", r.code = 8, Promise.reject(r) } return !0 === i.video ? i.video = { mediaSource: t } : i.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(i) }) } Object.defineProperty(i, "__esModule", { value: !0 }), i.shimGetDisplayMedia = r }, {}], 9: [function (e, t, i) { Object.defineProperty(i, "__esModule", { value: !0 }); var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; i.shimGetUserMedia = o; var n = a(e("../utils")); function a(e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t.default = e, t } function o(e, t) { var i = e && e.navigator, a = e && e.MediaStreamTrack; if (i.getUserMedia = function (e, t, r) { n.deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), i.mediaDevices.getUserMedia(e).then(t, r) }, !(t.version > 55 && "autoGainControl" in i.mediaDevices.getSupportedConstraints())) { var o = function (e, t, i) { t in e && !(i in e) && (e[i] = e[t], delete e[t]) }, s = i.mediaDevices.getUserMedia.bind(i.mediaDevices); if (i.mediaDevices.getUserMedia = function (e) { return "object" === (void 0 === e ? "undefined" : r(e)) && "object" === r(e.audio) && (e = JSON.parse(JSON.stringify(e)), o(e.audio, "autoGainControl", "mozAutoGainControl"), o(e.audio, "noiseSuppression", "mozNoiseSuppression")), s(e) }, a && a.prototype.getSettings) { var l = a.prototype.getSettings; a.prototype.getSettings = function () { var e = l.apply(this, arguments); return o(e, "mozAutoGainControl", "autoGainControl"), o(e, "mozNoiseSuppression", "noiseSuppression"), e } } if (a && a.prototype.applyConstraints) { var c = a.prototype.applyConstraints; a.prototype.applyConstraints = function (e) { return "audio" === this.kind && "object" === (void 0 === e ? "undefined" : r(e)) && (e = JSON.parse(JSON.stringify(e)), o(e, "autoGainControl", "mozAutoGainControl"), o(e, "noiseSuppression", "mozNoiseSuppression")), c.apply(this, [e]) } } } } }, { "../utils": 11 }], 10: [function (e, t, i) { Object.defineProperty(i, "__esModule", { value: !0 }); var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; i.shimLocalStreamsAPI = o, i.shimRemoteStreamsAPI = s, i.shimCallbacksAPI = l, i.shimGetUserMedia = c, i.shimConstraints = h, i.shimRTCIceServerUrls = u, i.shimTrackEventTransceiver = d, i.shimCreateOfferLegacy = p, i.shimAudioContext = f; var n = a(e("../utils")); function a(e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t.default = e, t } function o(e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCPeerConnection) { if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () { return this._localStreams || (this._localStreams = []), this._localStreams }), !("addStream" in e.RTCPeerConnection.prototype)) { var t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream = function (e) { var i = this; this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach((function (r) { return t.call(i, r, e) })), e.getVideoTracks().forEach((function (r) { return t.call(i, r, e) })) }, e.RTCPeerConnection.prototype.addTrack = function (e) { for (var i = this, r = arguments.length, n = Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)n[a - 1] = arguments[a]; return n && n.forEach((function (e) { i._localStreams ? i._localStreams.includes(e) || i._localStreams.push(e) : i._localStreams = [e] })), t.apply(this, arguments) } } "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) { var t = this; this._localStreams || (this._localStreams = []); var i = this._localStreams.indexOf(e); if (-1 !== i) { this._localStreams.splice(i, 1); var r = e.getTracks(); this.getSenders().forEach((function (e) { r.includes(e.track) && t.removeTrack(e) })) } }) } } function s(e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () { return this._remoteStreams ? this._remoteStreams : [] }), !("onaddstream" in e.RTCPeerConnection.prototype))) { Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", { get: function () { return this._onaddstream }, set: function (e) { var t = this; this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = function (e) { e.streams.forEach((function (e) { if (t._remoteStreams || (t._remoteStreams = []), !t._remoteStreams.includes(e)) { t._remoteStreams.push(e); var i = new Event("addstream"); i.stream = e, t.dispatchEvent(i) } })) }) } }); var t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { var e = this; return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function (t) { t.streams.forEach((function (t) { if (e._remoteStreams || (e._remoteStreams = []), !(e._remoteStreams.indexOf(t) >= 0)) { e._remoteStreams.push(t); var i = new Event("addstream"); i.stream = t, e.dispatchEvent(i) } })) }), t.apply(e, arguments) } } } function l(e) { if ("object" === (void 0 === e ? "undefined" : r(e)) && e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype, i = t.createOffer, n = t.createAnswer, a = t.setLocalDescription, o = t.setRemoteDescription, s = t.addIceCandidate; t.createOffer = function (e, t) { var r = arguments.length >= 2 ? arguments[2] : arguments[0], n = i.apply(this, [r]); return t ? (n.then(e, t), Promise.resolve()) : n }, t.createAnswer = function (e, t) { var i = arguments.length >= 2 ? arguments[2] : arguments[0], r = n.apply(this, [i]); return t ? (r.then(e, t), Promise.resolve()) : r }; var l = function (e, t, i) { var r = a.apply(this, [e]); return i ? (r.then(t, i), Promise.resolve()) : r }; t.setLocalDescription = l, l = function (e, t, i) { var r = o.apply(this, [e]); return i ? (r.then(t, i), Promise.resolve()) : r }, t.setRemoteDescription = l, l = function (e, t, i) { var r = s.apply(this, [e]); return i ? (r.then(t, i), Promise.resolve()) : r }, t.addIceCandidate = l } } function c(e) { var t = e && e.navigator; if (t.mediaDevices && t.mediaDevices.getUserMedia) { var i = t.mediaDevices, r = i.getUserMedia.bind(i); t.mediaDevices.getUserMedia = function (e) { return r(h(e)) } } !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (e, i, r) { t.mediaDevices.getUserMedia(e).then(i, r) }.bind(t)) } function h(e) { return e && void 0 !== e.video ? Object.assign({}, e, { video: n.compactObject(e.video) }) : e } function u(e) { if (e.RTCPeerConnection) { var t = e.RTCPeerConnection; e.RTCPeerConnection = function (e, i) { if (e && e.iceServers) { for (var r = [], a = 0; a < e.iceServers.length; a++) { var o = e.iceServers[a]; !o.hasOwnProperty("urls") && o.hasOwnProperty("url") ? (n.deprecated("RTCIceServer.url", "RTCIceServer.urls"), (o = JSON.parse(JSON.stringify(o))).urls = o.url, delete o.url, r.push(o)) : r.push(e.iceServers[a]) } e.iceServers = r } return new t(e, i) }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", { get: function () { return t.generateCertificate } }) } } function d(e) { "object" === (void 0 === e ? "undefined" : r(e)) && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get: function () { return { receiver: this.receiver } } }) } function p(e) { var t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (e) { if (e) { void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio); var i = this.getTransceivers().find((function (e) { return "audio" === e.receiver.track.kind })); !1 === e.offerToReceiveAudio && i ? "sendrecv" === i.direction ? i.setDirection ? i.setDirection("sendonly") : i.direction = "sendonly" : "recvonly" === i.direction && (i.setDirection ? i.setDirection("inactive") : i.direction = "inactive") : !0 !== e.offerToReceiveAudio || i || this.addTransceiver("audio"), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo); var r = this.getTransceivers().find((function (e) { return "video" === e.receiver.track.kind })); !1 === e.offerToReceiveVideo && r ? "sendrecv" === r.direction ? r.setDirection ? r.setDirection("sendonly") : r.direction = "sendonly" : "recvonly" === r.direction && (r.setDirection ? r.setDirection("inactive") : r.direction = "inactive") : !0 !== e.offerToReceiveVideo || r || this.addTransceiver("video") } return t.apply(this, arguments) } } function f(e) { "object" !== (void 0 === e ? "undefined" : r(e)) || e.AudioContext || (e.AudioContext = e.webkitAudioContext) } }, { "../utils": 11 }], 11: [function (e, t, i) { Object.defineProperty(i, "__esModule", { value: !0 }); var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }; function n(e, t, i) { return t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } i.extractVersion = s, i.wrapPeerConnectionEvent = l, i.disableLog = c, i.disableWarnings = h, i.log = u, i.deprecated = d, i.detectBrowser = p, i.compactObject = m, i.walkStats = g, i.filterStats = y; var a = !0, o = !0; function s(e, t, i) { var r = e.match(t); return r && r.length >= i && parseInt(r[i], 10) } function l(e, t, i) { if (e.RTCPeerConnection) { var r = e.RTCPeerConnection.prototype, n = r.addEventListener; r.addEventListener = function (e, r) { if (e !== t) return n.apply(this, arguments); var a = function (e) { var t = i(e); t && (r.handleEvent ? r.handleEvent(t) : r(t)) }; return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(r, a), n.apply(this, [e, a]) }; var a = r.removeEventListener; r.removeEventListener = function (e, i) { if (e !== t || !this._eventMap || !this._eventMap[t]) return a.apply(this, arguments); if (!this._eventMap[t].has(i)) return a.apply(this, arguments); var r = this._eventMap[t].get(i); return this._eventMap[t].delete(i), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, a.apply(this, [e, r]) }, Object.defineProperty(r, "on" + t, { get: function () { return this["_on" + t] }, set: function (e) { this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e) }, enumerable: !0, configurable: !0 }) } } function c(e) { return "boolean" != typeof e ? new Error("Argument type: " + (void 0 === e ? "undefined" : r(e)) + ". Please use a boolean.") : (a = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled") } function h(e) { return "boolean" != typeof e ? new Error("Argument type: " + (void 0 === e ? "undefined" : r(e)) + ". Please use a boolean.") : (o = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled")) } function u() { if ("object" === ("undefined" == typeof window ? "undefined" : r(window))) { if (a) return; "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments) } } function d(e, t) { o && console.warn(e + " is deprecated, please use " + t + " instead.") } function p(e) { var t = { browser: null, version: null }; if (void 0 === e || !e.navigator) return t.browser = "Not a browser.", t; var i = e.navigator; if (i.mozGetUserMedia) t.browser = "firefox", t.version = s(i.userAgent, /Firefox\/(\d+)\./, 1); else if (i.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection && !e.RTCIceGatherer) t.browser = "chrome", t.version = s(i.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else { if (!e.RTCPeerConnection || !i.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t; t.browser = "safari", t.version = s(i.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype } return t } function f(e) { return "[object Object]" === Object.prototype.toString.call(e) } function m(e) { return f(e) ? Object.keys(e).reduce((function (t, i) { var r = f(e[i]), a = r ? m(e[i]) : e[i], o = r && !Object.keys(a).length; return void 0 === a || o ? t : Object.assign(t, n({}, i, a)) }), {}) : e } function g(e, t, i) { t && !i.has(t.id) && (i.set(t.id, t), Object.keys(t).forEach((function (r) { r.endsWith("Id") ? g(e, e.get(t[r]), i) : r.endsWith("Ids") && t[r].forEach((function (t) { g(e, e.get(t), i) })) }))) } function y(e, t, i) { var r = i ? "outbound-rtp" : "inbound-rtp", n = new Map; if (null === t) return n; var a = []; return e.forEach((function (e) { "track" === e.type && e.trackIdentifier === t.id && a.push(e) })), a.forEach((function (t) { e.forEach((function (i) { i.type === r && i.trackId === t.id && g(e, i, n) })) })), n } }, {}], 12: [function (e, t, i) { var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, n = { generateIdentifier: function () { return Math.random().toString(36).substr(2, 10) } }; n.localCName = n.generateIdentifier(), n.splitLines = function (e) { return e.trim().split("\n").map((function (e) { return e.trim() })) }, n.splitSections = function (e) { return e.split("\nm=").map((function (e, t) { return (t > 0 ? "m=" + e : e).trim() + "\r\n" })) }, n.getDescription = function (e) { var t = n.splitSections(e); return t && t[0] }, n.getMediaSections = function (e) { var t = n.splitSections(e); return t.shift(), t }, n.matchPrefix = function (e, t) { return n.splitLines(e).filter((function (e) { return 0 === e.indexOf(t) })) }, n.parseCandidate = function (e) { for (var t = void 0, i = { foundation: (t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" "))[0], component: { 1: "rtp", 2: "rtcp" }[t[1]] || t[1], protocol: t[2].toLowerCase(), priority: parseInt(t[3], 10), ip: t[4], address: t[4], port: parseInt(t[5], 10), type: t[7] }, r = 8; r < t.length; r += 2)switch (t[r]) { case "raddr": i.relatedAddress = t[r + 1]; break; case "rport": i.relatedPort = parseInt(t[r + 1], 10); break; case "tcptype": i.tcpType = t[r + 1]; break; case "ufrag": i.ufrag = t[r + 1], i.usernameFragment = t[r + 1]; break; default: void 0 === i[t[r]] && (i[t[r]] = t[r + 1]) }return i }, n.writeCandidate = function (e) { var t = []; t.push(e.foundation); var i = e.component; "rtp" === i ? t.push(1) : "rtcp" === i ? t.push(2) : t.push(i), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port); var r = e.type; return t.push("typ"), t.push(r), "host" !== r && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ") }, n.parseIceOptions = function (e) { return e.substr(14).split(" ") }, n.parseRtpMap = function (e) { var t = e.substr(9).split(" "), i = { payloadType: parseInt(t.shift(), 10) }; return t = t[0].split("/"), i.name = t[0], i.clockRate = parseInt(t[1], 10), i.channels = 3 === t.length ? parseInt(t[2], 10) : 1, i.numChannels = i.channels, i }, n.writeRtpMap = function (e) { var t = e.payloadType; void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType); var i = e.channels || e.numChannels || 1; return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== i ? "/" + i : "") + "\r\n" }, n.parseExtmap = function (e) { var t = e.substr(9).split(" "); return { id: parseInt(t[0], 10), direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv", uri: t[1] } }, n.writeExtmap = function (e) { return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n" }, n.parseFmtp = function (e) { for (var t = {}, i = void 0, r = e.substr(e.indexOf(" ") + 1).split(";"), n = 0; n < r.length; n++)t[(i = r[n].trim().split("="))[0].trim()] = i[1]; return t }, n.writeFmtp = function (e) { var t = "", i = e.payloadType; if (void 0 !== e.preferredPayloadType && (i = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) { var r = []; Object.keys(e.parameters).forEach((function (t) { void 0 !== e.parameters[t] ? r.push(t + "=" + e.parameters[t]) : r.push(t) })), t += "a=fmtp:" + i + " " + r.join(";") + "\r\n" } return t }, n.parseRtcpFb = function (e) { var t = e.substr(e.indexOf(" ") + 1).split(" "); return { type: t.shift(), parameter: t.join(" ") } }, n.writeRtcpFb = function (e) { var t = "", i = e.payloadType; return void 0 !== e.preferredPayloadType && (i = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach((function (e) { t += "a=rtcp-fb:" + i + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n" })), t }, n.parseSsrcMedia = function (e) { var t = e.indexOf(" "), i = { ssrc: parseInt(e.substr(7, t - 7), 10) }, r = e.indexOf(":", t); return r > -1 ? (i.attribute = e.substr(t + 1, r - t - 1), i.value = e.substr(r + 1)) : i.attribute = e.substr(t + 1), i }, n.parseSsrcGroup = function (e) { var t = e.substr(13).split(" "); return { semantics: t.shift(), ssrcs: t.map((function (e) { return parseInt(e, 10) })) } }, n.getMid = function (e) { var t = n.matchPrefix(e, "a=mid:")[0]; if (t) return t.substr(6) }, n.parseFingerprint = function (e) { var t = e.substr(14).split(" "); return { algorithm: t[0].toLowerCase(), value: t[1].toUpperCase() } }, n.getDtlsParameters = function (e, t) { return { role: "auto", fingerprints: n.matchPrefix(e + t, "a=fingerprint:").map(n.parseFingerprint) } }, n.writeDtlsParameters = function (e, t) { var i = "a=setup:" + t + "\r\n"; return e.fingerprints.forEach((function (e) { i += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n" })), i }, n.parseCryptoLine = function (e) { var t = e.substr(9).split(" "); return { tag: parseInt(t[0], 10), cryptoSuite: t[1], keyParams: t[2], sessionParams: t.slice(3) } }, n.writeCryptoLine = function (e) { return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" === r(e.keyParams) ? n.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n" }, n.parseCryptoKeyParams = function (e) { if (0 !== e.indexOf("inline:")) return null; var t = e.substr(7).split("|"); return { keyMethod: "inline", keySalt: t[0], lifeTime: t[1], mkiValue: t[2] ? t[2].split(":")[0] : void 0, mkiLength: t[2] ? t[2].split(":")[1] : void 0 } }, n.writeCryptoKeyParams = function (e) { return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "") }, n.getCryptoParameters = function (e, t) { return n.matchPrefix(e + t, "a=crypto:").map(n.parseCryptoLine) }, n.getIceParameters = function (e, t) { var i = n.matchPrefix(e + t, "a=ice-ufrag:")[0], r = n.matchPrefix(e + t, "a=ice-pwd:")[0]; return i && r ? { usernameFragment: i.substr(12), password: r.substr(10) } : null }, n.writeIceParameters = function (e) { var t = "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n"; return e.iceLite && (t += "a=ice-lite\r\n"), t }, n.parseRtpParameters = function (e) { for (var t = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, i = n.splitLines(e)[0].split(" "), r = 3; r < i.length; r++) { var a = i[r], o = n.matchPrefix(e, "a=rtpmap:" + a + " ")[0]; if (o) { var s = n.parseRtpMap(o), l = n.matchPrefix(e, "a=fmtp:" + a + " "); switch (s.parameters = l.length ? n.parseFmtp(l[0]) : {}, s.rtcpFeedback = n.matchPrefix(e, "a=rtcp-fb:" + a + " ").map(n.parseRtcpFb), t.codecs.push(s), s.name.toUpperCase()) { case "RED": case "ULPFEC": t.fecMechanisms.push(s.name.toUpperCase()) } } } return n.matchPrefix(e, "a=extmap:").forEach((function (e) { t.headerExtensions.push(n.parseExtmap(e)) })), t }, n.writeRtpDescription = function (e, t) { var i = ""; i += "m=" + e + " ", i += t.codecs.length > 0 ? "9" : "0", i += " UDP/TLS/RTP/SAVPF ", i += t.codecs.map((function (e) { return void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType })).join(" ") + "\r\n", i += "c=IN IP4 0.0.0.0\r\n", i += "a=rtcp:9 IN IP4 0.0.0.0\r\n", t.codecs.forEach((function (e) { i += n.writeRtpMap(e), i += n.writeFmtp(e), i += n.writeRtcpFb(e) })); var r = 0; return t.codecs.forEach((function (e) { e.maxptime > r && (r = e.maxptime) })), r > 0 && (i += "a=maxptime:" + r + "\r\n"), t.headerExtensions && t.headerExtensions.forEach((function (e) { i += n.writeExtmap(e) })), i }, n.parseRtpEncodingParameters = function (e) { var t = [], i = n.parseRtpParameters(e), r = -1 !== i.fecMechanisms.indexOf("RED"), a = -1 !== i.fecMechanisms.indexOf("ULPFEC"), o = n.matchPrefix(e, "a=ssrc:").map((function (e) { return n.parseSsrcMedia(e) })).filter((function (e) { return "cname" === e.attribute })), s = o.length > 0 && o[0].ssrc, l = void 0, c = n.matchPrefix(e, "a=ssrc-group:FID").map((function (e) { return e.substr(17).split(" ").map((function (e) { return parseInt(e, 10) })) })); c.length > 0 && c[0].length > 1 && c[0][0] === s && (l = c[0][1]), i.codecs.forEach((function (e) { if ("RTX" === e.name.toUpperCase() && e.parameters.apt) { var i = { ssrc: s, codecPayloadType: parseInt(e.parameters.apt, 10) }; s && l && (i.rtx = { ssrc: l }), t.push(i), r && ((i = JSON.parse(JSON.stringify(i))).fec = { ssrc: s, mechanism: a ? "red+ulpfec" : "red" }, t.push(i)) } })), 0 === t.length && s && t.push({ ssrc: s }); var h = n.matchPrefix(e, "b="); return h.length && (h = 0 === h[0].indexOf("b=TIAS:") ? parseInt(h[0].substr(7), 10) : 0 === h[0].indexOf("b=AS:") ? 1e3 * parseInt(h[0].substr(5), 10) * .95 - 16e3 : void 0, t.forEach((function (e) { e.maxBitrate = h }))), t }, n.parseRtcpParameters = function (e) { var t = {}, i = n.matchPrefix(e, "a=ssrc:").map((function (e) { return n.parseSsrcMedia(e) })).filter((function (e) { return "cname" === e.attribute }))[0]; i && (t.cname = i.value, t.ssrc = i.ssrc); var r = n.matchPrefix(e, "a=rtcp-rsize"); t.reducedSize = r.length > 0, t.compound = 0 === r.length; var a = n.matchPrefix(e, "a=rtcp-mux"); return t.mux = a.length > 0, t }, n.writeRtcpParameters = function (e) { var t = ""; return e.reducedSize && (t += "a=rtcp-rsize\r\n"), e.mux && (t += "a=rtcp-mux\r\n"), void 0 !== e.ssrc && e.cname && (t += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"), t }, n.parseMsid = function (e) { var t = void 0, i = n.matchPrefix(e, "a=msid:"); if (1 === i.length) return { stream: (t = i[0].substr(7).split(" "))[0], track: t[1] }; var r = n.matchPrefix(e, "a=ssrc:").map((function (e) { return n.parseSsrcMedia(e) })).filter((function (e) { return "msid" === e.attribute })); return r.length > 0 ? { stream: (t = r[0].value.split(" "))[0], track: t[1] } : void 0 }, n.parseSctpDescription = function (e) { var t = n.parseMLine(e), i = n.matchPrefix(e, "a=max-message-size:"), r = void 0; i.length > 0 && (r = parseInt(i[0].substr(19), 10)), isNaN(r) && (r = 65536); var a = n.matchPrefix(e, "a=sctp-port:"); if (a.length > 0) return { port: parseInt(a[0].substr(12), 10), protocol: t.fmt, maxMessageSize: r }; var o = n.matchPrefix(e, "a=sctpmap:"); if (o.length > 0) { var s = o[0].substr(10).split(" "); return { port: parseInt(s[0], 10), protocol: s[1], maxMessageSize: r } } }, n.writeSctpDescription = function (e, t) { var i = []; return i = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && i.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), i.join("") }, n.generateSessionId = function () { return Math.random().toString().substr(2, 21) }, n.writeSessionBoilerplate = function (e, t, i) { var r = void 0 !== t ? t : 2; return "v=0\r\no=" + (i || "thisisadapterortc") + " " + (e || n.generateSessionId()) + " " + r + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n" }, n.getDirection = function (e, t) { for (var i = n.splitLines(e), r = 0; r < i.length; r++)switch (i[r]) { case "a=sendrecv": case "a=sendonly": case "a=recvonly": case "a=inactive": return i[r].substr(2) }return t ? n.getDirection(t) : "sendrecv" }, n.getKind = function (e) { return n.splitLines(e)[0].split(" ")[0].substr(2) }, n.isRejected = function (e) { return "0" === e.split(" ", 2)[1] }, n.parseMLine = function (e) { var t = n.splitLines(e)[0].substr(2).split(" "); return { kind: t[0], port: parseInt(t[1], 10), protocol: t[2], fmt: t.slice(3).join(" ") } }, n.parseOLine = function (e) { var t = n.matchPrefix(e, "o=")[0].substr(2).split(" "); return { username: t[0], sessionId: t[1], sessionVersion: parseInt(t[2], 10), netType: t[3], addressType: t[4], address: t[5] } }, n.isValidSDP = function (e) { if ("string" != typeof e || 0 === e.length) return !1; for (var t = n.splitLines(e), i = 0; i < t.length; i++)if (t[i].length < 2 || "=" !== t[i].charAt(1)) return !1; return !0 }, "object" === (void 0 === t ? "undefined" : r(t)) && (t.exports = n) }, {}] }, {}, [1])(1) }(adapterLatest); class WebRtcPlayer { constructor(e) { e = e || {}; var t = this; this.cfg = e.peerConnectionOptions || {}, this.useTCP = e.useTCP || !0, this.cfg.sdpSemantics = "unified-plan", this.cfg.offerExtmapAllowMixed = !1, this.pcClient = null, this.dcClient = null, this.tnClient = null, this.sdpConstraints = { offerToReceiveAudio: 0, offerToReceiveVideo: 1, voiceActivityDetection: !1 }, this.dataChannelOptions = { ordered: !0 }; const i = new URLSearchParams(window.location.search); this.useMic = i.has("useMic"), this.useMic || console.log("Microphone access is not enabled. Pass ?useMic in the url to enable it."); let r = "localhost" === location.hostname || "127.0.0.1" === location.hostname, n = "https:" === location.protocol; function a(e) { console.info("signaling state change:", e) } function o(e) { console.info("ice connection state change:", e) } function s(e) { console.info("ice gathering state change:", e) } function l(e) { if (console.log("handleOnTrack", e.streams), e.track && console.log("Got track - " + e.track.kind + " id=" + e.track.id + " readyState=" + e.track.readyState), "audio" != e.track.kind) return "video" == e.track.kind && (t.video.srcObject, e.streams[0]), t.video.srcObject = e.streams[0], void console.log("Set video source from video track ontrack."); !function (e) { if (t.video.srcObject == e) return; if (t.video.srcObject && t.video.srcObject !== e) { let t = document.createElement("Audio"); t.autoplay = !0, t.srcObject = e, t.play(), console.log("Created new audio element to play seperate audio stream.") } }(e.streams[0]) } function c(e) { console.log("ICE candidate", e), e.candidate && e.candidate.candidate && t.onWebRtcCandidate(e.candidate) } !this.useMic || r || n || (this.useMic = !1, console.error("Microphone access in the browser will not work if you are not on HTTPS or localhost. Disabling mic access."), console.error("For testing you can enable HTTP microphone access Chrome by visiting chrome://flags/ and enabling 'unsafely-treat-insecure-origin-as-secure'")), this.latencyTestTimings = { TestStartTimeMs: null, UEReceiptTimeMs: null, UEPreCaptureTimeMs: null, UEPostCaptureTimeMs: null, UEPreEncodeTimeMs: null, UEPostEncodeTimeMs: null, UETransmissionTimeMs: null, BrowserReceiptTimeMs: null, FrameDisplayDeltaTimeMs: null, Reset: function () { this.TestStartTimeMs = null, this.UEReceiptTimeMs = null, this.UEPreCaptureTimeMs = null, this.UEPostCaptureTimeMs = null, this.UEPreEncodeTimeMs = null, this.UEPostEncodeTimeMs = null, this.UETransmissionTimeMs = null, this.BrowserReceiptTimeMs = null, this.FrameDisplayDeltaTimeMs = null }, SetUETimings: function (e) { this.UEReceiptTimeMs = e.ReceiptTimeMs, this.UEPreCaptureTimeMs = e.PreCaptureTimeMs, this.UEPostCaptureTimeMs = e.PostCaptureTimeMs, this.UEPreEncodeTimeMs = e.PreEncodeTimeMs, this.UEPostEncodeTimeMs = e.PostEncodeTimeMs, this.UETransmissionTimeMs = e.TransmissionTimeMs, this.BrowserReceiptTimeMs = Date.now(), this.OnAllLatencyTimingsReady(this) }, SetFrameDisplayDeltaTime: function (e) { null == this.FrameDisplayDeltaTimeMs && (this.FrameDisplayDeltaTimeMs = Math.round(e), this.OnAllLatencyTimingsReady(this)) }, OnAllLatencyTimingsReady: function (e) { } }, this.video = function () { var e = document.createElement("video"); if (e.id = "streamingVideo", e.playsInline = !0, e.disablepictureinpicture = !0, e.muted = !1, e.addEventListener("loadedmetadata", (function (e) { t.onVideoInitialised && t.onVideoInitialised() }), !0), "requestVideoFrameCallback" in HTMLVideoElement.prototype) { const i = (r, n) => { if (n.receiveTime && n.expectedDisplayTime) { const e = n.presentationTime - n.receiveTime; t.aggregatedStats.receiveToCompositeMs = e } e.requestVideoFrameCallback(i) }; e.requestVideoFrameCallback(i) } return e }(), this.startLatencyTest = function (e) { t.video && (t.latencyTestTimings.Reset(), t.latencyTestTimings.TestStartTimeMs = Date.now(), e(t.latencyTestTimings.TestStartTimeMs)) }, this.handleCandidateFromServer = function (e) { console.log("ICE candidate: ", e); let i = new RTCIceCandidate(e); t.useTCP || "tcp" != i.protocol ? t.pcClient.addIceCandidate(i).then((e => { console.log("ICE candidate successfully added") })) : console.log("RTCIceCandidate protocol TCP Not add in") }, this.createOffer = function () { t.pcClient && (console.log("Closing existing PeerConnection"), t.pcClient.close(), t.pcClient = null), t.pcClient = new RTCPeerConnection(t.cfg), async function (e) { if (e.addTransceiver("video", { direction: "recvonly" }), t.useMic) { let i = !!t.useMic && { autoGainControl: !1, channelCount: 1, echoCancellation: !1, latency: 0, noiseSuppression: !1, sampleRate: 16e3, volume: 1 }; const r = await navigator.mediaDevices.getUserMedia({ video: !1, audio: i }); if (r) for (const t of r.getTracks()) t.kind && "audio" == t.kind && e.addTransceiver(t, { direction: "sendrecv" }); else e.addTransceiver("audio", { direction: "recvonly" }) } else e.addTransceiver("audio", { direction: "recvonly" }) }(t.pcClient).finally((function () { var e; (e = t.pcClient).SetBitrate && console.log("Hurray! there's RTCPeerConnection.SetBitrate function"), e.onsignalingstatechange = a, e.oniceconnectionstatechange = o, e.onicegatheringstatechange = s, e.ontrack = l, e.onicecandidate = c, t.dcClient = function (e, i, r) { try { let n = e.createDataChannel(i, r); return console.log(`Created datachannel (${i})`), n.binaryType = "arraybuffer", n.onopen = function (e) { console.log(`data channel (${i}) connect`), t.onDataChannelConnected && t.onDataChannelConnected() }, n.onclose = function (e) { console.log(`data channel (${i}) closed`) }, n.onmessage = function (e) { t.onDataChannelMessage && t.onDataChannelMessage(e.data) }, n } catch (e) { return console.warn("No data channel", e), null } }(t.pcClient, "cirrus", t.dataChannelOptions), function (e) { e.createOffer(t.sdpConstraints).then((function (i) { !function (e) { e.sdp = e.sdp.replace("useinbandfec=1", "useinbandfec=1;stereo=1;sprop-maxcapturerate=48000") }(i), e.setLocalDescription(i), t.onWebRtcOffer && t.onWebRtcOffer(i) }), (function () { console.warn("Couldn't create offer") })) }(t.pcClient) })) }, this.receiveAnswer = function (e) { console.log("Received answer:"), console.log(e); var i = new RTCSessionDescription(e); t.pcClient.setRemoteDescription(i); let r = t.pcClient.getReceivers(); for (let e of r) e.playoutDelayHint = 0 }, this.close = function () { t.pcClient && (console.log("Closing existing peerClient"), t.pcClient.close(), t.pcClient = null), t.aggregateStatsIntervalId && clearInterval(t.aggregateStatsIntervalId) }, this.send = function (e) { t.dcClient && "open" == t.dcClient.readyState && t.dcClient.send(e) }, this.getStats = function (e) { t.pcClient && e && t.pcClient.getStats(null).then((t => { e(t) })) }, this.aggregateStats = function (e) { let i = (t.aggregatedStats || (t.aggregatedStats = {}), function (e) { let i = {}; console.log("----------------------------- Stats start -----------------------------"), e.forEach((e => { "inbound-rtp" != e.type || e.isRemote || "video" != e.mediaType && !e.id.toLowerCase().includes("video") || (i.timestamp = e.timestamp, i.bytesReceived = e.bytesReceived, i.framesDecoded = e.framesDecoded, i.packetsLost = e.packetsLost, i.bytesReceivedStart = t.aggregatedStats && t.aggregatedStats.bytesReceivedStart ? t.aggregatedStats.bytesReceivedStart : e.bytesReceived, i.framesDecodedStart = t.aggregatedStats && t.aggregatedStats.framesDecodedStart ? t.aggregatedStats.framesDecodedStart : e.framesDecoded, i.timestampStart = t.aggregatedStats && t.aggregatedStats.timestampStart ? t.aggregatedStats.timestampStart : e.timestamp, t.aggregatedStats && t.aggregatedStats.timestamp && (t.aggregatedStats.bytesReceived && (i.bitrate = 8 * (i.bytesReceived - t.aggregatedStats.bytesReceived) / (i.timestamp - t.aggregatedStats.timestamp), i.bitrate = Math.floor(i.bitrate), i.lowBitrate = t.aggregatedStats.lowBitrate && t.aggregatedStats.lowBitrate < i.bitrate ? t.aggregatedStats.lowBitrate : i.bitrate, i.highBitrate = t.aggregatedStats.highBitrate && t.aggregatedStats.highBitrate > i.bitrate ? t.aggregatedStats.highBitrate : i.bitrate), t.aggregatedStats.bytesReceivedStart && (i.avgBitrate = 8 * (i.bytesReceived - t.aggregatedStats.bytesReceivedStart) / (i.timestamp - t.aggregatedStats.timestampStart), i.avgBitrate = Math.floor(i.avgBitrate)), t.aggregatedStats.framesDecoded && (i.framerate = (i.framesDecoded - t.aggregatedStats.framesDecoded) / ((i.timestamp - t.aggregatedStats.timestamp) / 1e3), i.framerate = Math.floor(i.framerate), i.lowFramerate = t.aggregatedStats.lowFramerate && t.aggregatedStats.lowFramerate < i.framerate ? t.aggregatedStats.lowFramerate : i.framerate, i.highFramerate = t.aggregatedStats.highFramerate && t.aggregatedStats.highFramerate > i.framerate ? t.aggregatedStats.highFramerate : i.framerate), t.aggregatedStats.framesDecodedStart && (i.avgframerate = (i.framesDecoded - t.aggregatedStats.framesDecodedStart) / ((i.timestamp - t.aggregatedStats.timestampStart) / 1e3), i.avgframerate = Math.floor(i.avgframerate)))), "track" != e.type || "video_label" != e.trackIdentifier && "video" != e.kind || (i.framesDropped = e.framesDropped, i.framesReceived = e.framesReceived, i.framesDroppedPercentage = e.framesDropped / e.framesReceived * 100, i.frameHeight = e.frameHeight, i.frameWidth = e.frameWidth, i.frameHeightStart = t.aggregatedStats && t.aggregatedStats.frameHeightStart ? t.aggregatedStats.frameHeightStart : e.frameHeight, i.frameWidthStart = t.aggregatedStats && t.aggregatedStats.frameWidthStart ? t.aggregatedStats.frameWidthStart : e.frameWidth), "candidate-pair" == e.type && e.hasOwnProperty("currentRoundTripTime") && 0 != e.currentRoundTripTime && (i.currentRoundTripTime = e.currentRoundTripTime) })), t.aggregatedStats.receiveToCompositeMs && (i.receiveToCompositeMs = t.aggregatedStats.receiveToCompositeMs, t.latencyTestTimings.SetFrameDisplayDeltaTime(t.aggregatedStats.receiveToCompositeMs)), t.aggregatedStats = i, t.onAggregatedStats && t.onAggregatedStats(i) }); t.aggregateStatsIntervalId = setInterval((() => { t.getStats(i) }), e) } } } var hammer = { exports: {} };
/*! Hammer.JS - v2.0.8 - 2016-04-23
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license */!function (e) { !function (t, i, r, n) { var a, o = ["", "webkit", "Moz", "MS", "ms", "o"], s = i.createElement("div"), l = Math.round, c = Math.abs, h = Date.now; function u(e, t, i) { return setTimeout(v(e, i), t) } function d(e, t, i) { return !!Array.isArray(e) && (p(e, i[t], i), !0) } function p(e, t, i) { var r; if (e) if (e.forEach) e.forEach(t, i); else if (e.length !== n) for (r = 0; r < e.length;)t.call(i, e[r], r, e), r++; else for (r in e) e.hasOwnProperty(r) && t.call(i, e[r], r, e) } function f(e, i, r) { var n = "DEPRECATED METHOD: " + i + "\n" + r + " AT \n"; return function () { var i = new Error("get-stack-trace"), r = i && i.stack ? i.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", a = t.console && (t.console.warn || t.console.log); return a && a.call(t.console, n, r), e.apply(this, arguments) } } a = "function" != typeof Object.assign ? function (e) { if (e === n || null === e) throw new TypeError("Cannot convert undefined or null to object"); for (var t = Object(e), i = 1; i < arguments.length; i++) { var r = arguments[i]; if (r !== n && null !== r) for (var a in r) r.hasOwnProperty(a) && (t[a] = r[a]) } return t } : Object.assign; var m = f((function (e, t, i) { for (var r = Object.keys(t), a = 0; a < r.length;)(!i || i && e[r[a]] === n) && (e[r[a]] = t[r[a]]), a++; return e }), "extend", "Use `assign`."), g = f((function (e, t) { return m(e, t, !0) }), "merge", "Use `assign`."); function y(e, t, i) { var r, n = t.prototype; (r = e.prototype = Object.create(n)).constructor = e, r._super = n, i && a(r, i) } function v(e, t) { return function () { return e.apply(t, arguments) } } function _(e, t) { return "function" == typeof e ? e.apply(t && t[0] || n, t) : e } function b(e, t) { return e === n ? t : e } function x(e, t, i) { p(T(t), (function (t) { e.addEventListener(t, i, !1) })) } function w(e, t, i) { p(T(t), (function (t) { e.removeEventListener(t, i, !1) })) } function S(e, t) { for (; e;) { if (e == t) return !0; e = e.parentNode } return !1 } function M(e, t) { return e.indexOf(t) > -1 } function T(e) { return e.trim().split(/\s+/g) } function A(e, t, i) { if (e.indexOf && !i) return e.indexOf(t); for (var r = 0; r < e.length;) { if (i && e[r][i] == t || !i && e[r] === t) return r; r++ } return -1 } function E(e) { return Array.prototype.slice.call(e, 0) } function C(e, t, i) { for (var r = [], n = [], a = 0; a < e.length;) { var o = t ? e[a][t] : e[a]; A(n, o) < 0 && r.push(e[a]), n[a] = o, a++ } return i && (r = t ? r.sort((function (e, i) { return e[t] > i[t] })) : r.sort()), r } function L(e, t) { for (var i, r, a = t[0].toUpperCase() + t.slice(1), s = 0; s < o.length;) { if ((r = (i = o[s]) ? i + a : t) in e) return r; s++ } return n } var R = 1; function D(e) { var i = e.ownerDocument || e; return i.defaultView || i.parentWindow || t } var P = "ontouchstart" in t, O = L(t, "PointerEvent") !== n, I = P && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent), k = "touch", B = "mouse", N = 24, F = ["x", "y"], U = ["clientX", "clientY"]; function z(e, t) { var i = this; this.manager = e, this.callback = t, this.element = e.element, this.target = e.options.inputTarget, this.domHandler = function (t) { _(e.options.enable, [e]) && i.handler(t) }, this.init() } function G(e, t, i) { var r = i.pointers.length, a = i.changedPointers.length, o = 1 & t && r - a == 0, s = 12 & t && r - a == 0; i.isFirst = !!o, i.isFinal = !!s, o && (e.session = {}), i.eventType = t, function (e, t) { var i = e.session, r = t.pointers, a = r.length; i.firstInput || (i.firstInput = H(t)); a > 1 && !i.firstMultiple ? i.firstMultiple = H(t) : 1 === a && (i.firstMultiple = !1); var o = i.firstInput, s = i.firstMultiple, l = s ? s.center : o.center, u = t.center = V(r); t.timeStamp = h(), t.deltaTime = t.timeStamp - o.timeStamp, t.angle = Y(l, u), t.distance = $(l, u), function (e, t) { var i = t.center, r = e.offsetDelta || {}, n = e.prevDelta || {}, a = e.prevInput || {}; 1 !== t.eventType && 4 !== a.eventType || (n = e.prevDelta = { x: a.deltaX || 0, y: a.deltaY || 0 }, r = e.offsetDelta = { x: i.x, y: i.y }); t.deltaX = n.x + (i.x - r.x), t.deltaY = n.y + (i.y - r.y) }(i, t), t.offsetDirection = W(t.deltaX, t.deltaY); var d = j(t.deltaTime, t.deltaX, t.deltaY); t.overallVelocityX = d.x, t.overallVelocityY = d.y, t.overallVelocity = c(d.x) > c(d.y) ? d.x : d.y, t.scale = s ? function (e, t) { return $(t[0], t[1], U) / $(e[0], e[1], U) }(s.pointers, r) : 1, t.rotation = s ? function (e, t) { return Y(t[1], t[0], U) + Y(e[1], e[0], U) }(s.pointers, r) : 0, t.maxPointers = i.prevInput ? t.pointers.length > i.prevInput.maxPointers ? t.pointers.length : i.prevInput.maxPointers : t.pointers.length, function (e, t) { var i, r, a, o, s = e.lastInterval || t, l = t.timeStamp - s.timeStamp; if (8 != t.eventType && (l > 25 || s.velocity === n)) { var h = t.deltaX - s.deltaX, u = t.deltaY - s.deltaY, d = j(l, h, u); r = d.x, a = d.y, i = c(d.x) > c(d.y) ? d.x : d.y, o = W(h, u), e.lastInterval = t } else i = s.velocity, r = s.velocityX, a = s.velocityY, o = s.direction; t.velocity = i, t.velocityX = r, t.velocityY = a, t.direction = o }(i, t); var p = e.element; S(t.srcEvent.target, p) && (p = t.srcEvent.target); t.target = p }(e, i), e.emit("hammer.input", i), e.recognize(i), e.session.prevInput = i } function H(e) { for (var t = [], i = 0; i < e.pointers.length;)t[i] = { clientX: l(e.pointers[i].clientX), clientY: l(e.pointers[i].clientY) }, i++; return { timeStamp: h(), pointers: t, center: V(t), deltaX: e.deltaX, deltaY: e.deltaY } } function V(e) { var t = e.length; if (1 === t) return { x: l(e[0].clientX), y: l(e[0].clientY) }; for (var i = 0, r = 0, n = 0; n < t;)i += e[n].clientX, r += e[n].clientY, n++; return { x: l(i / t), y: l(r / t) } } function j(e, t, i) { return { x: t / e || 0, y: i / e || 0 } } function W(e, t) { return e === t ? 1 : c(e) >= c(t) ? e < 0 ? 2 : 4 : t < 0 ? 8 : 16 } function $(e, t, i) { i || (i = F); var r = t[i[0]] - e[i[0]], n = t[i[1]] - e[i[1]]; return Math.sqrt(r * r + n * n) } function Y(e, t, i) { i || (i = F); var r = t[i[0]] - e[i[0]], n = t[i[1]] - e[i[1]]; return 180 * Math.atan2(n, r) / Math.PI } z.prototype = { handler: function () { }, init: function () { this.evEl && x(this.element, this.evEl, this.domHandler), this.evTarget && x(this.target, this.evTarget, this.domHandler), this.evWin && x(D(this.element), this.evWin, this.domHandler) }, destroy: function () { this.evEl && w(this.element, this.evEl, this.domHandler), this.evTarget && w(this.target, this.evTarget, this.domHandler), this.evWin && w(D(this.element), this.evWin, this.domHandler) } }; var X = { mousedown: 1, mousemove: 2, mouseup: 4 }, Z = "mousedown", q = "mousemove mouseup"; function J() { this.evEl = Z, this.evWin = q, this.pressed = !1, z.apply(this, arguments) } y(J, z, { handler: function (e) { var t = X[e.type]; 1 & t && 0 === e.button && (this.pressed = !0), 2 & t && 1 !== e.which && (t = 4), this.pressed && (4 & t && (this.pressed = !1), this.callback(this.manager, t, { pointers: [e], changedPointers: [e], pointerType: B, srcEvent: e })) } }); var K = { pointerdown: 1, pointermove: 2, pointerup: 4, pointercancel: 8, pointerout: 8 }, Q = { 2: k, 3: "pen", 4: B, 5: "kinect" }, ee = "pointerdown", te = "pointermove pointerup pointercancel"; function ie() { this.evEl = ee, this.evWin = te, z.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] } t.MSPointerEvent && !t.PointerEvent && (ee = "MSPointerDown", te = "MSPointerMove MSPointerUp MSPointerCancel"), y(ie, z, { handler: function (e) { var t = this.store, i = !1, r = e.type.toLowerCase().replace("ms", ""), n = K[r], a = Q[e.pointerType] || e.pointerType, o = a == k, s = A(t, e.pointerId, "pointerId"); 1 & n && (0 === e.button || o) ? s < 0 && (t.push(e), s = t.length - 1) : 12 & n && (i = !0), s < 0 || (t[s] = e, this.callback(this.manager, n, { pointers: t, changedPointers: [e], pointerType: a, srcEvent: e }), i && t.splice(s, 1)) } }); var re = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }, ne = "touchstart", ae = "touchstart touchmove touchend touchcancel"; function oe() { this.evTarget = ne, this.evWin = ae, this.started = !1, z.apply(this, arguments) } function se(e, t) { var i = E(e.touches), r = E(e.changedTouches); return 12 & t && (i = C(i.concat(r), "identifier", !0)), [i, r] } y(oe, z, { handler: function (e) { var t = re[e.type]; if (1 === t && (this.started = !0), this.started) { var i = se.call(this, e, t); 12 & t && i[0].length - i[1].length == 0 && (this.started = !1), this.callback(this.manager, t, { pointers: i[0], changedPointers: i[1], pointerType: k, srcEvent: e }) } } }); var le = { touchstart: 1, touchmove: 2, touchend: 4, touchcancel: 8 }, ce = "touchstart touchmove touchend touchcancel"; function he() { this.evTarget = ce, this.targetIds = {}, z.apply(this, arguments) } function ue(e, t) { var i = E(e.touches), r = this.targetIds; if (3 & t && 1 === i.length) return r[i[0].identifier] = !0, [i, i]; var n, a, o = E(e.changedTouches), s = [], l = this.target; if (a = i.filter((function (e) { return S(e.target, l) })), 1 === t) for (n = 0; n < a.length;)r[a[n].identifier] = !0, n++; for (n = 0; n < o.length;)r[o[n].identifier] && s.push(o[n]), 12 & t && delete r[o[n].identifier], n++; return s.length ? [C(a.concat(s), "identifier", !0), s] : void 0 } y(he, z, { handler: function (e) { var t = le[e.type], i = ue.call(this, e, t); i && this.callback(this.manager, t, { pointers: i[0], changedPointers: i[1], pointerType: k, srcEvent: e }) } }); function de() { z.apply(this, arguments); var e = v(this.handler, this); this.touch = new he(this.manager, e), this.mouse = new J(this.manager, e), this.primaryTouch = null, this.lastTouches = [] } function pe(e, t) { 1 & e ? (this.primaryTouch = t.changedPointers[0].identifier, fe.call(this, t)) : 12 & e && fe.call(this, t) } function fe(e) { var t = e.changedPointers[0]; if (t.identifier === this.primaryTouch) { var i = { x: t.clientX, y: t.clientY }; this.lastTouches.push(i); var r = this.lastTouches; setTimeout((function () { var e = r.indexOf(i); e > -1 && r.splice(e, 1) }), 2500) } } function me(e) { for (var t = e.srcEvent.clientX, i = e.srcEvent.clientY, r = 0; r < this.lastTouches.length; r++) { var n = this.lastTouches[r], a = Math.abs(t - n.x), o = Math.abs(i - n.y); if (a <= 25 && o <= 25) return !0 } return !1 } y(de, z, { handler: function (e, t, i) { var r = i.pointerType == k, n = i.pointerType == B; if (!(n && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) { if (r) pe.call(this, t, i); else if (n && me.call(this, i)) return; this.callback(e, t, i) } }, destroy: function () { this.touch.destroy(), this.mouse.destroy() } }); var ge = L(s.style, "touchAction"), ye = ge !== n, ve = "compute", _e = "auto", be = "manipulation", xe = "none", we = "pan-x", Se = "pan-y", Me = function () { if (!ye) return !1; var e = {}, i = t.CSS && t.CSS.supports; return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach((function (r) { e[r] = !i || t.CSS.supports("touch-action", r) })), e }(); function Te(e, t) { this.manager = e, this.set(t) } Te.prototype = { set: function (e) { e == ve && (e = this.compute()), ye && this.manager.element.style && Me[e] && (this.manager.element.style[ge] = e), this.actions = e.toLowerCase().trim() }, update: function () { this.set(this.manager.options.touchAction) }, compute: function () { var e = []; return p(this.manager.recognizers, (function (t) { _(t.options.enable, [t]) && (e = e.concat(t.getTouchAction())) })), function (e) { if (M(e, xe)) return xe; var t = M(e, we), i = M(e, Se); if (t && i) return xe; if (t || i) return t ? we : Se; if (M(e, be)) return be; return _e }(e.join(" ")) }, preventDefaults: function (e) { var t = e.srcEvent, i = e.offsetDirection; if (this.manager.session.prevented) t.preventDefault(); else { var r = this.actions, n = M(r, xe) && !Me.none, a = M(r, Se) && !Me["pan-y"], o = M(r, we) && !Me["pan-x"]; if (n) { var s = 1 === e.pointers.length, l = e.distance < 2, c = e.deltaTime < 250; if (s && l && c) return } if (!o || !a) return n || a && 6 & i || o && i & N ? this.preventSrc(t) : void 0 } }, preventSrc: function (e) { this.manager.session.prevented = !0, e.preventDefault() } }; var Ae = 32; function Ee(e) { this.options = a({}, this.defaults, e || {}), this.id = R++, this.manager = null, this.options.enable = b(this.options.enable, !0), this.state = 1, this.simultaneous = {}, this.requireFail = [] } function Ce(e) { return 16 & e ? "cancel" : 8 & e ? "end" : 4 & e ? "move" : 2 & e ? "start" : "" } function Le(e) { return 16 == e ? "down" : 8 == e ? "up" : 2 == e ? "left" : 4 == e ? "right" : "" } function Re(e, t) { var i = t.manager; return i ? i.get(e) : e } function De() { Ee.apply(this, arguments) } function Pe() { De.apply(this, arguments), this.pX = null, this.pY = null } function Oe() { De.apply(this, arguments) } function Ie() { Ee.apply(this, arguments), this._timer = null, this._input = null } function ke() { De.apply(this, arguments) } function Be() { De.apply(this, arguments) } function Ne() { Ee.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 } function Fe(e, t) { return (t = t || {}).recognizers = b(t.recognizers, Fe.defaults.preset), new Ue(e, t) } Ee.prototype = { defaults: {}, set: function (e) { return a(this.options, e), this.manager && this.manager.touchAction.update(), this }, recognizeWith: function (e) { if (d(e, "recognizeWith", this)) return this; var t = this.simultaneous; return t[(e = Re(e, this)).id] || (t[e.id] = e, e.recognizeWith(this)), this }, dropRecognizeWith: function (e) { return d(e, "dropRecognizeWith", this) || (e = Re(e, this), delete this.simultaneous[e.id]), this }, requireFailure: function (e) { if (d(e, "requireFailure", this)) return this; var t = this.requireFail; return -1 === A(t, e = Re(e, this)) && (t.push(e), e.requireFailure(this)), this }, dropRequireFailure: function (e) { if (d(e, "dropRequireFailure", this)) return this; e = Re(e, this); var t = A(this.requireFail, e); return t > -1 && this.requireFail.splice(t, 1), this }, hasRequireFailures: function () { return this.requireFail.length > 0 }, canRecognizeWith: function (e) { return !!this.simultaneous[e.id] }, emit: function (e) { var t = this, i = this.state; function r(i) { t.manager.emit(i, e) } i < 8 && r(t.options.event + Ce(i)), r(t.options.event), e.additionalEvent && r(e.additionalEvent), i >= 8 && r(t.options.event + Ce(i)) }, tryEmit: function (e) { if (this.canEmit()) return this.emit(e); this.state = Ae }, canEmit: function () { for (var e = 0; e < this.requireFail.length;) { if (!(33 & this.requireFail[e].state)) return !1; e++ } return !0 }, recognize: function (e) { var t = a({}, e); if (!_(this.options.enable, [this, t])) return this.reset(), void (this.state = Ae); 56 & this.state && (this.state = 1), this.state = this.process(t), 30 & this.state && this.tryEmit(t) }, process: function (e) { }, getTouchAction: function () { }, reset: function () { } }, y(De, Ee, { defaults: { pointers: 1 }, attrTest: function (e) { var t = this.options.pointers; return 0 === t || e.pointers.length === t }, process: function (e) { var t = this.state, i = e.eventType, r = 6 & t, n = this.attrTest(e); return r && (8 & i || !n) ? 16 | t : r || n ? 4 & i ? 8 | t : 2 & t ? 4 | t : 2 : Ae } }), y(Pe, De, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: 30 }, getTouchAction: function () { var e = this.options.direction, t = []; return 6 & e && t.push(Se), e & N && t.push(we), t }, directionTest: function (e) { var t = this.options, i = !0, r = e.distance, n = e.direction, a = e.deltaX, o = e.deltaY; return n & t.direction || (6 & t.direction ? (n = 0 === a ? 1 : a < 0 ? 2 : 4, i = a != this.pX, r = Math.abs(e.deltaX)) : (n = 0 === o ? 1 : o < 0 ? 8 : 16, i = o != this.pY, r = Math.abs(e.deltaY))), e.direction = n, i && r > t.threshold && n & t.direction }, attrTest: function (e) { return De.prototype.attrTest.call(this, e) && (2 & this.state || !(2 & this.state) && this.directionTest(e)) }, emit: function (e) { this.pX = e.deltaX, this.pY = e.deltaY; var t = Le(e.direction); t && (e.additionalEvent = this.options.event + t), this._super.emit.call(this, e) } }), y(Oe, De, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function () { return [xe] }, attrTest: function (e) { return this._super.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || 2 & this.state) }, emit: function (e) { if (1 !== e.scale) { var t = e.scale < 1 ? "in" : "out"; e.additionalEvent = this.options.event + t } this._super.emit.call(this, e) } }), y(Ie, Ee, { defaults: { event: "press", pointers: 1, time: 251, threshold: 9 }, getTouchAction: function () { return [_e] }, process: function (e) { var t = this.options, i = e.pointers.length === t.pointers, r = e.distance < t.threshold, n = e.deltaTime > t.time; if (this._input = e, !r || !i || 12 & e.eventType && !n) this.reset(); else if (1 & e.eventType) this.reset(), this._timer = u((function () { this.state = 8, this.tryEmit() }), t.time, this); else if (4 & e.eventType) return 8; return Ae }, reset: function () { clearTimeout(this._timer) }, emit: function (e) { 8 === this.state && (e && 4 & e.eventType ? this.manager.emit(this.options.event + "up", e) : (this._input.timeStamp = h(), this.manager.emit(this.options.event, this._input))) } }), y(ke, De, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function () { return [xe] }, attrTest: function (e) { return this._super.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || 2 & this.state) } }), y(Be, De, { defaults: { event: "swipe", threshold: 10, velocity: .3, direction: 30, pointers: 1 }, getTouchAction: function () { return Pe.prototype.getTouchAction.call(this) }, attrTest: function (e) { var t, i = this.options.direction; return 30 & i ? t = e.overallVelocity : 6 & i ? t = e.overallVelocityX : i & N && (t = e.overallVelocityY), this._super.attrTest.call(this, e) && i & e.offsetDirection && e.distance > this.options.threshold && e.maxPointers == this.options.pointers && c(t) > this.options.velocity && 4 & e.eventType }, emit: function (e) { var t = Le(e.offsetDirection); t && this.manager.emit(this.options.event + t, e), this.manager.emit(this.options.event, e) } }), y(Ne, Ee, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10 }, getTouchAction: function () { return [be] }, process: function (e) { var t = this.options, i = e.pointers.length === t.pointers, r = e.distance < t.threshold, n = e.deltaTime < t.time; if (this.reset(), 1 & e.eventType && 0 === this.count) return this.failTimeout(); if (r && n && i) { if (4 != e.eventType) return this.failTimeout(); var a = !this.pTime || e.timeStamp - this.pTime < t.interval, o = !this.pCenter || $(this.pCenter, e.center) < t.posThreshold; if (this.pTime = e.timeStamp, this.pCenter = e.center, o && a ? this.count += 1 : this.count = 1, this._input = e, 0 === this.count % t.taps) return this.hasRequireFailures() ? (this._timer = u((function () { this.state = 8, this.tryEmit() }), t.interval, this), 2) : 8 } return Ae }, failTimeout: function () { return this._timer = u((function () { this.state = Ae }), this.options.interval, this), Ae }, reset: function () { clearTimeout(this._timer) }, emit: function () { 8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), Fe.VERSION = "2.0.8", Fe.defaults = { domEvents: !1, touchAction: ve, enable: !0, inputTarget: null, inputClass: null, preset: [[ke, { enable: !1 }], [Oe, { enable: !1 }, ["rotate"]], [Be, { direction: 6 }], [Pe, { direction: 6 }, ["swipe"]], [Ne], [Ne, { event: "doubletap", taps: 2 }, ["tap"]], [Ie]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } }; function Ue(e, t) { var i; this.options = a({}, Fe.defaults, t || {}), this.options.inputTarget = this.options.inputTarget || e, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e, this.input = new ((i = this).options.inputClass || (O ? ie : I ? he : P ? de : J))(i, G), this.touchAction = new Te(this, this.options.touchAction), ze(this, !0), p(this.options.recognizers, (function (e) { var t = this.add(new e[0](e[1])); e[2] && t.recognizeWith(e[2]), e[3] && t.requireFailure(e[3]) }), this) } function ze(e, t) { var i, r = e.element; r.style && (p(e.options.cssProps, (function (n, a) { i = L(r.style, a), t ? (e.oldCssProps[i] = r.style[i], r.style[i] = n) : r.style[i] = e.oldCssProps[i] || "" })), t || (e.oldCssProps = {})) } Ue.prototype = { set: function (e) { return a(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this }, stop: function (e) { this.session.stopped = e ? 2 : 1 }, recognize: function (e) { var t = this.session; if (!t.stopped) { var i; this.touchAction.preventDefaults(e); var r = this.recognizers, n = t.curRecognizer; (!n || n && 8 & n.state) && (n = t.curRecognizer = null); for (var a = 0; a < r.length;)i = r[a], 2 === t.stopped || n && i != n && !i.canRecognizeWith(n) ? i.reset() : i.recognize(e), !n && 14 & i.state && (n = t.curRecognizer = i), a++ } }, get: function (e) { if (e instanceof Ee) return e; for (var t = this.recognizers, i = 0; i < t.length; i++)if (t[i].options.event == e) return t[i]; return null }, add: function (e) { if (d(e, "add", this)) return this; var t = this.get(e.options.event); return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), e }, remove: function (e) { if (d(e, "remove", this)) return this; if (e = this.get(e)) { var t = this.recognizers, i = A(t, e); -1 !== i && (t.splice(i, 1), this.touchAction.update()) } return this }, on: function (e, t) { if (e !== n && t !== n) { var i = this.handlers; return p(T(e), (function (e) { i[e] = i[e] || [], i[e].push(t) })), this } }, off: function (e, t) { if (e !== n) { var i = this.handlers; return p(T(e), (function (e) { t ? i[e] && i[e].splice(A(i[e], t), 1) : delete i[e] })), this } }, emit: function (e, t) { this.options.domEvents && function (e, t) { var r = i.createEvent("Event"); r.initEvent(e, !0, !0), r.gesture = t, t.target.dispatchEvent(r) }(e, t); var r = this.handlers[e] && this.handlers[e].slice(); if (r && r.length) { t.type = e, t.preventDefault = function () { t.srcEvent.preventDefault() }; for (var n = 0; n < r.length;)r[n](t), n++ } }, destroy: function () { this.element && ze(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, a(Fe, { INPUT_START: 1, INPUT_MOVE: 2, INPUT_END: 4, INPUT_CANCEL: 8, STATE_POSSIBLE: 1, STATE_BEGAN: 2, STATE_CHANGED: 4, STATE_ENDED: 8, STATE_RECOGNIZED: 8, STATE_CANCELLED: 16, STATE_FAILED: Ae, DIRECTION_NONE: 1, DIRECTION_LEFT: 2, DIRECTION_RIGHT: 4, DIRECTION_UP: 8, DIRECTION_DOWN: 16, DIRECTION_HORIZONTAL: 6, DIRECTION_VERTICAL: N, DIRECTION_ALL: 30, Manager: Ue, Input: z, TouchAction: Te, TouchInput: he, MouseInput: J, PointerEventInput: ie, TouchMouseInput: de, SingleTouchInput: oe, Recognizer: Ee, AttrRecognizer: De, Tap: Ne, Pan: Pe, Swipe: Be, Pinch: Oe, Rotate: ke, Press: Ie, on: x, off: w, each: p, merge: g, extend: m, assign: a, inherit: y, bindFn: v, prefixed: L }), (void 0 !== t ? t : "undefined" != typeof self ? self : {}).Hammer = Fe, e.exports ? e.exports = Fe : t.Hammer = Fe }(window, document) }(hammer); var Hammer = hammer.exports; const MessageType$1 = { IFrameRequest: 0, RequestQualityControl: 1, MaxFpsRequest: 2, AverageBitrateRequest: 3, StartStreaming: 4, StopStreaming: 5, UIInteraction: 50, Command: 51, KeyDown: 60, KeyUp: 61, KeyPress: 62, MouseEnter: 70, MouseLeave: 71, MouseDown: 72, MouseUp: 73, MouseMove: 74, MouseWheel: 75, TouchStart: 80, TouchEnd: 81, TouchMove: 82 }, ToClientMessageType = { QualityControlOwnership: 0, Response: 1, Command: 2, FreezeFrame: 3, UnfreezeFrame: 4, VideoEncoderAvgQP: 5 }, SpecialKeyCodes = { BackSpace: 8, Shift: 16, Control: 17, Alt: 18, RightShift: 253, RightControl: 254, RightAlt: 255 }, MouseButton = { MainButton: 0, AuxiliaryButton: 1, SecondaryButton: 2, FourthButton: 3, FifthButton: 4 }, MouseButtonsMask = { PrimaryButton: 1, SecondaryButton: 2, AuxiliaryButton: 4, FourthButton: 8, FifthButton: 16 }, MultiTouchState = { PanValueX: 0, PanValueY: 0, PanOffsetX: 0, PanOffsetY: 0, PanSize: .06, OrbitValueX: 0, OrbitValueY: 0, OrbitOffsetX: 0, OrbitOffsetY: 0, OrbitSize: .06, ZoomValue: 0, ZoomOffset: 0, ZoomSize: 1, DeltaTimeValue: 5e3 }, ControlSchemeType = { LockedMouse: 0, HoveringMouse: 1 }, VideoQualityType = { High: 0, Medium: 1, Low: 2 }; class StreamingPlayerState { constructor() { this.videoQuality = VideoQualityType.High, this.videoQuantizationParameter = "N/A", this.duration = "N/A", this.VideoResolution = "N/A", this.framerate = "N/A", this.bitrate = "N/A", this.packetsLost = "N/A", this.framesDropped = "N/A", this.latency = "N/A" } } class StreamingPlayer { constructor(e) { this.webRtcPlayerObj = null, this.client = null, this.playerElement = null, this.canInputConsoleCommand = !1, this._responseCallback = new Map, this._controlScheme = ControlSchemeType.LockedMouse, this._printInputs = !1, this._printLog = !1, this._queryInterval = 0, this._stateCallback = null, this._ws = null, this._videoEncoderQP = "N/A", this._lastPoint = { x: 0, y: 0 }, this._lastPanPoint = { x: 0, y: 0 }, this._lastOrbitPoint = { x: 0, y: 0 }, this._lastScale = 0, this._isTouch = !1, this._useTCP = !0, this._useWebSockets = !1, this._webSocketsOnlySend = !0, this._controlScheme = e.controlScheme, this._printInputs = e.printInputs, this._printLog = e.printLog, this._queryInterval = e.stateQueryInterval } createVideoElement(e) { const t = document.createElement("div"); t.setAttribute("id", "playerDiv"); var i = !1, r = !0; e.iceServers && e.iceServers.length > 0 && (0 == e.isForceRelay && (r = !1), e.iceServers[0].urls && e.iceServers[0].urls.forEach((e => { e.startsWith("turn") && (i = !0) }))); i && r && (e.iceTransportPolicy = "relay"), this.playerElement = this._setupWebRtcPlayer(t, e), this.playerElement.tabIndex = 0 } startPlay(e) { if (window.WebSocket = window.WebSocket || window.MozWebSocket, !window.WebSocket) return void alert("Your browser doesn't support WebSocket"); let t = this; this._ws = new WebSocket(e), this._ws.onopen = e => { switch (t._createWebRtcOffer(), t._registerKeyboardEvents(t.playerElement), t._registerInputs(t.playerElement), t._controlScheme) { case ControlSchemeType.HoveringMouse: t._registerHoveringMouseEvents(t.playerElement); break; case ControlSchemeType.LockedMouse: t._registerLockedMouseEvents(t.playerElement); break; default: t._printLog && logger.debug("ERROR: Unknown control scheme"), t._registerLockedMouseEvents(t.playerElement) }setInterval((() => { "1" == this._ws.readyState && t._ws.send(JSON.stringify({ type: "ping" })) }), 5e3) }, this._ws.onmessage = function (e) { if (e.data) if (t._printLog && logger.debug(`<- SS: ${e.data}`), "UE4 stopped" !== e.data) try { var i = JSON.parse(e.data); "config" === i.type ? logger.debug(i) : "playerCount" === i.type ? updateKickButton(i.count - 1) : "answer" === i.type ? t._onWebRtcAnswer(i) : "iceCandidate" === i.type ? t._onWebRtcIce(i.candidate) : "avwResponse" === i.type ? t._useWebSockets && !t._webSocketsOnlySend && t._onWebSocketsAvwResponse(i) : "RTSAStats" === i.type && i.stats ? t._recieveFromRTSAStats(i.stats) : "RTSAStats" === i.type && i.forceKeyFrame ? t._recieveFromRTSAforceKeyFrame() : logger.warn(`invalid SS message type: ${i.type}`) } catch (t) { logger.warn(`unknown SS message : ${e.data}`) } else logger.error("WS error: UE4 stopped") }, this._ws.onerror = function (e) { logger.error(`WS error: ${JSON.stringify(e)}`) }, this._ws.onclose = function (i) { if (t._printLog && logger.debug(`WS closed: ${JSON.stringify(i.code)} - ${i.reason}`), "forever" !== i.reason && "" !== i.reason) return setTimeout((() => { t.startPlay(e) }), 3e3), void (t._ws = void 0); t._destroyObject() } } emitUIInteraction(e) { this._emitDescriptor(MessageType$1.UIInteraction, e) } emitCommand(e) { this._emitDescriptor(MessageType$1.Command, e) } registerResponseEvent(e, t) { this._responseCallback.set(e, t) } unRegisterResponseEvent(e) { this._responseCallback.remove(e) } addStatusChangedListener(e) { "function" == typeof e ? this._stateCallback = e : logger.error("监听状态改变参数不正确，应传入函数") } removeStatusChangedListener() { this._stateCallback = null } destroy() { this._printLog && logger.debug("开始销毁StreamingPlayer。"), this._ws ? this._ws.close() : this._destroyObject() } _destroyObject() { let e = this; this._stateCallback = void 0, this._responseCallback && (this._responseCallback.clear(), this._responseCallback = void 0); let t = document.getElementById("playerDiv"); t && t.removeChild(e.webRtcPlayerObj.video), e.webRtcPlayerObj && (e.webRtcPlayerObj.close(), e.webRtcPlayerObj = void 0) } _emitMouseMove(e, t, i, r) { this._printInputs && logger.debug(`x: ${e}, y:${t}, dX: ${i}, dY: ${r}`); let n = this._runNormalizeAndQuantizeUnsigned(e, t), a = this._runNormalizeAndQuantizeSigned(i, r); var o = new DataView(new ArrayBuffer(9)); o.setUint8(0, MessageType$1.MouseMove), o.setUint16(1, n.x, !0), o.setUint16(3, n.y, !0), o.setInt16(5, a.x, !0), o.setInt16(7, a.y, !0), this._sendInputData(o.buffer), this._lastPoint.x = e, this._lastPoint.y = t } _emitMouseDown(e, t, i) { this._printInputs && logger.debug(`mouse button ${e} down at (${t}, ${i})`); let r = this._runNormalizeAndQuantizeUnsigned(t, i); var n = new DataView(new ArrayBuffer(6)); n.setUint8(0, MessageType$1.MouseDown), n.setUint8(1, e), n.setUint16(2, r.x, !0), n.setUint16(4, r.y, !0), this._sendInputData(n.buffer), this._lastPoint.x = t, this._lastPoint.y = i } _emitMouseUp(e, t, i) { this._printInputs && logger.debug(`mouse button ${e} up at (${t}, ${i})`); let r = this._runNormalizeAndQuantizeUnsigned(t, i); var n = new DataView(new ArrayBuffer(6)); n.setUint8(0, MessageType$1.MouseUp), n.setUint8(1, e), n.setUint16(2, r.x, !0), n.setUint16(4, r.y, !0), this._sendInputData(n.buffer), this._lastPoint.x = t, this._lastPoint.y = i } _emitMouseWheel(e, t, i) { this._printInputs && logger.debug(`mouse wheel with delta ${e} at (${t}, ${i})`); let r = this._runNormalizeAndQuantizeUnsigned(t, i); var n = new DataView(new ArrayBuffer(7)); n.setUint8(0, MessageType$1.MouseWheel), n.setInt16(1, e, !0), n.setUint16(3, r.x, !0), n.setUint16(5, r.y, !0), this._sendInputData(n.buffer), this._lastPoint.x = r.x, this._lastPoint.y = r.y } _setupWebRtcPlayer(e, t) { let i = this; return this.webRtcPlayerObj = new WebRtcPlayer({ peerConnectionOptions: t, useTCP: i._useTCP }), e.appendChild(this.webRtcPlayerObj.video), this.webRtcPlayerObj.onWebRtcOffer = function (e) { if (i._ws && 1 === i._ws.readyState) { let t = JSON.stringify(e); i._printLog && logger.debug(`-> SS: offer:\n${t}`), i._ws.send(t) } }, this.webRtcPlayerObj.onWebRtcCandidate = function (e) { i._ws && 1 === i._ws.readyState && (i._printLog && logger.debug(`-> SS: iceCandidate\n${JSON.stringify(e, void 0, 4)}`), i._ws.send(JSON.stringify({ type: "iceCandidate", candidate: e }))) }, this.webRtcPlayerObj.onVideoInitialised = function () { i._ws && i._ws.readyState }, this.webRtcPlayerObj.onDataChannelConnected = function () { i._ws && 1 === i._ws.readyState && i._printLog && logger.debug("WebRTC connected, waiting for video") }, this.webRtcPlayerObj.onDataChannelMessage = function (e) { if (!i._useWebSockets || i._webSocketsOnlySend) { var t = new Uint8Array(e); if (t[0] === ToClientMessageType.Response) { let t = new TextDecoder("utf-16").decode(e.slice(1)); if (i._responseCallback) for (let e of i._responseCallback.values()) e({ detail: t }) } else if (t[0] === ToClientMessageType.Command) { let t = new TextDecoder("utf-16").decode(e.slice(1)); i._printLog && logger.debug(t); let r = JSON.parse(t); "onScreenKeyboard" === r.command && showOnScreenKeyboard(r) } else t[0] === ToClientMessageType.FreezeFrame ? (freezeFrame.size = new DataView(t.slice(1, 5).buffer).getInt32(0, !0), freezeFrame.jpeg = t.slice(5), freezeFrame.jpeg.length < freezeFrame.size ? (i._printLog && logger.debug(`received first chunk of freeze frame: ${freezeFrame.jpeg.length}/${freezeFrame.size}`), freezeFrame.receiving = !0) : (i._printLog && logger.debug(`received complete freeze frame: ${freezeFrame.jpeg.length}/${freezeFrame.size}`), showFreezeFrame())) : t[0] === ToClientMessageType.UnfreezeFrame ? invalidateFreezeFrameOverlay() : t[0] === ToClientMessageType.VideoEncoderAvgQP ? (i._videoEncoderQP = new TextDecoder("utf-16").decode(e.slice(1)), i._printLog && logger.debug(`received VideoEncoderAvgQP ${i._videoEncoderQP}`)) : logger.error(`unrecognized data received, packet ID ${t[0]}`) } }, this.webRtcPlayerObj.video } _createWebRtcOffer() { let e = this; this.webRtcPlayerObj ? (e._printLog && logger.debug("Creating offer"), this.webRtcPlayerObj.createOffer()) : logger.error("WebRTC player not setup, cannot create offer") } _onWebRtcAnswer(e) { let t = this; this.webRtcPlayerObj.receiveAnswer(e), this.webRtcPlayerObj.onAggregatedStats = e => { let i = new Intl.NumberFormat(window.navigator.language, { maximumFractionDigits: 0 }), r = new Intl.NumberFormat(window.navigator.language, { maximumFractionDigits: 0, minimumIntegerDigits: 2 }), n = (e.timestamp - e.timestampStart) / 1e3, a = [], o = [60, 60]; for (let e = 0; e < o.length; e++)a.push(n % o[e]), n /= o[e]; a.push(n); let s = a[0], l = Math.floor(a[1]), c = Math.floor([a[2]]); let h = new StreamingPlayerState; t._videoEncoderQP > 35 ? h.videoQuality = VideoQualityType.Low : t._videoEncoderQP > 26 && (h.videoQuality = VideoQualityType.Medium), h.videoQuantizationParameter = t._videoEncoderQP, h.duration = `${r.format(c)}:${r.format(l)}:${r.format(s)}`, h.VideoResolution = "" + (e.hasOwnProperty("frameWidth") && e.frameWidth && e.hasOwnProperty("frameHeight") && e.frameHeight ? e.frameWidth + "x" + e.frameHeight : "N/A"), h.framerate = `${e.hasOwnProperty("framerate") ? i.format(e.framerate) : "N/A"}`, h.bitrate = `${e.hasOwnProperty("bitrate") ? i.format(e.bitrate) : "N/A"}`, h.packetsLost = `${e.hasOwnProperty("packetsLost") ? i.format(e.packetsLost) : "N/A"}`, h.framesDropped = `${e.hasOwnProperty("framesDropped") ? i.format(e.framesDropped) : "N/A"}`, h.latency = `${e.hasOwnProperty("currentRoundTripTime") ? i.format(1e3 * e.currentRoundTripTime) : "N/A"}`, t._stateCallback && "function" == typeof t._stateCallback && this._queryInterval > 0 && t._stateCallback(h) }, this.webRtcPlayerObj.aggregateStats(1e3 * this._queryInterval == 0 ? 6e4 : 1e3 * this._queryInterval) } _onWebRtcIce(e) { this.webRtcPlayerObj && this.webRtcPlayerObj.handleCandidateFromServer(e) } async _onWebSocketsAvwResponse(e) { let t = JSON.parse(e.response); if (this._responseCallback && t) { var i = this._responseCallback.get("message"); if (i) { i({ detail: JSON.stringify(t) }) } } } _emitDescriptor(e, t) { let i = JSON.stringify(t), r = new DataView(new ArrayBuffer(3 + 2 * i.length)), n = 0; r.setUint8(n, e), n++, r.setUint16(n, i.length, !0), n += 2; for (let e = 0; e < i.length; e++)r.setUint16(n, i.charCodeAt(e), !0), n += 2; this._sendInputData(r.buffer) } _sendInputData(e) { this._useWebSockets ? this._webSocketSendInputData(e) : this.webRtcPlayerObj ? this.webRtcPlayerObj.send(e) : logger.error("Cannot sent data!") } _webSocketSendInputData(e) { if (this._ws && 1 === this._ws.readyState) { let t = []; for (let i of new Uint8Array(e)) t.push(("00" + i.toString(16)).slice(-2)); this._ws.send(JSON.stringify({ type: "avwCommand", data: t.join("") })) } else logger.error("Cannot sent data by websockets!") } _webSocketSendInputData2(e) { if (this._ws && 1 === this._ws.readyState) { var t = JSON.stringify(e); this._ws.send(t) } else logger.error("Cannot sent data by websockets!") } _registerKeyboardEvents(e) { let t = this; e.onkeydown = function (i) { t._printInputs && logger.debug(`key down ${i.code}, repeat = ${i.repeat}`), t._isKeyCodeBrowserKey(i.keyCode) || t._sendInputData(new Uint8Array([MessageType$1.KeyDown, t._getKeyCode(i), i.repeat]).buffer), i.code === SpecialKeyCodes.BackSpace && e.onkeypress({ charCode: SpecialKeyCodes.BackSpace }), t.canInputConsoleCommand || i.preventDefault(), "KeyB" === i.code && i.altKey && i.ctrlKey && t.DebugModePress && t.DebugModePress() }, e.onkeyup = function (e) { t._printInputs && logger.debug(`key up ${e.keyCode}`), t._isKeyCodeBrowserKey(e.keyCode) ? "F5" == e.key && window.location.reload() : t._sendInputData(new Uint8Array([MessageType$1.KeyUp, t._getKeyCode(e)]).buffer), t.canInputConsoleCommand || e.preventDefault() }, e.onkeypress = function (e) { if (t._printInputs && logger.debug(`key press ${e.charCode}`), !t._isKeyCodeBrowserKey(e.keyCode)) { let i = new DataView(new ArrayBuffer(3)); i.setUint8(0, MessageType$1.KeyPress), i.setUint16(1, e.charCode, !0), t._sendInputData(i.buffer) } t.canInputConsoleCommand || e.preventDefault() } } _isKeyCodeBrowserKey(e) { return e >= 112 && e <= 123 || 9 === e } _getKeyCode(e) { return e.keyCode === SpecialKeyCodes.Shift && "ShiftRight" === e.code ? SpecialKeyCodes.RightShift : e.keyCode === SpecialKeyCodes.Control && "ControlRight" === e.code ? SpecialKeyCodes.RightControl : e.keyCode === SpecialKeyCodes.Alt && "AltRight" === e.code ? SpecialKeyCodes.RightAlt : e.keyCode } _registerHoveringMouseEvents(e) { let t = this; e.onmousemove = function (e) { t._isTouch ? t._emitMouseMove(e.offsetX, e.offsetY, e.offsetX - t._lastPoint.x, e.offsetY - t._lastPoint.y) : t._emitMouseMove(e.offsetX, e.offsetY, e.movementX, e.movementY), t._isTouch = !1, e.preventDefault() }, e.onmousedown = function (e) { t._emitMouseDown(e.button, e.offsetX, e.offsetY) }, e.onmouseup = function (e) { t._printInputs && logger.debug(`mouse button ${e.button} up from playerElement.onmouseup`), t._emitMouseUp(e.button, e.offsetX, e.offsetY) }, e.oncontextmenu = function (e) { e.button > 0 ? t._printInputs && logger.debug(`fake mouse button ${e.button} up from playerElement.oncontextmenu`) : (t._printInputs && logger.debug(`mouse button ${e.button} up from playerElement.oncontextmenu`), t._emitMouseUp(e.button, e.offsetX, e.offsetY)), e.preventDefault() }, "onmousewheel" in e ? e.onmousewheel = function (e) { t._emitMouseWheel(e.wheelDelta, e.offsetX, e.offsetY), e.preventDefault() } : e.addEventListener("DOMMouseScroll", (function (e) { t._emitMouseWheel(-120 * e.detail, e.offsetX, e.offsetY), e.preventDefault() }), !1), e.pressMouseButtons = function (e) { t._pressMouseButtons(e.buttons, e.offsetX, e.offsetY) }, e.releaseMouseButtons = function (e) { t._releaseMouseButtons(e.buttons, e.offsetX, e.offsetY) } } _releaseMouseButtons(e, t, i) { this._printInputs && logger.debug(`mouse button ${e} up from _releaseMouseButtons`), e & MouseButtonsMask.PrimaryButton && this._emitMouseUp(MouseButton.MainButton, t, i), e & MouseButtonsMask.SecondaryButton && this._emitMouseUp(MouseButton.SecondaryButton, t, i), e & MouseButtonsMask.AuxiliaryButton && this._emitMouseUp(MouseButton.AuxiliaryButton, t, i), e & MouseButtonsMask.FourthButton && this._emitMouseUp(MouseButton.FourthButton, t, i), e & MouseButtonsMask.FifthButton && this._emitMouseUp(MouseButton.FifthButton, t, i) } _pressMouseButtons(e, t, i) { e & MouseButtonsMask.PrimaryButton && this._emitMouseDown(MouseButton.MainButton, t, i), e & MouseButtonsMask.SecondaryButton && this._emitMouseDown(MouseButton.SecondaryButton, t, i), e & MouseButtonsMask.AuxiliaryButton && this._emitMouseDown(MouseButton.AuxiliaryButton, t, i), e & MouseButtonsMask.FourthButton && this._emitMouseDown(MouseButton.FourthButton, t, i), e & MouseButtonsMask.FifthButton && this._emitMouseDown(MouseButton.FifthButton, t, i) } _registerLockedMouseEvents(e) { let t = this, i = e.width / 2, r = e.height / 2; function n() { document.pointerLockElement === e || document.mozPointerLockElement === e ? (t._printLog && logger.debug("Pointer locked"), document.addEventListener("mousemove", a, !1)) : (t._printLog && logger.debug("The pointer lock status is now unlocked"), document.removeEventListener("mousemove", a, !1)) } function a(n) { i += n.movementX, r += n.movementY, i > e.width && (i -= e.width), r > e.height && (r -= e.height), i < 0 && (i = e.width + i), r < 0 && (r = e.height - r), t._emitMouseMove(i, r, n.movementX, n.movementY) } e.requestPointerLock = e.requestPointerLock || e.mozRequestPointerLock, document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock, e.onclick = function () { e.requestPointerLock() }, document.addEventListener("pointerlockchange", n, !1), document.addEventListener("mozpointerlockchange", n, !1), e.onmousedown = function (e) { t._emitMouseDown(e.button, i, r) }, e.onmouseup = function (e) { t._printInputs && logger.debug(`mouse button ${button} up from playerElement.onmouseup`), t._emitMouseUp(e.button, i, r) }, e.onmousewheel = function (e) { t._emitMouseWheel(e.wheelDelta, i, r) }, e.pressMouseButtons = function (e) { t._pressMouseButtons(e.buttons, i, r) }, e.releaseMouseButtons = function (e) { t._releaseMouseButtons(e.buttons, i, r) } } _registerMouseEnterAndLeaveEvents(e) { let t = this; e.onmouseenter = function (i) { t._printInputs && logger.debug("mouse enter"); let r = new DataView(new ArrayBuffer(1)); r.setUint8(0, MessageType$1.MouseEnter), t._sendInputData(r.buffer), e.pressMouseButtons(i), t.sendMouseMoveIn(i) }, e.onmouseleave = function (i) { t._printInputs && logger.debug("mouse leave"); let r = new DataView(new ArrayBuffer(1)); r.setUint8(0, MessageType$1.MouseLeave), t._sendInputData(r.buffer), e.releaseMouseButtons(i), t.sendMouseMoveOut(i) } } _registerInputs(e) { e && (this._registerMouseEnterAndLeaveEvents(e), this._registerHammerEvents(e)) } _registerHammerEvents(e) { e.addEventListener("touchmove", (function (e) { e.preventDefault() }), { passive: !1 }); let t = this, i = new Hammer(e); i.get("pan").set({ enable: !0, direction: Hammer.DIRECTION_ALL }), i.get("pinch").set({ enable: !0, direction: Hammer.DIRECTION_ALL }), i.on("tap", (e => { "mouse" !== e.pointerType && (this._printInputs && logger.debug("单指点击操作！", e), t._lastPanPoint.x = 0, t._lastPanPoint.y = 0, t._lastOrbitPoint.x = 0, t._lastOrbitPoint.y = 0, t._lastScale = 0, t._isTouch = !0) })), i.on("pan", (e => { if ("mouse" !== e.pointerType && 1 == e.pointers.length) { if (this._printInputs && logger.debug("单指pan，场景旋转（orbit） ev：", e), e.isFirst) return t._lastOrbitPoint.x = e.center.x, t._lastOrbitPoint.y = e.center.y, void (t._printInputs && logger.debug("orbit start", _lastOrbitPoint)); if (0 == t._lastOrbitPoint.x && 0 == t._lastOrbitPoint.y) return t._lastOrbitPoint.x = e.center.x, t._lastOrbitPoint.y = e.center.y, void (t._printInputs && logger.debug("orbit start2", this._lastOrbitPoint)); if (e.isFinal) this._lastOrbitPoint.x = 0, this._lastOrbitPoint.y = 0, this._printInputs && logger.debug("orbit stop", this._lastOrbitPoint); else { var i = { kx: t.playerElement.clientWidth / 1920, ky: t.playerElement.clientHeight / 1080 }; this._lastPanPoint.x = 0, this._lastPanPoint.y = 0, this._lastScale = 0; const r = { mouseAndPanelMove: !0, params: { Type: "orbit", DeltaX: (e.center.x - t._lastOrbitPoint.x) * i.kx * MultiTouchState.OrbitSize, DeltaY: -(e.center.y - t._lastOrbitPoint.y) * i.ky * MultiTouchState.OrbitSize } }; if (r.params.DeltaX > 20 || r.params.DeltaX < -20 || r.params.DeltaY > 20 || r.params.DeltaY < -20) return void (t._printInputs && logger.debug("orbit 变换量过大 不处理", r)); t._printInputs && logger.debug("orbit emit", r), t.emitUIInteraction(r), t._lastOrbitPoint.x = e.center.x, t._lastOrbitPoint.y = e.center.y } } })), i.on("pinch", (e => { if ("mouse" !== e.pointerType) if (2 !== e.pointers.length); else { if (e.scale > .75 && e.scale < 1.25) return void logger.debug("scale 过小 不作为zoom", e); if (this._printInputs && logger.debug("两指缩放，场景缩放（zoom） ev：", e), e.isFirst) return t._lastScale = 1, void (t._printInputs && logger.debug("zoom start", e)); if (0 === t._lastScale) return t._lastScale = 1, void (t._printInputs && logger.debug("zoom start 2", e)); if (e.isFinal) this._printInputs && logger.debug("zoom stop", e); else { t._lastPanPoint.x = 0, t._lastPanPoint.y = 0, t._lastOrbitPoint.x = 0, t._lastOrbitPoint.y = 0; const i = { mouseAndPanelMove: !0, params: { Type: "pushPull", DeltaX: 0, DeltaY: 1 === e.scale ? 0 : e.scale * MultiTouchState.ZoomSize - 1 } }; if (i.params.DeltaY > 5 || i.params.DeltaY < -5) return void (t._printInputs && logger.debug("zoom 变换量过大 不处理", i)); this._lastScale = e.scale, t.emitUIInteraction(i), t._printInputs && logger.debug("zoom emit", i) } } })), i.on("hammer.input", (e => { if ("mouse" !== e.pointerType && e.pointers.length >= 2) { if (this._printInputs && logger.debug("多指pan，场景平移（pan） ev：", e), e.scale < .75 || e.scale > 1.25) return void logger.debug("scale 过大 当做zoom", e); if (e.isFirst) return t._lastPanPoint.x = e.center.x, t._lastPanPoint.y = e.center.y, void (t._printInputs && logger.debug("pan start1", this._lastPanPoint)); if (0 == t._lastPanPoint.x && 0 == t._lastPanPoint.y) return t._lastPanPoint.x = e.center.x, t._lastPanPoint.y = e.center.y, void (t._printInputs && logger.debug("pan start2", this._lastPanPoint)); if (e.isFinal) this._lastPanPoint.x = 0, this._lastPanPoint.y = 0, this._printInputs && logger.debug("pan stop", this._lastPanPoint); else { var i = { kx: 1, ky: 1 }; this._lastOrbitPoint.x = 0, this._lastOrbitPoint.y = 0, this._lastScale = 0; const r = { mouseAndPanelMove: !0, params: { Type: "pan", DeltaX: (e.center.x - t._lastPanPoint.x) * i.kx * MultiTouchState.PanSize, DeltaY: -(e.center.y - t._lastPanPoint.y) * i.ky * MultiTouchState.PanSize } }; if (r.params.DeltaX > 20 || r.params.DeltaX < -20 || r.params.DeltaY > 20 || r.params.DeltaY < -20) return void (t._printInputs && logger.debug("pan 变换量过大 不处理", r)); t._printInputs && logger.debug("pan emit", r), t.emitUIInteraction(r), t._lastPanPoint.x = e.center.x, t._lastPanPoint.y = e.center.y } } })) } _runNormalizeAndQuantizeUnsigned(e, t) { let i = this.playerElement.parentElement, r = this.playerElement, n = i.clientHeight / i.clientWidth, a = r.videoHeight / r.videoWidth; if (n > a) { let r = n / a; return this._normalizeAndQuantizeUnsignedWithHPAR(i, r, e, t) } { let r = a / n; return this._normalizeAndQuantizeUnsignedWithLPAR(i, r, e, t) } } _runNormalizeAndQuantizeSigned(e, t) { let i = this.playerElement.parentElement, r = this.playerElement, n = i.clientHeight / i.clientWidth, a = r.videoHeight / r.videoWidth; if (n > a) { let r = n / a; return this._normalizeAndQuantizeSignedWithHPAR(i, r, e, t) } { let r = a / n; return this._normalizeAndQuantizeSignedWithLPAR(i, r, e, t) } } _normalizeAndQuantizeUnsignedWithHPAR(e, t, i, r) { let n = i / e.clientWidth, a = t * (r / e.clientHeight - .5) + .5; return n < 0 || n > 1 || a < 0 || a > 1 ? { inRange: !1, x: 65535, y: 65535 } : { inRange: !0, x: 65536 * n, y: 65536 * a } } _normalizeAndQuantizeSignedWithHPAR(e, t, i, r) { return { x: 32767 * (i / (.5 * e.clientWidth)), y: 32767 * (t * r / (.5 * e.clientHeight)) } } _normalizeAndQuantizeUnsignedWithLPAR(e, t, i, r) { let n = t * (i / e.clientWidth - .5) + .5, a = r / e.clientHeight; return n < 0 || n > 1 || a < 0 || a > 1 ? { inRange: !1, x: 65535, y: 65535 } : { inRange: !0, x: 65536 * n, y: 65536 * a } } _normalizeAndQuantizeSignedWithLPAR(e, t, i, r) { return { x: 32767 * (t * i / (.5 * e.clientWidth)), y: 32767 * (r / (.5 * e.clientHeight)) } } checkMaxByteLength(e, t, i) { let r = 2 * JSON.stringify(t).length + 3; if (logger.info(`${e} 总byte长度 ${r}`), this._useWebSockets) { if (r > 1048576) { n = `${e} 消息总长度 ${r / 1024}kb 超出最大支持长度 1mb 无法发送！`; return logger.error(n), i && i({ result: 0, message: "失败。" + n }), !1 } } else if (r > 131072) { var n = `${e} 消息总长度 ${r / 1024}kb 超出最大支持长度 128kb 无法发送！`; return logger.error(n), i && i({ result: 0, message: "失败。" + n }), !1 } return !0 } sendMouseMoveOut(e) { let t = e.offsetX / this.playerElement.clientWidth * this.playerElement.videoWidth, i = e.offsetY / this.playerElement.clientHeight * this.playerElement.videoHeight; const r = { mouseMoveOut: !0, params: { isButtonDown: e.buttons > 0, button: e.buttons, x: t, y: i } }; this.emitUIInteraction(r) } sendMouseMoveIn(e) { let t = e.offsetX / this.playerElement.clientWidth * this.playerElement.videoWidth, i = e.offsetY / this.playerElement.clientHeight * this.playerElement.videoHeight; const r = { mouseMoveIn: !0, params: { isButtonDown: e.buttons > 0, button: e.buttons, x: t, y: i } }; this.emitUIInteraction(r) } } let Util = { isFunction: e => "function" == typeof e, isString: e => "string" == typeof e, isStringNotEmpty: e => "string" == typeof e && "" !== e, guid: () => { function e() { return (65536 * (1 + Math.random()) | 0).toString(16).substring(1) } return e() + e() + "-" + e() + "-" + e() + "-" + e() + "-" + e() + e() + e() }, randomString: e => { e = e || 32; for (var t = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678", i = t.length, r = "", n = 0; n < e; n++)r += t.charAt(Math.floor(Math.random() * i)); return r }, fetchJSON: (e, t, i, r) => { switch (t.toLowerCase()) { case "get": case "delete": case "head": case "post": case "put": break; default: t = "GET" }return new Promise((function (n, a) { let o = new XMLHttpRequest; if (o.onreadystatechange = function () { 4 == o.readyState && (200 == o.status || 204 == o.status || 304 == o.status ? n(o.responseText) : a(new Error(o.statusText))) }, o.open(t, e, !0), i instanceof Array) for (let e of i) o.setRequestHeader(e.key, e.value); o.send(JSON.stringify(r)) })) }, Mercator2LonLat: e => { var t = {}, i = e.x / 20037508.3427892 * 180, r = e.y / 20037508.3427892 * 180; return r = 180 / Math.PI * (2 * Math.atan(Math.exp(r * Math.PI / 180)) - Math.PI / 2), t.x = i, t.y = r, t } }; Util.throttle = (e, t = 300) => { let i = 0; return function () { (new Date).getTime() - i > t && (e.call(this), i = (new Date).getTime()) } }; var eventMap = { onServiceConnected: {}, onSceneInit: { backtrack: ["name", "default"] }, onServiceInit: { backtrack: ["name", "default"] }, onSceneChanged: { backtrack: ["name", "default"] }, onSceneSwitch: { backtrack: ["name", "default"] }, onServiceSwitch: { backtrack: ["name", "default"] }, onServiceLoad: { backtrack: ["name", "default"] }, onSceneLoaded: { backtrack: ["name", "default"] }, onResolutionChange: { backtrack: ["width", "height"] }, onBrowserMinimize: {}, onBrowserClose: {}, onStateSwitch: { backtrack: ["name", "default"] }, onStateTick: {}, onCameraRoamingStart: { backtrack: ["name", "default"] }, onCameraRoamingEnd: {}, onCameraToMoveStart: {}, onCameraToMoveEnd: {}, onFocusWorldMapStart: {}, onFocusWorldMapEnd: {}, onFocustCountryStart: { backtrack: ["name"] }, onFocustCountryEnd: { backtrack: ["name"] }, onFocusChinaMapStart: {}, onFocusChinaMapEnd: {}, onFocustProvinceStart: { backtrack: ["name"] }, onFocustProvinceEnd: { backtrack: ["name"] }, onCountryHover: { backtrack: ["name"] }, onCountryUnhover: { backtrack: ["name"] }, onCountryClick: { backtrack: ["name", "seleted"] }, onProvinceHover: { backtrack: ["name"] }, onProvinceUnhover: { backtrack: ["name"] }, onProvinceClick: { backtrack: ["name", "seleted"] }, onSwitchWorldMapEnd: { backtrack: ["preloadOnlay"] }, onSwitchChinaMapEnd: { backtrack: ["preloadOnlay"] }, onRectOverlaySelectionResult: { backtrack: ["type", "data"] }, onCircleOverlaySelectionResult: { backtrack: ["type", "data"] }, onPolygonOverlaySelectionResult: { backtrack: ["type", "data"] }, onClickOverlayResult: { backtrack: ["type", "id", "ids", "selected"] }, onClickOverlayTypeResult: { backtrack: ["type", "selected", "data"] }, onFocusLandmarkStart: { backtrack: ["id"] }, onFocusLandmarkEnd: { backtrack: ["id"] }, onFocusAllLandmarkStart: {}, onFocusAllLandmarkEnd: {}, onLandmarkHover: { backtrack: ["id", "tag"] }, onLandmarkUnhover: { backtrack: ["id", "tag"] }, onLandmarkClick: { backtrack: ["id", "selected", "label", "tag"] }, onFocusPathStart: { backtrack: ["id"] }, onFocusPathEnd: { backtrack: ["id"] }, onFocusAllPathStart: {}, onFocusAllPathEnd: {}, onPathHover: { backtrack: ["id", "coord", "tag"] }, onPathUnhover: { backtrack: ["id", "tag"] }, onPathClick: { backtrack: ["id", "selected", "coord", "tag"] }, onFocusAreaStart: { backtrack: ["id"] }, onFocusAreaEnd: { backtrack: ["id"] }, onFocusAllAreaStart: {}, onFocusAllAreaEnd: {}, onAreaHover: { backtrack: ["id", "coord", "tag"] }, onAreaUnhover: { backtrack: ["id", "tag"] }, onAreaClick: { backtrack: ["id", "selected", "coord", "tag"] }, onFocusCircularAreaStart: { backtrack: ["id"] }, onFocusCircularAreaEnd: { backtrack: ["id"] }, onFocusAllCircularAreaStart: {}, onFocusAllCircularAreaEnd: {}, onCircularAreaHover: { backtrack: ["id", "coord", "tag"] }, onCircularAreaUnhover: { backtrack: ["id", "tag"] }, onCircularAreaClick: { backtrack: ["id", "selected", "coord", "tag"] }, onFocus3DTileStart: { backtrack: ["id"] }, onFocus3DTileEnd: { backtrack: ["id"] }, onFocusAll3DTileStart: {}, onFocusAll3DTileEnd: {}, on3DTileHover: { backtrack: ["id", "coord"] }, on3DTileUnhover: { backtrack: ["id"] }, on3DTileClick: { backtrack: ["id", "selected", "coord"] }, onFocusGISMapStart: { backtrack: ["id"] }, onFocusGISMapEnd: { backtrack: ["id"] }, onFocusAllGISMapStart: {}, onFocusAllGISMapEnd: {}, onGISMapHover: { backtrack: ["id", "coord"] }, onGISMapUnhover: { backtrack: ["id"] }, onGISMapClick: { backtrack: ["id", "selected", "coord"] }, onFocusLandmarkLayerStart: { backtrack: ["idLayer"] }, onFocusLandmarkLayerEnd: { backtrack: ["idLayer"] }, onFocusAllLandmarkLayerStart: {}, onFocusAllLandmarkLayerEnd: {}, onFocusLandmarkLayerObjStart: { backtrack: ["idObj", "idLayer"] }, onFocusLandmarkLayerObjEnd: { backtrack: ["idObj", "idLayer"] }, onFocusLandmarkLayerLegendStart: { backtrack: ["legend", "idLayer"] }, onFocusLandmarkLayerLegendEnd: { backtrack: ["legend", "idLayer"] }, onLandmarkLayerHover: { backtrack: ["idObj", "idLayer"] }, onLandmarkLayerUnhover: { backtrack: ["idObj", "idLayer"] }, onLandmarkLayerClick: { backtrack: ["idObj", "idLayer", "selected", "type", "label"] }, onFocus3DColumnLayerStart: { backtrack: ["idLayer"] }, onFocus3DColumnLayerEnd: { backtrack: ["idLayer"] }, onFocusAll3DColumnLayerStart: {}, onFocusAll3DColumnLayerEnd: {}, on3DColumnLayerHover: { backtrack: ["idObj", "idLayer", "coord"] }, on3DColumnLayerUnhover: { backtrack: ["idLayer", "idLayer"] }, on3DColumnLayerClick: { backtrack: ["idObj", "idLayer", "selected", "coord"] }, onFocus3DGridLayerStart: { backtrack: ["idLayer"] }, onFocus3DGridLayerEnd: { backtrack: ["idLayer"] }, onFocusAll3DGridLayerStart: {}, onFocusAll3DGridLayerEnd: {}, on3DGridLayerHover: { backtrack: ["idObj", "idLayer", "coord"] }, on3DGridLayerUnhover: { backtrack: ["idObj", "idLayer"] }, on3DGridLayerClick: { backtrack: ["idObj", "idLayer", "selected", "coord"] }, onFocusHeatmapLayerStart: { backtrack: ["idLayer"] }, onFocusHeatmapLayerEnd: { backtrack: ["idLayer"] }, onFocusAllHeatmapLayerStart: {}, onFocusAllHeatmapLayerEnd: {}, onHeatmapLayerHover: { backtrack: ["idLayer", "coord"] }, onHeatmapLayerUnhover: { backtrack: ["idLayer"] }, onHeatmapLayerClick: { backtrack: ["idLayer", "selected", "coord"] }, onFocusBubbleLayerStart: { backtrack: ["idLayer"] }, onFocusBubbleLayerEnd: { backtrack: ["idLayer"] }, onFocusAllBubbleLayerStart: {}, onFocusAllBubbleLayerEnd: {}, onFocusBubbleLayerObjStart: { backtrack: ["idObj", "idLayer"] }, onFocusBubbleLayerObjEnd: { backtrack: ["idObj", "idLayer"] }, onFocusBubbleLayerLegendStart: { backtrack: ["idLayer", "legend"] }, onFocusBubbleLayerLegendEnd: { backtrack: ["idLayer", "legend"] }, onBubbleLayerHover: { backtrack: ["idObj", "idLayer"] }, onBubbleLayerUnhover: { backtrack: ["idObj", "idLayer"] }, onBubbleLayerClick: { backtrack: ["idObj", "idLayer", "selected", "type"] }, onFocusEventLayerStart: { backtrack: ["idLayer"] }, onFocusEventLayerEnd: { backtrack: ["idLayer"] }, onFocusAllEventLayerStart: {}, onFocusAllEventLayerEnd: {}, onFocusEventLayerObjStart: { backtrack: ["idObj", "idLayer"] }, onFocusEventLayerObjEnd: { backtrack: ["idObj", "idLayer"] }, onFocusEventLayerLegendStart: { backtrack: ["idLayer", "legend"] }, onFocusEventLayerLegendEnd: { backtrack: ["idLayer", "legend"] }, onEventLayerHover: { backtrack: ["idObj", "idLayer"] }, onEventLayerUnhover: { backtrack: ["idObj", "idLayer"] }, onEventLayerClick: { backtrack: ["idObj", "idLayer", "selected"] }, onFocusTrailLayerStart: { backtrack: ["idLayer"] }, onFocusTrailLayerEnd: { backtrack: ["idLayer"] }, onFocusAllTrailLayerStart: {}, onFocusAllTrailLayerEnd: {}, onFocusTrailLayerObjStart: { backtrack: ["idObj", "idLayer"] }, onFocusTrailLayerObjEnd: { backtrack: ["idObj", "idLayer"] }, onFocusTrailLayerLegendStart: { backtrack: ["idLayer", "legend"] }, onFocusTrailLayerLegendEnd: { backtrack: ["idLayer", "legend"] }, onTrailLayerHover: { backtrack: ["idObj", "idLayer"] }, onTrailLayerUnhover: { backtrack: ["idObj", "idLayer"] }, onTrailLayerClick: { backtrack: ["idObj", "idLayer", "selected", "type", "label"] }, onFocusTrackLayerStart: { backtrack: ["idLayer"] }, onFocusTrackLayerEnd: { backtrack: ["idLayer"] }, onFocusAllTrackLayerStart: {}, onFocusAllTrackLayerEnd: {}, onFocusTrackLayerObjStart: { backtrack: ["idObj", "idLayer"] }, onFocusTrackLayerObjEnd: { backtrack: ["idObj", "idLayer"] }, onFocusTrackLayerLegendStart: { backtrack: ["idLayer", "legend"] }, onFocusTrackLayerLegendEnd: { backtrack: ["idLayer", "legend"] }, onTrackLayerHover: { backtrack: ["idObj", "idLayer"] }, onTrackLayerUnhover: { backtrack: ["idObj", "idLayer"] }, onTrackLayerClick: { backtrack: ["idObj", "idLayer", "selected"] }, onFocusODLineLayerStart: { backtrack: ["idLayer"] }, onFocusODLineLayerEnd: { backtrack: ["idLayer"] }, onFocusAllODLineLayerStart: {}, onFocusAllODLineLayerEnd: {}, onFocusODLineLayerobjStart: { backtrack: ["idObj", "idLayer"] }, onFocusODLineLayerObjEnd: { backtrack: ["idObj", "idLayer"] }, onFocusODLineLayerLegendStart: { backtrack: ["idLayer", "legend"] }, onFocusODLineLayerLegendEnd: { backtrack: ["idLayer", "legend"] }, onODLineLayerHover: { backtrack: ["idObj", "idLayer"] }, onODLineLayerUnhover: { backtrack: ["idObj", "idLayer"] }, onODLineLayerClick: { backtrack: ["idObj", "idLayer", "selected", "type"] }, onFocusTypeAreaLayerStart: { backtrack: ["idLayer"] }, onFocusTypeAreaLayerEnd: { backtrack: ["idLayer"] }, onFocusAllTypeAreaLayerStart: {}, onFocusAllTypeAreaLayerEnd: {}, onFocusTypeAreaStart: { backtrack: ["nameArea", "idLayer"] }, onFocusTypeAreaEnd: { backtrack: ["nameArea", "idLayer"] }, onFocusTypeAreaLayerLegendStart: { backtrack: ["idLayer", "legend"] }, onFocusTypeAreaLayerLegendEnd: { backtrack: ["idLayer", "legend"] }, onFocusLayerLegendStart: { backtrack: ["idLayer", "legend"] }, onFocusLayerLegendEnd: { backtrack: ["idLayer", "legend"] }, onTypeAreaLayerHover: { backtrack: ["nameArea", "idLayer", "coord"] }, onTypeAreaLayerUnhover: { backtrack: ["nameArea", "idLayer"] }, onTypeAreaLayerClick: { backtrack: ["nameArea", "idLayer", "selected", "coord"] }, onFocusColorAreaLayerStart: { backtrack: ["idLayer"] }, onFocusColorAreaLayerEnd: { backtrack: ["idLayer"] }, onFocusAllColorAreaLayerStart: {}, onFocusAllColorAreaLayerEnd: {}, onFocusColorAreaStart: { backtrack: ["nameArea", "idLayer"] }, onFocusColorAreaEnd: { backtrack: ["nameArea", "idLayer"] }, onColorAreaLayerHover: { backtrack: ["nameArea", "idLayer", "coord"] }, onColorAreaLayerUnhover: { backtrack: ["nameArea", "idLayer"] }, onColorAreaLayerClick: { backtrack: ["nameArea", "idLayer", "selected", "coord"] }, onFocusRoadPtHeatLayerStart: { backtrack: ["idLayer"] }, onFocusRoadPtHeatLayerEnd: { backtrack: ["idLayer"] }, onFocusAllRoadPtHeatLayerStart: {}, onFocusAllRoadPtHeatLayerEnd: {}, onRoadPtHeatLayerHover: { backtrack: ["idLayer", "coord"] }, onRoadPtHeatLayerUnhover: { backtrack: ["idLayer"] }, onRoadPtHeatLayerClick: { backtrack: ["idLayer", "selected", "coord"] }, onFocusRoadSgHeatLayerStart: { backtrack: ["idLayer"] }, onFocusRoadSgHeatLayerEnd: { backtrack: ["idLayer"] }, onFocusAllRoadSgHeatLayerStart: {}, onFocusAllRoadSgHeatLayerEnd: {}, onFocusRoadSgHeatStart: { backtrack: ["nameSegment", "idLayer"] }, onFocusRoadSgHeatEnd: { backtrack: ["nameSegment", "idLayer"] }, onRoadSgHeatLayerHover: { backtrack: ["nameSegment", "idLayer", "coord"] }, onRoadSgHeatLayerUnhover: { backtrack: ["nameSegment", "idLayer"] }, onRoadSgHeatLayerClick: { backtrack: ["nameSegment", "idLayer", "selected", "coord"] }, onFocusModelStart: { backtrack: ["id"] }, onFocusModelEnd: { backtrack: ["id"] }, onFocusAllModelStart: {}, onFocusAllModelEnd: {}, onModelHover: { backtrack: ["id"] }, onModelUnhover: { backtrack: ["id"] }, onModelClick: { backtrack: ["id", "selected", "meta", "userData"] }, onRectModelSelectionResult: { backtrack: ["type", "data"] }, onCircleModelSelectionResult: { backtrack: ["type", "data"] }, onPolygonModelSelectionResult: { backtrack: ["type", "data"] }, onClickModelResult: { backtrack: ["type", "id", "selected"] }, onClickModelTypeResult: { backtrack: ["type", "selected", "data"] }, onFocusBuildingStart: { backtrack: ["id"] }, onFocusBuildingEnd: { backtrack: ["id"] }, onFocusAllBuildingStart: {}, onFocusAllBuildingEnd: {}, onFocusFloorStart: { backtrack: ["floor", "idBuilding"] }, onFocusFloorEnd: { backtrack: ["floor", "idBuilding"] }, onFocusRoomStart: { backtrack: ["nameRoom", "floor", "idBuilding"] }, onFocusRoomEnd: { backtrack: ["nameRoom", "floor", "idBuilding"] }, onBuildingHover: { backtrack: ["id"] }, onBuildingUnhover: { backtrack: ["id"] }, onBuildingClick: { backtrack: ["id", "selected"] }, onFloorHover: { backtrack: ["floor", "idBuilding"] }, onFloorUnhover: { backtrack: ["floor", "idBuilding"] }, onFloorClick: { backtrack: ["floor", "idBuilding", "selected"] }, onRoomHover: { backtrack: ["nameRoom", "floor", "idBuilding"] }, onRoomUnhover: { backtrack: ["nameRoom", "floor", "idBuilding"] }, onRoomClick: { backtrack: ["nameRoom", "floor", "idBuilding", "selected"] }, onFocus3DMarkerStart: { backtrack: ["id"] }, onFocus3DMarkerEnd: { backtrack: ["id"] }, onFocusAll3DMarkerStart: {}, onFocusAll3DMarkerEnd: {}, on3DMarkerHover: { backtrack: ["id", "tag"] }, on3DMarkerUnhover: { backtrack: ["id", "tag"] }, on3DMarkerClick: { backtrack: ["id", "selected", "tag"] }, onAggLandmarkLayerClick: { backtrack: ["idLayer", "selected", "data"] }, onFocusAggLandmarkLayerStart: { backtrack: ["idLayer"] }, onFocusAggLandmarkLayerEnd: { backtrack: ["idLayer"] }, onFocusAggLandmarkLayerObjStart: { backtrack: ["idObj", "idLayer"] }, onFocusAggLandmarkLayerObjEnd: { backtrack: ["idObj", "idLayer"] }, onAggLandmarkLayerHover: { backtrack: ["idObj", "idLayer"] }, onAggLandmarkLayerUnhover: { backtrack: ["idObj", "idLayer"] }, onSceneClick: { backtrack: ["data"] }, onFocusModelLandmarkLayerStart: { backtrack: ["idLayer"] }, onFocusModelLandmarkLayerEnd: { backtrack: ["idLayer"] }, onFocusAllModelLandmarkLayerStart: {}, onFocusAllModelLandmarkLayerEnd: {}, onFocusModelLandmarkLayerObjStart: { backtrack: ["idObj", "idLayer"] }, onFocusModelLandmarkLayerObjEnd: { backtrack: ["idObj", "idLayer"] }, onModelLandmarkLayerHover: { backtrack: ["idObj", "idLayer"] }, onModelLandmarkLayerUnhover: { backtrack: ["idObj", "idLayer"] }, onFocusModelTrailLayerStart: { backtrack: ["idLayer"] }, onFocusModelTrailLayerEnd: { backtrack: ["idLayer"] }, onFocusAllModelTrailLayerStart: {}, onFocusAllModelTrailLayerEnd: {}, onFocusModelTrailLayerObjStart: { backtrack: ["idObj", "idLayer"] }, onFocusModelTrailLayerObjEnd: { backtrack: ["idObj", "idLayer"] }, onFocusModelTrailLayerLegendStart: { backtrack: ["idLayer", "legend"] }, onFocusModelTrailLayerLegendEnd: { backtrack: ["idLayer", "legend"] }, onUeSceneClick: { backtrack: ["coord", "coordZ"] }, onModelTrailLayerClick: { backtrack: ["idObj", "idLayer", "selected"] }, onModelTrailLayerHover: { backtrack: ["idObj", "idLayer"] }, onModelTrailLayerUnhover: { backtrack: ["idObj", "idLayer"] }, onModelTrailLayerTempClick: { backtrack: ["id", "idLayer", "selected"] }, subscribeServerMessage: {}, onAgg3DColumnLayerClick: { backtrack: ["idLayer", "selected", "data"] }, onAgg3DColumnLayerHover: { backtrack: ["idObj", "idLayer"] }, onAgg3DColumnLayerUnhover: { backtrack: ["idObj", "idLayer"] }, onFocusAgg3DColumnLayerStart: { backtrack: ["idLayer"] }, onFocusAgg3DColumnLayerEnd: { backtrack: ["idLayer"] }, onFocusAgg3DColumnLayerObjStart: { backtrack: ["idObj", "idLayer"] }, onFocusAgg3DColumnLayerObjEnd: { backtrack: ["idObj", "idLayer"] }, onModelLandmarkLayerClick: { backtrack: ["idObj", "idLayer", "selected"] }, onScaleAxisDrag: {}, onRotationAxisDrag: {}, onArticulationStart: { backtrack: ["id"] }, onArticulationEnd: { backtrack: ["id"] }, onAnimationStart: { backtrack: ["id"] }, onAnimationEnd: { backtrack: ["id"] }, onCameraMove: { backtrack: ["coordType", "coordTypeZ", "centerCoord", "coordZ", "distance", "pitch", "heading"] }, onCameraRotateStart: {}, onCameraRotateEnd: {}, onTransformAxisDrag: { backtrack: ["idObj", "idLayer", "overlayType", "coordType", "data"] }, onScaleAxisDrag: { backtrack: ["idObj", "idLayer", "overlayType", "coordType", "data"] }, onRotationAxisDrag: { backtrack: ["idObj", "idLayer", "overlayType", "coordType", "data"] }, onTransformAxisDragStart: { backtrack: ["idObj", "idLayer", "overlayType", "coordType", "data"] }, onTransformAxisDragEnd: { backtrack: ["idObj", "idLayer", "overlayType", "coordType", "data"] }, onSetCameraStart: {}, onSetCameraEnd: {}, onFocus3DMarkerLandmarkLayerStart: { backtrack: ["idLayer"] }, onFocus3DMarkerLandmarkLayerEnd: { backtrack: ["idLayer"] }, onFocusAll3DMarkerLandmarkLayerStart: {}, onFocusAll3DMarkerLandmarkLayerEnd: {}, onFocus3DMarkerLandmarkLayerObjStart: { backtrack: ["idObj", "idLayer"] }, onFocus3DMarkerLandmarkLayerObjEnd: { backtrack: ["idObj", "idLayer"] }, onFocus3DMarkerLandmarkLayerLegendStart: { backtrack: ["idLayer", "legend"] }, onFocus3DMarkerLandmarkLayerLegendEnd: { backtrack: ["idLayer", "legend"] }, on3DMarkerLandmarkLayerHover: { backtrack: ["idObj", "idLayer"] }, on3DMarkerLandmarkLayerUnhover: { backtrack: ["idObj", "idLayer"] }, on3DMarkerLandmarkLayerClick: { backtrack: ["idObj", "idLayer", "selected"] }, onFocusStarLightLayerStart: { backtrack: ["idLayer"] }, onFocusStarLightLayerEnd: { backtrack: ["idLayer"] }, onFocusAllStarLightLayerStart: { backtrack: [] }, onFocusAllStarLightLayerEnd: { backtrack: [] }, onStarLightLayerHover: { backtrack: ["idLayer", "coord"] }, onStarLightLayerUnhover: { backtrack: ["idLayer"] }, onStarLightLayerClick: { backtrack: ["idLayer", "selected", "coord"] }, onConnectionHover: { backtrack: ["id"] }, onConnectionUnhover: { backtrack: ["id"] }, onConnectionClick: { backtrack: ["id", "selected", "overlayType", "idLayer", "startIdObj", "endIdObj"] }, onAggBubbleLayerHover: { backtrack: ["idObj", "idLayer"] }, onAggBubbleLayerUnhover: { backtrack: ["idObj", "idLayer"] }, onAggBubbleLayerClick: { backtrack: ["idLayer", "selected", "data"] } }; for (const e in eventMap) if (Object.hasOwnProperty.call(eventMap, e)) { const t = eventMap[e]; t.backtrack || (t.backtrack = []), t.callback = null, t.function = (e, i) => { t.callback = i } } function styleInject(e, t) { void 0 === t && (t = {}); var i = t.insertAt; if (e && "undefined" != typeof document) { var r = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style"); n.type = "text/css", "top" === i && r.firstChild ? r.insertBefore(n, r.firstChild) : r.appendChild(n), n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e)) } } var css_248z = ".avw-loader {\r\n  box-sizing: border-box;\r\n  display: flex;\r\n  flex: 0 1 auto;\r\n  flex-direction: column;\r\n  flex-grow: 1;\r\n  flex-shrink: 0;\r\n  flex-basis: 25%;\r\n  align-items: center;\r\n  justify-content: center;\r\n}\r\n\r\n@-webkit-keyframes line-scale {\r\n  0% {\r\n    -webkit-transform: scaley(1);\r\n    transform: scaley(1);\r\n  }\r\n\r\n  50% {\r\n    -webkit-transform: scaley(0.4);\r\n    transform: scaley(0.4);\r\n  }\r\n\r\n  100% {\r\n    -webkit-transform: scaley(1);\r\n    transform: scaley(1);\r\n  }\r\n}\r\n@keyframes line-scale {\r\n  0% {\r\n    -webkit-transform: scaley(1);\r\n    transform: scaley(1);\r\n  }\r\n\r\n  50% {\r\n    -webkit-transform: scaley(0.4);\r\n    transform: scaley(0.4);\r\n  }\r\n\r\n  100% {\r\n    -webkit-transform: scaley(1);\r\n    transform: scaley(1);\r\n  }\r\n}\r\n\r\n.line-scale > div:nth-child(1) {\r\n  -webkit-animation: line-scale 1s 0.1s infinite cubic-bezier(0.2, 0.68, 0.18, 1.08);\r\n  animation: line-scale 1s 0.1s infinite cubic-bezier(0.2, 0.68, 0.18, 1.08);\r\n}\r\n.line-scale > div:nth-child(2) {\r\n  -webkit-animation: line-scale 1s 0.2s infinite cubic-bezier(0.2, 0.68, 0.18, 1.08);\r\n  animation: line-scale 1s 0.2s infinite cubic-bezier(0.2, 0.68, 0.18, 1.08);\r\n}\r\n.line-scale > div:nth-child(3) {\r\n  -webkit-animation: line-scale 1s 0.3s infinite cubic-bezier(0.2, 0.68, 0.18, 1.08);\r\n  animation: line-scale 1s 0.3s infinite cubic-bezier(0.2, 0.68, 0.18, 1.08);\r\n}\r\n.line-scale > div:nth-child(4) {\r\n  -webkit-animation: line-scale 1s 0.4s infinite cubic-bezier(0.2, 0.68, 0.18, 1.08);\r\n  animation: line-scale 1s 0.4s infinite cubic-bezier(0.2, 0.68, 0.18, 1.08);\r\n}\r\n.line-scale > div:nth-child(5) {\r\n  -webkit-animation: line-scale 1s 0.5s infinite cubic-bezier(0.2, 0.68, 0.18, 1.08);\r\n  animation: line-scale 1s 0.5s infinite cubic-bezier(0.2, 0.68, 0.18, 1.08);\r\n}\r\n.line-scale > div {\r\n  background-color: #fff;\r\n  width: 4px;\r\n  height: 35px;\r\n  border-radius: 2px;\r\n  margin: 2px;\r\n  -webkit-animation-fill-mode: both;\r\n  animation-fill-mode: both;\r\n  display: inline-block;\r\n}\r\n.line-scale > span {\r\n  color: #fff;\r\n  position: absolute;\r\n  top: calc(50% + 40px);\r\n  left: 50%;\r\n  transform: translate(-50%, -50%);\r\n}\r\n", LogLevel; styleInject(css_248z); class ProgressBar { constructor(e) { this._progress = .01, this._dom = document.createElement("div"), this._dom.style.position = "relative", this._dom.style.width = "100%", this._dom.style.height = "100%", this._dom.style.backgroundColor = "#000000", this._dom.className = "avw-loader", this._loadingDom = document.createElement("div"), this._loadingDom.className = "loader-inner line-scale", this._loadingDom.appendChild(document.createElement("div")), this._loadingDom.appendChild(document.createElement("div")), this._loadingDom.appendChild(document.createElement("div")), this._loadingDom.appendChild(document.createElement("div")), this._loadingDom.appendChild(document.createElement("div")); var t = document.createElement("span"); t.innerText = e.text ? e.text : "", this._loadingDom.appendChild(t), this._dom.appendChild(this._loadingDom), this._container = e.container || document.body, this._container.insertBefore(this._dom, this._container.firstChild) } get progress() { return this._progress } set progress(e) { NaN !== (e = Number(e)) && (e >= 1 && (e = 1), e < .01 && (e = .01), this._progress = e) } destroy() { this._container.removeChild(this._dom) } hide() { } show() { } } class HttpError extends Error { constructor(e, t) { const i = new.target.prototype; super(`${e}: Status code '${t}'`), this.statusCode = t, this.__proto__ = i } } class TimeoutError extends Error { constructor(e = "A timeout occurred.") { const t = new.target.prototype; super(e), this.__proto__ = t } } class AbortError extends Error { constructor(e = "An abort occurred.") { const t = new.target.prototype; super(e), this.__proto__ = t } } class UnsupportedTransportError extends Error { constructor(e, t) { const i = new.target.prototype; super(e), this.transport = t, this.errorType = "UnsupportedTransportError", this.__proto__ = i } } class DisabledTransportError extends Error { constructor(e, t) { const i = new.target.prototype; super(e), this.transport = t, this.errorType = "DisabledTransportError", this.__proto__ = i } } class FailedToStartTransportError extends Error { constructor(e, t) { const i = new.target.prototype; super(e), this.transport = t, this.errorType = "FailedToStartTransportError", this.__proto__ = i } } class FailedToNegotiateWithServerError extends Error { constructor(e) { const t = new.target.prototype; super(e), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = t } } class AggregateErrors extends Error { constructor(e, t) { const i = new.target.prototype; super(e), this.innerErrors = t, this.__proto__ = i } } class HttpResponse { constructor(e, t, i) { this.statusCode = e, this.statusText = t, this.content = i } } class HttpClient { get(e, t) { return this.send({ ...t, method: "GET", url: e }) } post(e, t) { return this.send({ ...t, method: "POST", url: e }) } delete(e, t) { return this.send({ ...t, method: "DELETE", url: e }) } getCookieString(e) { return "" } } !function (e) { e[e.Trace = 0] = "Trace", e[e.Debug = 1] = "Debug", e[e.Information = 2] = "Information", e[e.Warning = 3] = "Warning", e[e.Error = 4] = "Error", e[e.Critical = 5] = "Critical", e[e.None = 6] = "None" }(LogLevel || (LogLevel = {})); class NullLogger { constructor() { } log(e, t) { } } NullLogger.instance = new NullLogger; const VERSION$1 = "6.0.4"; class Arg { static isRequired(e, t) { if (null == e) throw new Error(`The '${t}' argument is required.`) } static isNotEmpty(e, t) { if (!e || e.match(/^\s*$/)) throw new Error(`The '${t}' argument should not be empty.`) } static isIn(e, t, i) { if (!(e in t)) throw new Error(`Unknown ${i} value: ${e}.`) } } class Platform { static get isBrowser() { return "object" == typeof window && "object" == typeof window.document } static get isWebWorker() { return "object" == typeof self && "importScripts" in self } static get isReactNative() { return "object" == typeof window && void 0 === window.document } static get isNode() { return !this.isBrowser && !this.isWebWorker && !this.isReactNative } } function getDataDetail(e, t) { let i = ""; return isArrayBuffer(e) ? (i = `Binary data of length ${e.byteLength}`, t && (i += `. Content: '${formatArrayBuffer(e)}'`)) : "string" == typeof e && (i = `String data of length ${e.length}`, t && (i += `. Content: '${e}'`)), i } function formatArrayBuffer(e) { const t = new Uint8Array(e); let i = ""; return t.forEach((e => { i += `0x${e < 16 ? "0" : ""}${e.toString(16)} ` })), i.substr(0, i.length - 1) } function isArrayBuffer(e) { return e && "undefined" != typeof ArrayBuffer && (e instanceof ArrayBuffer || e.constructor && "ArrayBuffer" === e.constructor.name) } async function sendMessage(e, t, i, r, n, a, o) { let s = {}; if (n) { const e = await n(); e && (s = { Authorization: `Bearer ${e}` }) } const [l, c] = getUserAgentHeader(); s[l] = c, e.log(LogLevel.Trace, `(${t} transport) sending data. ${getDataDetail(a, o.logMessageContent)}.`); const h = isArrayBuffer(a) ? "arraybuffer" : "text", u = await i.post(r, { content: a, headers: { ...s, ...o.headers }, responseType: h, timeout: o.timeout, withCredentials: o.withCredentials }); e.log(LogLevel.Trace, `(${t} transport) request complete. Response status: ${u.statusCode}.`) } function createLogger(e) { return void 0 === e ? new ConsoleLogger(LogLevel.Information) : null === e ? NullLogger.instance : void 0 !== e.log ? e : new ConsoleLogger(e) } class SubjectSubscription { constructor(e, t) { this._subject = e, this._observer = t } dispose() { const e = this._subject.observers.indexOf(this._observer); e > -1 && this._subject.observers.splice(e, 1), 0 === this._subject.observers.length && this._subject.cancelCallback && this._subject.cancelCallback().catch((e => { })) } } class ConsoleLogger { constructor(e) { this._minLevel = e, this.out = console } log(e, t) { if (e >= this._minLevel) { const i = `[${(new Date).toISOString()}] ${LogLevel[e]}: ${t}`; switch (e) { case LogLevel.Critical: case LogLevel.Error: this.out.error(i); break; case LogLevel.Warning: this.out.warn(i); break; case LogLevel.Information: this.out.info(i); break; default: this.out.log(i) } } } } function getUserAgentHeader() { let e = "X-SignalR-User-Agent"; return Platform.isNode && (e = "User-Agent"), [e, constructUserAgent(VERSION$1, getOsName(), getRuntime(), getRuntimeVersion())] } function constructUserAgent(e, t, i, r) { let n = "Microsoft SignalR/"; const a = e.split("."); return n += `${a[0]}.${a[1]}`, n += ` (${e}; `, n += t && "" !== t ? `${t}; ` : "Unknown OS; ", n += `${i}`, n += r ? `; ${r}` : "; Unknown Runtime Version", n += ")", n } function getOsName() { if (!Platform.isNode) return ""; switch (process.platform) { case "win32": return "Windows NT"; case "darwin": return "macOS"; case "linux": return "Linux"; default: return process.platform } } function getRuntimeVersion() { if (Platform.isNode) return process.versions.node } function getRuntime() { return Platform.isNode ? "NodeJS" : "Browser" } function getErrorString(e) { return e.stack ? e.stack : e.message ? e.message : `${e}` } function getGlobalThis() { if ("undefined" != typeof globalThis) return globalThis; if ("undefined" != typeof self) return self; if ("undefined" != typeof window) return window; if ("undefined" != typeof global) return global; throw new Error("could not find global") } class FetchHttpClient extends HttpClient { constructor(e) { if (super(), this._logger = e, "undefined" == typeof fetch) { const e = "function" == typeof __webpack_require__ ? __non_webpack_require__ : require; this._jar = new (e("tough-cookie").CookieJar), this._fetchType = e("node-fetch"), this._fetchType = e("fetch-cookie")(this._fetchType, this._jar) } else this._fetchType = fetch.bind(getGlobalThis()); if ("undefined" == typeof AbortController) { const e = "function" == typeof __webpack_require__ ? __non_webpack_require__ : require; this._abortControllerType = e("abort-controller") } else this._abortControllerType = AbortController } async send(e) { if (e.abortSignal && e.abortSignal.aborted) throw new AbortError; if (!e.method) throw new Error("No method defined."); if (!e.url) throw new Error("No url defined."); const t = new this._abortControllerType; let i; e.abortSignal && (e.abortSignal.onabort = () => { t.abort(), i = new AbortError }); let r, n = null; if (e.timeout) { const r = e.timeout; n = setTimeout((() => { t.abort(), this._logger.log(LogLevel.Warning, "Timeout from HTTP request."), i = new TimeoutError }), r) } try { r = await this._fetchType(e.url, { body: e.content, cache: "no-cache", credentials: !0 === e.withCredentials ? "include" : "same-origin", headers: { "Content-Type": "text/plain;charset=UTF-8", "X-Requested-With": "XMLHttpRequest", ...e.headers }, method: e.method, mode: "cors", redirect: "follow", signal: t.signal }) } catch (e) { if (i) throw i; throw this._logger.log(LogLevel.Warning, `Error from HTTP request. ${e}.`), e } finally { n && clearTimeout(n), e.abortSignal && (e.abortSignal.onabort = null) } if (!r.ok) { const e = await deserializeContent(r, "text"); throw new HttpError(e || r.statusText, r.status) } const a = deserializeContent(r, e.responseType), o = await a; return new HttpResponse(r.status, r.statusText, o) } getCookieString(e) { let t = ""; return Platform.isNode && this._jar && this._jar.getCookies(e, ((e, i) => t = i.join("; "))), t } } function deserializeContent(e, t) { let i; switch (t) { case "arraybuffer": i = e.arrayBuffer(); break; case "text": i = e.text(); break; case "blob": case "document": case "json": throw new Error(`${t} is not supported.`); default: i = e.text() }return i } class XhrHttpClient extends HttpClient { constructor(e) { super(), this._logger = e } send(e) { return e.abortSignal && e.abortSignal.aborted ? Promise.reject(new AbortError) : e.method ? e.url ? new Promise(((t, i) => { const r = new XMLHttpRequest; r.open(e.method, e.url, !0), r.withCredentials = void 0 === e.withCredentials || e.withCredentials, r.setRequestHeader("X-Requested-With", "XMLHttpRequest"), r.setRequestHeader("Content-Type", "text/plain;charset=UTF-8"); const n = e.headers; n && Object.keys(n).forEach((e => { r.setRequestHeader(e, n[e]) })), e.responseType && (r.responseType = e.responseType), e.abortSignal && (e.abortSignal.onabort = () => { r.abort(), i(new AbortError) }), e.timeout && (r.timeout = e.timeout), r.onload = () => { e.abortSignal && (e.abortSignal.onabort = null), r.status >= 200 && r.status < 300 ? t(new HttpResponse(r.status, r.statusText, r.response || r.responseText)) : i(new HttpError(r.response || r.responseText || r.statusText, r.status)) }, r.onerror = () => { this._logger.log(LogLevel.Warning, `Error from HTTP request. ${r.status}: ${r.statusText}.`), i(new HttpError(r.statusText, r.status)) }, r.ontimeout = () => { this._logger.log(LogLevel.Warning, "Timeout from HTTP request."), i(new TimeoutError) }, r.send(e.content || "") })) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined.")) } } class DefaultHttpClient extends HttpClient { constructor(e) { if (super(), "undefined" != typeof fetch || Platform.isNode) this._httpClient = new FetchHttpClient(e); else { if ("undefined" == typeof XMLHttpRequest) throw new Error("No usable HttpClient found."); this._httpClient = new XhrHttpClient(e) } } send(e) { return e.abortSignal && e.abortSignal.aborted ? Promise.reject(new AbortError) : e.method ? e.url ? this._httpClient.send(e) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined.")) } getCookieString(e) { return this._httpClient.getCookieString(e) } } class TextMessageFormat { static write(e) { return `${e}${TextMessageFormat.RecordSeparator}` } static parse(e) { if (e[e.length - 1] !== TextMessageFormat.RecordSeparator) throw new Error("Message is incomplete."); const t = e.split(TextMessageFormat.RecordSeparator); return t.pop(), t } } TextMessageFormat.RecordSeparatorCode = 30, TextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode); class HandshakeProtocol { writeHandshakeRequest(e) { return TextMessageFormat.write(JSON.stringify(e)) } parseHandshakeResponse(e) { let t, i; if (isArrayBuffer(e)) { const r = new Uint8Array(e), n = r.indexOf(TextMessageFormat.RecordSeparatorCode); if (-1 === n) throw new Error("Message is incomplete."); const a = n + 1; t = String.fromCharCode.apply(null, Array.prototype.slice.call(r.slice(0, a))), i = r.byteLength > a ? r.slice(a).buffer : null } else { const r = e, n = r.indexOf(TextMessageFormat.RecordSeparator); if (-1 === n) throw new Error("Message is incomplete."); const a = n + 1; t = r.substring(0, a), i = r.length > a ? r.substring(a) : null } const r = TextMessageFormat.parse(t), n = JSON.parse(r[0]); if (n.type) throw new Error("Expected a handshake response from the server."); return [i, n] } } var MessageType; !function (e) { e[e.Invocation = 1] = "Invocation", e[e.StreamItem = 2] = "StreamItem", e[e.Completion = 3] = "Completion", e[e.StreamInvocation = 4] = "StreamInvocation", e[e.CancelInvocation = 5] = "CancelInvocation", e[e.Ping = 6] = "Ping", e[e.Close = 7] = "Close" }(MessageType || (MessageType = {})); class Subject { constructor() { this.observers = [] } next(e) { for (const t of this.observers) t.next(e) } error(e) { for (const t of this.observers) t.error && t.error(e) } complete() { for (const e of this.observers) e.complete && e.complete() } subscribe(e) { return this.observers.push(e), new SubjectSubscription(this, e) } } const DEFAULT_TIMEOUT_IN_MS = 3e4, DEFAULT_PING_INTERVAL_IN_MS = 15e3; var HubConnectionState; !function (e) { e.Disconnected = "Disconnected", e.Connecting = "Connecting", e.Connected = "Connected", e.Disconnecting = "Disconnecting", e.Reconnecting = "Reconnecting" }(HubConnectionState || (HubConnectionState = {})); class HubConnection { constructor(e, t, i, r) { this._nextKeepAlive = 0, this._freezeEventListener = () => { this._logger.log(LogLevel.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep") }, Arg.isRequired(e, "connection"), Arg.isRequired(t, "logger"), Arg.isRequired(i, "protocol"), this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS, this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS, this._logger = t, this._protocol = i, this.connection = e, this._reconnectPolicy = r, this._handshakeProtocol = new HandshakeProtocol, this.connection.onreceive = e => this._processIncomingData(e), this.connection.onclose = e => this._connectionClosed(e), this._callbacks = {}, this._methods = {}, this._closedCallbacks = [], this._reconnectingCallbacks = [], this._reconnectedCallbacks = [], this._invocationId = 0, this._receivedHandshakeResponse = !1, this._connectionState = HubConnectionState.Disconnected, this._connectionStarted = !1, this._cachedPingMessage = this._protocol.writeMessage({ type: MessageType.Ping }) } static create(e, t, i, r) { return new HubConnection(e, t, i, r) } get state() { return this._connectionState } get connectionId() { return this.connection && this.connection.connectionId || null } get baseUrl() { return this.connection.baseUrl || "" } set baseUrl(e) { if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url."); if (!e) throw new Error("The HubConnection url must be a valid url."); this.connection.baseUrl = e } start() { return this._startPromise = this._startWithStateTransitions(), this._startPromise } async _startWithStateTransitions() { if (this._connectionState !== HubConnectionState.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state.")); this._connectionState = HubConnectionState.Connecting, this._logger.log(LogLevel.Debug, "Starting HubConnection."); try { await this._startInternal(), Platform.isBrowser && window.document.addEventListener("freeze", this._freezeEventListener), this._connectionState = HubConnectionState.Connected, this._connectionStarted = !0, this._logger.log(LogLevel.Debug, "HubConnection connected successfully.") } catch (e) { return this._connectionState = HubConnectionState.Disconnected, this._logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`), Promise.reject(e) } } async _startInternal() { this._stopDuringStartError = void 0, this._receivedHandshakeResponse = !1; const e = new Promise(((e, t) => { this._handshakeResolver = e, this._handshakeRejecter = t })); await this.connection.start(this._protocol.transferFormat); try { const t = { protocol: this._protocol.name, version: this._protocol.version }; if (this._logger.log(LogLevel.Debug, "Sending handshake request."), await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(t)), this._logger.log(LogLevel.Information, `Using HubProtocol '${this._protocol.name}'.`), this._cleanupTimeout(), this._resetTimeoutPeriod(), this._resetKeepAliveInterval(), await e, this._stopDuringStartError) throw this._stopDuringStartError } catch (e) { throw this._logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`), this._cleanupTimeout(), this._cleanupPingTimer(), await this.connection.stop(e), e } } async stop() { const e = this._startPromise; this._stopPromise = this._stopInternal(), await this._stopPromise; try { await e } catch (e) { } } _stopInternal(e) { return this._connectionState === HubConnectionState.Disconnected ? (this._logger.log(LogLevel.Debug, `Call to HubConnection.stop(${e}) ignored because it is already in the disconnected state.`), Promise.resolve()) : this._connectionState === HubConnectionState.Disconnecting ? (this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`), this._stopPromise) : (this._connectionState = HubConnectionState.Disconnecting, this._logger.log(LogLevel.Debug, "Stopping HubConnection."), this._reconnectDelayHandle ? (this._logger.log(LogLevel.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this._reconnectDelayHandle), this._reconnectDelayHandle = void 0, this._completeClose(), Promise.resolve()) : (this._cleanupTimeout(), this._cleanupPingTimer(), this._stopDuringStartError = e || new Error("The connection was stopped before the hub handshake could complete."), this.connection.stop(e))) } stream(e, ...t) { const [i, r] = this._replaceStreamingParams(t), n = this._createStreamInvocation(e, t, r); let a; const o = new Subject; return o.cancelCallback = () => { const e = this._createCancelInvocation(n.invocationId); return delete this._callbacks[n.invocationId], a.then((() => this._sendWithProtocol(e))) }, this._callbacks[n.invocationId] = (e, t) => { t ? o.error(t) : e && (e.type === MessageType.Completion ? e.error ? o.error(new Error(e.error)) : o.complete() : o.next(e.item)) }, a = this._sendWithProtocol(n).catch((e => { o.error(e), delete this._callbacks[n.invocationId] })), this._launchStreams(i, a), o } _sendMessage(e) { return this._resetKeepAliveInterval(), this.connection.send(e) } _sendWithProtocol(e) { return this._sendMessage(this._protocol.writeMessage(e)) } send(e, ...t) { const [i, r] = this._replaceStreamingParams(t), n = this._sendWithProtocol(this._createInvocation(e, t, !0, r)); return this._launchStreams(i, n), n } invoke(e, ...t) { const [i, r] = this._replaceStreamingParams(t), n = this._createInvocation(e, t, !1, r); return new Promise(((e, t) => { this._callbacks[n.invocationId] = (i, r) => { r ? t(r) : i && (i.type === MessageType.Completion ? i.error ? t(new Error(i.error)) : e(i.result) : t(new Error(`Unexpected message type: ${i.type}`))) }; const r = this._sendWithProtocol(n).catch((e => { t(e), delete this._callbacks[n.invocationId] })); this._launchStreams(i, r) })) } on(e, t) { e && t && (e = e.toLowerCase(), this._methods[e] || (this._methods[e] = []), -1 === this._methods[e].indexOf(t) && this._methods[e].push(t)) } off(e, t) { if (!e) return; e = e.toLowerCase(); const i = this._methods[e]; if (i) if (t) { const r = i.indexOf(t); -1 !== r && (i.splice(r, 1), 0 === i.length && delete this._methods[e]) } else delete this._methods[e] } onclose(e) { e && this._closedCallbacks.push(e) } onreconnecting(e) { e && this._reconnectingCallbacks.push(e) } onreconnected(e) { e && this._reconnectedCallbacks.push(e) } _processIncomingData(e) { if (this._cleanupTimeout(), this._receivedHandshakeResponse || (e = this._processHandshakeResponse(e), this._receivedHandshakeResponse = !0), e) { const t = this._protocol.parseMessages(e, this._logger); for (const e of t) switch (e.type) { case MessageType.Invocation: this._invokeClientMethod(e); break; case MessageType.StreamItem: case MessageType.Completion: { const t = this._callbacks[e.invocationId]; if (t) { e.type === MessageType.Completion && delete this._callbacks[e.invocationId]; try { t(e) } catch (e) { this._logger.log(LogLevel.Error, `Stream callback threw error: ${getErrorString(e)}`) } } break } case MessageType.Ping: break; case MessageType.Close: { this._logger.log(LogLevel.Information, "Close message received from server."); const t = e.error ? new Error("Server returned an error on close: " + e.error) : void 0; !0 === e.allowReconnect ? this.connection.stop(t) : this._stopPromise = this._stopInternal(t); break } default: this._logger.log(LogLevel.Warning, `Invalid message type: ${e.type}.`) } } this._resetTimeoutPeriod() } _processHandshakeResponse(e) { let t, i; try { [i, t] = this._handshakeProtocol.parseHandshakeResponse(e) } catch (e) { const t = "Error parsing handshake response: " + e; this._logger.log(LogLevel.Error, t); const i = new Error(t); throw this._handshakeRejecter(i), i } if (t.error) { const e = "Server returned handshake error: " + t.error; this._logger.log(LogLevel.Error, e); const i = new Error(e); throw this._handshakeRejecter(i), i } return this._logger.log(LogLevel.Debug, "Server handshake complete."), this._handshakeResolver(), i } _resetKeepAliveInterval() { this.connection.features.inherentKeepAlive || (this._nextKeepAlive = (new Date).getTime() + this.keepAliveIntervalInMilliseconds, this._cleanupPingTimer()) } _resetTimeoutPeriod() { if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this._timeoutHandle = setTimeout((() => this.serverTimeout()), this.serverTimeoutInMilliseconds), void 0 !== this._pingServerHandle))) { let e = this._nextKeepAlive - (new Date).getTime(); e < 0 && (e = 0), this._pingServerHandle = setTimeout((async () => { if (this._connectionState === HubConnectionState.Connected) try { await this._sendMessage(this._cachedPingMessage) } catch { this._cleanupPingTimer() } }), e) } } serverTimeout() { this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server.")) } _invokeClientMethod(e) { const t = this._methods[e.target.toLowerCase()]; if (t) { try { t.forEach((t => t.apply(this, e.arguments))) } catch (t) { this._logger.log(LogLevel.Error, `A callback for the method ${e.target.toLowerCase()} threw error '${t}'.`) } if (e.invocationId) { const e = "Server requested a response, which is not supported in this version of the client."; this._logger.log(LogLevel.Error, e), this._stopPromise = this._stopInternal(new Error(e)) } } else this._logger.log(LogLevel.Warning, `No client method with the name '${e.target}' found.`) } _connectionClosed(e) { this._logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${e}) called while in state ${this._connectionState}.`), this._stopDuringStartError = this._stopDuringStartError || e || new Error("The underlying connection was closed before the hub handshake could complete."), this._handshakeResolver && this._handshakeResolver(), this._cancelCallbacksWithError(e || new Error("Invocation canceled due to the underlying connection being closed.")), this._cleanupTimeout(), this._cleanupPingTimer(), this._connectionState === HubConnectionState.Disconnecting ? this._completeClose(e) : this._connectionState === HubConnectionState.Connected && this._reconnectPolicy ? this._reconnect(e) : this._connectionState === HubConnectionState.Connected && this._completeClose(e) } _completeClose(e) { if (this._connectionStarted) { this._connectionState = HubConnectionState.Disconnected, this._connectionStarted = !1, Platform.isBrowser && window.document.removeEventListener("freeze", this._freezeEventListener); try { this._closedCallbacks.forEach((t => t.apply(this, [e]))) } catch (t) { this._logger.log(LogLevel.Error, `An onclose callback called with error '${e}' threw error '${t}'.`) } } } async _reconnect(e) { const t = Date.now(); let i = 0, r = void 0 !== e ? e : new Error("Attempting to reconnect due to a unknown error."), n = this._getNextRetryDelay(i++, 0, r); if (null === n) return this._logger.log(LogLevel.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this._completeClose(e); if (this._connectionState = HubConnectionState.Reconnecting, e ? this._logger.log(LogLevel.Information, `Connection reconnecting because of error '${e}'.`) : this._logger.log(LogLevel.Information, "Connection reconnecting."), 0 !== this._reconnectingCallbacks.length) { try { this._reconnectingCallbacks.forEach((t => t.apply(this, [e]))) } catch (t) { this._logger.log(LogLevel.Error, `An onreconnecting callback called with error '${e}' threw error '${t}'.`) } if (this._connectionState !== HubConnectionState.Reconnecting) return void this._logger.log(LogLevel.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.") } for (; null !== n;) { if (this._logger.log(LogLevel.Information, `Reconnect attempt number ${i} will start in ${n} ms.`), await new Promise((e => { this._reconnectDelayHandle = setTimeout(e, n) })), this._reconnectDelayHandle = void 0, this._connectionState !== HubConnectionState.Reconnecting) return void this._logger.log(LogLevel.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting."); try { if (await this._startInternal(), this._connectionState = HubConnectionState.Connected, this._logger.log(LogLevel.Information, "HubConnection reconnected successfully."), 0 !== this._reconnectedCallbacks.length) try { this._reconnectedCallbacks.forEach((e => e.apply(this, [this.connection.connectionId]))) } catch (e) { this._logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`) } return } catch (e) { if (this._logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`), this._connectionState !== HubConnectionState.Reconnecting) return this._logger.log(LogLevel.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this._connectionState === HubConnectionState.Disconnecting && this._completeClose()); r = e instanceof Error ? e : new Error(e.toString()), n = this._getNextRetryDelay(i++, Date.now() - t, r) } } this._logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - t} ms and ${i} failed attempts. Connection disconnecting.`), this._completeClose() } _getNextRetryDelay(e, t, i) { try { return this._reconnectPolicy.nextRetryDelayInMilliseconds({ elapsedMilliseconds: t, previousRetryCount: e, retryReason: i }) } catch (i) { return this._logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${e}, ${t}) threw error '${i}'.`), null } } _cancelCallbacksWithError(e) { const t = this._callbacks; this._callbacks = {}, Object.keys(t).forEach((i => { const r = t[i]; try { r(null, e) } catch (t) { this._logger.log(LogLevel.Error, `Stream 'error' callback called with '${e}' threw error: ${getErrorString(t)}`) } })) } _cleanupPingTimer() { this._pingServerHandle && (clearTimeout(this._pingServerHandle), this._pingServerHandle = void 0) } _cleanupTimeout() { this._timeoutHandle && clearTimeout(this._timeoutHandle) } _createInvocation(e, t, i, r) { if (i) return 0 !== r.length ? { arguments: t, streamIds: r, target: e, type: MessageType.Invocation } : { arguments: t, target: e, type: MessageType.Invocation }; { const i = this._invocationId; return this._invocationId++, 0 !== r.length ? { arguments: t, invocationId: i.toString(), streamIds: r, target: e, type: MessageType.Invocation } : { arguments: t, invocationId: i.toString(), target: e, type: MessageType.Invocation } } } _launchStreams(e, t) { if (0 !== e.length) { t || (t = Promise.resolve()); for (const i in e) e[i].subscribe({ complete: () => { t = t.then((() => this._sendWithProtocol(this._createCompletionMessage(i)))) }, error: e => { let r; r = e instanceof Error ? e.message : e && e.toString ? e.toString() : "Unknown error", t = t.then((() => this._sendWithProtocol(this._createCompletionMessage(i, r)))) }, next: e => { t = t.then((() => this._sendWithProtocol(this._createStreamItemMessage(i, e)))) } }) } } _replaceStreamingParams(e) { const t = [], i = []; for (let r = 0; r < e.length; r++) { const n = e[r]; if (this._isObservable(n)) { const a = this._invocationId; this._invocationId++, t[a] = n, i.push(a.toString()), e.splice(r, 1) } } return [t, i] } _isObservable(e) { return e && e.subscribe && "function" == typeof e.subscribe } _createStreamInvocation(e, t, i) { const r = this._invocationId; return this._invocationId++, 0 !== i.length ? { arguments: t, invocationId: r.toString(), streamIds: i, target: e, type: MessageType.StreamInvocation } : { arguments: t, invocationId: r.toString(), target: e, type: MessageType.StreamInvocation } } _createCancelInvocation(e) { return { invocationId: e, type: MessageType.CancelInvocation } } _createStreamItemMessage(e, t) { return { invocationId: e, item: t, type: MessageType.StreamItem } } _createCompletionMessage(e, t, i) { return t ? { error: t, invocationId: e, type: MessageType.Completion } : { invocationId: e, result: i, type: MessageType.Completion } } } const DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2e3, 1e4, 3e4, null]; class DefaultReconnectPolicy { constructor(e) { this._retryDelays = void 0 !== e ? [...e, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS } nextRetryDelayInMilliseconds(e) { return this._retryDelays[e.previousRetryCount] } } class HeaderNames { } var HttpTransportType, TransferFormat; HeaderNames.Authorization = "Authorization", HeaderNames.Cookie = "Cookie", function (e) { e[e.None = 0] = "None", e[e.WebSockets = 1] = "WebSockets", e[e.ServerSentEvents = 2] = "ServerSentEvents", e[e.LongPolling = 4] = "LongPolling" }(HttpTransportType || (HttpTransportType = {})), function (e) { e[e.Text = 1] = "Text", e[e.Binary = 2] = "Binary" }(TransferFormat || (TransferFormat = {})); class AbortController$1 { constructor() { this._isAborted = !1, this.onabort = null } abort() { this._isAborted || (this._isAborted = !0, this.onabort && this.onabort()) } get signal() { return this } get aborted() { return this._isAborted } } class LongPollingTransport { constructor(e, t, i, r) { this._httpClient = e, this._accessTokenFactory = t, this._logger = i, this._pollAbort = new AbortController$1, this._options = r, this._running = !1, this.onreceive = null, this.onclose = null } get pollAborted() { return this._pollAbort.aborted } async connect(e, t) { if (Arg.isRequired(e, "url"), Arg.isRequired(t, "transferFormat"), Arg.isIn(t, TransferFormat, "transferFormat"), this._url = e, this._logger.log(LogLevel.Trace, "(LongPolling transport) Connecting."), t === TransferFormat.Binary && "undefined" != typeof XMLHttpRequest && "string" != typeof (new XMLHttpRequest).responseType) throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported."); const [i, r] = getUserAgentHeader(), n = { [i]: r, ...this._options.headers }, a = { abortSignal: this._pollAbort.signal, headers: n, timeout: 1e5, withCredentials: this._options.withCredentials }; t === TransferFormat.Binary && (a.responseType = "arraybuffer"); const o = await this._getAccessToken(); this._updateHeaderToken(a, o); const s = `${e}&_=${Date.now()}`; this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${s}.`); const l = await this._httpClient.get(s, a); 200 !== l.statusCode ? (this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${l.statusCode}.`), this._closeError = new HttpError(l.statusText || "", l.statusCode), this._running = !1) : this._running = !0, this._receiving = this._poll(this._url, a) } async _getAccessToken() { return this._accessTokenFactory ? await this._accessTokenFactory() : null } _updateHeaderToken(e, t) { e.headers || (e.headers = {}), t ? e.headers[HeaderNames.Authorization] = `Bearer ${t}` : e.headers[HeaderNames.Authorization] && delete e.headers[HeaderNames.Authorization] } async _poll(e, t) { try { for (; this._running;) { const i = await this._getAccessToken(); this._updateHeaderToken(t, i); try { const i = `${e}&_=${Date.now()}`; this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${i}.`); const r = await this._httpClient.get(i, t); 204 === r.statusCode ? (this._logger.log(LogLevel.Information, "(LongPolling transport) Poll terminated by server."), this._running = !1) : 200 !== r.statusCode ? (this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${r.statusCode}.`), this._closeError = new HttpError(r.statusText || "", r.statusCode), this._running = !1) : r.content ? (this._logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(r.content, this._options.logMessageContent)}.`), this.onreceive && this.onreceive(r.content)) : this._logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.") } catch (e) { this._running ? e instanceof TimeoutError ? this._logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this._closeError = e, this._running = !1) : this._logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`) } } } finally { this._logger.log(LogLevel.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this._raiseOnClose() } } async send(e) { return this._running ? sendMessage(this._logger, "LongPolling", this._httpClient, this._url, this._accessTokenFactory, e, this._options) : Promise.reject(new Error("Cannot send until the transport is connected")) } async stop() { this._logger.log(LogLevel.Trace, "(LongPolling transport) Stopping polling."), this._running = !1, this._pollAbort.abort(); try { await this._receiving, this._logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`); const e = {}, [t, i] = getUserAgentHeader(); e[t] = i; const r = { headers: { ...e, ...this._options.headers }, timeout: this._options.timeout, withCredentials: this._options.withCredentials }, n = await this._getAccessToken(); this._updateHeaderToken(r, n), await this._httpClient.delete(this._url, r), this._logger.log(LogLevel.Trace, "(LongPolling transport) DELETE request sent.") } finally { this._logger.log(LogLevel.Trace, "(LongPolling transport) Stop finished."), this._raiseOnClose() } } _raiseOnClose() { if (this.onclose) { let e = "(LongPolling transport) Firing onclose event."; this._closeError && (e += " Error: " + this._closeError), this._logger.log(LogLevel.Trace, e), this.onclose(this._closeError) } } } class ServerSentEventsTransport { constructor(e, t, i, r) { this._httpClient = e, this._accessTokenFactory = t, this._logger = i, this._options = r, this.onreceive = null, this.onclose = null } async connect(e, t) { if (Arg.isRequired(e, "url"), Arg.isRequired(t, "transferFormat"), Arg.isIn(t, TransferFormat, "transferFormat"), this._logger.log(LogLevel.Trace, "(SSE transport) Connecting."), this._url = e, this._accessTokenFactory) { const t = await this._accessTokenFactory(); t && (e += (e.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(t)}`) } return new Promise(((i, r) => { let n, a = !1; if (t === TransferFormat.Text) { if (Platform.isBrowser || Platform.isWebWorker) n = new this._options.EventSource(e, { withCredentials: this._options.withCredentials }); else { const t = this._httpClient.getCookieString(e), i = {}; i.Cookie = t; const [r, a] = getUserAgentHeader(); i[r] = a, n = new this._options.EventSource(e, { withCredentials: this._options.withCredentials, headers: { ...i, ...this._options.headers } }) } try { n.onmessage = e => { if (this.onreceive) try { this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent)}.`), this.onreceive(e.data) } catch (e) { return void this._close(e) } }, n.onerror = e => { a ? this._close() : r(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled.")) }, n.onopen = () => { this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`), this._eventSource = n, a = !0, i() } } catch (e) { return void r(e) } } else r(new Error("The Server-Sent Events transport only supports the 'Text' transfer format")) })) } async send(e) { return this._eventSource ? sendMessage(this._logger, "SSE", this._httpClient, this._url, this._accessTokenFactory, e, this._options) : Promise.reject(new Error("Cannot send until the transport is connected")) } stop() { return this._close(), Promise.resolve() } _close(e) { this._eventSource && (this._eventSource.close(), this._eventSource = void 0, this.onclose && this.onclose(e)) } } class WebSocketTransport { constructor(e, t, i, r, n, a) { this._logger = i, this._accessTokenFactory = t, this._logMessageContent = r, this._webSocketConstructor = n, this._httpClient = e, this.onreceive = null, this.onclose = null, this._headers = a } async connect(e, t) { if (Arg.isRequired(e, "url"), Arg.isRequired(t, "transferFormat"), Arg.isIn(t, TransferFormat, "transferFormat"), this._logger.log(LogLevel.Trace, "(WebSockets transport) Connecting."), this._accessTokenFactory) { const t = await this._accessTokenFactory(); t && (e += (e.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(t)}`) } return new Promise(((i, r) => { let n; e = e.replace(/^http/, "ws"); const a = this._httpClient.getCookieString(e); let o = !1; if (Platform.isNode) { const t = {}, [i, r] = getUserAgentHeader(); t[i] = r, a && (t[HeaderNames.Cookie] = `${a}`), n = new this._webSocketConstructor(e, void 0, { headers: { ...t, ...this._headers } }) } n || (n = new this._webSocketConstructor(e)), t === TransferFormat.Binary && (n.binaryType = "arraybuffer"), n.onopen = t => { this._logger.log(LogLevel.Information, `WebSocket connected to ${e}.`), this._webSocket = n, o = !0, i() }, n.onerror = e => { let t = null; t = "undefined" != typeof ErrorEvent && e instanceof ErrorEvent ? e.error : "There was an error with the transport", this._logger.log(LogLevel.Information, `(WebSockets transport) ${t}.`) }, n.onmessage = e => { if (this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(e.data, this._logMessageContent)}.`), this.onreceive) try { this.onreceive(e.data) } catch (e) { return void this._close(e) } }, n.onclose = e => { if (o) this._close(e); else { let t = null; t = "undefined" != typeof ErrorEvent && e instanceof ErrorEvent ? e.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", r(new Error(t)) } } })) } send(e) { return this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN ? (this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(e, this._logMessageContent)}.`), this._webSocket.send(e), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state") } stop() { return this._webSocket && this._close(void 0), Promise.resolve() } _close(e) { this._webSocket && (this._webSocket.onclose = () => { }, this._webSocket.onmessage = () => { }, this._webSocket.onerror = () => { }, this._webSocket.close(), this._webSocket = void 0), this._logger.log(LogLevel.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this._isCloseEvent(e) || !1 !== e.wasClean && 1e3 === e.code ? e instanceof Error ? this.onclose(e) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${e.code} (${e.reason || "no reason given"}).`))) } _isCloseEvent(e) { return e && "boolean" == typeof e.wasClean && "number" == typeof e.code } } const MAX_REDIRECTS = 100; class HttpConnection { constructor(e, t = {}) { if (this._stopPromiseResolver = () => { }, this.features = {}, this._negotiateVersion = 1, Arg.isRequired(e, "url"), this._logger = createLogger(t.logger), this.baseUrl = this._resolveUrl(e), (t = t || {}).logMessageContent = void 0 !== t.logMessageContent && t.logMessageContent, "boolean" != typeof t.withCredentials && void 0 !== t.withCredentials) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value"); t.withCredentials = void 0 === t.withCredentials || t.withCredentials, t.timeout = void 0 === t.timeout ? 1e5 : t.timeout; let i = null, r = null; if (Platform.isNode && "undefined" != typeof require) { const e = "function" == typeof __webpack_require__ ? __non_webpack_require__ : require; i = e("ws"), r = e("eventsource") } Platform.isNode || "undefined" == typeof WebSocket || t.WebSocket ? Platform.isNode && !t.WebSocket && i && (t.WebSocket = i) : t.WebSocket = WebSocket, Platform.isNode || "undefined" == typeof EventSource || t.EventSource ? Platform.isNode && !t.EventSource && void 0 !== r && (t.EventSource = r) : t.EventSource = EventSource, this._httpClient = t.httpClient || new DefaultHttpClient(this._logger), this._connectionState = "Disconnected", this._connectionStarted = !1, this._options = t, this.onreceive = null, this.onclose = null } async start(e) { if (e = e || TransferFormat.Binary, Arg.isIn(e, TransferFormat, "transferFormat"), this._logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[e]}'.`), "Disconnected" !== this._connectionState) return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state.")); if (this._connectionState = "Connecting", this._startInternalPromise = this._startInternal(e), await this._startInternalPromise, "Disconnecting" === this._connectionState) { const e = "Failed to start the HttpConnection before stop() was called."; return this._logger.log(LogLevel.Error, e), await this._stopPromise, Promise.reject(new Error(e)) } if ("Connected" !== this._connectionState) { const e = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!"; return this._logger.log(LogLevel.Error, e), Promise.reject(new Error(e)) } this._connectionStarted = !0 } send(e) { return "Connected" !== this._connectionState ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this._sendQueue || (this._sendQueue = new TransportSendQueue(this.transport)), this._sendQueue.send(e)) } async stop(e) { return "Disconnected" === this._connectionState ? (this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : "Disconnecting" === this._connectionState ? (this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`), this._stopPromise) : (this._connectionState = "Disconnecting", this._stopPromise = new Promise((e => { this._stopPromiseResolver = e })), await this._stopInternal(e), void await this._stopPromise) } async _stopInternal(e) { this._stopError = e; try { await this._startInternalPromise } catch (e) { } if (this.transport) { try { await this.transport.stop() } catch (e) { this._logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`), this._stopConnection() } this.transport = void 0 } else this._logger.log(LogLevel.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.") } async _startInternal(e) { let t = this.baseUrl; this._accessTokenFactory = this._options.accessTokenFactory; try { if (this._options.skipNegotiation) { if (this._options.transport !== HttpTransportType.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly."); this.transport = this._constructTransport(HttpTransportType.WebSockets), await this._startTransport(t, e) } else { let i = null, r = 0; do { if (i = await this._getNegotiationResponse(t), "Disconnecting" === this._connectionState || "Disconnected" === this._connectionState) throw new Error("The connection was stopped during negotiation."); if (i.error) throw new Error(i.error); if (i.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details."); if (i.url && (t = i.url), i.accessToken) { const e = i.accessToken; this._accessTokenFactory = () => e } r++ } while (i.url && r < MAX_REDIRECTS); if (r === MAX_REDIRECTS && i.url) throw new Error("Negotiate redirection limit exceeded."); await this._createTransport(t, this._options.transport, i, e) } this.transport instanceof LongPollingTransport && (this.features.inherentKeepAlive = !0), "Connecting" === this._connectionState && (this._logger.log(LogLevel.Debug, "The HttpConnection connected successfully."), this._connectionState = "Connected") } catch (e) { return this._logger.log(LogLevel.Error, "Failed to start the connection: " + e), this._connectionState = "Disconnected", this.transport = void 0, this._stopPromiseResolver(), Promise.reject(e) } } async _getNegotiationResponse(e) { const t = {}; if (this._accessTokenFactory) { const e = await this._accessTokenFactory(); e && (t[HeaderNames.Authorization] = `Bearer ${e}`) } const [i, r] = getUserAgentHeader(); t[i] = r; const n = this._resolveNegotiateUrl(e); this._logger.log(LogLevel.Debug, `Sending negotiation request: ${n}.`); try { const e = await this._httpClient.post(n, { content: "", headers: { ...t, ...this._options.headers }, timeout: this._options.timeout, withCredentials: this._options.withCredentials }); if (200 !== e.statusCode) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${e.statusCode}'`)); const i = JSON.parse(e.content); return (!i.negotiateVersion || i.negotiateVersion < 1) && (i.connectionToken = i.connectionId), i } catch (e) { let t = "Failed to complete negotiation with the server: " + e; return e instanceof HttpError && 404 === e.statusCode && (t += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this._logger.log(LogLevel.Error, t), Promise.reject(new FailedToNegotiateWithServerError(t)) } } _createConnectUrl(e, t) { return t ? e + (-1 === e.indexOf("?") ? "?" : "&") + `id=${t}` : e } async _createTransport(e, t, i, r) { let n = this._createConnectUrl(e, i.connectionToken); if (this._isITransport(t)) return this._logger.log(LogLevel.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = t, await this._startTransport(n, r), void (this.connectionId = i.connectionId); const a = [], o = i.availableTransports || []; let s = i; for (const i of o) { const o = this._resolveTransportOrError(i, t, r); if (o instanceof Error) a.push(`${i.transport} failed:`), a.push(o); else if (this._isITransport(o)) { if (this.transport = o, !s) { try { s = await this._getNegotiationResponse(e) } catch (e) { return Promise.reject(e) } n = this._createConnectUrl(e, s.connectionToken) } try { return await this._startTransport(n, r), void (this.connectionId = s.connectionId) } catch (e) { if (this._logger.log(LogLevel.Error, `Failed to start the transport '${i.transport}': ${e}`), s = void 0, a.push(new FailedToStartTransportError(`${i.transport} failed: ${e}`, HttpTransportType[i.transport])), "Connecting" !== this._connectionState) { const e = "Failed to select transport before stop() was called."; return this._logger.log(LogLevel.Debug, e), Promise.reject(new Error(e)) } } } } return a.length > 0 ? Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${a.join(" ")}`, a)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server.")) } _constructTransport(e) { switch (e) { case HttpTransportType.WebSockets: if (!this._options.WebSocket) throw new Error("'WebSocket' is not supported in your environment."); return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {}); case HttpTransportType.ServerSentEvents: if (!this._options.EventSource) throw new Error("'EventSource' is not supported in your environment."); return new ServerSentEventsTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options); case HttpTransportType.LongPolling: return new LongPollingTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options); default: throw new Error(`Unknown transport: ${e}.`) } } _startTransport(e, t) { return this.transport.onreceive = this.onreceive, this.transport.onclose = e => this._stopConnection(e), this.transport.connect(e, t) } _resolveTransportOrError(e, t, i) { const r = HttpTransportType[e.transport]; if (null == r) return this._logger.log(LogLevel.Debug, `Skipping transport '${e.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${e.transport}' because it is not supported by this client.`); if (!transportMatches(t, r)) return this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[r]}' because it was disabled by the client.`), new DisabledTransportError(`'${HttpTransportType[r]}' is disabled by the client.`, r); if (!(e.transferFormats.map((e => TransferFormat[e])).indexOf(i) >= 0)) return this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[r]}' because it does not support the requested transfer format '${TransferFormat[i]}'.`), new Error(`'${HttpTransportType[r]}' does not support ${TransferFormat[i]}.`); if (r === HttpTransportType.WebSockets && !this._options.WebSocket || r === HttpTransportType.ServerSentEvents && !this._options.EventSource) return this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[r]}' because it is not supported in your environment.'`), new UnsupportedTransportError(`'${HttpTransportType[r]}' is not supported in your environment.`, r); this._logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[r]}'.`); try { return this._constructTransport(r) } catch (e) { return e } } _isITransport(e) { return e && "object" == typeof e && "connect" in e } _stopConnection(e) { if (this._logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${e}) called while in state ${this._connectionState}.`), this.transport = void 0, e = this._stopError || e, this._stopError = void 0, "Disconnected" !== this._connectionState) { if ("Connecting" === this._connectionState) throw this._logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${e}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${e}) was called while the connection is still in the connecting state.`); if ("Disconnecting" === this._connectionState && this._stopPromiseResolver(), e ? this._logger.log(LogLevel.Error, `Connection disconnected with error '${e}'.`) : this._logger.log(LogLevel.Information, "Connection disconnected."), this._sendQueue && (this._sendQueue.stop().catch((e => { this._logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`) })), this._sendQueue = void 0), this.connectionId = void 0, this._connectionState = "Disconnected", this._connectionStarted) { this._connectionStarted = !1; try { this.onclose && this.onclose(e) } catch (t) { this._logger.log(LogLevel.Error, `HttpConnection.onclose(${e}) threw error '${t}'.`) } } } else this._logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${e}) was ignored because the connection is already in the disconnected state.`) } _resolveUrl(e) { if (0 === e.lastIndexOf("https://", 0) || 0 === e.lastIndexOf("http://", 0)) return e; if (!Platform.isBrowser) throw new Error(`Cannot resolve '${e}'.`); const t = window.document.createElement("a"); return t.href = e, this._logger.log(LogLevel.Information, `Normalizing '${e}' to '${t.href}'.`), t.href } _resolveNegotiateUrl(e) { const t = e.indexOf("?"); let i = e.substring(0, -1 === t ? e.length : t); return "/" !== i[i.length - 1] && (i += "/"), i += "negotiate", i += -1 === t ? "" : e.substring(t), -1 === i.indexOf("negotiateVersion") && (i += -1 === t ? "?" : "&", i += "negotiateVersion=" + this._negotiateVersion), i } } function transportMatches(e, t) { return !e || 0 != (t & e) } class TransportSendQueue { constructor(e) { this._transport = e, this._buffer = [], this._executing = !0, this._sendBufferedData = new PromiseSource, this._transportResult = new PromiseSource, this._sendLoopPromise = this._sendLoop() } send(e) { return this._bufferData(e), this._transportResult || (this._transportResult = new PromiseSource), this._transportResult.promise } stop() { return this._executing = !1, this._sendBufferedData.resolve(), this._sendLoopPromise } _bufferData(e) { if (this._buffer.length && typeof this._buffer[0] != typeof e) throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof e}`); this._buffer.push(e), this._sendBufferedData.resolve() } async _sendLoop() { for (; ;) { if (await this._sendBufferedData.promise, !this._executing) { this._transportResult && this._transportResult.reject("Connection stopped."); break } this._sendBufferedData = new PromiseSource; const e = this._transportResult; this._transportResult = void 0; const t = "string" == typeof this._buffer[0] ? this._buffer.join("") : TransportSendQueue._concatBuffers(this._buffer); this._buffer.length = 0; try { await this._transport.send(t), e.resolve() } catch (t) { e.reject(t) } } } static _concatBuffers(e) { const t = e.map((e => e.byteLength)).reduce(((e, t) => e + t)), i = new Uint8Array(t); let r = 0; for (const t of e) i.set(new Uint8Array(t), r), r += t.byteLength; return i.buffer } } class PromiseSource { constructor() { this.promise = new Promise(((e, t) => [this._resolver, this._rejecter] = [e, t])) } resolve() { this._resolver() } reject(e) { this._rejecter(e) } } const JSON_HUB_PROTOCOL_NAME = "json"; class JsonHubProtocol { constructor() { this.name = JSON_HUB_PROTOCOL_NAME, this.version = 1, this.transferFormat = TransferFormat.Text } parseMessages(e, t) { if ("string" != typeof e) throw new Error("Invalid input for JSON hub protocol. Expected a string."); if (!e) return []; null === t && (t = NullLogger.instance); const i = TextMessageFormat.parse(e), r = []; for (const e of i) { const i = JSON.parse(e); if ("number" != typeof i.type) throw new Error("Invalid payload."); switch (i.type) { case MessageType.Invocation: this._isInvocationMessage(i); break; case MessageType.StreamItem: this._isStreamItemMessage(i); break; case MessageType.Completion: this._isCompletionMessage(i); break; case MessageType.Ping: case MessageType.Close: break; default: t.log(LogLevel.Information, "Unknown message type '" + i.type + "' ignored."); continue }r.push(i) } return r } writeMessage(e) { return TextMessageFormat.write(JSON.stringify(e)) } _isInvocationMessage(e) { this._assertNotEmptyString(e.target, "Invalid payload for Invocation message."), void 0 !== e.invocationId && this._assertNotEmptyString(e.invocationId, "Invalid payload for Invocation message.") } _isStreamItemMessage(e) { if (this._assertNotEmptyString(e.invocationId, "Invalid payload for StreamItem message."), void 0 === e.item) throw new Error("Invalid payload for StreamItem message.") } _isCompletionMessage(e) { if (e.result && e.error) throw new Error("Invalid payload for Completion message."); !e.result && e.error && this._assertNotEmptyString(e.error, "Invalid payload for Completion message."), this._assertNotEmptyString(e.invocationId, "Invalid payload for Completion message.") } _assertNotEmptyString(e, t) { if ("string" != typeof e || "" === e) throw new Error(t) } } const LogLevelNameMapping = { trace: LogLevel.Trace, debug: LogLevel.Debug, info: LogLevel.Information, information: LogLevel.Information, warn: LogLevel.Warning, warning: LogLevel.Warning, error: LogLevel.Error, critical: LogLevel.Critical, none: LogLevel.None }; function parseLogLevel(e) { const t = LogLevelNameMapping[e.toLowerCase()]; if (void 0 !== t) return t; throw new Error(`Unknown log level: ${e}`) } class HubConnectionBuilder { configureLogging(e) { if (Arg.isRequired(e, "logging"), isLogger(e)) this.logger = e; else if ("string" == typeof e) { const t = parseLogLevel(e); this.logger = new ConsoleLogger(t) } else this.logger = new ConsoleLogger(e); return this } withUrl(e, t) { return Arg.isRequired(e, "url"), Arg.isNotEmpty(e, "url"), this.url = e, this.httpConnectionOptions = "object" == typeof t ? { ...this.httpConnectionOptions, ...t } : { ...this.httpConnectionOptions, transport: t }, this } withHubProtocol(e) { return Arg.isRequired(e, "protocol"), this.protocol = e, this } withAutomaticReconnect(e) { if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set."); return e ? Array.isArray(e) ? this.reconnectPolicy = new DefaultReconnectPolicy(e) : this.reconnectPolicy = e : this.reconnectPolicy = new DefaultReconnectPolicy, this } build() { const e = this.httpConnectionOptions || {}; if (void 0 === e.logger && (e.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection."); const t = new HttpConnection(this.url, e); return HubConnection.create(t, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol, this.reconnectPolicy) } } function isLogger(e) { return void 0 !== e.log } class Logger { constructor() { this._mode = !1, this.debug = () => { }, this.info = () => { }, this.warn = () => { }, this.error = () => { }, this.setLogMode(!1) } setLogMode(e) { this._mode = e, this._mode ? (this.debug = console.log.bind(console), this.info = console.log.bind(console), this.warn = console.warn.bind(console), this.error = console.error.bind(console)) : (this.debug = () => { }, this.info = () => { }, this.warn = console.warn.bind(console), this.error = console.error.bind(console)) } } class HTMLToolTipParams { constructor() { this.id = "", this.container = "", this.divId = "", this.showCloseButton = !0, this.toolTipWidth = 0, this.toolTipHeight = 0, this.toolTipLeftOffset = 0, this.toolTipBottomOffset = 0, this.updateDelay = 200 } } class HTMLToolTip { constructor(e) { this.htmlToolTipParams = e, this.onClose = null, this.id = e.id, this._show = !1, this._close = !1, this._timeoutArray = [] } addToScreen() { const e = document.getElementById(this.htmlToolTipParams.divId); if (!e) return "不存在该divId"; this._parentElement = e.parentElement, this._parentElement.removeChild(e), e.style.position = "absolute", e.style.display = "none", e.style.width = `${this.htmlToolTipParams.toolTipWidth}px`, e.style.height = `${this.htmlToolTipParams.toolTipHeight}px`, this.tooltipElement = e, this.htmlToolTipParams.showCloseButton && this._addCloseButton(), this.htmlToolTipParams.container.appendChild(e) } updatePosition(e, t) { const i = this, r = setTimeout((() => { i._checkBoundary(e, t), i.tooltipElement.style.top = t - i.htmlToolTipParams.toolTipHeight - i.htmlToolTipParams.toolTipBottomOffset + "px", i.tooltipElement.style.left = `${e + i.htmlToolTipParams.toolTipLeftOffset}px`, i.tooltipElement.style.display = i._show ? "block" : "none", i._timeoutArray.shift() }), i.htmlToolTipParams.updateDelay); this._timeoutArray.push(r) } updateVisible(e) { e ? this.hideTooltip() : this.showTooltip() } showTooltip() { this._close = !1 } hideTooltip() { this._close = !0 } removeTooltip() { this._closeButton && this.tooltipElement.removeChild(this._closeButton); for (const e of this._timeoutArray) window.clearTimeout(e); this._timeoutArray = [], this.tooltipElement.parentElement?.removeChild(this.tooltipElement), this.tooltipElement.style.display = "none" } _addCloseButton() { const e = document.createElement("button"); e.style.background = "none", e.style.border = "0px", e.style.position = "absolute", e.style.left = "100%", e.style.bottom = "100%", e.style.cursor = "pointer", e.style.fontSize = "18px", e.style.lineHeight = "18px", e.innerText = "X"; let t = this; e.onclick = () => { t.removeTooltip(), t._close = !0, t.onClose && "function" == typeof t.onClose && t.onClose(t.htmlToolTipParams.id) }, this.tooltipElement.appendChild(e), this._closeButton = e } _checkBoundary(e, t) { if (this._close) return void (this._show = !1); const i = document.getElementById("streamingVideo"), r = i.clientWidth, n = i.clientHeight; this._show = !(e > r + 9 || e < -9 || t < -9 || t > n + 9) } } const _OVERLAY_LANDMARK = "landmark", _OVERLAY_PATH = "path", _OVERLAY_AREA = "area", _OVERLAY_CIRCULAR_AREA = "circulararea", _OVERLAY_3D_TILE = "3dtile", _OVERLAY_GISMAP = "gismap", _OVERLAY_LANDMARK_LAYER = "landmarklayer", _OVERLAY_3D_COLUMN_LAYER = "3dcolumnlayer", _OVERLAY_3D_GRID_LAYER = "3dgridlayer", _OVERLAY_HEATMAP_LAYER = "heatmaplayer", _OVERLAY_BUBBLE_LAYER = "bubblelayer", _OVERLAY_EVENTBUBBLE_LAYER = "eventbubblelayer", _OVERLAY_TRAIL_LAYER = "traillayer", _OVERLAY_POINT_TRAIL_LAYER = "pointtraillayer", _OVERLAY_ODLINE_LAYER = "odlinelayer", _OVERLAY_TYPE_AREA_LAYER = "typearealayer", _OVERLAY_COLOR_AREA_LAYER = "colorarealayer", _OVERLAY_ROAD_PT_HEAT_LAYER = "roadptheatlayer", _OVERLAY_ROAD_SG_HEAT_LAYER = "roadsgheatlayer", _OVERLAY_3D_MARKER = "3dmarker", _OVERLAY_AGGLANDMARKLAYER = "agglandmarklayer", _OVERLAY_AGGBUBBLELAYER = "aggbubblelayer", _OVERLAY_AGGEVENTBUBBLELAYER = "aggeventbubblelayer", _OVERLAY_AGGHEATMAPLAYER = "aggheatmaplayer", _OVERLAY_AGG3DCOLUMNLAYER = "agg3dcolumnlayer", _OVERLAY_AGG3DGRIDLAYER = "agg3dgridlayer", _OVERLAY_MODELTRAILLAYER = "modeltraillayer", _OVERLAY_MODELLANDMARKLAYER = "modellandmarklayer", _OVERLAY_MODELLANDMARKLAYERTEMP = "modellandmarklayertemp", _OVERLAY_TRACKLAYER = "tracklayer", _OVERLAY_3DMARKERLANDMARKLAYERLAYER = "3dmarkerlandmarklayer", _OVERLAY_EVENTLAYER = "eventlayer", _OVERLAY_STARLIGHTLAYER = "starlightlayer", overlays$1 = {}; overlays$1[_OVERLAY_LANDMARK] = "landmark", overlays$1[_OVERLAY_PATH] = "path", overlays$1[_OVERLAY_AREA] = "area", overlays$1[_OVERLAY_CIRCULAR_AREA] = "circulararea", overlays$1[_OVERLAY_3D_TILE] = "3dtile", overlays$1[_OVERLAY_GISMAP] = "gismap", overlays$1[_OVERLAY_LANDMARK_LAYER] = "landmarklayer", overlays$1[_OVERLAY_3D_COLUMN_LAYER] = "3dcolumnlayer", overlays$1[_OVERLAY_3D_GRID_LAYER] = "3dgridlayer", overlays$1[_OVERLAY_HEATMAP_LAYER] = "heatmaplayer", overlays$1[_OVERLAY_BUBBLE_LAYER] = "bubblelayer", overlays$1[_OVERLAY_EVENTBUBBLE_LAYER] = "eventbubblelayer", overlays$1[_OVERLAY_TRAIL_LAYER] = "traillayer", overlays$1[_OVERLAY_POINT_TRAIL_LAYER] = "pointtraillayer", overlays$1[_OVERLAY_ODLINE_LAYER] = "odlinelayer", overlays$1[_OVERLAY_TYPE_AREA_LAYER] = "typearealayer", overlays$1[_OVERLAY_COLOR_AREA_LAYER] = "colorarealayer", overlays$1[_OVERLAY_ROAD_PT_HEAT_LAYER] = "roadptheatlayer", overlays$1[_OVERLAY_ROAD_SG_HEAT_LAYER] = "roadsgheatlayer", overlays$1[_OVERLAY_3D_MARKER] = "3dmarker", overlays$1[_OVERLAY_AGGLANDMARKLAYER] = "agglandmarklayer", overlays$1[_OVERLAY_AGGBUBBLELAYER] = "aggbubblelayer", overlays$1[_OVERLAY_AGGEVENTBUBBLELAYER] = "aggeventbubblelayer", overlays$1[_OVERLAY_AGGHEATMAPLAYER] = "aggheatmaplayer", overlays$1[_OVERLAY_AGG3DCOLUMNLAYER] = "agg3dcolumnlayer", overlays$1[_OVERLAY_AGG3DGRIDLAYER] = "agg3dgridlayer", overlays$1[_OVERLAY_MODELTRAILLAYER] = "modeltraillayer", overlays$1[_OVERLAY_MODELLANDMARKLAYER] = "modellandmarklayer", overlays$1[_OVERLAY_MODELLANDMARKLAYERTEMP] = "modellandmarklayertemp", overlays$1[_OVERLAY_TRACKLAYER] = "tracklayer", overlays$1[_OVERLAY_3DMARKERLANDMARKLAYERLAYER] = "3dmarkerlandmarklayer", overlays$1[_OVERLAY_EVENTLAYER] = "eventlayer", overlays$1[_OVERLAY_STARLIGHTLAYER] = "starlightlayer"; const weathers = { Sunny: "晴天", Cloudy: "晴间少云", PartlyCloudy: "晴间多云", Overcast: "阴天", LightRain: "小雨", ModerateRain: "中雨", HeavyRain: "大雨", LightSnow: "小雪", ModerateSnow: "中雪", HeavySnow: "大雪", Foggy: "雾天", Dust: "扬尘", Haze: "雾霾" }, circleTypes = { rect: "屏幕矩形", circle: "地表圆形", polygon: "地表多边形" }, clickTypes = { click: "点击选中", hover: "悬停选中" }, states = { pause: "暂停", continue: "继续", stop: "停止，回到初始状态" }, loopModes = { none: "不循环", round: "往返", repeat: "从头循环" }, pathDirections = { path: "沿路径调整模型方向", self: "模型自己原本方向不变" }, _3DMarkerType = { radar01: "radar01", revolve01: "revolve01", revolve02: "revolve02", revolve03: "revolve03", revolve04: "revolve04", revolve05: "revolve05", revolve06: "revolve06", revolve07: "revolve07", spread01: "spread01", spread02: "spread02", spread03: "spread03", spread04: "spread04", spread05: "spread05", spread06: "spread06", spread07: "spread07", spread08: "spread08", spread09: "spread09", spread10: "spread10", spread11: "spread11", spread12: "spread12", spread13: "spread13", spread14: "spread14", spread15: "spread15", spread16: "spread16", spread17: "spread17", square01: "square01", explosion: "explosion", flame: "flame" }, pathTypes = { Arrow01: "Arrow01", Arrow02: "Arrow02", Arrow03: "Arrow03", Arrow04: "Arrow04", Arrow05: "Arrow05", Arrow06: "Arrow06", Segment01: "Segment01", Segment02: "Segment02", Segment03: "Segment03", Segment04: "Segment04", Segment05: "Segment05", Segment06: "Segment06" }, areaTypes = { Arrow01: "Arrow01", Gradient01: "Gradient01", Gradient02: "Gradient02", Gradient03: "Gradient03", Grid01: "Grid01", Grid02: "Grid02", Grid03: "Grid03", Grid04: "Grid04", Grid05: "Grid05", Segment01: "Segment01", Segment02: "Segment02", Segment03: "Segment03" }, areaFillAreaTypes = { none: "none", Gradient01: "Gradient01", Gradient02: "Gradient02", Grid01: "Grid01", Grid02: "Grid02", Segment01: "Segment01", Segment02: "Segment02" }; class TGStreaming3Renderer { constructor() { this.callbackMap = new Map, this.tooltipMap = new Map, this.tooltipDivMap = new Map, this.deleteTipMap = new Map, this.deleteTempTipMap = new Map, this.tooltipCallback = new Map, this.tempTipMap = new Map, this.channelId = "default", this.firstSwitch = !0, this.initIsPreheat = !1, this.pingInterval = void 0, this.setResolutionCheckDelayMs = 2500, this.serviceMap = new Map; for (let e in eventMap) this[e] = eventMap[e].function } init({ url: e, token: t, container: i, isShareToken: r, resolution: n, events: a, showDefaultLoading: o, name: s, editMode: l, useTCP: c }, h) { if (this.streamingPlayer = new StreamingPlayer({ controlScheme: 1, printInputs: !1, printLog: !1, stateQueryInterval: 1, useTCP: c }), this.callback = h, this.resolution = n, this.isShareToken = r, this.serverUrl = e, "/" == this.serverUrl[this.serverUrl.length - 1] && (this.serverUrl = this.serverUrl.substr(0, this.serverUrl.length - 1)), this.token = t, this.conversationId = Util.guid(), i.style.position = "relative", i.style.overflow = "none", this.container = i, this.aggServerUrl = this.serverUrl + "/DataServer", this.logger = new Logger, this.name = s, this.editMode = l, this.streamingEngineVer = "无渲染引擎版本信息", this.hasPreheatReset = void 0, this.clientStatus = {}, window.logger = this.logger, logger.debug(this.aggServerUrl), this.createElementBox(), this.useTCP = c, this.initServerSocket(), o && (this.progressBar = new ProgressBar({ container: this.elementParent, text: "Loading..." })), this.events = a, this.streamingPlayer.addStatusChangedListener((e => { this.streamingPlayerState = e })), "function" == typeof this.callback && this.callback({ result: 1, message: "成功。" }), !this.switchServiceFlag && s) { const i = { name: s, url: e, token: t, default: !0 }; this.serviceMap.set(s, i) } } getServerPath(e, t) { var i = this.isShareToken; return Util.fetchJSON(e + `/RenderUnit/GetChannelPreviewInfo?connectionId=${this.connectionId}&isSharePreview=${i}&token=${t}`, "get", [{ key: "Accept-Language", value: "zh-CN,zh;q=0.9" }]) } createStreaming3(t) { var i = this; this.apiData = t, this.timeOut = null, this.apiData.data.isUseWebSocket ? i.streamingPlayer._useWebSockets = this.apiData.data.isUseWebSocket : i.streamingPlayer._useWebSockets = !1, this.streamingWidthMax = this.apiData.data.resolutionX, this.streamingHeightMax = this.apiData.data.resolutionY; var r = this.container; if (null != i.resolution && 2 == i.resolution.length || (window.onresize = function () { i.resize() }), this.autoResize(), r) { if (r.style.position = "relative", !r) return logger.warn(`模型加载出错。无效的容器名称（${r}）。`), void (onFinish && onFinish(0)); window.streamingDOM && (window.streamingDOM.remove(), window.streamingDOM = null), this.streamingPlayer.createVideoElement(t.data.rtcPeerConnection), window.streamingDOM = this.streamingPlayer.playerElement; let n = document.createElement("div"); return n.setAttribute("id", "innerContainer"), n.appendChild(window.streamingDOM), this.container.appendChild(n), this.eventListenerFromUE(), this.url = this.signallingWsUrl, this.streamingDOMaddListener(), this.streamingPlayer.startPlay(this.url), this.streamingPlayer.DebugModePress = function () { i.isDebugMode ? (i.isDebugMode = !1, logger.debug("关闭debug模式"), i.hiddenDebugWindow(), i.streamingPlayer.canInputConsoleCommand = !1, e.preventDefault()) : (i.isDebugMode = !0, logger.debug("开启debug模式"), i.showDebugWindow(), i.streamingPlayer.canInputConsoleCommand = !0, e.preventDefault()) }, void (this.streamingPlayer.webRtcPlayerObj.onDataChannelConnected = function () { i.apiData.data.needReset && !0 === i.apiData.data.needReset && i.preheatReset(i.apiData, !1), i.serverSocket.invoke("GetChannelId").then((e => { i.channelId = e, i.logger.info(`channelId:${e}`), i.getClientStatusInner() })).catch((e => { i.logger.error("获取通道Id失败", e), i.clientStatus = { error: "获取通道Id失败" } })) }) } } streamingDOMaddListener() { var e = this; window.streamingDOM.oncanplay = function () { logger.debug("准备就绪"); let t = { command: "PixelStreaming.Encoder.MaxQP " + e.apiData.data.videoQualityParameters }; e.setCommand(t, ""), e.initScene({ editMode: e.editMode }), e.createStatusBox(), e.createSceneInfoBox(); e.executeCommand("getAppInfo", {}, e._getAppInfoUECallback), e.executeCommand("videoConnected", {}, (t => e.logger.info("通知UE场景串流成功完成", t))) }, window.streamingDOM.addEventListener("playing", (e => { if (window.streamingDOM.focus(), this.switchServiceFlag) { const e = this.serviceMap.get(this.name); let t = { result: 0, message: "成功", name: e.name, default: e.default }; for (let e of this.events.onServiceSwitch) e(t); this.switchServiceFlag = !1 } })), window.streamingDOM.addEventListener("error", (e => { window.streamingDOM.pause() })), window.streamingDOM.emitDescriptor = e => { this.streamingPlayer.emitUIInteraction(e) }, window.streamingDOM.muted = !0, window.streamingDOM.autoplay = !0 } autoResize() { if (!this.container) return; let e = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver, t = { width: "0", height: "0" }, i = this; new e((e => { let r = getComputedStyle(i.container).getPropertyValue("width"), n = getComputedStyle(i.container).getPropertyValue("height"); r === t.width && n === t.height || (t = { width: r, height: n }, i.resize()) })).observe(i.container, { attributes: !0, attributeFilter: ["style"], attributeOldValue: !0 }) } resize() { this.progressBar || (this.timeOut && clearTimeout(this.timeOut), this.timeOut = setTimeout((() => { this.setResolutionSDK(this.apiData) }), 30)) } setSize(e) { null == this.resolution || 2 != this.resolution.length || this.isShareToken || (e.width && e.height && (this.apiData.data.resolutionX = e.width, this.apiData.data.resolutionY = e.height), e.codeRate && (this.apiData.data.codeRate = e.codeRate), e.frameRate && (this.apiData.data.frameRate = e.frameRate)), this.setResolutionSDK(this.apiData, !0) } setResolutionSDK(e, t, i = !1) { var r = e.data; this.container; var n = r.stretch, a = this.isShareToken; null == r.multipleRendering && (r.multipleRendering = 1); var o = r.multipleRendering, s = r.resolutionX, l = r.resolutionY; i ? (s = r.resolutionX, l = r.resolutionY, this.maxWidth = s, this.maxHeight = l) : (s = this.maxWidth, l = this.maxHeight); var c = r.codeRate; this.rateMax = c; var h = r.frameRate; this.fpsMax = h, this.surpassMaxResolution(s, l), a && 0 == n && (n = 1), this.setResolutionByType(s, l, c, h, n, o, t) } setResolutionByType(e, t, i, r, n, a, o) { var s = this.container; streamingDOM.style.width = "100%"; var l = s.clientWidth / e, c = s.clientHeight / t, h = s.clientWidth / s.clientHeight, u = Math.max(l, c), d = Math.min(l, c); let p = e, f = t; 0 === n && (l <= 1 && c <= 1 ? (p = s.clientWidth, f = s.clientHeight) : c > l ? (p = t * h, f = t) : (p = e, f = e / h)); var m = 3840 / p, g = 2160 / f, y = Math.min(m, g); if (y <= 1 && (y = 1), a > y && (a = y), 0 == n) { var v = s.clientWidth, _ = s.clientHeight; u > 1 && (c > l ? (v = t * h, _ = t) : (v = e, _ = e / h)), streamingDOM.style.position = "absolute", streamingDOM.style.width = "100%", streamingDOM.style.height = "100%", streamingDOM.style.left = "0px", streamingDOM.style.top = "0px", streamingDOM.style.transform = "", streamingDOM.style.outline = 0, this.container.style.overflow = "hidden", streamingDOM.parentElement.style.position = "absolute", streamingDOM.parentElement.style.width = "100%", streamingDOM.parentElement.style.height = "100%", streamingDOM.parentElement.style.left = "0px", streamingDOM.parentElement.style.top = "0px", streamingDOM.parentElement.style.transform = "", streamingDOM.parentElement.style.outline = 0, streamingDOM.parentElement.style.overflow = "hidden", this.setResolutionInnerMethod({ width: v * a, height: _ * a, rateMax: i, fpsMax: r }, o) } else if (1 == n) { var b = e * d, x = t * d; if (streamingDOM.style.position = "absolute", streamingDOM.style.width = b + "px", streamingDOM.style.height = x + "px", streamingDOM.style.left = "50%", streamingDOM.style.top = "50%", streamingDOM.style.transform = "translateX(-50%) translateY(-50%)", streamingDOM.style.outline = 0, this.container.style.overflow = "hidden", streamingDOM.parentElement.style.position = "absolute", streamingDOM.parentElement.style.width = "100%", streamingDOM.parentElement.style.height = "100%", streamingDOM.parentElement.style.left = "50%", streamingDOM.parentElement.style.top = "50%", streamingDOM.parentElement.style.transform = "translateX(-50%) translateY(-50%)", streamingDOM.parentElement.style.outline = 0, streamingDOM.parentElement.style.overflow = "hidden", this.lastResolutionSet && this.lastResolutionSet.width === e && this.lastResolutionSet.height === t && this.lastResolutionSet.multipleRendering === a && this.lastResolutionSet.rateMax === i && this.lastResolutionSet.fpsMax === r) return void (o && o({ result: 1, message: "成功" })); this.setResolutionInnerMethod({ width: e * a, height: t * a, rateMax: i, fpsMax: r }, o), this.lastResolutionSet = { width: e, height: t, multipleRendering: a, rateMax: i, fpsMax: r } } else { if (streamingDOM.style.position = "absolute", streamingDOM.style.width = e + "px", streamingDOM.style.height = t + "px", streamingDOM.style.left = "0px", streamingDOM.style.top = "0px", streamingDOM.style.transform = "", streamingDOM.style.outline = 0, this.container.style.overflow = "auto", streamingDOM.parentElement.style.position = "absolute", streamingDOM.parentElement.style.width = "100%", streamingDOM.parentElement.style.height = "100%", streamingDOM.parentElement.style.left = "0px", streamingDOM.parentElement.style.top = "0px", streamingDOM.parentElement.style.transform = "", streamingDOM.parentElement.style.outline = 0, streamingDOM.parentElement.style.overflow = "auto", this.lastResolutionSet && this.lastResolutionSet.width === e && this.lastResolutionSet.height === t && this.lastResolutionSet.multipleRendering === a && this.lastResolutionSet.rateMax === i && this.lastResolutionSet.fpsMax === r) return void (o && o({ result: 1, message: "成功" })); this.setResolutionInnerMethod({ width: e * a, height: t * a, rateMax: i, fpsMax: r }, o), this.lastResolutionSet = { width: e, height: t, multipleRendering: a, rateMax: i, fpsMax: r } } } surpassMaxResolution(e, t) { var i = this.container, r = i.clientWidth, n = i.clientHeight; return r <= e && n <= t ? "allIn" : r >= e && n >= t ? "all" : r >= e ? "w" : "h" } time_dis(e, t) { var i = Date.parse(new Date(t)), r = Date.parse(new Date(e)); if (r < i) return !1; var n = r - i, a = n % 864e5, o = a % 36e5; return Math.floor(n / 864e5) + "天" + Math.floor(a / 36e5) + "小时" + Math.floor(o / 6e4) + "分" + o % 6e4 / 1e3 + "秒" } eventListenerFromUE() { var e = this; this.streamingPlayer.registerResponseEvent("message", (async t => { if (t && t.detail || console.error("返回值结构为空！"), t.detail) try { JSON.parse(t.detail) } catch (e) { return void console.error("返回值结构不合格！", t.detail) } let i = JSON.parse(t.detail); if (i.eventName && "onHTMLTipObjectPositionChanged" === i.eventName) this._updateHTMLToolTipsPosition(i.args.screenPositions, e.tooltipMap, e.tooltipDivMap); else if ("onSceneChanged" === i.eventName && e.events.onSceneSwitch.length > 0 && (i.eventName = "onSceneSwitch"), i.eventName && null != eventMap[i.eventName]) { let t = { result: i.result, message: i.message }; if (eventMap[i.eventName].backtrack.forEach((e => { t[e] = i.args[e] })), null != eventMap[i.eventName].callback && eventMap[i.eventName].callback(t), e.events[i.eventName]) for (let r of e.events[i.eventName]) r(t); if ("onSceneInit" === i.eventName) { if (e.switchServiceFlag) { for (let i of e.events.onServiceSwitch) i(t); e.switchServiceFlag = !1 } else for (let i of e.events.onServiceInit) i(t); try { this.firstInit || ("default" != e.channelId && e.serverSocket.invoke("ReportConnectState", e.channelId), this.firstInit = !0) } catch (e) { } e.setResolutionSDK(e.apiData, (function () { e.progressBar && (e.progressBar.destroy(), e.progressBar = null) }), !0) } } else { var r = this.callbackMap.get(i.method); if (this.tooltipCallback.has(i.callbackId)) { if (0 == i.params.result) { const e = this.tooltipCallback.get(i.callbackId); e.removeTooltip(), this.tooltipMap.delete(e.id), this.tooltipDivMap.delete(e.id) } this.tooltipCallback.delete(i.callbackId) } if ("getScenesInfo" === i.method) { i.params.customIcons = i.params.customIcons.map((e => ({ name: e, url: "" }))); try { let t = await Util.fetchJSON(`${e.serverUrl}/Streaming/GetProjectCustomIcons/${e.token}`, "get"); if (t = JSON.parse(t), 0 === t.status) for (const e of t.data) { const t = i.params.customIcons.find((t => t.name === e.name)); t && (t.url = e.url) } else e.logger.error("读取图标地址失败！", t.message) } catch (t) { e.logger.error("读取图标地址失败！", t) } } if ("removeOverlayTip" === i.method || "removeModelTip" === i.method) for (const [t, r] of e.deleteTipMap.entries()) if (r === i.callbackId) { if (0 === i.params.result) break; if (e.deleteTempTipMap.has(i.callbackId)) { e.deleteTempTipMap.delete(i.callbackId); break } return void e.deleteTempTipMap.set(i.callbackId, "") } if (r && "function" == typeof r.get(i.callbackId)) { let e = this; r.get(i.callbackId)(i.params, e) } } })) } createElementBox() { var e = document.createElement("div"); e.className = "elementOver", e.style.position = "absolute", e.style.height = "100%", e.style.width = "100%", e.style.top = 0, e.style.left = 0, e.style.pointerEvents = "none", e.style.zIndex = 50; var t = document.createElement("div"); t.className = "elementParent", t.style.position = "absolute", t.style.height = "100%", t.style.width = "100%", t.style.top = 0, t.style.left = 0, t.style.pointerEvents = "none", t.style.zIndex = 100; var i = document.createElement("div"); i.className = "messageBox", i.style.maxHeight = "300px", i.style.maxWidth = "600px", i.style.position = "absolute", i.style.left = "50%", i.style.top = "50%", i.style.fontSize = "25px", i.style.transform = "translate(-50%, -50%)", i.style.color = "white", this.elementParent = t, this.elementOver = e, this.messageBox = i, this.container.appendChild(t), this.container.appendChild(e), this.elementParent.appendChild(i) } createStatusBox() { let e = document.createElement("div"); e.setAttribute("id", "debugDiv"), e.style.position = "absolute", e.style.top = 0, e.style.left = "100%", e.style.color = "lawngreen", e.style.background = "black", e.style.padding = "15px", e.style.width = "fit-content", e.style.pointerEvents = "none", e.style.fontSize = "10px", e.style.transform = "translate(-100%, 0%)", e.style.textAlign = "left", e.style.display = "none", this.container.appendChild(e) } createSceneInfoBox() { let e = document.createElement("div"); e.setAttribute("id", "debugDiv"), e.style.position = "absolute", e.style.minWidth = "543px", e.style.maxWidth = "80%", e.style.padding = "0px 10px", e.style.left = "50%", e.style.transform = "translateX(-50%)", e.style.bottom = "20px", e.style.borderRadius = "8px", e.style.backgroundColor = "rgba(0,0,0,0.5)", e.style.lineHeight = "32px", e.style.fontSize = "14px", e.style.color = "rgb(204,204,204)", this.container.appendChild(e) } removeStatusBox() { this.hiddenDebugWindow(); let e = document.getElementById("debugDiv"); e && (this.container.removeChild(e), e = void 0, this.isDebugMode = !1) } showDebugWindow() { let e = document.getElementById("debugDiv"); e.style.display = "block", e && this.streamingPlayer.addStatusChangedListener((t => { let i = "", r = ""; switch (t.videoQuality) { case VideoQualityType.High: r = "High"; break; case VideoQualityType.Medium: r = "Medium"; break; case VideoQualityType.Low: r = "Low"; break; default: r = "N/A" }i += `<div>连接质量：${r}</div>`, i += `<div>视频质量参数：${t.videoQuantizationParameter}</div>`, i += `<div>视频运行时长：${t.duration}</div>`, i += `<div>视频分辨率：${t.VideoResolution}</div>`, i += `<div>视频帧率：${t.framerate}</div>`, i += `<div>视频比特率(kbps)：${t.bitrate}</div>`, i += `<div>视频丢包：${t.packetsLost}</div>`, i += `<div>视频丢帧：${t.framesDropped}</div>`, i += `<div>视频延迟(ms)：${t.latency}</div>`, e.innerHTML = i })) } hiddenDebugWindow() { let e = document.getElementById("debugDiv"); e && (e.style.display = "none", this.streamingPlayer.removeStatusChangedListener()) } setMessage(e, t) { let i = this; null != t && logger.debug(`错误码：code-${t}`), this.progressBar && (this.progressBar.destroy(), this.progressBar = null); let r = { type: "message", code: t, message: e }; if (null == eventMap.subscribeServerMessage.callback) if (i.events.subscribeServerMessage.length > 0) for (let e of i.events.subscribeServerMessage) e(r); else this.messageBox.innerHTML = "", this.messageBox.innerText = e, this.elementOver.style.backgroundColor = "black", this.elementOver.style.opacity = "80%"; else if (eventMap.subscribeServerMessage.callback(r), i.events.subscribeServerMessage) for (let e of i.events.subscribeServerMessage) e(r) } initServerSocket() { var e = this.serverUrl.indexOf("https") > -1 ? "wss:" : "ws:", t = this; this.serverSocket = (new HubConnectionBuilder).withUrl(this.serverUrl + "/SdkHub").configureLogging(LogLevel.Error).withAutomaticReconnect([0, 2e3, 5e3, 1e4]).build(), this.serverSocket.keepAliveIntervalInMilliseconds = 5e3, this.serverSocket.serverTimeoutInMilliseconds = 864e7, this.serverSocket.onreconnecting((e => { t.progressBar = new ProgressBar({ container: this.elementParent, text: "Loading..." }) })), this.serverSocket.onreconnected((e => { t.progressBar.destroy(), t.progressBar = null, t.serverSocket.invoke("ReConnection", { OldConnectionId: t.connectionId }).catch((e => t.logger.error("上报重连信息出错", e))), t.connectionId = t.serverSocket.connectionId, t.logger.info("流渲染服务重连成功。") })), this.serverSocket.onclose((e => { t.reinit && !0 === t.reinit ? t.reinit = !1 : (t.progressBar && (t.progressBar.destroy(), t.progressBar = null), t.setMessage("Failed to connect to service")) })), this.subscribeSignalRMessage(), this.serverSocket.start().then((i => { if (logger.debug("服务器socket连接成功！", i), t.events.onServiceConnected) for (let e of t.events.onServiceConnected) e(); t.connectionId = t.serverSocket.connectionId, t.getServerPath(t.serverUrl, t.token).then((i => { if ("" != i) { i = JSON.parse(i); var r = t.serverUrl; if (r) var n = r.split(":"); if (100 == i.status) { if (r.indexOf("[") >= 0 && r.indexOf("]") >= 0) { var a = r.substring(n[0].length + 1); t.signallingWsUrl = e + a + i.data.signallingUrl } else n.length >= 3 ? t.signallingWsUrl = e + n[1] + ":" + n[2] + i.data.signallingUrl : t.signallingWsUrl = e + n[1] + i.data.signallingUrl; t.switchServiceFlag || (t.initIsPreheat = !0), t.createStreaming3(i) } else 101 == i.status ? t.serverSocket.on("EnterStreamingPreview", (a => { if (r.indexOf("[") >= 0 && r.indexOf("]") >= 0) { var o = r.substring(n[0].length + 1); t.signallingWsUrl = e + o + a.previewUrl } else n.length >= 3 ? t.signallingWsUrl = e + n[1] + ":" + n[2] + a.previewUrl : t.signallingWsUrl = e + n[1] + a.previewUrl; t.createStreaming3(i) })) : t.setMessage(i.message, i.status) } else t.setMessage("场景 token 异常！请检查场景 token！") })).catch((e => { logger.error(e), "Forbidden" === e.message ? t.setMessage("该资源禁止访问！", 403) : t.setMessage("请求出现异常！") })) })).catch((function (e) { logger.debug(e) })), window.onbeforeunload = () => { t.pingInterval && (clearInterval(t.pingInterval), t.pingInterval = void 0), t.preheatReset(t.apiData, !0); let e = { token: this.token, isMaster: !1, state: 2, type: "" }; this.serverSocket.invoke("ReportChannelState", e), t.stopService() } } setCloseMessage(e) { var t = document.createElement("div"); t.className = "elementParent", t.style.position = "absolute", t.style.height = "100%", t.style.width = "100%", t.style.top = 0, t.style.left = 0, t.style.pointerEvents = "none", t.style.zIndex = 100; var i = document.createElement("div"); i.className = "messageBoxClose", i.style.maxHeight = "300px", i.style.maxWidth = "600px", i.style.position = "absolute", i.style.left = "50%", i.style.top = "50%", i.style.fontSize = "25px", i.style.transform = "translate(-50%, -50%)", i.style.color = "white", this.elementParent = t, this.messageBoxClose = i, this.container.appendChild(t), this.elementParent.appendChild(i), this.messageBoxClose.innerHTML = "", this.messageBoxClose.innerText = e } subscribeSignalRMessage() { let e = this; this.serverSocket.on("StopChannelVisiting", (t => { e.destroy(), e.setCloseMessage(t.message) })), this.serverSocket.on("ShowMessage", (t => { e.setMessage(t.message, t.code) })), this.serverSocket.on("PreheatFailed", (t => { e.setMessage(t.message, t.code) })), this.serverSocket.on("ApplicationExit", (t => { e.setMessage(t.message, t.code), setTimeout((() => { e.setMessage(""), e.destroy(), e.reinit = !0, e.init({ url: e.serverUrl, token: e.token, container: e.container, isShareToken: e.isShareToken, showDefaultLoading: !0, name: e.name, events: e.events, editMode: e.editMode, useTCP: e.useTCP }) }), 3e3) })), this.serverSocket.on("Restart", (t => { e.setMessage(""), e.destroy(), e.reinit = !0, e.init({ url: e.serverUrl, token: e.token, container: e.container, isShareToken: e.isShareToken, showDefaultLoading: !0, events: e.events, editMode: e.editMode, useTCP: e.useTCP }) })), this.serverSocket.on("UpdateMasterToken", (t => { e.setMessage("Token Updated"), e.destroy() })), this.serverSocket.on("PreheatStateChangeMessage", (t => { e.apiData.data.isPreheat = t.isPreheat, this.logger.info("接收到PreheatStateChangeMessage", e.apiData) })), this.serverSocket.on("PreheatResetChangeMessage", (t => { e.apiData.data.preHeatReset = t.preheatReset, this.logger.info("接收到PreheatResetChangeMessage", e.apiData) })), this.serverSocket.on("RefreshScencesProperty", (t => { if (t.token === e.token && (null == t.multipleRendering && (t.multipleRendering = 1), null == t.stretch || null == t.resolutionX || null == t.resolutionY || null == t.codeRate || null == t.frameRate || null == t.multipleRendering || e.apiData.data.resolutionX == t.resolutionX && e.apiData.data.resolutionY == t.resolutionY && e.apiData.data.stretch == t.stretch && e.apiData.data.codeRate == t.codeRate && e.apiData.data.frameRate == t.frameRate && e.apiData.data.multipleRendering == t.multipleRendering || (e.apiData.data.resolutionX = t.resolutionX, e.apiData.data.resolutionY = t.resolutionY, e.apiData.data.stretch = t.stretch, e.apiData.data.codeRate = t.codeRate, e.apiData.data.frameRate = t.frameRate, e.apiData.data.multipleRendering = t.multipleRendering, e.streamingWidthMax = e.apiData.data.resolutionX, e.streamingHeightMax = e.apiData.data.resolutionY, e.setResolutionSDK(e.apiData, null, !0)), t.videoQualityParameters && e.apiData.data.videoQualityParameters != t.videoQualityParameters)) { e.apiData.data.videoQualityParameters = t.videoQualityParameters; let i = { command: "PixelStreaming.Encoder.MaxQP " + t.videoQualityParameters }; e.setCommand(i, "") } })), this.serverSocket.on("Pong", (t => { e.logger.info("ws <- Pong"), e.pingInterval || (e.pingInterval = setInterval((() => { e.serverSocket.invoke("Ping", e.connectionId), e.logger.info("ws -> Ping") }), 1e4)) })) } sendServerSocketMess(e, t, i, r) { t ? this.serverSocket.invoke(e, t).then((function (e) { void 0 !== i && i(1, e) })).catch((function (e) { void 0 !== i && i(0, e) })) : this.serverSocket.invoke(e).then((function (e) { void 0 !== i && i(1, e) })).catch((function (e) { void 0 !== i && i(0, e) })) } takeEvent(e, t) { "message" == e && (this.takeMessageEvent = t) } async preheatReset(e, t) { if ((!this.hasPreheatReset || 1 != t) && (!0 === t && (this.hasPreheatReset = !0), this.logger.info("进入预热重置逻辑！"), e.data.isPreheat && !0 === e.data.isPreheat && null != this.isShareToken && !1 === this.isShareToken)) { let e = {}; if (this.streamingPlayer._useWebSockets || this.executeCommand("restoreSceneInitalState", e, (e => { this.logger.info("restoreSceneInitalState backup ", e) })), this.logger.info("预热重置逻辑完成"), t && this.serverSocket && "Connected" === this.serverSocket.state) try { await this.serverSocket.invoke("PreheatResetFinish", this.connectionId) } catch (e) { this.logger.warn("PreheatResetFinish 未完成", e) } } } getClientStatusInner() { if (this.channelId) { let e = this; try { Util.fetchJSON(this.serverUrl + `/Streaming/GetClientStatus/${this.channelId}`, "get").then((t => { var i = JSON.parse(t); if (e.logger.info("getClientStatusInner", i.data), 0 == i.status && i.data) if (i.data.clientStatus) try { e.clientStatus = JSON.parse(i.data.clientStatus) } catch (t) { e.clientStatus = { error: "getClientStatus 方法出错 clientStatus 不是Json结构类型" } } else e.clientStatus = {}; else e.clientStatus = { error: "getClientStatus 方法出错" + message } })) } catch (t) { e.clientStatus = { error: "getClientStatus 方法出错" }, e.logger.error("getClientStatus 方法出错！", t) } } } async saveClientStatusInner(e) { if (this.channelId) { let i = { channelId: this.channelId, clientStatus: JSON.stringify(e) }; var t = await Util.fetchJSON(`${this.serverUrl}/Streaming/SaveClientStatus`, "post", [{ key: "Content-Type", value: "application/json" }], i); return JSON.parse(t) } return null } destroy() { this.preheatReset(this.apiData, !0), this.pingInterval && (clearInterval(this.pingInterval), this.pingInterval = void 0), window.streamingDOM && (this.streamingPlayer.removeStatusChangedListener(), this.streamingPlayer.destroy(), window.streamingDOM.remove(), this.messageBox.remove(), this.elementOver.remove()), this.container.innerHTML = "", this.removeStatusBox(), this.serverSocket && (this.serverSocket.stop(), this.serverSocket = null), this._updateHTMLToolTipsPosition([], this.tooltipMap, this.tooltipDivMap), logger.debug("TGUE4StreamingRenderer.destroy()") } stopService() { for (const e of this.serviceMap.values()) if (e.default) { if (!this.firstSwitch && !this.initIsPreheat) try { Util.fetchJSON(`${e.url}/Streaming/StopService/${e.token}`, "get") } catch (e) { this.logger.error(e) } } else try { Util.fetchJSON(`${e.url}/Streaming/StopService/${e.token}`, "get") } catch (e) { this.logger.error(e) } } focusWorldMap(e, t) { this.executeCommand("focusWorldMap", e, t) } focusCountry(e, t) { this.executeCommand("focusCountry", e, t) } focusChinaMap(e, t) { this.executeCommand("focusChinaMap", e, t) } focusProvince(e, t) { this.executeCommand("focusProvince", e, t) } addLandmark(e, t) { null == e.visible || null != e.visible && "boolean" != typeof e.visible ? t && t({ result: 0, message: "visible 属性值错误，应为布尔值" }) : this.executeCommand("addLandmark", e, t) } updateLandmarkCoord(e, t) { this.executeCommand("updateLandmarkCoord", e, t) } updateLandmarkStyle(e, t) { this.executeCommand("updateLandmarkStyle", e, t) } selectLandmark(e, t) { this.executeCommand("selectLandmark", e, t) } deselectLandmark(e, t) { this.executeCommand("deselectLandmark", e, t) } clearLandmarkSelection(e, t) { this.executeCommand("clearLandmarkSelection", e, t) } setCamera(e, t) { e.duration <= 0 ? t && t({ result: 0, message: "失败，飞行时间无效。" }) : "number" != typeof e.pitch || e.pitch < 5 || e.pitch > 89 ? t && t({ result: 0, message: "pitch 属性值错误。 范围(5~89)" }) : "number" != typeof e.heading || e.heading < 0 || e.heading > 359 ? t && t({ result: 0, message: "heading 属性值错误。 范围(0~359)" }) : this.executeCommand("setCamera", e, t) } getCameraInfo(e, t) { this.executeCommand("getCameraInfo", e, t) } setCameraOrbit(e, t) { this.executeCommand("setCameraOrbit", e, t) } setOverlayVisibility(e, t) { this.checkOverlayTypeExist(e.overlayType) ? this.executeCommand("setOverlayVisibility", e, t) : this.returnOverlayTypeError(t) } removeOverlay(e, t) { if (!this.checkOverlayTypeExist(e.overlayType)) return void this.returnOverlayTypeError(t); this.executeCommand("removeOverlay", e, t); let i = this; Util.fetchJSON(`${this.aggServerUrl}/RemoveLayersRecord`, "post", [{ key: "Content-Type", value: "application/json" }], e).catch((e => { i.logger.error("删除图层记录失败", e) })) } clearOverlay(e, t) { this.executeCommand("clearOverlay", e, t) } clearOverlayType(e, t) { let i = e.overlayType.toLowerCase(); if ("all" != i && !overlays$1[i]) return void (t && t({ result: 0, message: "失败，覆盖物类型错误。" })); this.executeCommand("clearOverlayType", e, t); let r = this; Util.fetchJSON(`${this.aggServerUrl}/RemoveLayersRecord`, "post", [{ key: "Content-Type", value: "application/json" }], e).catch((e => { r.logger.error("删除图层记录失败", e) })) } async addPath(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); if (null == e.width || null != e.width && "number" != typeof e.width || null != e.width && e.width <= 0) return void (t && t({ result: 0, message: "width 属性值错误" })); if (!pathTypes[e.type]) return void (t && t({ result: 0, message: "失败，路线样式类别不存在。" })); let i = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.dataServer = i.data, e.channelId = this.channelId; let r = this; if (e.lineDataId) try { let i = await Util.fetchJSON(`${r.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: r.channelId, id: e.lineDataId, layerId: e.id, layerType: "pathLayer" }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.lineDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addPath", e, t) } updatePathCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updatePathCoord", e, t) } updatePathStyle(e, t) { pathTypes[e.type] ? "number" != typeof e.width || e.width < 0 ? t && t({ result: 0, message: "width 属性值错误。" }) : this.executeCommand("updatePathStyle", e, t) : t && t({ result: 0, message: "失败，路线样式类别不存在。" }) } addLandmarkLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) t && t({ result: 0, message: "visible 属性值错误，应为布尔值" }); else if (e.name && this.checkSpecial(e.name)) t && t({ result: 0, message: "name 属性值包含特殊字符" }); else { try { e.legends && e.legends.forEach((e => { if (e.iconName && this.checkSpecial(e.iconName)) throw new Error("legends中iconName"); if (e.name && this.checkSpecial(e.name)) throw new Error("legends中name"); if (e.color && this.checkSpecial(e.color)) throw new Error("legends中color") })), e.data && e.data.forEach((e => { if (e.type && this.checkSpecial(e.type)) throw new Error("data中type"); if (e.id && this.checkSpecial(e.id)) throw new Error("data中id") })) } catch (e) { return void (t && t({ result: 0, message: e.message + "属性值包含特殊字符" })) } this.executeCommand("addLandmarkLayer", e, t) } } addLandmarkLayerLegend(e, t) { this.executeCommand("addLandmarkLayerLegend", e, t) } removeLandmarkLayerLegend(e, t) { this.executeCommand("removeLandmarkLayerLegend", e, t) } updateLandmarkLayerStyle(e, t) { if (e.name && this.checkSpecial(e.name)) t && t({ result: 0, message: "name 属性值包含特殊字符" }); else if (null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend) t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }); else { try { e.legends && e.legends.forEach((e => { if (e.iconName && this.checkSpecial(e.iconName)) throw new Error("legends中iconName"); if (e.name && this.checkSpecial(e.name)) throw new Error("legends中name"); if (e.color && this.checkSpecial(e.color)) throw new Error("legends中color") })), e.data && e.data.forEach((e => { if (e.label && this.checkSpecial(e.label)) throw new Error("data中lable"); if (e.type && this.checkSpecial(e.type)) throw new Error("data中type"); if (e.id && this.checkSpecial(e.id)) throw new Error("data中id") })) } catch (e) { return void (t && t({ result: 0, message: e.message + "属性值包含特殊字符" })) } this.executeCommand("updateLandmarkLayerStyle", e, t) } } updateLandmarkLayerCoord(e, t) { if (e.name && this.checkSpecial(e.name)) t && t({ result: 0, message: "name 属性值包含特殊字符" }); else if (null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend) t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }); else { try { e.legends && e.legends.forEach((e => { if (e.name && this.checkSpecial(e.name)) throw new Error("legends中name"); if (e.iconName && this.checkSpecial(e.iconName)) throw new Error("legends中iconName"); if (e.color && this.checkSpecial(e.color)) throw new Error("legends中color") })), e.data && e.data.forEach((e => { if (e.label && this.checkSpecial(e.label)) throw new Error("data中lable"); if (e.type && this.checkSpecial(e.type)) throw new Error("data中type"); if (e.id && this.checkSpecial(e.id)) throw new Error("data中id") })) } catch (e) { return void (t && t({ result: 0, message: e.message + "属性值包含特殊字符" })) } this.executeCommand("updateLandmarkLayerCoord", e, t) } } async add3DColumnLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); if ("number" != typeof e.columnAlpha || e.columnAlpha < 0 || e.columnAlpha > 1) return void (t && t({ result: 0, message: "columnAlpha 属性值错误。" })); if (e.columnType && "cube" != e.columnType && "cylinder" != e.columnType) return void (t && t({ result: 0, message: "columnType  柱体外观类别 属性值错误。" })); if (e.columnPaint && "solid" != e.columnPaint && "linear" != e.columnPaint && "legend" != e.columnPaint) return void (t && t({ result: 0, message: "columnPaint  柱体样式类别 属性值错误。" })); var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (!i.ok) return void (t && t(i.data)); var r = this.checkMinMaxValue(e.columnMinHeight, e.columnMaxHeight, "columnMinHeight", "columnMaxHeight"); if (!r.ok) return void (t && t(r.data)); let n = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.dataServer = n.data, e.channelId = this.channelId; let a = this; if (e.pointDataId) try { let i = await Util.fetchJSON(`${a.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: a.channelId, id: e.pointDataId, layerId: e.id, layerType: "3DColumnLayer" }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.pointDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("add3DColumnLayer", e, t) } update3DColumnLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("update3DColumnLayerCoord", e, t) } update3DColumnLayerStyle(e, t) { if ("number" != typeof e.columnAlpha || e.columnAlpha < 0 || e.columnAlpha > 1) t && t({ result: 0, message: "columnAlpha 属性值错误。" }); else if (e.columnType && "cube" != e.columnType && "cylinder" != e.columnType) t && t({ result: 0, message: "columnType  柱体外观类别 属性值错误。" }); else if (e.columnPaint && "solid" != e.columnPaint && "linear" != e.columnPaint && "legend" != e.columnPaint) t && t({ result: 0, message: "columnPaint  柱体样式类别 属性值错误。" }); else { var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (i.ok) { var r = this.checkMinMaxValue(e.columnMinHeight, e.columnMaxHeight, "columnMinHeight", "columnMaxHeight"); r.ok ? this.executeCommand("update3DColumnLayerStyle", e, t) : t && t(r.data) } else t && t(i.data) } } async add3DGridLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); if ("number" != typeof e.gridAlpha || e.gridAlpha < 0 || e.gridAlpha > 1) return void (t && t({ result: 0, message: "gridAlpha 属性值错误。" })); if (!e.gridType || e.gridType && "grid" != e.gridType && "dot" != e.gridType) return void (t && t({ result: 0, message: "gridType  栅格外观类别 属性值错误。" })); var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (!i.ok) return void (t && t(i.data)); let r = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.dataServer = r.data, e.channelId = this.channelId; let n = this; if (e.pointDataId) try { let i = await Util.fetchJSON(`${n.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: n.channelId, id: e.pointDataId, layerId: e.id, layerType: "3DGridLayer" }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.pointDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("add3DGridLayer", e, t) } update3DGridLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("update3DGridLayerCoord", e, t) } update3DGridLayerStyle(e, t) { if ("number" != typeof e.gridAlpha || e.gridAlpha < 0 || e.gridAlpha > 1) t && t({ result: 0, message: "gridAlpha 属性值错误。" }); else if (!e.gridType || e.gridType && "grid" != e.gridType && "dot" != e.gridType) t && t({ result: 0, message: "gridType  栅格外观类别 属性值错误。" }); else { var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); i.ok ? this.executeCommand("update3DGridLayerStyle", e, t) : t && t(i.data) } } addAreaLayer(e, t) { areaTypes[e.type] ? areaFillAreaTypes[e.fillArea] ? this.executeCommand("addAreaLayer", e, t) : t && t({ result: 0, message: "失败，区域填充样式类型错误。" }) : t && t({ result: 0, message: "失败，区域边界样式类型错误。" }) } updateAreaLayerCoord(e, t) { this.executeCommand("updateAreaLayerCoord", e, t) } updateAreaLayerStyle(e, t) { areaTypes[e.type] ? areaFillAreaTypes[e.fillArea] ? this.executeCommand("updateAreaLayerStyle", e, t) : t && t({ result: 0, message: "失败，区域填充样式类型错误。" }) : t && t({ result: 0, message: "失败，区域边界样式类型错误。" }) } addCircularAreaLayer(e, t) { areaTypes[e.type] ? areaFillAreaTypes[e.fillArea] ? this.executeCommand("addCircularAreaLayer", e, t) : t && t({ result: 0, message: "失败，区域填充样式类型错误。" }) : t && t({ result: 0, message: "失败，区域边界样式类型错误。" }) } updateCircularAreaLayerCoord(e, t) { this.executeCommand("updateCircularAreaLayerCoord", e, t) } updateCircularAreaLayerStyle(e, t) { areaTypes[e.type] ? areaFillAreaTypes[e.fillArea] ? this.executeCommand("updateCircularAreaLayerStyle", e, t) : t && t({ result: 0, message: "失败，区域填充样式类型错误。" }) : t && t({ result: 0, message: "失败，区域边界样式类型错误。" }) } setEnvTime(e, t) { if (e.envTime) { var i = e.envTime.split(/:|：| |-|\//); if (null == i[0] || i[0] >= 24) return void (t && t({ result: 0, message: `时间 ${e.envTime} 格式错误。` })); if (null == i[1] || i[1] >= 60) return void (t && t({ result: 0, message: `时间 ${e.envTime} 格式错误。` })); e.envTime = i.join(":") } this.executeCommand("setEnvTime", e, t) } setEnvWeather(e, t) { weathers[e.envWeather] ? this.executeCommand("setEnvWeather", e, t) : t && t({ result: 0, message: `失败，天气 ${e.envWeather} 暂不支持。` }) } async addBubbleLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); if ("number" != typeof e.valueMin || e.valueMin <= 0) return void (t && t({ result: 0, message: "valueMin 属性值错误" })); if ("number" != typeof e.valueMax || e.valueMax <= 0) return void (t && t({ result: 0, message: "valueMax 属性值错误" })); if ("number" != typeof e.radiusMax || e.radiusMax <= 0) return void (t && t({ result: 0, message: "radiusMax 属性值错误" })); if ("number" != typeof e.radiusMin || e.radiusMin <= 0) return void (t && t({ result: 0, message: "radiusMin 属性值错误" })); var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (!i.ok) return void (t && t(i.data)); var r = this.checkMinMaxValue(e.radiusMin, e.radiusMax, "radiusMin", "radiusMax"); if (!r.ok) return void (t && t(r.data)); let n = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.dataServer = n.data, e.channelId = this.channelId; let a = this; if (e.pointDataId) try { let i = await Util.fetchJSON(`${a.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: a.channelId, id: e.pointDataId, layerId: e.id, layerType: "bubbleLayer" }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.pointDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addBubbleLayer", e, t) } async addTrailLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); let i = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.trailServer = i.data, e.channelId = this.channelId, this.executeCommand("addTrailLayer", e, t) } deletePath(e, t) { this.executeCommand("deletePath", e, t) } addODLineLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) t && t({ result: 0, message: "visible 属性值错误，应为布尔值" }); else if (e.data) if ("number" != typeof e.lineSpeed || e.lineSpeed < 0) t && t({ result: 0, message: "lineSpeed 属性值错误。" }); else if (e.curvature > 1 || e.curvature < 0) t && t({ result: 0, message: "curvature 属性值错误。" }); else { var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (i.ok) { var r = this.checkMinMaxValue(e.bubbleRadiusMin, e.bubbleRadiusMax, "bubbleRadiusMin", "bubbleRadiusMax"); if (r.ok) { var n = this.checkMinMaxValue(e.lineWidthMin, e.lineWidthMax, "lineWidthMin", "lineWidthMax"); n.ok ? this.executeCommand("addODLineLayer", e, t) : t && t(n.data) } else t && t(r.data) } else t && t(i.data) } else t && t({ result: 0, message: "data 不能为空。" }) } updateODLineLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateODLineLayerCoord", e, t) } updateODLineLayerStyle(e, t) { if ("number" != typeof e.lineSpeed || e.lineSpeed < 0) t && t({ result: 0, message: "lineSpeed 属性值错误。" }); else if (e.curvature > 1 || e.curvature < 0) t && t({ result: 0, message: "curvature 属性值错误。" }); else { var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (i.ok) { var r = this.checkMinMaxValue(e.bubbleRadiusMin, e.bubbleRadiusMax, "bubbleRadiusMin", "bubbleRadiusMax"); if (r.ok) { var n = this.checkMinMaxValue(e.lineWidthMin, e.lineWidthMax, "lineWidthMin", "lineWidthMax"); n.ok ? null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateODLineLayerStyle", e, t) : t && t(n.data) } else t && t(r.data) } else t && t(i.data) } } updateTrailLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateTrailLayerCoord", e, t) } updateTrailLayerStyle(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateTrailLayerStyle", e, t) } updateBubbleLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateBubbleLayerCoord", e, t) } updateBubbleLayerStyle(e, t) { if ("number" != typeof e.valueMin || e.valueMin < 0) t && t({ result: 0, message: "valueMin 属性值错误" }); else if ("number" != typeof e.valueMax || e.valueMax < 0) t && t({ result: 0, message: "valueMax 属性值错误" }); else if ("number" != typeof e.radiusMax || e.radiusMax <= 0) t && t({ result: 0, message: "radiusMax 属性值错误" }); else if ("number" != typeof e.radiusMin || e.radiusMin <= 0) t && t({ result: 0, message: "radiusMin 属性值错误" }); else { var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (i.ok) { var r = this.checkMinMaxValue(e.radiusMin, e.radiusMax, "radiusMin", "radiusMax"); r.ok ? this.executeCommand("updateBubbleLayerStyle", e, t) : t && t(r.data) } else t && t(i.data) } } addCircularArea(e, t) { null == e.visible || null != e.visible && "boolean" != typeof e.visible ? t && t({ result: 0, message: "visible 属性值错误，应为布尔值" }) : this.executeCommand("addCircularArea", e, t) } updateCircularAreaCoord(e, t) { this.executeCommand("updateCircularAreaCoord", e, t) } updateCircularAreaStyle(e, t) { this.executeCommand("updateCircularAreaStyle", e, t) } add3DMarker(e, t) { e.alpha && "number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1 ? t && t({ result: 0, message: "alpha 属性值错误。 值域范围大于等于0 小于等于1" }) : _3DMarkerType[e.type.toLowerCase()] ? this.executeCommand("add3DMarker", e, t) : t && t({ result: 0, message: `失败，特效样式类别 ${e.type} 不存在。` }) } update3DMarkerCoord(e, t) { this.executeCommand("update3DMarkerCoord", e, t) } update3DMarkerStyle(e, t) { e.alpha && "number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1 ? t && t({ result: 0, message: "alpha 属性值错误。 值域范围大于等于0 小于等于1" }) : _3DMarkerType[e.type.toLowerCase()] ? this.executeCommand("update3DMarkerStyle", e, t) : t && t({ result: 0, message: `失败，特效样式类别 ${e.type} 不存在。` }) } add3DMarkerLandmarkLayer(e, t) { e.alpha && "number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1 ? t && t({ result: 0, message: "alpha 属性值错误。 值域范围大于等于0 小于等于1" }) : this.executeCommand("add3DMarkerLandmarkLayer", e, t) } update3DMarkerLandmarkLayerCoord(e, t) { this.executeCommand("update3DMarkerLandmarkLayerCoord", e, t) } update3DMarkerLandmarkLayerStyle(e, t) { e.alpha && "number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1 ? t && t({ result: 0, message: "alpha 属性值错误。 值域范围大于等于0 小于等于1" }) : this.executeCommand("update3DMarkerLandmarkLayerStyle", e, t) } getStates(e, t) { this.executeCommand("getStates", e, t) } switchState(e, t) { this.executeCommand("switchState", e, t) } restrictCamera(e, t) { if (e.limitPitch) { if (e.limitPitch.length < 2) return void (t && t({ result: 0, message: "失败，摄像机镜头垂直俯仰角数组结构出错。" })); if ("number" != typeof e.limitPitch[0] || e.limitPitch[0] < 1 || "number" != typeof e.limitPitch[1] || e.limitPitch[1] > 89) return void (t && t({ result: 0, message: "失败，摄像机镜头垂直俯仰角范围在 1~89。" })) } if (e.limitPitch) { if (e.limitYaw.length < 2) return void (t && t({ result: 0, message: "失败，摄像机镜头水平摇摆角数组结构出错。" })); if ("number" != typeof e.limitYaw[0] || e.limitYaw[0] < 0 || "number" != typeof e.limitYaw[1] || e.limitYaw[1] > 359) return void (t && t({ result: 0, message: "失败，摄像机镜头水平摇摆角范围在 0~359。" })) } if (e.limitCoordZ) { if (e.limitCoordZ.length < 2) return void (t && t({ result: 0, message: "失败，摄像机镜头坐标高度限制数组结构出错。" })); if ("number" != typeof e.limitCoordZ[0] || "number" != typeof e.limitCoordZ[1]) return void (t && t({ result: 0, message: "失败，摄像机镜头坐标高度限制非数字。" })) } if (e.limitDistance) { if (e.limitDistance.length < 2) return void (t && t({ result: 0, message: "失败，摄像机镜头距离限制数组结构出错。" })); if ("number" != typeof e.limitDistance[0] || "number" != typeof e.limitDistance[1]) return void (t && t({ result: 0, message: "失败，摄像机镜头距离限制非数字。" })) } this.executeCommand("restrictCamera", e, t) } setCameraRestrictionState(e, t) { this.executeCommand("setCameraRestrictionState", e, t) } roamingCamera(e, t) { if (loopModes[e.loopMode]) { try { e.points && e.points.forEach((e => { if (!e.pitch) throw new Error("points中缺少pitch字段"); if ("number" != typeof e.pitch || e.pitch < -89 || e.pitch > 89) throw new Error("points中pitch值属性异常"); if (!e.yaw) throw new Error("points中缺少yaw字段"); if ("number" != typeof e.yaw || e.yaw < 0 || e.yaw > 359) throw new Error("points中yaw值属性异常") })) } catch (e) { return void (t && t({ result: 0, message: e.message })) } this.executeCommand("roamingCamera", e, t) } else t && t({ result: 0, message: `失败，循环模式 ${e.loopMode} 不支持。` }) } setCameraRoamingState(e, t) { this.executeCommand("setCameraRoamingState", e, t) } pathingCamera(e, t) { "number" != typeof e.pitch || e.pitch < 0 || e.pitch > 89 ? t && t({ result: 0, message: "pitch 属性值错误。 范围(0~89)" }) : this.executeCommand("pathingCamera", e, t) } setCameraPathingState(e, t) { this.executeCommand("setCameraPathingState", e, t) } focusById(e, t) { this.checkOverlayTypeExist(e.overlayType) ? this.executeCommand("focusById", e, t) : this.returnOverlayTypeError(t) } focusByType(e, t) { this.checkOverlayTypeExist(e.overlayType) ? this.executeCommand("focusByType", e, t) : this.returnOverlayTypeError(t) } focusBuilding(e, t) { this.executeCommand("focusBuilding", e, t) } focusFloor(e, t) { this.executeCommand("focusFloor", e, t) } focusRoom(e, t) { this.executeCommand("focusRoom", e, t) } setCompass(e, t) { this.executeCommand("setCompass", e, t) } addWatermark(e, t) { if (e.alpha) { if ("number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1) return void (t && t({ result: 0, message: "alpha 属性值错误。 范围(0~1)" })) } else t && t({ result: 0, message: "alpha 属性值为空。" }); if (e.scale) { if ("number" != typeof e.scale || e.scale < .01 || e.scale > 100) return void (t && t({ result: 0, message: "scale 属性值错误。 范围(0.01~100)" })) } else t && t({ result: 0, message: "scale 属性值为空。" }); e.dockHorizontal || t && t({ result: 0, message: "dockHorizontal 属性值为空。" }), e.dockVertical || t && t({ result: 0, message: "dockVertical 属性值为空。" }), this.executeCommand("addWatermark", e, t) } removeWatermark(e, t) { this.executeCommand("removeWatermark", e, t) } switchWorldMap(e, t) { this.executeCommand("switchWorldMap", e, t) } highlightCountry(e, t) { this.executeCommand("highlightCountry", e, t) } setCountryNameVisible(e, t) { this.executeCommand("setCountryNameVisible", e, t) } switchChinaMap(e, t) { this.executeCommand("switchChinaMap", e, t) } highlightProvince(e, t) { this.executeCommand("highlightProvince", e, t) } setProvinceNameVisible(e, t) { this.executeCommand("setProvinceNameVisible", e, t) } setOverlaySelectState(e, t) { this.executeCommand("setOverlaySelectState", e, t) } clickOverlay(e, t) { this.executeCommand("clickOverlay", e, t) } getLandmarkScreenRange(e, t) { this.executeCommand("getLandmarkScreenRange", e, t) } addPathShp(e, t) { this.executeCommand("addPathShp", e, t) } addArea(e, t) { null == e.visible || null != e.visible && "boolean" != typeof e.visible ? t && t({ result: 0, message: "visible 属性值错误，应为布尔值" }) : this.executeCommand("addArea", e, t) } updateAreaCoord(e, t) { this.executeCommand("updateAreaCoord", e, t) } updateAreaStyle(e, t) { this.executeCommand("updateAreaStyle", e, t) } addAreaShp(e, t) { this.executeCommand("addAreaShp", e, t) } add3DTile(e, t) { null == e.visible || null != e.visible && "boolean" != typeof e.visible ? t && t({ result: 0, message: "visible 属性值错误，应为布尔值" }) : this.executeCommand("add3DTile", e, t) } update3DTile(e, t) { this.executeCommand("update3DTile", e, t) } update3DTileStyle(e, t) { this.executeCommand("update3DTileStyle", e, t) } addGISMap(e, t) { null == e.visible || null != e.visible && "boolean" != typeof e.visible ? t && t({ result: 0, message: "visible 属性值错误，应为布尔值" }) : this.executeCommand("addGISMap", e, t) } updateGISMap(e, t) { this.executeCommand("updateGISMap", e, t) } updateGISMapStyle(e, t) { this.executeCommand("updateGISMapStyle", e, t) } setBaseCenter(e, t) { this.executeCommand("setBaseCenter", e, t) } setDefaultBaseCenter(e, t) { this.executeCommand("setDefaultBaseCenter", e, t) } resetDefaultBaseCenter(e, t) { this.executeCommand("resetDefaultBaseCenter", e, t) } updateHeatMapLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateHeatMapLayerCoord", e, t) } updateHeatMapLayerStyle(e, t) { if ("number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1) t && t({ result: 0, message: "失败，alpha 属性值错误。" }); else if ("default" == e.type || "dot" == e.type) { var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); i.ok ? this.executeCommand("updateHeatMapLayerStyle", e, t) : t && t(i.data) } else t && t({ result: 0, message: "失败，type 属性值错误。" }) } async addTypeAreaLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); if ("number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1) return void (t && t({ result: 0, message: "失败，alpha 属性值错误。" })); let i = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.dataServer = i.data, e.channelId = this.channelId; let r = this; if (e.lineDataId) try { let i = await Util.fetchJSON(`${r.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: r.channelId, id: e.lineDataId, layerId: e.id, layerType: "typeAreaLayer" }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.lineDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addTypeAreaLayer", e, t) } updateTypeAreaLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateTypeAreaLayerCoord", e, t) } updateTypeAreaLayerStyle(e, t) { "number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1 ? t && t({ result: 0, message: "失败，alpha 属性值错误。" }) : null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateTypeAreaLayerStyle", e, t) } updateTypeAreaLayerArea(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateTypeAreaLayerArea", e, t) } async addColorAreaLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); if ("number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1) return void (t && t({ result: 0, message: "失败，alpha 属性值错误。" })); var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (!i.ok) return void (t && t(i.data)); if (!areaTypes[e.type]) return void (t && t({ result: 0, message: "失败，区域边界样式类型错误。" })); if (!areaFillAreaTypes[e.fillArea]) return void (t && t({ result: 0, message: "失败，区域填充样式类型错误。" })); let r = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.dataServer = r.data, e.channelId = this.channelId; let n = this; if (e.lineDataId) try { let i = await Util.fetchJSON(`${n.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: n.channelId, id: e.lineDataId, layerId: e.id, layerType: "colorArea" }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.lineDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addColorAreaLayer", e, t) } updateColorAreaLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateColorAreaLayerCoord", e, t) } updateColorAreaLayerStyle(e, t) { if ("number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1) t && t({ result: 0, message: "失败，alpha 属性值错误。" }); else { var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); i.ok ? areaTypes[e.type] ? areaFillAreaTypes[e.fillArea] ? this.executeCommand("updateColorAreaLayerStyle", e, t) : t && t({ result: 0, message: "失败，区域填充样式类型错误。" }) : t && t({ result: 0, message: "失败，区域边界样式类型错误。" }) : t && t(i.data) } } updateColorAreaLayerArea(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateColorAreaLayerArea", e, t) } async addRoadPtHeatLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (!i.ok) return void (t && t(i.data)); if (e && ("number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1)) return void (t && t({ result: 0, message: "失败，alpha 属性值错误。" })); if (e.width && this.checkSpecial(e.width)) return void (t && t({ result: 0, message: "width 属性值包含特殊字符" })); if (e.width && ("number" != typeof e.width || e.width < 0)) return void (t && t({ result: 0, message: "失败，width 属性值错误。" })); let r = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.dataServer = r.data, e.channelId = this.channelId; let n = this; if (e.pointDataId) try { let i = await Util.fetchJSON(`${n.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: n.channelId, id: e.pointDataId, layerId: e.id, layerType: "roadPtHeatLayer" }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.pointDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addRoadPtHeatLayer", e, t) } updateRoadPtHeatLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateRoadPtHeatLayerCoord", e, t) } updateRoadPtHeatLayerStyle(e, t) { var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); i.ok ? e.width && ("number" != typeof e.width || e.width < 0) ? t && t({ result: 0, message: "失败，width 属性值错误。" }) : e && ("number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1) ? t && t({ result: 0, message: "失败，alpha 属性值错误。" }) : this.executeCommand("updateRoadPtHeatLayerStyle", e, t) : t && t(i.data) } async addRoadSgHeatLayerCoord(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); if (e && ("number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1)) return void (t && t({ result: 0, message: "失败，alpha 属性值错误。" })); var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (!i.ok) return void (t && t(i.data)); let r = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.dataServer = r.data, e.channelId = this.channelId; let n = this; if (e.lineDataId) try { let i = await Util.fetchJSON(`${n.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: n.channelId, id: e.lineDataId, layerId: e.id, layerType: "roadSgHeatLayer" }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.lineDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addRoadSgHeatLayerCoord", e, t) } updateRoadSgHeatLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateRoadSgHeatLayerCoord", e, t) } updateRoadSgHeatLayerStyle(e, t) { if ("number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1) t && t({ result: 0, message: "失败，alpha 属性值错误。" }); else { var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); i.ok ? this.executeCommand("updateRoadSgHeatLayerStyle", e, t) : t && t(i.data) } } updateRoadSgHeatLayerSegment(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateRoadSgHeatLayerSegment", e, t) } addEventBubbleLayer(e, t) { var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (i.ok) { var r = this.checkMinMaxValue(e.radiusMin, e.radiusMax, "radiusMin", "radiusMax"); r.ok ? this.executeCommand("addEventBubbleLayer", e, t) : t && t(r.data) } else t && t(i.data) } updateEventBubbleLayerCoord(e, t) { this.executeCommand("updateEventBubbleLayerCoord", e, t) } updateEventBubbleLayerStyle(e, t) { var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (i.ok) { var r = this.checkMinMaxValue(e.radiusMin, e.radiusMax, "radiusMin", "radiusMax"); r.ok ? this.executeCommand("updateEventBubbleLayerStyle", e, t) : t && t(r.data) } else t && t(i.data) } addPointTrackLayer(e, t) { this.executeCommand("addPointTrackLayer", e, t) } updatePointTrackLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updatePointTrackLayerCoord", e, t) } updatePointTrackLayerStyle(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updatePointTrackLayerStyle", e, t) } getSceneObjects(e, t) { this.executeCommand("getSceneObjects", e, t) } addModel(e, t) { e.alpha && ("number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1) ? t && t({ result: 0, message: "alpha 属性值错误。" }) : e.scale && ("number" != typeof e.scale || e.scale < 0) ? t && t({ result: 0, message: "scale 属性值错误。" }) : this.executeCommand("addModel", e, t) } removeModel(e, t) { this.executeCommand("removeModel", e, t) } getModelType(e, t) { this.executeCommand("getModelType", e, t) } setModelTransform(e, t) { this.executeCommand("setModelTransform", e, t) } setModelOpacity(e, t) { this.executeCommand("setModelOpacity", e, t) } setModelVisibility(e, t) { this.executeCommand("setModelVisibility", e, t) } setModelStyle(e, t) { e.maskPictureScale && ("number" != typeof e.maskPictureScale || e.maskPictureScale < 0) ? t && t({ result: 0, message: "失败，maskPictureScale 属性值错误。" }) : this.executeCommand("setModelStyle", e, t) } getModelsByType(e, t) { this.executeCommand("getModelsByType", e, t) } setModelCoord(e, t) { this.executeCommand("setModelCoord", e, t) } getModelArticulation(e, t) { this.executeCommand("getModelArticulation", e, t) } setModelArticulation(e, t) { this.executeCommand("setModelArticulation", e, t) } getModelAnimation(e, t) { this.executeCommand("getModelAnimation", e, t) } setModelAnimation(e, t) { this.executeCommand("setModelAnimation", e, t) } playModelAnimation(e, t) { this.executeCommand("playModelAnimation", e, t) } addModelTip(e, t) { const i = this.buildCommandCallbackId(); if (e.divId) { const t = this._checkCanAddHTMLTip(`${e.id}#model`, e.divId); if (t) return t; this.tempTipMap.set(`${e.id}#model`, { divId: e.divId, isShowClose: e.isShowClose, size: e.size, offset: e.offset, callbackId: i }) } this.executeCommand("addModelTip", e, t, i) } rotatingModel(e, t) { e.durationX < 0 || e.durationY < 0 || e.durationZ < 0 ? t && t({ result: 0, message: "旋转周期应为非负数。" }) : "clockwise" != e.directionX && "counterclockwise" != e.directionX || "clockwise" != e.directionY && "counterclockwise" != e.directionY || "clockwise" != e.directionZ && "counterclockwise" != e.directionZ ? t && t({ result: 0, message: "旋转方向只能为 clockwise（顺时针方向） 或 counterclockwise（逆时针方向）" }) : this.executeCommand("rotatingModel", e, t) } setModelRotationState(e, t) { states[e.state] ? this.executeCommand("setModelRotationState", e, t) : t && t({ result: 0, message: `失败，持续旋转状态 ${e.state} 暂不支持。` }) } blinkingModel(e, t) { e.duration <= 0 ? t && t({ result: 0, message: "闪烁周期应为正数。" }) : "default" == e.type ? this.executeCommand("blinkingModel", e, t) : t && t({ result: 0, message: "闪烁风格目前只支持default" }) } setModelBlinkState(e, t) { states[e.state] ? this.executeCommand("setModelBlinkState", e, t) : t && t({ result: 0, message: `失败，持续闪烁状态 ${e.state} 暂不支持。` }) } movingModel(e, t) { loopModes[e.loopMode] ? this.executeCommand("movingModel", e, t) : t && t({ result: 0, message: `失败，循环模式 ${e.loopMode} 不支持。` }) } setModelMoveState(e, t) { states[e.state] ? this.executeCommand("setModelMoveState", e, t) : t && t({ result: 0, message: `失败，持续移动状态 ${e.state} 暂不支持。` }) } pathingModel(e, t) { loopModes[e.loopMode] ? pathDirections[e.direction] ? this.executeCommand("pathingModel", e, t) : t && t({ result: 0, message: `失败，沿路径调整方向 ${e.direction} 不支持。` }) : t && t({ result: 0, message: `失败，循环模式 ${e.loopMode} 不支持。` }) } setModelPathingState(e, t) { states[e.state] ? this.executeCommand("setModelPathingState", e, t) : t && t({ result: 0, message: `失败，持续移动状态 ${e.state} 暂不支持。` }) } showBuildingFloor(e, t) { null == e.animation || 1 == e.animation ? this.executeCommand("showBuildingFloor", e, t) : t && t({ result: 0, message: "失败，animation 属性值错误。" }) } showBuildingFloor(e, t) { this.executeCommand("showBuildingFloor", e, t) } resetBuildingFloor(e, t) { null == e.animation || 1 == e.animation ? this.executeCommand("resetBuildingFloor", e, t) : t && t({ result: 0, message: "失败，animation 属性值错误。" }) } highlightBuilding(e, t) { "style1" == e.type || "none" == e.type ? this.executeCommand("highlightBuilding", e, t) : t && t({ result: 0, message: "高亮风格目前只支持style1" }) } highlightFloor(e, t) { "style1" == e.type || "none" == e.type ? this.executeCommand("highlightFloor", e, t) : t && t({ result: 0, message: "高亮风格目前只支持style1" }) } highlightRoom(e, t) { "style1" == e.type || "none" == e.type ? this.executeCommand("highlightRoom", e, t) : t && t({ result: 0, message: "高亮风格目前只支持style1" }) } getBuildings(e, t) { this.executeCommand("getBuildings", e, t) } addSection(e, t) { this.executeCommand("addSection", e, t) } removeSection(e, t) { this.executeCommand("removeSection", e, t) } updateSection(e, t) { this.executeCommand("updateSection", e, t) } setSectionState(e, t) { this.executeCommand("setSectionState", e, t) } setFirework(e, t) { this.executeCommand("setFirework", e, t) } rotateCamera(e, t) { e.duration <= 0 ? t && t({ result: 0, message: "失败，飞行时间无效。" }) : this.executeCommand("rotateCamera", e, t) } getLandmarkScreenPosition(e, t) { this.executeCommand("getLandmarkScreenPosition", e, t) } setResolutionInnerMethod(e, t) { e.rateMax && (e.rateMax = 1024 * e.rateMax), e.width = parseInt(e.width) > 3840 ? 3840 : e.width, e.height = parseInt(e.height) > 2160 ? 2160 : e.height, this.setUEResolutionWidth = e.width, this.setUEResolutionHeight = e.height, this.executeCommand("setResolution", e, t), this.setResolutionSaveParams = e, this.setResolutionTimer && clearTimeout(this.setResolutionTimer); let i = this; if (this.setResolutionTimer = setTimeout((() => { if (!i.setResolutionSaveParams) return; let e = Math.abs(i.streamingPlayer.playerElement.videoWidth - i.setResolutionSaveParams.width); (Math.abs(i.streamingPlayer.playerElement.videoHeight - i.setResolutionSaveParams.height) > 1 || e > 1) && i.executeCommand("setResolution", i.setResolutionSaveParams, t), i.setResolutionSaveParams = null }), i.setResolutionCheckDelayMs), this.events.onResolutionChange) for (let t of this.events.onResolutionChange) t({ width: e.width, height: e.height }) } setResolution(e, t) { window.streamingDOM ? this.progressBar ? t && t({ result: 0, message: "失败，未完成初始化!" }) : e.width && ("number" != typeof e.width || e.width < 0) ? t && t({ result: 0, message: "失败，width 属性值错误。" }) : e.height && ("number" != typeof e.height || e.height < 0) ? t && t({ result: 0, message: "失败，height 属性值错误。" }) : e.rateMax && ("number" != typeof e.rateMax || e.rateMax < 0) ? t && t({ result: 0, message: "失败，rateMax 属性值错误。" }) : e.fpsMax && ("number" != typeof e.fpsMax || e.fpsMax < 0) ? t && t({ result: 0, message: "失败，fpsMax 属性值错误。" }) : e.width && e.height && (e.width > this.streamingWidthMax || e.height > this.streamingHeightMax) ? t && t({ result: 0, message: "失败，分辨率宽高超过该场景最大分辨率。" }) : this.isShareToken ? t && t({ result: 0, message: "失败，共享模式不支持设置分辨率。" }) : (e.width && e.height && (this.apiData.data.resolutionX = e.width, this.apiData.data.resolutionY = e.height), e.rateMax && (this.apiData.data.codeRate = e.rateMax), e.fpsMax && (this.apiData.data.frameRate = e.fpsMax), this.lastResolutionSet = void 0, this.setResolutionSDK(this.apiData, t, !0)) : t && t({ result: 0, message: "失败，视频流未初始化!" }) } focusByLayer(e, t) { this.checkOverlayTypeExist(e.layerType) ? this.executeCommand("focusByLayer", e, t) : this.returnOverlayTypeError(t) } focusByLegend(e, t) { if (!this.checkOverlayTypeExist(e.layerType)) return void this.returnOverlayTypeError(t); let i = e.layerType.toLowerCase(); i === _OVERLAY_LANDMARK_LAYER || i === _OVERLAY_BUBBLE_LAYER || i === _OVERLAY_TRAIL_LAYER || i === _OVERLAY_ODLINE_LAYER || i === _OVERLAY_TYPE_AREA_LAYER || i === _OVERLAY_AGG3DGRIDLAYER || i === _OVERLAY_MODELTRAILLAYER || i === _OVERLAY_MODELLANDMARKLAYERTEMP || i === _OVERLAY_TRACKLAYER || i === _OVERLAY_3D_MARKER || i === _OVERLAY_ROAD_SG_HEAT_LAYER || i === _OVERLAY_3DMARKERLANDMARKLAYERLAYER || i === _OVERLAY_EVENTLAYER || i === _OVERLAY_STARLIGHTLAYER ? this.executeCommand("focusByLegend", e, t) : t && t({ result: 0, message: "失败，覆盖物类型没有图例。" }) } focusModel(e, t) { this.executeCommand("focusModel", e, t) } getBaseCenter(e, t) { this.executeCommand("getBaseCenter", e, t) } getDefaultBaseCenter(e, t) { this.executeCommand("getDefaultBaseCenter", e, t) } setLogMode(e, t) { "boolean" == typeof e.mode ? logger && (logger.setLogMode(e.mode), t({ result: 1, message: `日志模式设置成功! 当前mode ${e.mode} 。` })) : t({ result: 0, message: "参数不合法 参数 mode 为布尔值" }) } setOverlayTypeVisibility(e, t) { this.checkOverlayTypeExist(e.overlayType) ? this.executeCommand("setOverlayTypeVisibility", e, t) : this.returnOverlayTypeError(t) } getOverlaysByType(e, t) { this.checkOverlayTypeExist(e.overlayType) ? this.executeCommand("getOverlaysByType", e, t) : this.returnOverlayTypeError(t) } getOverlaysByLayer(e, t) { this.executeCommand("getOverlaysByLayer", e, t) } selectOverlay(e, t) { this.checkOverlayTypeExist(e.overlayType) ? this.executeCommand("selectOverlay", e, t) : this.returnOverlayTypeError(t) } endSelectOverlay(e, t) { this.executeCommand("endSelectOverlay", e, t) } pickScreen(e, t) { this.executeCommand("pickScreen", e, t) } pickOverlay(e, t) { this.checkOverlayTypeExist(e.overlayType) ? clickTypes[e.type] ? this.executeCommand("pickOverlay", e, t) : t && t({ result: 0, message: "失败，单选模式错误。" }) : this.returnOverlayTypeError(t) } endPickOverlay(e, t) { this.checkOverlayTypeExist(e.overlayType) ? !e.type || "" == e.type || clickTypes[e.type] ? this.executeCommand("endPickOverlay", e, t) : t && t({ result: 0, message: "失败，单选模式错误。" }) : this.returnOverlayTypeError(t) } clickOverlayType(e, t) { this.checkOverlayTypeExist(e.overlayType) ? this.executeCommand("clickOverlayType", e, t) : this.returnOverlayTypeError(t) } clearOverlaySelected(e, t) { this.executeCommand("clearOverlaySelected", e, t) } addTrackLayer(e, t) { null == e.visible || null != e.visible && "boolean" != typeof e.visible ? t && t({ result: 0, message: "visible 属性值错误，应为布尔值" }) : this.executeCommand("addTrackLayer", e, t) } updateTrackLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateTrackLayerCoord", e, t) } updateTrackLayerStyle(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateTrackLayerStyle", e, t) } selectModel(e, t) { circleTypes[e.type] ? this.executeCommand("selectModel", e, t) : t && t({ result: 0, message: `失败，框选模式 ${e.type} 无效。` }) } endSelectModel(e, t) { this.executeCommand("endSelectModel", e, t) } pickModel(e, t) { clickTypes[e.type] ? this.executeCommand("pickModel", e, t) : t && t({ result: 0, message: `失败，单选模式 ${e.type} 不匹配。` }) } endPickModel(e, t) { this.executeCommand("endPickModel", e, t) } clickModel(e, t) { this.executeCommand("clickModel", e, t) } clickModelType(e, t) { this.executeCommand("clickModelType", e, t) } clearModelSelected(e, t) { this.executeCommand("clearModelSelected", e, t) } addOverlayTip(e, t) { if (!this.checkOverlayTypeExist(e.overlayType)) return void this.returnOverlayTypeError(t); const i = this.buildCommandCallbackId(); if (e.divId) { const t = this._checkCanAddHTMLTip(`${e.id}#${e.overlayType}`, e.divId); if (t) return t; this.tempTipMap.set(`${e.id}#${e.overlayType}`, { divId: e.divId, isShowClose: e.isShowClose, size: e.size, offset: e.offset, callbackId: i }) } this.executeCommand("addOverlayTip", e, t, i) } checkApi(e) { var t = [], i = this; e.forEach((e => { null == i[e] && t.push(e) })), logger.debug(t) } async addHeatMapLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); if ("number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1) return void (t && t({ result: 0, message: "失败，alpha 属性值错误。" })); if ("default" != e.type && "dot" != e.type) return void (t && t({ result: 0, message: "失败，type 属性值错误。" })); var i = this.checkMinMaxValue(e.valueMin, e.valueMax, "valueMin", "valueMax"); if (!i.ok) return void (t && t(i.data)); let r = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.dataServer = r.data, e.channelId = this.channelId; let n = this; if (e.pointDataId) try { let i = await Util.fetchJSON(`${n.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: n.channelId, id: e.pointDataId, layerId: e.id, layerType: "heatmaplayer" }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.pointDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addHeatMapLayer", e, t) } playAnimation(e, t) { this.executeCommand("playAnimation", e, t) } switchScene(e, t) { this.executeCommand("switchScene", e, t) } focusModelByType(e, t) { this.executeCommand("focusModelByType", e, t) } removeOverlayTip(e, t) { if (!this.checkOverlayTypeExist(e.overlayType)) return void this.returnOverlayTypeError(t); const i = this.buildCommandCallbackId(); this.tooltipMap.has(`${e.id}#${e.overlayType}`) && this.deleteTipMap.set(`${e.id}#${e.overlayType}`, i), this.executeCommand("removeOverlayTip", e, t, i) } removeModelTip(e, t) { const i = this.buildCommandCallbackId(); this.tooltipMap.has(e.id) && this.deleteTipMap.set(e.id, i), this.executeCommand("removeModelTip", e, t, i) } updateAggLandmarkLayerCoord(e, t) { var i = this; if (!streamingDOM) return; if (null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend) return void (t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" })); let r = { id: e.id, isAppend: e.isAppend, conversationId: i.conversationId, data: e.data }; Util.fetchJSON(`${i.aggServerUrl}/UpdateAggLandmarkLayerCoord`, "post", [{ key: "Content-Type", value: "application/json" }], r).then((r => { logger.debug(r); let n = { id: e.id, conversationId: i.conversationId }; n.callbackId = Util.guid(); let a = this.callbackMap.get("updateAggLandmarkLayerCoord"); a || (this.callbackMap.set("updateAggLandmarkLayerCoord", new Map), a = this.callbackMap.get("updateAggLandmarkLayerCoord")), a.set(n.callbackId, t); var o = { updateAggLandmarkLayerCoord: !0, params: n }; streamingDOM.emitDescriptor(o) })).catch((e => { i.logger.debug(e) })) } addAggData(e, t) { if (!streamingDOM) return; let i = this; e.aggRadius && (e.radius = e.aggRadius), Util.fetchJSON(`${i.aggServerUrl}/V3.1/AddAggData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let i = { result: 1, message: "添加数据成功。" }; 1 !== (e = JSON.parse(e)).code && (i.result = 0, i.message = `添加数据失败(${e.message})！`), t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "添加数据失败！" }) })) } addPointData(e, t) { if (!streamingDOM) return; let i = this; e.channelId = this.channelId, Util.fetchJSON(`${i.aggServerUrl}/AddPointData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let r = { result: 1, message: "添加数据成功。" }; 1 !== (e = JSON.parse(e)).code ? (r.result = 0, r.message = `添加数据失败(${e.message})！`) : i.executeCommand("updateLayerData", { data: e.layers }), t(r) })).catch((e => { i.logger.error(e), t({ result: 0, message: "添加数据失败！" }) })) } async addAggLandmarkLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); let i = await this.serverSocket.invoke("GetAggregationServiceAddress"); if (e.aggServer = i.data, e.channelId = this.channelId, e.aggMaxMapLevel < 0 || e.aggMaxMapLevel > 20) return void (t && t({ result: 0, message: "失败，aggMaxMapLevel 属性值错误。" })); try { e.clusters && e.clusters.forEach((e => { var i = this.checkMinMaxValue(e.value_range_min, e.value_range_max, "value_range_min", "value_range_max"); i.ok || t && t(i.data) })) } catch (e) { return void (t && t({ result: 0, message: e.message })) } let r = this; if (e.aggDataId) try { let i = await Util.fetchJSON(`${r.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: r.channelId, id: e.aggDataId, layerId: e.id, layerType: "aggLandmarkLayer", aggRadius: e.aggRadius, aggType: e.aggType }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.aggDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addAggLandmarkLayer", e, t) } async addAgg3DColumnLayer(e, t) { let i = await this.serverSocket.invoke("GetAggregationServiceAddress"); if (e.aggServer = i.data, e.channelId = this.channelId, e.aggMaxMapLevel < 0 || e.aggMaxMapLevel > 20) return void (t && t({ result: 0, message: "失败，aggMaxMapLevel 属性值错误。" })); let r = this; if (e.aggDataId) try { let i = await Util.fetchJSON(`${r.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: r.channelId, id: e.aggDataId, layerId: e.id, layerType: "agg3DColumnLayer", aggRadius: e.aggRadius, aggType: e.aggType }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.aggDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addAgg3DColumnLayer", e, t) } async addAggBubbleLayer(e, t) { let i = await this.serverSocket.invoke("GetAggregationServiceAddress"); if (e.aggServer = i.data, e.channelId = this.channelId, e.aggMaxMapLevel < 0 || e.aggMaxMapLevel > 20) return void (t && t({ result: 0, message: "失败，aggMaxMapLevel 属性值错误。" })); if ("number" != typeof e.radiusMax || e.radiusMax <= 0) return void (t && t({ result: 0, message: "radiusMax 属性值错误" })); if ("number" != typeof e.radiusMin || e.radiusMin <= 0) return void (t && t({ result: 0, message: "radiusMin 属性值错误" })); if ("number" != typeof e.speed || e.speed <= 0) return void (t && t({ result: 0, message: "speed 属性值错误" })); var r = this.checkMinMaxValue(e.radiusMin, e.radiusMax, "radiusMin", "radiusMax"); if (!r.ok) return void (t && t(r.data)); let n = this; if (e.aggDataId) try { let i = await Util.fetchJSON(`${n.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: n.channelId, id: e.aggDataId, layerId: e.id, layerType: "aggBubbleLayer", aggRadius: e.aggRadius, aggType: e.aggType }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.aggDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addAggBubbleLayer", e, t) } async addAgg3DGridLayer(e, t) { let i = await this.serverSocket.invoke("GetAggregationServiceAddress"); if (e.aggServer = i.data, e.channelId = this.channelId, e.aggMaxMapLevel < 0 || e.aggMaxMapLevel > 20) return void (t && t({ result: 0, message: "失败，aggMaxMapLevel 属性值错误。" })); let r = this; if (e.aggDataId) try { let i = await Util.fetchJSON(`${r.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: r.channelId, id: e.aggDataId, layerId: e.id, layerType: "agg3DGridLayer", aggRadius: e.aggRadius, aggType: e.aggType }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.aggDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addAgg3DGridLayer", e, t) } updateAggData(e, t) { if (!streamingDOM) return; if (null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend) return void (t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" })); let i = this; Util.fetchJSON(`${i.aggServerUrl}/V3.1/UpdateAggData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let i = { result: 1, message: "更新数据成功。" }; 1 !== (e = JSON.parse(e)).code && (i.result = 0, i.message = `更新数据失败(${e.message})！`), t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "更新数据失败！" }) })) } updatePointData(e, t) { if (!streamingDOM) return; let i = this; e.channelId = this.channelId, Util.fetchJSON(`${i.aggServerUrl}/UpdatePointData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let r = { result: 1, message: "更新数据成功。" }; 1 !== (e = JSON.parse(e)).code ? (r.result = 0, r.message = `更新数据失败(${e.message})！`) : i.executeCommand("updateLayerData", { data: e.layers }), t(r) })).catch((e => { i.logger.error(e), t({ result: 0, message: "更新数据失败！" }) })) } updateAggLandmarkLayerStyle(e, t) { this.executeCommand("updateAggLandmarkLayerStyle", e, t) } updateAgg3DColumnLayerStyle(e, t) { this.executeCommand("updateAgg3DColumnLayerStyle", e, t) } updateAggBubbleLayerStyle(e, t) { this.executeCommand("updateAggBubbleLayerStyle", e, t) } updateAgg3DGridLayerStyle(e, t) { this.executeCommand("updateAgg3DGridLayerStyle", e, t) } countAggData(e, t) { if (!streamingDOM) return; let i = this; Util.fetchJSON(`${i.aggServerUrl}/V3.1/CountAggData/${e.id}`, "get").then((e => { let i = { result: 1, message: "成功。", count: (e = JSON.parse(e)).data }; 1 !== e.code && (i.result = 0, i.message = `查询失败(${e.message})！`), t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "查询失败" }) })) } countPointData(e, t) { if (!streamingDOM) return; let i = this; Util.fetchJSON(`${i.aggServerUrl}/CountPointData/${e.id}/${this.channelId}`, "get").then((e => { let i = { result: 1, message: "成功。", count: (e = JSON.parse(e)).data }; 1 !== e.code && (i.result = 0, i.message = `查询失败(${e.message})！`), t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "查询失败" }) })) } searchDataByPoint(e, t) { if (!streamingDOM) return; let i = this; e.channelId = this.channelId, Util.fetchJSON(`${i.aggServerUrl}/SearchDataByPoint`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let i = { result: 1, message: "成功。" }; 1 !== (e = JSON.parse(e)).code ? (i.result = 0, i.message = `查询数据失败(${e.message})！`) : i.datas = e.data, t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "查询数据失败" }) })) } searchDataByArea(e, t) { if (!streamingDOM) return; let i = this; e.channelId = this.channelId, Util.fetchJSON(`${i.aggServerUrl}/SearchDataByArea`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let i = { result: 1, message: "成功。" }; 1 !== (e = JSON.parse(e)).code ? (i.result = 0, i.message = `查询数据失败(${e.message})！`) : i.datas = e.data, t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "查询数据失败" }) })) } searchDataByPath(e, t) { if (!streamingDOM) return; let i = this; e.channelId = this.channelId, Util.fetchJSON(`${i.aggServerUrl}/SearchDataByPath`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let i = { result: 1, message: "成功。" }; 1 !== (e = JSON.parse(e)).code ? (i.result = 0, i.message = `查询数据失败(${e.message})！`) : i.datas = e.data, t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "查询数据失败" }) })) } removeAggData(e, t) { if (!streamingDOM) return; let i = this; Util.fetchJSON(`${i.aggServerUrl}/V3.1/RemoveAggData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let i = { result: 1, message: "删除成功。" }; 1 !== (e = JSON.parse(e)).code && (i.result = 0, i.message = `删除数据失败(${e.message})！`), t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "删除数据失败！" }) })) } removePointData(e, t) { if (!streamingDOM) return; let i = this; Util.fetchJSON(`${i.aggServerUrl}/V3.1/RemovePointData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let i = { result: 1, message: "删除成功。" }; 1 !== (e = JSON.parse(e)).code && (i.result = 0, i.message = `删除数据失败(${e.message})！`), t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "删除数据失败！" }) })) } removeData(e, t) { if (!streamingDOM) return; let i = this; e.channelId = this.channelId, Util.fetchJSON(`${i.aggServerUrl}/RemoveData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let r = { result: 1, message: "删除成功。" }; 1 !== (e = JSON.parse(e)).code ? (r.result = 0, r.message = `删除数据失败(${e.message})！`) : i.executeCommand("updateLayerData", { data: e.layers }), t(r) })).catch((e => { i.logger.error(e), t({ result: 0, message: "删除数据失败！" }) })) } removeAllAggData(e, t) { if (!streamingDOM) return; let i = this; Util.fetchJSON(`${i.aggServerUrl}/V3.1/RemoveAllAggData/${e.id}`, "delete").then((e => { let i = { result: 1, message: "成功。" }; 1 !== (e = JSON.parse(e)).code && (i.result = 0, i.message = `删除失败(${e.message})！`), t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "删除失败" }) })) } removeAllPointData(e, t) { if (!streamingDOM) return; let i = this; Util.fetchJSON(`${i.aggServerUrl}/DeleteAllPointData/${e.id}`, "delete").then((e => { let i = { result: 1, message: "成功。" }; 1 !== (e = JSON.parse(e)).code && (i.result = 0, i.message = `删除失败(${e.message})！`), t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "删除失败" }) })) } removeAllData(e, t) { if (!streamingDOM) return; let i = this; Util.fetchJSON(`${i.aggServerUrl}/RemoveAllData/${e.id}/${this.channelId}`, "delete").then((e => { let r = { result: 1, message: "成功。" }; 1 !== (e = JSON.parse(e)).code ? (r.result = 0, r.message = `删除失败(${e.message})！`) : i.executeCommand("updateLayerData", { data: e.layers }), t(r) })).catch((e => { i.logger.error(e), t({ result: 0, message: "删除失败" }) })) } async addModelTrailLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); if (e.trackDuration && ("number" != typeof e.trackDuration || e.trackDuration < 0)) return void (t && t({ result: 0, message: "trackDuration 属性值错误。 " })); if (e.trackWidth && ("number" != typeof e.trackWidth || e.trackWidth < 0)) return void (t && t({ result: 0, message: "trackWidth 属性值错误。 " })); let i = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.modelTrailServer = i.data, e.channelId = this.channelId, this.executeCommand("addModelTrailLayer", e, t) } updateModelTrailLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateModelTrailLayerCoord", e, t) } updateModelTrailLayerStyle(e, t) { this.executeCommand("updateModelTrailLayerStyle", e, t) } addModelTrailData(e, t) { var i = this; streamingDOM && Util.fetchJSON(`${i.aggServerUrl}/TrailData/UpdateModelTrailData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { e = JSON.parse(e), i.logger.debug(e), t({ result: e.data, message: e.message }) })).catch((e => { i.logger.debug(e) })) } removeModelTrailData(e, t) { var i = this; streamingDOM && Util.fetchJSON(`${i.aggServerUrl}/TrailData/RemoveTrailData/${e.id}`, "delete").then((e => { e = JSON.parse(e), i.logger.debug(e), t({ result: e.data, message: e.message }) })).catch((e => { i.logger.debug(e) })) } removeModelTrailCoord(e, t) { this.executeCommand("removeModelTrailCoord", e, t) } followCamera(e, t) { this.executeCommand("followCamera", e, t) } stopCameraFollow(e, t) { this.executeCommand("stopCameraFollow", e, t) } getScenesInfo(e, t) { this.executeCommand("getScenesInfo", e, t) } async addModelLandmarkLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); if (e.alpha && "number" != typeof e.alpha) return void (t && t({ result: 0, message: "alpha 属性值错误。 值域范围大于等于0 小于等于1" })); if (e.alpha < 0 || e.alpha > 1) return void (t && t({ result: 0, message: "alpha 属性值错误。 值域范围大于等于0 小于等于1" })); try { e.legends && e.legends.forEach((e => { if (!e.modelType) throw new Error("legends中modelType不能为空"); if (e.modelType && this.checkSpecial(e.modelType)) throw new Error("legends中modelType属性值包含特殊字符") })) } catch (e) { return void (t && t({ result: 0, message: e.message })) } let i = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.dataServer = i.data, e.channelId = this.channelId; let r = this; if (e.modelLandmarkDataId) try { let i = await Util.fetchJSON(`${r.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: r.channelId, id: e.modelLandmarkDataId, layerId: e.id, layerType: "modelLandmarkLayer" }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.modelLandmarkDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addModelLandmarkLayer", e, t) } updateModelLandmarkLayerCoord(e, t) { this.executeCommand("updateModelLandmarkLayerCoord", e, t) } updateModelLandmarkLayerStyle(e, t) { this.executeCommand("updateModelLandmarkLayerStyle", e, t) } addModelLandmarkLayerTemp(e, t) { this.executeCommand("addModelLandmarkLayerTemp", e, t) } updateModelLandmarkLayerTempCoord(e, t) { this.executeCommand("updateModelLandmarkLayerTempCoord", e, t) } updateModelLandmarkLayerTempStyle(e, t) { this.executeCommand("updateModelLandmarkLayerTempStyle", e, t) } setModelClipping(e, t) { e.modelType ? "model" == e.modelType || "building" == e.modelType ? e.planeStyle ? "style1" == e.planeStyle || "style2" == e.planeStyle ? this.executeCommand("setModelClipping", e, t) : t && t({ result: 0, message: "planeStyle 属性值错误，应为style1或者style2" }) : t && t({ result: 0, message: "planeStyle 属性值为空，应为style1或者style2" }) : t && t({ result: 0, message: "modelType 属性值错误，应为model或者building" }) : t && t({ result: 0, message: "modelType 属性值为空，需要指定model或者building" }) } clearModelClipping(e, t) { this.executeCommand("clearModelClipping", e, t) } expandBuildingFloor(e, t) { e.floorPadding ? "number" != typeof e.floorPadding || e.floorPadding < 0 ? t && t({ result: 0, message: "floorPadding 属性值错误。 范围应大于等于0" }) : e.duration ? "number" != typeof e.duration || e.duration < 0 ? t && t({ result: 0, message: "duration 属性值错误。 范围应大于等于0" }) : this.executeCommand("expandBuildingFloor", e, t) : t && t({ result: 0, message: "缺少字段 duration " }) : t && t({ result: 0, message: "缺少字段 floorPadding " }) } setSceneEffect(e, t) { e.lightPower && "number" != typeof e.lightPower || e.lightPower <= 0 || e.lightPower > 10 ? t && t({ result: 0, message: "lightPower 属性值错误。 值域范围大于0 小于等于10.0" }) : (this.updateTipDelay = 200, e.divTipMovingDelay && (this.updateTipDelay = e.divTipMovingDelay), this.executeCommand("setSceneEffect", e, t)) } getAppInfo(e, t) { if (t) { if (!streamingDOM) return void t({ result: 0, message: "未完成初始化。" }); var i = 0, r = 0; this.streamingPlayerState && (i = this.streamingPlayerState.VideoResolution.split("x")[0], r = this.streamingPlayerState.VideoResolution.split("x")[1]); let e = "无流渲染服务版本信息"; this.apiData.data && this.apiData.data.version && (e = this.apiData.data.version), t({ result: 1, message: "成功。", tgApiSdkVer: "3.3", tgApiDocUrl: "http://www.tuguan.net/doc/tg-api/", streamingSdkVer: "3.3.3", streamingServerVer: e, streamingEngineVer: this.streamingEngineVer, streamingWidthMax: this.apiData.data.resolutionX, streamingHeightMax: this.apiData.data.resolutionY, streamingRateMax: 1024 * this.apiData.data.codeRate, streamingFpsMax: this.apiData.data.frameRate, clientWidth: i, clientHeight: r }) } } _getAppInfoUECallback(e, t) { t.logger.info(e), e && e.streamingEngineVer ? t.streamingEngineVer = e.streamingEngineVer : t.streamingEngineVer = "无渲染引擎版本信息" } async switchService(e, t) { const { name: i } = e; if (!this.serviceMap.has(i)) return void (t && t({ result: 0, message: "不存在此名称的Service" })); if (this.name === i) return void (t && t({ result: 0, message: `切换失败，当前已经是Service：${i}！` })); if (this.switchServiceFlag) return void (t && t({ result: 0, message: "当前正在切换Service，请等待当前Service切换成功后再次切换" })); const { url: r, token: n } = this.serviceMap.get(i), a = this.container, o = this.isShareToken, s = this.resolution, l = this.events; if (this.switchServiceFlag = !0, this.reinit = !0, this.destroy(), t && t({ result: 1, message: `正在切换到Service：${i}` }), this.firstSwitch && (this.firstSwitch = !1, !this.initIsPreheat)) try { await Util.fetchJSON(`${this.serverUrl}/Streaming/LoadService/${this.token}`, "get") } catch (e) { this.logger.error(e) } this.init({ url: r, token: n, container: a, isShareToken: o, resolution: s, events: l, showDefaultLoading: !0, name: i, editMode: this.editMode }) } async loadService(e, t) { const { name: i, url: r, mode: n, token: a } = e; if (this.serviceMap.has(i)) t && t({ result: 0, message: "此Service已经预加载！" }); else try { const e = await Util.fetchJSON(`${r}/Streaming/LoadService/${a}`, "get"), n = JSON.parse(e); if (!n.data) return void (t && t({ result: 0, message: `预读取服务失败（${n.message}）！` })); const o = { name: i, url: r, token: a, default: !1 }; if (this.serviceMap.set(i, o), t && t({ result: 1, message: "成功" }), this.events.onServiceLoad) for (let e of this.events.onServiceLoad) e({ name: i, default: !1 }) } catch (e) { this.logger.warn(e), t && t({ result: 0, message: "预读取服务失败！" }) } } getServicesInfo(e, t) { if (!t) return; t({ result: 1, message: "成功", mode: "streaming", services: [...this.serviceMap.values()] }) } initScene(e, t) { this.executeCommand("initScene", e, t) } getOverlaysOrder(e, t) { this.executeCommand("getOverlaysOrder", e, t) } moveOverlayForward(e, t) { this.executeCommand("moveOverlayForward", e, t) } moveOverlayBackward(e, t) { this.executeCommand("moveOverlayBackward", e, t) } setModelTransform2(e, t) { null == e.coordX || null == e.coordX ? e.coordX = "null" : e.coordX = e.coordX.toString(), null == e.coordY || null == e.coordY ? e.coordY = "null" : e.coordY = e.coordY.toString(), null == e.coordZ || null == e.coordZ ? e.coordZ = "null" : e.coordZ = e.coordZ.toString(), null == e.rotationX || null == e.rotationX ? e.rotationX = "null" : e.rotationX = e.rotationX.toString(), null == e.rotationY || null == e.rotationY ? e.rotationY = "null" : e.rotationY = e.rotationY.toString(), null == e.rotationZ || null == e.rotationZ ? e.rotationZ = "null" : e.rotationZ = e.rotationZ.toString(), null == e.scaleX || null == e.scaleX ? e.scaleX = "null" : e.scaleX = e.scaleX.toString(), null == e.scaleY || null == e.scaleY ? e.scaleY = "null" : e.scaleY = e.scaleY.toString(), null == e.scaleZ || null == e.scaleZ ? e.scaleZ = "null" : e.scaleZ = e.scaleZ.toString(), e.duration ? "number" != typeof e.duration || e.duration < 0 ? t && t({ result: 0, message: "duration 属性值错误。 范围应大于0" }) : this.executeCommand("setModelTransform2", e, t) : t && t({ result: 0, message: "缺少字段 duration " }) } followingCamera(e, t) { this.executeCommand("followingCamera", e, t) } setCameraFollowingState(e, t) { this.executeCommand("setCameraFollowingState", e, t) } setCommand(e, t) { this.executeCommand("setCommand", e, t) } getClientStatus(e, t) { if (t) { if (this.clientStatus && this.clientStatus.error) { return void t({ result: 0, message: this.clientStatus.error }) } t({ result: 1, message: "成功。", clientStatus: this.clientStatus }) } } async saveClientStatus(e, t) { if (t) { if (!e.clientStatus) { return void t({ result: 0, message: "失败，未设置clientStatus" }) } try { var i = await this.saveClientStatusInner(e.clientStatus); if (!i) { return t({ result: 0, message: "失败，saveClientStatus 出错!" }), void this.logger.error("失败，saveClientStatus 出错!") } if (0 == i.status) { t({ result: 1, message: "成功。" }) } else { t({ result: 0, message: i.message }) } } catch (e) { t({ result: 0, message: "失败，saveClientStatus 出错!" + e }), this.logger.error("失败，saveClientStatus 出错!", e) } } } addEventLayer(e, t) { null == e.visible || null != e.visible && "boolean" != typeof e.visible ? t && t({ result: 0, message: "visible 属性值错误，应为布尔值" }) : this.executeCommand("addEventLayer", e, t) } updateEventLayerCoord(e, t) { null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : this.executeCommand("updateEventLayerCoord", e, t) } updateEventLayerStyle(e, t) { this.executeCommand("updateEventLayerStyle", e, t) } async addStarLightLayer(e, t) { if (null == e.visible || null != e.visible && "boolean" != typeof e.visible) return void (t && t({ result: 0, message: "visible 属性值错误，应为布尔值" })); if (e.alpha && "number" != typeof e.alpha) return void (t && t({ result: 0, message: "alpha 属性值错误。 值域范围大于等于0 小于等于1" })); if (e.alpha < 0 || e.alpha > 1) return void (t && t({ result: 0, message: "alpha 属性值错误。 值域范围大于等于0 小于等于1" })); let i = await this.serverSocket.invoke("GetAggregationServiceAddress"); e.dataServer = i.data, e.channelId = this.channelId; let r = this; if (e.pointDataId) try { let i = await Util.fetchJSON(`${r.aggServerUrl}/RecordLayers`, "post", [{ key: "Content-Type", value: "application/json" }], { channelId: r.channelId, id: e.pointDataId, layerId: e.id, layerType: "starLightLayer" }); if (i = JSON.parse(i), 111 === i.code) return void t({ result: 0, message: `数据服务中不包含id为${e.pointDataId}的数据` }) } catch (e) { this.logger.error("记录图层失败", e) } this.executeCommand("addStarLightLayer", e, t) } updateStarLightLayerCoord(e, t) { this.executeCommand("updateStarLightLayerCoord", e, t) } updateStarLightLayerStyle(e, t) { e.alpha && "number" != typeof e.alpha || e.alpha < 0 || e.alpha > 1 ? t && t({ result: 0, message: "alpha 属性值错误。 值域范围大于等于0 小于等于1" }) : this.executeCommand("updateStarLightLayerStyle", e, t) } addConnection(e, t) { this.executeCommand("addConnection", e, t) } updateConnection(e, t) { this.executeCommand("updateConnection", e, t) } updateConnectionStyle(e, t) { this.executeCommand("updateConnectionStyle", e, t) } addLineData(e, t) { if (!streamingDOM) return; let i = this; e.channelId = this.channelId, Util.fetchJSON(`${i.aggServerUrl}/AddLineData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let r = { result: 1, message: "添加数据成功。" }; 1 !== (e = JSON.parse(e)).code ? (r.result = 0, r.message = `添加数据失败(${e.message})！`) : i.executeCommand("updateLayerData", { data: e.layers }), t(r) })).catch((r => { -1 != r.message.indexOf("Not Found") ? Util.fetchJSON(`${i.aggServerUrl}/RoadLineData/AddLineData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let r = { result: 1, message: "添加数据成功。" }; 1 !== (e = JSON.parse(e)).code ? (r.result = 0, r.message = `添加数据失败(${e.message})！`) : i.executeCommand("updateLayerData", { data: e.layers }), t(r) })).catch((e => { i.logger.error(e), t({ result: 0, message: "添加数据失败！" }) })) : (i.logger.error(r), t({ result: 0, message: "添加数据失败！" })) })) } updateLineData(e, t) { if (!streamingDOM) return; let i = this; null == e.isAppend || null != e.isAppend && "boolean" != typeof e.isAppend ? t && t({ result: 0, message: "isAppend 属性值错误，应为布尔值" }) : (e.channelId = this.channelId, Util.fetchJSON(`${i.aggServerUrl}/UpdateLineData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let r = { result: 1, message: "更新数据成功。" }; 1 !== (e = JSON.parse(e)).code ? (r.result = 0, r.message = `更新数据失败(${e.message})！`) : i.executeCommand("updateLayerData", { data: e.layers }), t(r) })).catch((r => { -1 != r.message.indexOf("Not Found") ? Util.fetchJSON(`${i.aggServerUrl}/RoadLineData/UpdateLineData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let r = { result: 1, message: "更新数据成功。" }; 1 !== (e = JSON.parse(e)).code ? (r.result = 0, r.message = `更新数据失败(${e.message})！`) : i.executeCommand("updateLayerData", { data: e.layers }), t(r) })).catch((e => { i.logger.error(e), t({ result: 0, message: "更新数据失败！" }) })) : (i.logger.error(r), t({ result: 0, message: "更新数据失败！" })) }))) } updateLineDataAttribute(e, t) { if (!streamingDOM) return; let i = this; e.channelId = this.channelId, Util.fetchJSON(`${i.aggServerUrl}/UpdateLineDataAttribute`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let r = { result: 1, message: "更新数据成功。" }; 1 !== (e = JSON.parse(e)).code ? (r.result = 0, r.message = `更新数据失败(${e.message})！`) : i.executeCommand("updateLayerData", { data: e.layers }), t(r) })).catch((r => { -1 != r.message.indexOf("Not Found") ? Util.fetchJSON(`${i.aggServerUrl}/RoadLineData/UpdateLineDataAttribute`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let r = { result: 1, message: "更新数据成功。" }; 1 !== (e = JSON.parse(e)).code ? (r.result = 0, r.message = `更新数据失败(${e.message})！`) : i.executeCommand("updateLayerData", { data: e.layers }), t(r) })).catch((e => { i.logger.error(e), t({ result: 0, message: "更新数据失败！" }) })) : (i.logger.error(r), t({ result: 0, message: "更新数据失败！" })) })) } queryLineData(e, t) { if (!streamingDOM) return; let i = this; e.channelId = this.channelId, Util.fetchJSON(`${i.aggServerUrl}/QueryLineData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let i = { result: 1, message: "查询数据成功。" }; 1 !== (e = JSON.parse(e)).code ? (i.result = 0, i.message = `查询数据失败(${e.message})！`) : (i.id = e.id, i.attribute = e.attribute, i.data = e.data), t(i) })).catch((r => { -1 != r.message.indexOf("Not Found") ? Util.fetchJSON(`${i.aggServerUrl}/RoadLineData/QueryLineData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let i = { result: 1, message: "查询数据成功。" }; 1 !== (e = JSON.parse(e)).code ? (i.result = 0, i.message = `查询数据失败(${e.message})！`) : (i.id = e.id, i.attribute = e.attribute, i.data = e.data), t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "查询数据失败！" }) })) : (i.logger.error(r), t({ result: 0, message: "查询数据失败！" })) })) } countLineData(e, t) { if (!streamingDOM) return; let i = this; e.channelId = this.channelId, Util.fetchJSON(`${i.aggServerUrl}/CountLineData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let i = { result: 1, message: "成功。" }; 1 !== (e = JSON.parse(e)).code ? (i.result = 0, i.message = `查询失败(${e.message})！`) : (i.pathCount = e.data.lineCount, i.pointCount = e.data.pointCount, i.data = e.data.data), t(i) })).catch((r => { -1 != r.message.indexOf("Not Found") ? Util.fetchJSON(`${i.aggServerUrl}/RoadLineData/CountLineData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let i = { result: 1, message: "成功。" }; 1 !== (e = JSON.parse(e)).code ? (i.result = 0, i.message = `查询失败(${e.message})！`) : (i.pathCount = e.data.lineCount, i.pointCount = e.data.pointCount, i.data = e.data.data), t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "查询失败" }) })) : (i.logger.error(r), t({ result: 0, message: "查询失败" })) })) } queryPointData(e, t) { if (!streamingDOM) return; let i = this; e.channelId = this.channelId, Util.fetchJSON(`${i.aggServerUrl}/QueryPointData`, "post", [{ key: "Content-Type", value: "application/json" }], e).then((e => { let i = { result: 1, message: "查询数据成功。" }; 1 !== (e = JSON.parse(e)).code ? (i.result = 0, i.message = `查询数据失败(${e.message})！`) : (i.id = e.id, i.attribute = e.attribute, i.data = e.data), t(i) })).catch((e => { i.logger.error(e), t({ result: 0, message: "查询数据失败！" }) })) } showObjectAxis(e, t) { this.executeCommand("showObjectAxis", e, t) } setModelMaterial(e, t) { this.executeCommand("setModelMaterial", e, t) } addWMSLayer(e, t) { this.executeCommand("addWMSLayer", e, t) } updateWMSLayerStyle(e, t) { this.executeCommand("updateWMSLayerStyle", e, t) } removeWMSLayer(e, t) { this.executeCommand("removeWMSLayer", e, t) } executeCommand(e, t, i, r) { this.checkStreamingDOM(); let n = r || this.buildCommandCallbackId(); this.storeCommandCallbackIdToMap(e, n, i); let a = this.buildCommand(e, t, n); this.streamingPlayer && !this.streamingPlayer.checkMaxByteLength(e, a, i) || this.sendCommandToUE(a) } checkStreamingDOM() { if (!streamingDOM) throw new ReferenceError("Not Find StreamingDOM") } buildCommandCallbackId() { return Util.guid() } storeCommandCallbackIdToMap(e, t, i) { let r = this.callbackMap.get(e); r || (this.callbackMap.set(e, new Map), r = this.callbackMap.get(e)), r.set(t, i) } buildCommand(e, t, i) { let r = { params: t }; return r[e] = !0, r.params.callbackId = i, r } sendCommandToUE(e) { streamingDOM.emitDescriptor(e) } checkOverlayTypeExist(e) { let t = e.toLowerCase(); return void 0 !== overlays$1[t] } returnOverlayTypeError(e) { e && e({ result: 0, message: "失败，覆盖物类型错误。" }) } checkMinMaxValue(e, t, i, r) { var n = {}; if (e && t) { if ("number" != typeof e) return n.ok = !1, n.data = { result: 0, message: `${i} 非数值类型 ` }, n; if ("number" != typeof t) return n.ok = !1, n.data = { result: 0, message: `${r} 非数值类型 ` }, n; if (e > t) return n.ok = !1, n.data = { result: 0, message: `数值不合法 ${i} 的值大于 ${r} 的值 ` }, n } return n.ok = !0, n } checkSpecial(e) { return !!new RegExp("[`~!@$^&*()=|{}':;',\\[\\]<>《》/?~！@￥……&*（）——|{}【】‘；：”“'。，、？ ]").test(e) } _addHTMLToolTip(e, t, i, r, n, a) { let o = this; if (this.tooltipMap || (this.tooltipMap = new Map, this.tooltipDivMap = new Map), this.tooltipMap.has(e)) return { result: 0, message: "失败，该对象已存在Tip。" }; if ([...this.tooltipDivMap.values()].includes(t)) return { result: 0, message: "失败，该divId已被使用。" }; const s = new HTMLToolTipParams; s.id = e, s.container = this.container, s.divId = t, s.showCloseButton = i, s.toolTipWidth = r[0], s.toolTipHeight = r[1], s.toolTipLeftOffset = n[0], s.toolTipBottomOffset = n[1], this.updateTipDelay && (s.updateDelay = this.updateTipDelay); const l = new HTMLToolTip(s), c = l.addToScreen(); if (c) return this.logger.error("添加HTML标牌失败", c), { result: 0, message: c }; this.tooltipMap.set(e, l), this.tooltipDivMap.set(e, t), this.tooltipCallback.set(a, l), l.onClose = e => { o._removeHTMLTooltip(e) } } getObjXy(e) { var t = e.getBoundingClientRect(), i = t.top - document.documentElement.clientTop + document.documentElement.scrollTop, r = t.bottom, n = t.left - document.documentElement.clientLeft + document.documentElement.scrollLeft, a = t.right; return { top: i, right: a, bottom: r, left: n, width: t.width || a - n, height: t.height || r - i } } async _updateHTMLToolTipsPosition(e, t, i) { let r = this; const n = []; for (const i of e) if (!t.has(i.id)) { const e = this.tempTipMap.get(i.id); e && (this._addHTMLToolTip(i.id, e.divId, e.isShowClose, e.size, e.offset, e.callbackId), this.tempTipMap.delete(i.id)) } for (const [r, d] of t) { const t = e.find((e => e.id === r)); if (t) { d.updateVisible(t.isHide); var a = this.container, o = t.position[0], s = t.position[1], l = t.position[0] / this.setUEResolutionWidth * this.streamingPlayer.playerElement.clientWidth, c = t.position[1] / this.setUEResolutionHeight * this.streamingPlayer.playerElement.clientHeight; if (1 == this.apiData.data.stretch) o = l + (a.clientWidth - this.streamingPlayer.playerElement.clientWidth) / 2, s = c + (a.clientHeight - this.streamingPlayer.playerElement.clientHeight) / 2; else o = l, s = c; var h = document.getElementById(d.htmlToolTipParams.divId); h.style.visibility = "visible"; var u = this.getObjXy(h); o < 0 && (h.style.visibility = "hidden"), 0 < s && s < u.height && (h.style.visibility = "visible", s = u.height), o + u.width > this.setUEResolutionWidth && o < this.setUEResolutionWidth && (h.style.visibility = "visible", o = this.setUEResolutionWidth - u.width), d.updatePosition(o, s) } else d.removeTooltip(), i.delete(r), n.push(r) } n.forEach((e => { t.delete(e); const i = r.deleteTipMap.get(e); if (i) { if (!r.deleteTempTipMap.has(i)) return void r.deleteTempTipMap.set(i, ""); if (r.deleteTipMap.delete(e), r.deleteTempTipMap.delete(i), e.includes("#")) { const e = r.callbackMap.get("removeOverlayTip"); e && "function" == typeof e.get(i) && e.get(i)({ result: 1, message: "成功" }, r) } else { const e = r.callbackMap.get("removeModelTip"); e && "function" == typeof e.get(i) && e.get(i)({ result: 1, message: "成功" }, r) } } })) } _removeHTMLTooltip(e) { if (this.tooltipMap.delete(e), this.tooltipDivMap.delete(e), e.includes("#")) { const t = e.split("#"); this.removeOverlayTip({ id: t[0], overlayType: t[1] }) } else this.removeModelTip({ id: e }) } _checkCanAddHTMLTip(e, t) { if (this.tooltipMap || (this.tooltipMap = new Map, this.tooltipDivMap = new Map), this.tooltipMap.has(e)) return { result: 0, message: "失败，该对象已存在Tip。" }; if ([...this.tooltipDivMap.values()].includes(t)) return { result: 0, message: "失败，该divId已被使用。" }; const i = document.getElementById(t); if (!i) return { result: 0, message: "不存在该divId" }; i.style.display = "none" } } class Camera$1 { constructor(e) { this.behavior = e.behavior || 0, this.distance = e.distance || "", this.posture = e.posture || "", this.target = e.target || "" } } var util = { randomString: function (e) { e = e || 32; for (var t = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678", i = t.length, r = "", n = 0; n < e; n++)r += t.charAt(Math.floor(Math.random() * i)); return r }, colorToRGBAObject: e => "string" != typeof (e = "" + e) ? { r: 1, g: 1, b: 1, a: 1 } : ("#" === e.charAt(0) && (e = e.substring(1)), 3 === e.length && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]), 4 === e.length && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] + e[3] + e[3]), /^[0-9a-fA-F]{6}$/.test(e) ? { r: parseInt(e.substr(0, 2), 16) / 255, g: parseInt(e.substr(2, 2), 16) / 255, b: parseInt(e.substr(4, 2), 16) / 255, a: 1 } : /^[0-9a-fA-F]{8}$/.test(e) ? { r: parseInt(e.substr(0, 2), 16) / 255, g: parseInt(e.substr(2, 2), 16) / 255, b: parseInt(e.substr(4, 2), 16) / 255, a: parseInt(e.substr(6, 2), 16) / 255 } : void 0), colorToRGBAString: e => "string" != typeof (e = "" + e) ? "rgba (1, 1, 1, 1)" : ("#" === e.charAt(0) && (e = e.substring(1)), 3 === e.length && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]), 4 === e.length && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] + e[3] + e[3]), /^[0-9a-fA-F]{6}$/.test(e) ? `rgba (${parseInt(e.substr(0, 2), 16) / 255}, ${parseInt(e.substr(2, 2), 16) / 255}, ${parseInt(e.substr(4, 2), 16) / 255}, 1)` : /^[0-9a-fA-F]{8}$/.test(e) ? `rgba (${parseInt(e.substr(0, 2), 16) / 255}, ${parseInt(e.substr(2, 2), 16) / 255}, ${parseInt(e.substr(4, 2), 16) / 255}, ${parseInt(e.substr(6, 2), 16) / 255})` : void 0), randomRGBAObject: () => ({ r: Math.random(), g: Math.random(), b: Math.random(), a: .5 + .5 * Math.random() }), randomRGBAString: () => `rgba (${Math.random()}, ${Math.random()}, ${Math.random()}, ${.5 + .5 * Math.random()})`, addDegrees: (e, t) => e && t && e.lon && e.lat && t.lon && t.lat ? { lon: e.lon + t.lon, lat: e.lat + t.lat, alt: e.alt ? t.alt ? e.alt + t.alt : e.alt : t.alt ? t.alt : 0 } : { lon: 0, lat: 0, alt: 0 }, unifyCoordinates(e, t) { if (t) { switch ("surface" === e.type.toLowerCase() && (e.type = "Surface"), "ecef" === e.type.toLowerCase() && (e.type = "ECEF"), "planarglobal" === e.type.toLowerCase() && (e.type = "PlanarGlobal"), "planarlocal" === e.type.toLowerCase() && (e.type = "PlanarLocal"), "default" === e.type.toLowerCase() && (e.type = "default"), e.type.toLowerCase()) { case "surface": let i = t({ X: e.lon, Y: e.lat, Z: e.alt }, "Surface"); e.x = i.x, e.y = 0 - i.z, e.z = 0 - i.y }return e } }, fetchJSON(e, t, i, r) { switch (t.toLowerCase()) { case "get": case "delete": case "post": case "put": break; default: t = "GET" }return new Promise((function (n, a) { let o = new XMLHttpRequest; if (o.onreadystatechange = function () { 4 == o.readyState && (200 == o.status || 204 == o.status ? n(o.responseText) : a(new Error(o.statusText))) }, o.open(t, e, !1), i instanceof Array) for (let e of i) o.setRequestHeader(e.key, e.value); o.send(JSON.stringify(r)) })) }, getRgbaNum(e = "rgba(255,255,255,0)", t) { let i = e.match(/(\d(\.\d+)?)+/g); return i[t] ? parseFloat(i[t]) : 0 }, syntheticImage: async (e = "", t = "#FFFFFF", i = "") => new Promise(((r, n) => { ("" == e && "" == i || "" == i) && r(""); let a = new Image, o = new Image, s = document.createElement("canvas"), l = s.getContext("2d"); "" != e ? (a.onload = () => { s.width = a.width, s.height = a.height, l.drawImage(a, 0, 0, s.width, s.height); let e, c = l.getImageData(0, 0, s.width, s.height); e = t.indexOf("#") > -1 ? util.colorToRGBAObject(t) : { r: util.getRgbaNum(t, 0), g: util.getRgbaNum(t, 1), b: util.getRgbaNum(t, 2), a: util.getRgbaNum(t, 3) }; for (let i = 0; i < c.data.length; i += 4)c.data[i + 3] > 0 && (c.data[i] = e.r, c.data[i + 1] = e.g, c.data[i + 2] = e.b, t.indexOf("rgba") > -1 && (c.data[i + 3] = 255 * e.a)); l.clearRect(0, 0, s.width, s.height), l.putImageData(c, 0, 0), o.onload = () => { l.drawImage(o, s.width / 5, s.height / 5, 3 * s.width / 5, 3 * s.height / 5), r(s.toDataURL()) }, o.onerror = () => { n("img load error") }, o.src = i }, a.onerror = () => { n("backgroundImg load error") }, a.src = e) : (o.onload = () => { s.width = 48, s.height = 48, l.drawImage(o, s.width / 5, s.height / 5, 3 * s.width / 5, 3 * s.height / 5), r(s.toDataURL()) }, o.onerror = () => { n("img load error") }, o.src = i) })) }; class Drawable { constructor(e, t) { return this.children = [], this.context = e.context || "", this.instance = e.instance || "", this.option = e.option || "", this.name = e.name || util.randomString(8), this.parent = e.parent || "", this.tags = e.tags || [], this.type = e.type || "", this.zLevel = "number" == typeof e.zLevel ? e.zLevel : 0, this._x = 0, this._y = 0, this._z = 0, t && t(1), this } addChild(e) { return this.children.push(e), this } convertLLAToXYZ(e, t, i) { if (e && "lla" === e.type.toLowerCase()) if (t) { let t = this.context.convertLLAToXYZ({ x: e.lon + Number(i.lonOffset ? i.lonOffset : 0), y: e.lat + Number(i.latOffset ? i.latOffset : 0), z: e.alt + Number(i.altOffset ? i.altOffset : 0) }); e.x = t.x, e.y = t.y, e.z = t.z } else { let t = this.context.convertLLAToXYZ({ x: e.lon, y: e.lat, z: e.alt }); e.x = t.x, e.y = t.y, e.z = t.z } return e } generateLableCanvas(e, t, i, r, n, a, o) { let s = document.createElement("canvas"), l = s.getContext("2d"); var c = 8 * t, h = ""; r && (h = "italic"); var u = ""; return i && (u = "bold"), l.font = `${h} ${u} ${c}px ${e}`, l.textAlign = "center", l.textBaseline = "middle", s.width = l.measureText(o).width + c, s.height = 2 * c, l.fillStyle = n, l.fillRect(0, 0, s.width, s.height), l.font = `${h} ${u} ${c}px ${e}`, l.fillStyle = a, l.textAlign = "center", l.textBaseline = "middle", l.fillText(o, s.width / 2, s.height / 2), s } getChildren() { return this.children } getFullName() { return `${this.parent}/${this.name}/${this.type}` } getXyz() { return { x: this._x, y: this._y, z: this._z } } hasChild() { return this.children.length > 0 } saveXyz(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this } updateZLevel(e) { let t = !1; return "function" == typeof this.context.updateDrawableRenderOrder && (t = this.context.updateDrawableRenderOrder(this.getFullName(), e), t && (this.zLevel = e)), t } toString() { return this.toString() } } class Layer$1 { constructor(e, t) { this.tags = e.tags || [], this.name = e.name || "", this.type = e.type || "", this.zLevel = "number" == typeof e.zLevel ? e.zLevel : 0, this._drawables = [], t && t(1) } action(e, t) { return t && t(1), this } addDrawable(e, t) { return e.name && "" !== e.name || (e.name = util.randomString(8)), this.getDrawable(e.name) ? (t && t(0, `已存在同名绘制物（${e.name}) `), this) : (e.parent = this.name, this._drawables.push(e), t && t(1, "成功"), this) } clearDrawables(e) { return this._drawables = [], e && e(1, "成功"), this } getDrawable(e) { for (let t of this._drawables) if (t.name.toString() === e.toString()) return t } getDrawablePosition(e) { if ("instanced" === this.type.toLowerCase() && 1 === this._drawables.length) { for (let t of this._drawables[0].points) if (t.name.toString() === e.toString()) return t } else for (let t of this._drawables) if (t.name.toString() === e.toString()) return t } getDrawables() { return this._drawables } hide() { return this } removeDrawable(e, t) { for (let i = 0; i < this._drawables.length; i++)if (this._drawables[i].name === e) return this._drawables.splice(i, 1), t && t(1), this; return t && t(0, `未找到名为 ${e} 的绘制物`), this } resetAction() { return callback && callback(1), this } show() { return this } updateZLevel(e) { let t = !1; for (let i = 0; i < this._drawables.length; i++)t = t || !this._drawables[i].updateZLevel(e); return t || (this.zLevel = e), !t } tag(e, t) { return this.tags.push(""), this } toJson() { return JSON.stringify(this._drawables) } toString() { return "" } } class Position { constructor(e) { this.alt = 0, this.lat = 0, this.lon = 0, this.type = e && "lla" === e.toLowerCase() ? e : "xyz", this.x = 0, this.y = 0, this.z = 0 } set(e, t, i) { switch (this.type.toLowerCase()) { case "lla": this.lon = Number(e), this.lat = Number(t), this.alt = Number(i); break; default: this.x = Number(e), this.y = Number(t), this.z = Number(i) }return this } toString() { return JSON.stringify(this) } } Position.Zero = function (e) { return new Position(e) }; const REVISION = "126", MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, CullFaceNone = 0, CullFaceBack = 1, CullFaceFront = 2, CullFaceFrontBack = 3, BasicShadowMap = 0, PCFShadowMap = 1, PCFSoftShadowMap = 2, VSMShadowMap = 3, FrontSide = 0, BackSide = 1, DoubleSide = 2, FlatShading = 1, SmoothShading = 2, NoBlending = 0, NormalBlending = 1, AdditiveBlending = 2, SubtractiveBlending = 3, MultiplyBlending = 4, CustomBlending = 5, AddEquation = 100, SubtractEquation = 101, ReverseSubtractEquation = 102, MinEquation = 103, MaxEquation = 104, ZeroFactor = 200, OneFactor = 201, SrcColorFactor = 202, OneMinusSrcColorFactor = 203, SrcAlphaFactor = 204, OneMinusSrcAlphaFactor = 205, DstAlphaFactor = 206, OneMinusDstAlphaFactor = 207, DstColorFactor = 208, OneMinusDstColorFactor = 209, SrcAlphaSaturateFactor = 210, NeverDepth = 0, AlwaysDepth = 1, LessDepth = 2, LessEqualDepth = 3, EqualDepth = 4, GreaterEqualDepth = 5, GreaterDepth = 6, NotEqualDepth = 7, MultiplyOperation = 0, MixOperation = 1, AddOperation = 2, NoToneMapping = 0, LinearToneMapping = 1, ReinhardToneMapping = 2, CineonToneMapping = 3, ACESFilmicToneMapping = 4, CustomToneMapping = 5, UVMapping = 300, CubeReflectionMapping = 301, CubeRefractionMapping = 302, EquirectangularReflectionMapping = 303, EquirectangularRefractionMapping = 304, CubeUVReflectionMapping = 306, CubeUVRefractionMapping = 307, RepeatWrapping = 1e3, ClampToEdgeWrapping = 1001, MirroredRepeatWrapping = 1002, NearestFilter = 1003, NearestMipmapNearestFilter = 1004, NearestMipMapNearestFilter = 1004, NearestMipmapLinearFilter = 1005, NearestMipMapLinearFilter = 1005, LinearFilter = 1006, LinearMipmapNearestFilter = 1007, LinearMipMapNearestFilter = 1007, LinearMipmapLinearFilter = 1008, LinearMipMapLinearFilter = 1008, UnsignedByteType = 1009, ByteType = 1010, ShortType = 1011, UnsignedShortType = 1012, IntType = 1013, UnsignedIntType = 1014, FloatType = 1015, HalfFloatType = 1016, UnsignedShort4444Type = 1017, UnsignedShort5551Type = 1018, UnsignedShort565Type = 1019, UnsignedInt248Type = 1020, AlphaFormat = 1021, RGBFormat = 1022, RGBAFormat = 1023, LuminanceFormat = 1024, LuminanceAlphaFormat = 1025, RGBEFormat = RGBAFormat, DepthFormat = 1026, DepthStencilFormat = 1027, RedFormat = 1028, RedIntegerFormat = 1029, RGFormat = 1030, RGIntegerFormat = 1031, RGBIntegerFormat = 1032, RGBAIntegerFormat = 1033, RGB_S3TC_DXT1_Format = 33776, RGBA_S3TC_DXT1_Format = 33777, RGBA_S3TC_DXT3_Format = 33778, RGBA_S3TC_DXT5_Format = 33779, RGB_PVRTC_4BPPV1_Format = 35840, RGB_PVRTC_2BPPV1_Format = 35841, RGBA_PVRTC_4BPPV1_Format = 35842, RGBA_PVRTC_2BPPV1_Format = 35843, RGB_ETC1_Format = 36196, RGB_ETC2_Format = 37492, RGBA_ETC2_EAC_Format = 37496, RGBA_ASTC_4x4_Format = 37808, RGBA_ASTC_5x4_Format = 37809, RGBA_ASTC_5x5_Format = 37810, RGBA_ASTC_6x5_Format = 37811, RGBA_ASTC_6x6_Format = 37812, RGBA_ASTC_8x5_Format = 37813, RGBA_ASTC_8x6_Format = 37814, RGBA_ASTC_8x8_Format = 37815, RGBA_ASTC_10x5_Format = 37816, RGBA_ASTC_10x6_Format = 37817, RGBA_ASTC_10x8_Format = 37818, RGBA_ASTC_10x10_Format = 37819, RGBA_ASTC_12x10_Format = 37820, RGBA_ASTC_12x12_Format = 37821, RGBA_BPTC_Format = 36492, SRGB8_ALPHA8_ASTC_4x4_Format = 37840, SRGB8_ALPHA8_ASTC_5x4_Format = 37841, SRGB8_ALPHA8_ASTC_5x5_Format = 37842, SRGB8_ALPHA8_ASTC_6x5_Format = 37843, SRGB8_ALPHA8_ASTC_6x6_Format = 37844, SRGB8_ALPHA8_ASTC_8x5_Format = 37845, SRGB8_ALPHA8_ASTC_8x6_Format = 37846, SRGB8_ALPHA8_ASTC_8x8_Format = 37847, SRGB8_ALPHA8_ASTC_10x5_Format = 37848, SRGB8_ALPHA8_ASTC_10x6_Format = 37849, SRGB8_ALPHA8_ASTC_10x8_Format = 37850, SRGB8_ALPHA8_ASTC_10x10_Format = 37851, SRGB8_ALPHA8_ASTC_12x10_Format = 37852, SRGB8_ALPHA8_ASTC_12x12_Format = 37853, LoopOnce = 2200, LoopRepeat = 2201, LoopPingPong = 2202, InterpolateDiscrete = 2300, InterpolateLinear = 2301, InterpolateSmooth = 2302, ZeroCurvatureEnding = 2400, ZeroSlopeEnding = 2401, WrapAroundEnding = 2402, NormalAnimationBlendMode = 2500, AdditiveAnimationBlendMode = 2501, TrianglesDrawMode = 0, TriangleStripDrawMode = 1, TriangleFanDrawMode = 2, LinearEncoding = 3e3, sRGBEncoding = 3001, GammaEncoding = 3007, RGBEEncoding = 3002, LogLuvEncoding = 3003, RGBM7Encoding = 3004, RGBM16Encoding = 3005, RGBDEncoding = 3006, BasicDepthPacking = 3200, RGBADepthPacking = 3201, TangentSpaceNormalMap = 0, ObjectSpaceNormalMap = 1, ZeroStencilOp = 0, KeepStencilOp = 7680, ReplaceStencilOp = 7681, IncrementStencilOp = 7682, DecrementStencilOp = 7683, IncrementWrapStencilOp = 34055, DecrementWrapStencilOp = 34056, InvertStencilOp = 5386, NeverStencilFunc = 512, LessStencilFunc = 513, EqualStencilFunc = 514, LessEqualStencilFunc = 515, GreaterStencilFunc = 516, NotEqualStencilFunc = 517, GreaterEqualStencilFunc = 518, AlwaysStencilFunc = 519, StaticDrawUsage = 35044, DynamicDrawUsage = 35048, StreamDrawUsage = 35040, StaticReadUsage = 35045, DynamicReadUsage = 35049, StreamReadUsage = 35041, StaticCopyUsage = 35046, DynamicCopyUsage = 35050, StreamCopyUsage = 35042, GLSL1 = "100", GLSL3 = "300 es"; function EventDispatcher() { } Object.assign(EventDispatcher.prototype, { addEventListener: function (e, t) { void 0 === this._listeners && (this._listeners = {}); const i = this._listeners; void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t) }, hasEventListener: function (e, t) { if (void 0 === this._listeners) return !1; const i = this._listeners; return void 0 !== i[e] && -1 !== i[e].indexOf(t) }, removeEventListener: function (e, t) { if (void 0 === this._listeners) return; const i = this._listeners[e]; if (void 0 !== i) { const e = i.indexOf(t); -1 !== e && i.splice(e, 1) } }, dispatchEvent: function (e) { if (void 0 === this._listeners) return; const t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; const i = t.slice(0); for (let t = 0, r = i.length; t < r; t++)i[t].call(this, e) } } }); const _lut$1 = []; for (let e = 0; e < 256; e++)_lut$1[e] = (e < 16 ? "0" : "") + e.toString(16); let _seed = 1234567; const MathUtils = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () { const e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return (_lut$1[255 & e] + _lut$1[e >> 8 & 255] + _lut$1[e >> 16 & 255] + _lut$1[e >> 24 & 255] + "-" + _lut$1[255 & t] + _lut$1[t >> 8 & 255] + "-" + _lut$1[t >> 16 & 15 | 64] + _lut$1[t >> 24 & 255] + "-" + _lut$1[63 & i | 128] + _lut$1[i >> 8 & 255] + "-" + _lut$1[i >> 16 & 255] + _lut$1[i >> 24 & 255] + _lut$1[255 & r] + _lut$1[r >> 8 & 255] + _lut$1[r >> 16 & 255] + _lut$1[r >> 24 & 255]).toUpperCase() }, clamp: function (e, t, i) { return Math.max(t, Math.min(i, e)) }, euclideanModulo: function (e, t) { return (e % t + t) % t }, mapLinear: function (e, t, i, r, n) { return r + (e - t) * (n - r) / (i - t) }, lerp: function (e, t, i) { return (1 - i) * e + i * t }, damp: function (e, t, i, r) { return MathUtils.lerp(e, t, 1 - Math.exp(-i * r)) }, pingpong: function (e, t = 1) { return t - Math.abs(MathUtils.euclideanModulo(e, 2 * t) - t) }, smoothstep: function (e, t, i) { return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e) }, smootherstep: function (e, t, i) { return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, seededRandom: function (e) { return void 0 !== e && (_seed = e % 2147483647), _seed = 16807 * _seed % 2147483647, (_seed - 1) / 2147483646 }, degToRad: function (e) { return e * MathUtils.DEG2RAD }, radToDeg: function (e) { return e * MathUtils.RAD2DEG }, isPowerOfTwo: function (e) { return 0 == (e & e - 1) && 0 !== e }, ceilPowerOfTwo: function (e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) }, floorPowerOfTwo: function (e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) }, setQuaternionFromProperEuler: function (e, t, i, r, n) { const a = Math.cos, o = Math.sin, s = a(i / 2), l = o(i / 2), c = a((t + r) / 2), h = o((t + r) / 2), u = a((t - r) / 2), d = o((t - r) / 2), p = a((r - t) / 2), f = o((r - t) / 2); switch (n) { case "XYX": e.set(s * h, l * u, l * d, s * c); break; case "YZY": e.set(l * d, s * h, l * u, s * c); break; case "ZXZ": e.set(l * u, l * d, s * h, s * c); break; case "XZX": e.set(s * h, l * f, l * p, s * c); break; case "YXY": e.set(l * p, s * h, l * f, s * c); break; case "ZYZ": e.set(l * f, l * p, s * h, s * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n) } } }; class Vector2 { constructor(e = 0, t = 0) { this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this) } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this) } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { const t = this.x, i = this.y, r = e.elements; return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { const i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, i = this.y - e.y; return t * t + i * i } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t, i) { return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { const i = Math.cos(t), r = Math.sin(t), n = this.x - e.x, a = this.y - e.y; return this.x = n * i - a * r + e.x, this.y = n * r + a * i + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } } Vector2.prototype.isVector2 = !0; class Matrix3 { constructor() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } set(e, t, i, r, n, a, o, s, l) { const c = this.elements; return c[0] = e, c[1] = r, c[2] = o, c[3] = t, c[4] = n, c[5] = s, c[6] = i, c[7] = a, c[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this } extractBasis(e, t, i) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { const t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const i = e.elements, r = t.elements, n = this.elements, a = i[0], o = i[3], s = i[6], l = i[1], c = i[4], h = i[7], u = i[2], d = i[5], p = i[8], f = r[0], m = r[3], g = r[6], y = r[1], v = r[4], _ = r[7], b = r[2], x = r[5], w = r[8]; return n[0] = a * f + o * y + s * b, n[3] = a * m + o * v + s * x, n[6] = a * g + o * _ + s * w, n[1] = l * f + c * y + h * b, n[4] = l * m + c * v + h * x, n[7] = l * g + c * _ + h * w, n[2] = u * f + d * y + p * b, n[5] = u * m + d * v + p * x, n[8] = u * g + d * _ + p * w, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { const e = this.elements, t = e[0], i = e[1], r = e[2], n = e[3], a = e[4], o = e[5], s = e[6], l = e[7], c = e[8]; return t * a * c - t * o * l - i * n * c + i * o * s + r * n * l - r * a * s } invert() { const e = this.elements, t = e[0], i = e[1], r = e[2], n = e[3], a = e[4], o = e[5], s = e[6], l = e[7], c = e[8], h = c * a - o * l, u = o * s - c * n, d = l * n - a * s, p = t * h + i * u + r * d; if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const f = 1 / p; return e[0] = h * f, e[1] = (r * l - c * i) * f, e[2] = (o * i - r * a) * f, e[3] = u * f, e[4] = (c * t - r * s) * f, e[5] = (r * n - o * t) * f, e[6] = d * f, e[7] = (i * s - l * t) * f, e[8] = (a * t - i * n) * f, this } transpose() { let e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { const t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, i, r, n, a, o) { const s = Math.cos(n), l = Math.sin(n); return this.set(i * s, i * l, -i * (s * a + l * o) + a + e, -r * l, r * s, -r * (-l * a + s * o) + o + t, 0, 0, 1), this } scale(e, t) { const i = this.elements; return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this } rotate(e) { const t = Math.cos(e), i = Math.sin(e), r = this.elements, n = r[0], a = r[3], o = r[6], s = r[1], l = r[4], c = r[7]; return r[0] = t * n + i * s, r[3] = t * a + i * l, r[6] = t * o + i * c, r[1] = -i * n + t * s, r[4] = -i * a + t * l, r[7] = -i * o + t * c, this } translate(e, t) { const i = this.elements; return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this } equals(e) { const t = this.elements, i = e.elements; for (let e = 0; e < 9; e++)if (t[e] !== i[e]) return !1; return !0 } fromArray(e, t = 0) { for (let i = 0; i < 9; i++)this.elements[i] = e[i + t]; return this } toArray(e = [], t = 0) { const i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e } clone() { return (new this.constructor).fromArray(this.elements) } } let _canvas; Matrix3.prototype.isMatrix3 = !0; const ImageUtils = { getDataURL: function (e) { if (/^data:/i.test(e.src)) return e.src; if ("undefined" == typeof HTMLCanvasElement) return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { void 0 === _canvas && (_canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), _canvas.width = e.width, _canvas.height = e.height; const i = _canvas.getContext("2d"); e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = _canvas } return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png") } }; let textureId = 0; class Texture$1 extends EventDispatcher { constructor(e = Texture$1.DEFAULT_IMAGE, t = Texture$1.DEFAULT_MAPPING, i = ClampToEdgeWrapping, r = ClampToEdgeWrapping, n = LinearFilter, a = LinearMipmapLinearFilter, o = RGBAFormat, s = UnsignedByteType, l = 1, c = LinearEncoding) { super(), Object.defineProperty(this, "id", { value: textureId++ }), this.uuid = MathUtils.generateUUID(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = i, this.wrapT = r, this.magFilter = n, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = s, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Matrix3, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this } toJSON(e) { const t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; const i = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { const r = this.image; if (void 0 === r.uuid && (r.uuid = MathUtils.generateUUID()), !t && void 0 === e.images[r.uuid]) { let t; if (Array.isArray(r)) { t = []; for (let e = 0, i = r.length; e < i; e++)r[e].isDataTexture ? t.push(serializeImage(r[e].image)) : t.push(serializeImage(r[e])) } else t = serializeImage(r); e.images[r.uuid] = { uuid: r.uuid, url: t } } i.image = r.uuid } return t || (e.textures[this.uuid] = i), i } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (this.mapping !== UVMapping) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case RepeatWrapping: e.x = e.x - Math.floor(e.x); break; case ClampToEdgeWrapping: e.x = e.x < 0 ? 0 : 1; break; case MirroredRepeatWrapping: 1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case RepeatWrapping: e.y = e.y - Math.floor(e.y); break; case ClampToEdgeWrapping: e.y = e.y < 0 ? 0 : 1; break; case MirroredRepeatWrapping: 1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { !0 === e && this.version++ } } function serializeImage(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? ImageUtils.getDataURL(e) : e.data ? { data: Array.prototype.slice.call(e.data), width: e.width, height: e.height, type: e.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } Texture$1.DEFAULT_IMAGE = void 0, Texture$1.DEFAULT_MAPPING = UVMapping, Texture$1.prototype.isTexture = !0; class Vector4 { constructor(e = 0, t = 0, i = 0, r = 1) { this.x = e, this.y = t, this.z = i, this.w = r } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, i, r) { return this.x = e, this.y = t, this.z = i, this.w = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this) } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this) } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { const t = this.x, i = this.y, r = this.z, n = this.w, a = e.elements; return this.x = a[0] * t + a[4] * i + a[8] * r + a[12] * n, this.y = a[1] * t + a[5] * i + a[9] * r + a[13] * n, this.z = a[2] * t + a[6] * i + a[10] * r + a[14] * n, this.w = a[3] * t + a[7] * i + a[11] * r + a[15] * n, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); const t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, i, r, n; const a = .01, o = .1, s = e.elements, l = s[0], c = s[4], h = s[8], u = s[1], d = s[5], p = s[9], f = s[2], m = s[6], g = s[10]; if (Math.abs(c - u) < a && Math.abs(h - f) < a && Math.abs(p - m) < a) { if (Math.abs(c + u) < o && Math.abs(h + f) < o && Math.abs(p + m) < o && Math.abs(l + d + g - 3) < o) return this.set(1, 0, 0, 0), this; t = Math.PI; const e = (l + 1) / 2, s = (d + 1) / 2, y = (g + 1) / 2, v = (c + u) / 4, _ = (h + f) / 4, b = (p + m) / 4; return e > s && e > y ? e < a ? (i = 0, r = .707106781, n = .707106781) : (i = Math.sqrt(e), r = v / i, n = _ / i) : s > y ? s < a ? (i = .707106781, r = 0, n = .707106781) : (r = Math.sqrt(s), i = v / r, n = b / r) : y < a ? (i = .707106781, r = .707106781, n = 0) : (n = Math.sqrt(y), i = _ / n, r = b / n), this.set(i, r, n, t), this } let y = Math.sqrt((m - p) * (m - p) + (h - f) * (h - f) + (u - c) * (u - c)); return Math.abs(y) < .001 && (y = 1), this.x = (m - p) / y, this.y = (h - f) / y, this.z = (u - c) / y, this.w = Math.acos((l + d + g - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { const i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t, i) { return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } } Vector4.prototype.isVector4 = !0; class WebGLRenderTarget extends EventDispatcher { constructor(e, t, i) { super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new Vector4(0, 0, e, t), this.scissorTest = !1, this.viewport = new Vector4(0, 0, e, t), i = i || {}, this.texture = new Texture$1(void 0, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.image = {}, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = 1, this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : LinearFilter, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null } setTexture(e) { e.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = e } setSize(e, t, i = 1) { this.width === e && this.height === t && this.depth === i || (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } WebGLRenderTarget.prototype.isWebGLRenderTarget = !0; class WebGLMultisampleRenderTarget extends WebGLRenderTarget { constructor(e, t, i) { super(e, t, i), this.samples = 4 } copy(e) { return super.copy.call(this, e), this.samples = e.samples, this } } WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = !0; class Quaternion { constructor(e = 0, t = 0, i = 0, r = 1) { this._x = e, this._y = t, this._z = i, this._w = r } static slerp(e, t, i, r) { return i.copy(e).slerp(t, r) } static slerpFlat(e, t, i, r, n, a, o) { let s = i[r + 0], l = i[r + 1], c = i[r + 2], h = i[r + 3]; const u = n[a + 0], d = n[a + 1], p = n[a + 2], f = n[a + 3]; if (0 === o) return e[t + 0] = s, e[t + 1] = l, e[t + 2] = c, void (e[t + 3] = h); if (1 === o) return e[t + 0] = u, e[t + 1] = d, e[t + 2] = p, void (e[t + 3] = f); if (h !== f || s !== u || l !== d || c !== p) { let e = 1 - o; const t = s * u + l * d + c * p + h * f, i = t >= 0 ? 1 : -1, r = 1 - t * t; if (r > Number.EPSILON) { const n = Math.sqrt(r), a = Math.atan2(n, t * i); e = Math.sin(e * a) / n, o = Math.sin(o * a) / n } const n = o * i; if (s = s * e + u * n, l = l * e + d * n, c = c * e + p * n, h = h * e + f * n, e === 1 - o) { const e = 1 / Math.sqrt(s * s + l * l + c * c + h * h); s *= e, l *= e, c *= e, h *= e } } e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = h } static multiplyQuaternionsFlat(e, t, i, r, n, a) { const o = i[r], s = i[r + 1], l = i[r + 2], c = i[r + 3], h = n[a], u = n[a + 1], d = n[a + 2], p = n[a + 3]; return e[t] = o * p + c * h + s * d - l * u, e[t + 1] = s * p + c * u + l * h - o * d, e[t + 2] = l * p + c * d + o * u - s * h, e[t + 3] = c * p - o * h - s * u - l * d, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, i, r) { return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t) { if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); const i = e._x, r = e._y, n = e._z, a = e._order, o = Math.cos, s = Math.sin, l = o(i / 2), c = o(r / 2), h = o(n / 2), u = s(i / 2), d = s(r / 2), p = s(n / 2); switch (a) { case "XYZ": this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p; break; case "YXZ": this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p; break; case "ZXY": this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p; break; case "ZYX": this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p; break; case "YZX": this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p; break; case "XZY": this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a) }return !1 !== t && this._onChangeCallback(), this } setFromAxisAngle(e, t) { const i = t / 2, r = Math.sin(i); return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this } setFromRotationMatrix(e) { const t = e.elements, i = t[0], r = t[4], n = t[8], a = t[1], o = t[5], s = t[9], l = t[2], c = t[6], h = t[10], u = i + o + h; if (u > 0) { const e = .5 / Math.sqrt(u + 1); this._w = .25 / e, this._x = (c - s) * e, this._y = (n - l) * e, this._z = (a - r) * e } else if (i > o && i > h) { const e = 2 * Math.sqrt(1 + i - o - h); this._w = (c - s) / e, this._x = .25 * e, this._y = (r + a) / e, this._z = (n + l) / e } else if (o > h) { const e = 2 * Math.sqrt(1 + o - i - h); this._w = (n - l) / e, this._x = (r + a) / e, this._y = .25 * e, this._z = (s + c) / e } else { const e = 2 * Math.sqrt(1 + h - i - o); this._w = (a - r) / e, this._x = (n + l) / e, this._y = (s + c) / e, this._z = .25 * e } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let i = e.dot(t) + 1; return i < 1e-6 ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(e), -1, 1))) } rotateTowards(e, t) { const i = this.angleTo(e); if (0 === i) return this; const r = Math.min(1, t / i); return this.slerp(e, r), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { const i = e._x, r = e._y, n = e._z, a = e._w, o = t._x, s = t._y, l = t._z, c = t._w; return this._x = i * c + a * o + r * l - n * s, this._y = r * c + a * s + n * o - i * l, this._z = n * c + a * l + i * s - r * o, this._w = a * c - i * o - r * s - n * l, this._onChangeCallback(), this } slerp(e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); const i = this._x, r = this._y, n = this._z, a = this._w; let o = a * e._w + i * e._x + r * e._y + n * e._z; if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = i, this._y = r, this._z = n, this; const s = 1 - o * o; if (s <= Number.EPSILON) { const e = 1 - t; return this._w = e * a + t * this._w, this._x = e * i + t * this._x, this._y = e * r + t * this._y, this._z = e * n + t * this._z, this.normalize(), this._onChangeCallback(), this } const l = Math.sqrt(s), c = Math.atan2(l, o), h = Math.sin((1 - t) * c) / l, u = Math.sin(t * c) / l; return this._w = a * h + this._w * u, this._x = i * h + this._x * u, this._y = r * h + this._y * u, this._z = n * h + this._z * u, this._onChangeCallback(), this } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } } Quaternion.prototype.isQuaternion = !0; class Vector3 { constructor(e = 0, t = 0, i = 0) { this.x = e, this.y = t, this.z = i } set(e, t, i) { return void 0 === i && (i = this.z), this.x = e, this.y = t, this.z = i, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this) } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this) } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this) } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(_quaternion.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(_quaternion.setFromAxisAngle(e, t)) } applyMatrix3(e) { const t = this.x, i = this.y, r = this.z, n = e.elements; return this.x = n[0] * t + n[3] * i + n[6] * r, this.y = n[1] * t + n[4] * i + n[7] * r, this.z = n[2] * t + n[5] * i + n[8] * r, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { const t = this.x, i = this.y, r = this.z, n = e.elements, a = 1 / (n[3] * t + n[7] * i + n[11] * r + n[15]); return this.x = (n[0] * t + n[4] * i + n[8] * r + n[12]) * a, this.y = (n[1] * t + n[5] * i + n[9] * r + n[13]) * a, this.z = (n[2] * t + n[6] * i + n[10] * r + n[14]) * a, this } applyQuaternion(e) { const t = this.x, i = this.y, r = this.z, n = e.x, a = e.y, o = e.z, s = e.w, l = s * t + a * r - o * i, c = s * i + o * t - n * r, h = s * r + n * i - a * t, u = -n * t - a * i - o * r; return this.x = l * s + u * -n + c * -o - h * -a, this.y = c * s + u * -a + h * -n - l * -o, this.z = h * s + u * -o + l * -a - c * -n, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { const t = this.x, i = this.y, r = this.z, n = e.elements; return this.x = n[0] * t + n[4] * i + n[8] * r, this.y = n[1] * t + n[5] * i + n[9] * r, this.z = n[2] * t + n[6] * i + n[10] * r, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { const i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this } cross(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e) } crossVectors(e, t) { const i = e.x, r = e.y, n = e.z, a = t.x, o = t.y, s = t.z; return this.x = r * s - n * o, this.y = n * a - i * s, this.z = i * o - r * a, this } projectOnVector(e) { const t = e.lengthSq(); if (0 === t) return this.set(0, 0, 0); const i = e.dot(this) / t; return this.copy(e).multiplyScalar(i) } projectOnPlane(e) { return _vector$1.copy(this).projectOnVector(e), this.sub(_vector$1) } reflect(e) { return this.sub(_vector$1.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { const t = Math.sqrt(this.lengthSq() * e.lengthSq()); if (0 === t) return Math.PI / 2; const i = this.dot(e) / t; return Math.acos(MathUtils.clamp(i, -1, 1)) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { const t = this.x - e.x, i = this.y - e.y, r = this.z - e.z; return t * t + i * i + r * r } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, i) { const r = Math.sin(t) * e; return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, i) { return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { const t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this } setFromMatrixScale(e) { const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = i, this.z = r, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, 4 * t) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, 3 * t) } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t, i) { return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } } Vector3.prototype.isVector3 = !0; const _vector$1 = new Vector3, _quaternion = new Quaternion; class Box3 { constructor(e = new Vector3(1 / 0, 1 / 0, 1 / 0), t = new Vector3(-1 / 0, -1 / 0, -1 / 0)) { this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(e) { let t = 1 / 0, i = 1 / 0, r = 1 / 0, n = -1 / 0, a = -1 / 0, o = -1 / 0; for (let s = 0, l = e.length; s < l; s += 3) { const l = e[s], c = e[s + 1], h = e[s + 2]; l < t && (t = l), c < i && (i = c), h < r && (r = h), l > n && (n = l), c > a && (a = c), h > o && (o = h) } return this.min.set(t, i, r), this.max.set(n, a, o), this } setFromBufferAttribute(e) { let t = 1 / 0, i = 1 / 0, r = 1 / 0, n = -1 / 0, a = -1 / 0, o = -1 / 0; for (let s = 0, l = e.count; s < l; s++) { const l = e.getX(s), c = e.getY(s), h = e.getZ(s); l < t && (t = l), c < i && (i = c), h < r && (r = h), l > n && (n = l), c > a && (a = c), h > o && (o = h) } return this.min.set(t, i, r), this.max.set(n, a, o), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, i = e.length; t < i; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const i = _vector$1$1.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } setFromObject(e) { return this.makeEmpty(), this.expandByObject(e) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new Vector3), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new Vector3), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e) { e.updateWorldMatrix(!1, !1); const t = e.geometry; void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), _box.copy(t.boundingBox), _box.applyMatrix4(e.matrixWorld), this.union(_box)); const i = e.children; for (let e = 0, t = i.length; e < t; e++)this.expandByObject(i[e]); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new Vector3), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, _vector$1$1), _vector$1$1.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, i; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant } intersectsTriangle(e) { if (this.isEmpty()) return !1; this.getCenter(_center), _extents.subVectors(this.max, _center), _v0.subVectors(e.a, _center), _v1$1.subVectors(e.b, _center), _v2$1.subVectors(e.c, _center), _f0.subVectors(_v1$1, _v0), _f1.subVectors(_v2$1, _v1$1), _f2.subVectors(_v0, _v2$1); let t = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0]; return !!satForAxes(t, _v0, _v1$1, _v2$1, _extents) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!satForAxes(t, _v0, _v1$1, _v2$1, _extents) && (_triangleNormal.crossVectors(_f0, _f1), t = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z], satForAxes(t, _v0, _v1$1, _v2$1, _extents))) } clampPoint(e, t) { return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new Vector3), t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return _vector$1$1.copy(e).clamp(this.min, this.max).sub(e).length() } getBoundingSphere(e) { return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize(_vector$1$1).length(), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() || (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(_points)), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } Box3.prototype.isBox3 = !0; const _points = [new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3], _vector$1$1 = new Vector3, _box = new Box3, _v0 = new Vector3, _v1$1 = new Vector3, _v2$1 = new Vector3, _f0 = new Vector3, _f1 = new Vector3, _f2 = new Vector3, _center = new Vector3, _extents = new Vector3, _triangleNormal = new Vector3, _testAxis = new Vector3; function satForAxes(e, t, i, r, n) { for (let a = 0, o = e.length - 3; a <= o; a += 3) { _testAxis.fromArray(e, a); const o = n.x * Math.abs(_testAxis.x) + n.y * Math.abs(_testAxis.y) + n.z * Math.abs(_testAxis.z), s = t.dot(_testAxis), l = i.dot(_testAxis), c = r.dot(_testAxis); if (Math.max(-Math.max(s, l, c), Math.min(s, l, c)) > o) return !1 } return !0 } const _box$1 = new Box3; class Sphere { constructor(e = new Vector3, t = -1) { this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(e, t) { const i = this.center; void 0 !== t ? i.copy(t) : _box$1.setFromPoints(e).getCenter(i); let r = 0; for (let t = 0, n = e.length; t < n; t++)r = Math.max(r, i.distanceToSquared(e[t])); return this.radius = Math.sqrt(r), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { const t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { const i = this.center.distanceToSquared(e); return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new Vector3), t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new Box3), this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e) } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return (new this.constructor).copy(this) } } const _vector$2 = new Vector3, _segCenter = new Vector3, _segDir = new Vector3, _diff = new Vector3, _edge1 = new Vector3, _edge2 = new Vector3, _normal = new Vector3; class Ray { constructor(e = new Vector3, t = new Vector3(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new Vector3), t.copy(this.direction).multiplyScalar(e).add(this.origin) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, _vector$2)), this } closestPointToPoint(e, t) { void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new Vector3), t.subVectors(e, this.origin); const i = t.dot(this.direction); return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { const t = _vector$2.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (_vector$2.copy(this.direction).multiplyScalar(t).add(this.origin), _vector$2.distanceToSquared(e)) } distanceSqToSegment(e, t, i, r) { _segCenter.copy(e).add(t).multiplyScalar(.5), _segDir.copy(t).sub(e).normalize(), _diff.copy(this.origin).sub(_segCenter); const n = .5 * e.distanceTo(t), a = -this.direction.dot(_segDir), o = _diff.dot(this.direction), s = -_diff.dot(_segDir), l = _diff.lengthSq(), c = Math.abs(1 - a * a); let h, u, d, p; if (c > 0) if (h = a * s - o, u = a * o - s, p = n * c, h >= 0) if (u >= -p) if (u <= p) { const e = 1 / c; h *= e, u *= e, d = h * (h + a * u + 2 * o) + u * (a * h + u + 2 * s) + l } else u = n, h = Math.max(0, -(a * u + o)), d = -h * h + u * (u + 2 * s) + l; else u = -n, h = Math.max(0, -(a * u + o)), d = -h * h + u * (u + 2 * s) + l; else u <= -p ? (h = Math.max(0, -(-a * n + o)), u = h > 0 ? -n : Math.min(Math.max(-n, -s), n), d = -h * h + u * (u + 2 * s) + l) : u <= p ? (h = 0, u = Math.min(Math.max(-n, -s), n), d = u * (u + 2 * s) + l) : (h = Math.max(0, -(a * n + o)), u = h > 0 ? n : Math.min(Math.max(-n, -s), n), d = -h * h + u * (u + 2 * s) + l); else u = a > 0 ? -n : n, h = Math.max(0, -(a * u + o)), d = -h * h + u * (u + 2 * s) + l; return i && i.copy(this.direction).multiplyScalar(h).add(this.origin), r && r.copy(_segDir).multiplyScalar(u).add(_segCenter), d } intersectSphere(e, t) { _vector$2.subVectors(e.center, this.origin); const i = _vector$2.dot(this.direction), r = _vector$2.dot(_vector$2) - i * i, n = e.radius * e.radius; if (r > n) return null; const a = Math.sqrt(n - r), o = i - a, s = i + a; return o < 0 && s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { const t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; const i = -(this.origin.dot(e.normal) + e.constant) / t; return i >= 0 ? i : null } intersectPlane(e, t) { const i = this.distanceToPlane(e); return null === i ? null : this.at(i, t) } intersectsPlane(e) { const t = e.distanceToPoint(this.origin); if (0 === t) return !0; return e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let i, r, n, a, o, s; const l = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin; return l >= 0 ? (i = (e.min.x - u.x) * l, r = (e.max.x - u.x) * l) : (i = (e.max.x - u.x) * l, r = (e.min.x - u.x) * l), c >= 0 ? (n = (e.min.y - u.y) * c, a = (e.max.y - u.y) * c) : (n = (e.max.y - u.y) * c, a = (e.min.y - u.y) * c), i > a || n > r ? null : ((n > i || i != i) && (i = n), (a < r || r != r) && (r = a), h >= 0 ? (o = (e.min.z - u.z) * h, s = (e.max.z - u.z) * h) : (o = (e.max.z - u.z) * h, s = (e.min.z - u.z) * h), i > s || o > r ? null : ((o > i || i != i) && (i = o), (s < r || r != r) && (r = s), r < 0 ? null : this.at(i >= 0 ? i : r, t))) } intersectsBox(e) { return null !== this.intersectBox(e, _vector$2) } intersectTriangle(e, t, i, r, n) { _edge1.subVectors(t, e), _edge2.subVectors(i, e), _normal.crossVectors(_edge1, _edge2); let a, o = this.direction.dot(_normal); if (o > 0) { if (r) return null; a = 1 } else { if (!(o < 0)) return null; a = -1, o = -o } _diff.subVectors(this.origin, e); const s = a * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); if (s < 0) return null; const l = a * this.direction.dot(_edge1.cross(_diff)); if (l < 0) return null; if (s + l > o) return null; const c = -a * _diff.dot(_normal); return c < 0 ? null : this.at(c / o, n) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return (new this.constructor).copy(this) } } class Matrix4 { constructor() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } set(e, t, i, r, n, a, o, s, l, c, h, u, d, p, f, m) { const g = this.elements; return g[0] = e, g[4] = t, g[8] = i, g[12] = r, g[1] = n, g[5] = a, g[9] = o, g[13] = s, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new Matrix4).fromArray(this.elements) } copy(e) { const t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this } copyPosition(e) { const t = this.elements, i = e.elements; return t[12] = i[12], t[13] = i[13], t[14] = i[14], this } setFromMatrix3(e) { const t = e.elements; return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, i) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this } makeBasis(e, t, i) { return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, i = e.elements, r = 1 / _v1$1$1.setFromMatrixColumn(e, 0).length(), n = 1 / _v1$1$1.setFromMatrixColumn(e, 1).length(), a = 1 / _v1$1$1.setFromMatrixColumn(e, 2).length(); return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * n, t[5] = i[5] * n, t[6] = i[6] * n, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); const t = this.elements, i = e.x, r = e.y, n = e.z, a = Math.cos(i), o = Math.sin(i), s = Math.cos(r), l = Math.sin(r), c = Math.cos(n), h = Math.sin(n); if ("XYZ" === e.order) { const e = a * c, i = a * h, r = o * c, n = o * h; t[0] = s * c, t[4] = -s * h, t[8] = l, t[1] = i + r * l, t[5] = e - n * l, t[9] = -o * s, t[2] = n - e * l, t[6] = r + i * l, t[10] = a * s } else if ("YXZ" === e.order) { const e = s * c, i = s * h, r = l * c, n = l * h; t[0] = e + n * o, t[4] = r * o - i, t[8] = a * l, t[1] = a * h, t[5] = a * c, t[9] = -o, t[2] = i * o - r, t[6] = n + e * o, t[10] = a * s } else if ("ZXY" === e.order) { const e = s * c, i = s * h, r = l * c, n = l * h; t[0] = e - n * o, t[4] = -a * h, t[8] = r + i * o, t[1] = i + r * o, t[5] = a * c, t[9] = n - e * o, t[2] = -a * l, t[6] = o, t[10] = a * s } else if ("ZYX" === e.order) { const e = a * c, i = a * h, r = o * c, n = o * h; t[0] = s * c, t[4] = r * l - i, t[8] = e * l + n, t[1] = s * h, t[5] = n * l + e, t[9] = i * l - r, t[2] = -l, t[6] = o * s, t[10] = a * s } else if ("YZX" === e.order) { const e = a * s, i = a * l, r = o * s, n = o * l; t[0] = s * c, t[4] = n - e * h, t[8] = r * h + i, t[1] = h, t[5] = a * c, t[9] = -o * c, t[2] = -l * c, t[6] = i * h + r, t[10] = e - n * h } else if ("XZY" === e.order) { const e = a * s, i = a * l, r = o * s, n = o * l; t[0] = s * c, t[4] = -h, t[8] = l * c, t[1] = e * h + n, t[5] = a * c, t[9] = i * h - r, t[2] = r * h - i, t[6] = o * c, t[10] = n * h + e } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(_zero, e, _one) } lookAt(e, t, i) { const r = this.elements; return _z.subVectors(e, t), 0 === _z.lengthSq() && (_z.z = 1), _z.normalize(), _x.crossVectors(i, _z), 0 === _x.lengthSq() && (1 === Math.abs(i.z) ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors(i, _z)), _x.normalize(), _y.crossVectors(_z, _x), r[0] = _x.x, r[4] = _y.x, r[8] = _z.x, r[1] = _x.y, r[5] = _y.y, r[9] = _z.y, r[2] = _x.z, r[6] = _y.z, r[10] = _z.z, this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const i = e.elements, r = t.elements, n = this.elements, a = i[0], o = i[4], s = i[8], l = i[12], c = i[1], h = i[5], u = i[9], d = i[13], p = i[2], f = i[6], m = i[10], g = i[14], y = i[3], v = i[7], _ = i[11], b = i[15], x = r[0], w = r[4], S = r[8], M = r[12], T = r[1], A = r[5], E = r[9], C = r[13], L = r[2], R = r[6], D = r[10], P = r[14], O = r[3], I = r[7], k = r[11], B = r[15]; return n[0] = a * x + o * T + s * L + l * O, n[4] = a * w + o * A + s * R + l * I, n[8] = a * S + o * E + s * D + l * k, n[12] = a * M + o * C + s * P + l * B, n[1] = c * x + h * T + u * L + d * O, n[5] = c * w + h * A + u * R + d * I, n[9] = c * S + h * E + u * D + d * k, n[13] = c * M + h * C + u * P + d * B, n[2] = p * x + f * T + m * L + g * O, n[6] = p * w + f * A + m * R + g * I, n[10] = p * S + f * E + m * D + g * k, n[14] = p * M + f * C + m * P + g * B, n[3] = y * x + v * T + _ * L + b * O, n[7] = y * w + v * A + _ * R + b * I, n[11] = y * S + v * E + _ * D + b * k, n[15] = y * M + v * C + _ * P + b * B, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { const e = this.elements, t = e[0], i = e[4], r = e[8], n = e[12], a = e[1], o = e[5], s = e[9], l = e[13], c = e[2], h = e[6], u = e[10], d = e[14]; return e[3] * (+n * s * h - r * l * h - n * o * u + i * l * u + r * o * d - i * s * d) + e[7] * (+t * s * d - t * l * u + n * a * u - r * a * d + r * l * c - n * s * c) + e[11] * (+t * l * h - t * o * d - n * a * h + i * a * d + n * o * c - i * l * c) + e[15] * (-r * o * c - t * s * h + t * o * u + r * a * h - i * a * u + i * s * c) } transpose() { const e = this.elements; let t; return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, i) { const r = this.elements; return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this } invert() { const e = this.elements, t = e[0], i = e[1], r = e[2], n = e[3], a = e[4], o = e[5], s = e[6], l = e[7], c = e[8], h = e[9], u = e[10], d = e[11], p = e[12], f = e[13], m = e[14], g = e[15], y = h * m * l - f * u * l + f * s * d - o * m * d - h * s * g + o * u * g, v = p * u * l - c * m * l - p * s * d + a * m * d + c * s * g - a * u * g, _ = c * f * l - p * h * l + p * o * d - a * f * d - c * o * g + a * h * g, b = p * h * s - c * f * s - p * o * u + a * f * u + c * o * m - a * h * m, x = t * y + i * v + r * _ + n * b; if (0 === x) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const w = 1 / x; return e[0] = y * w, e[1] = (f * u * n - h * m * n - f * r * d + i * m * d + h * r * g - i * u * g) * w, e[2] = (o * m * n - f * s * n + f * r * l - i * m * l - o * r * g + i * s * g) * w, e[3] = (h * s * n - o * u * n - h * r * l + i * u * l + o * r * d - i * s * d) * w, e[4] = v * w, e[5] = (c * m * n - p * u * n + p * r * d - t * m * d - c * r * g + t * u * g) * w, e[6] = (p * s * n - a * m * n - p * r * l + t * m * l + a * r * g - t * s * g) * w, e[7] = (a * u * n - c * s * n + c * r * l - t * u * l - a * r * d + t * s * d) * w, e[8] = _ * w, e[9] = (p * h * n - c * f * n - p * i * d + t * f * d + c * i * g - t * h * g) * w, e[10] = (a * f * n - p * o * n + p * i * l - t * f * l - a * i * g + t * o * g) * w, e[11] = (c * o * n - a * h * n - c * i * l + t * h * l + a * i * d - t * o * d) * w, e[12] = b * w, e[13] = (c * f * r - p * h * r + p * i * u - t * f * u - c * i * m + t * h * m) * w, e[14] = (p * o * r - a * f * r - p * i * s + t * f * s + a * i * m - t * o * m) * w, e[15] = (a * h * r - c * o * r + c * i * s - t * h * s - a * i * u + t * o * u) * w, this } scale(e) { const t = this.elements, i = e.x, r = e.y, n = e.z; return t[0] *= i, t[4] *= r, t[8] *= n, t[1] *= i, t[5] *= r, t[9] *= n, t[2] *= i, t[6] *= r, t[10] *= n, t[3] *= i, t[7] *= r, t[11] *= n, this } getMaxScaleOnAxis() { const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, i, r)) } makeTranslation(e, t, i) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this } makeRotationX(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { const t = Math.cos(e), i = Math.sin(e); return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { const i = Math.cos(t), r = Math.sin(t), n = 1 - i, a = e.x, o = e.y, s = e.z, l = n * a, c = n * o; return this.set(l * a + i, l * o - r * s, l * s + r * o, 0, l * o + r * s, c * o + i, c * s - r * a, 0, l * s - r * o, c * s + r * a, n * s * s + i, 0, 0, 0, 0, 1), this } makeScale(e, t, i) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this } makeShear(e, t, i) { return this.set(1, t, i, 0, e, 1, i, 0, e, t, 1, 0, 0, 0, 0, 1), this } compose(e, t, i) { const r = this.elements, n = t._x, a = t._y, o = t._z, s = t._w, l = n + n, c = a + a, h = o + o, u = n * l, d = n * c, p = n * h, f = a * c, m = a * h, g = o * h, y = s * l, v = s * c, _ = s * h, b = i.x, x = i.y, w = i.z; return r[0] = (1 - (f + g)) * b, r[1] = (d + _) * b, r[2] = (p - v) * b, r[3] = 0, r[4] = (d - _) * x, r[5] = (1 - (u + g)) * x, r[6] = (m + y) * x, r[7] = 0, r[8] = (p + v) * w, r[9] = (m - y) * w, r[10] = (1 - (u + f)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this } decompose(e, t, i) { const r = this.elements; let n = _v1$1$1.set(r[0], r[1], r[2]).length(); const a = _v1$1$1.set(r[4], r[5], r[6]).length(), o = _v1$1$1.set(r[8], r[9], r[10]).length(); this.determinant() < 0 && (n = -n), e.x = r[12], e.y = r[13], e.z = r[14], _m1.copy(this); const s = 1 / n, l = 1 / a, c = 1 / o; return _m1.elements[0] *= s, _m1.elements[1] *= s, _m1.elements[2] *= s, _m1.elements[4] *= l, _m1.elements[5] *= l, _m1.elements[6] *= l, _m1.elements[8] *= c, _m1.elements[9] *= c, _m1.elements[10] *= c, t.setFromRotationMatrix(_m1), i.x = n, i.y = a, i.z = o, this } makePerspective(e, t, i, r, n, a) { void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); const o = this.elements, s = 2 * n / (t - e), l = 2 * n / (i - r), c = (t + e) / (t - e), h = (i + r) / (i - r), u = -(a + n) / (a - n), d = -2 * a * n / (a - n); return o[0] = s, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this } makeOrthographic(e, t, i, r, n, a) { const o = this.elements, s = 1 / (t - e), l = 1 / (i - r), c = 1 / (a - n), h = (t + e) * s, u = (i + r) * l, d = (a + n) * c; return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this } equals(e) { const t = this.elements, i = e.elements; for (let e = 0; e < 16; e++)if (t[e] !== i[e]) return !1; return !0 } fromArray(e, t = 0) { for (let i = 0; i < 16; i++)this.elements[i] = e[i + t]; return this } toArray(e = [], t = 0) { const i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e } } Matrix4.prototype.isMatrix4 = !0; const _v1$1$1 = new Vector3, _m1 = new Matrix4, _zero = new Vector3(0, 0, 0), _one = new Vector3(1, 1, 1), _x = new Vector3, _y = new Vector3, _z = new Vector3, _matrix = new Matrix4, _quaternion$1 = new Quaternion; class Euler { constructor(e = 0, t = 0, i = 0, r = Euler.DefaultOrder) { this._x = e, this._y = t, this._z = i, this._order = r } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, i, r) { return this._x = e, this._y = t, this._z = i, this._order = r || this._order, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t, i) { const r = MathUtils.clamp, n = e.elements, a = n[0], o = n[4], s = n[8], l = n[1], c = n[5], h = n[9], u = n[2], d = n[6], p = n[10]; switch (t = t || this._order) { case "XYZ": this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-h, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, c), this._z = 0); break; case "YXZ": this._x = Math.asin(-r(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, a), this._z = 0); break; case "ZXY": this._x = Math.asin(r(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, a)); break; case "ZYX": this._y = Math.asin(-r(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-o, c)); break; case "YZX": this._z = Math.asin(r(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, a)) : (this._x = 0, this._y = Math.atan2(s, p)); break; case "XZY": this._z = Math.asin(-r(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-h, p), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, !1 !== i && this._onChangeCallback(), this } setFromQuaternion(e, t, i) { return _matrix.makeRotationFromQuaternion(e), this.setFromRotationMatrix(_matrix, t, i) } setFromVector3(e, t) { return this.set(e.x, e.y, e.z, t || this._order) } reorder(e) { return _quaternion$1.setFromEuler(this), this.setFromQuaternion(_quaternion$1, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } toVector3(e) { return e ? e.set(this._x, this._y, this._z) : new Vector3(this._x, this._y, this._z) } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } } Euler.prototype.isEuler = !0, Euler.DefaultOrder = "XYZ", Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; class Layers { constructor() { this.mask = 1 } set(e) { this.mask = 1 << e | 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return 0 != (this.mask & e.mask) } } let _object3DId = 0; const _v1$2 = new Vector3, _q1 = new Quaternion, _m1$1 = new Matrix4, _target = new Vector3, _position = new Vector3, _scale = new Vector3, _quaternion$2 = new Quaternion, _xAxis = new Vector3(1, 0, 0), _yAxis = new Vector3(0, 1, 0), _zAxis = new Vector3(0, 0, 1), _addedEvent = { type: "added" }, _removedEvent = { type: "removed" }; function Object3D() { Object.defineProperty(this, "id", { value: _object3DId++ }), this.uuid = MathUtils.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DefaultUp.clone(); const e = new Vector3, t = new Euler, i = new Quaternion, r = new Vector3(1, 1, 1); t._onChange((function () { i.setFromEuler(t, !1) })), i._onChange((function () { t.setFromQuaternion(i, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: i }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new Matrix4 }, normalMatrix: { value: new Matrix3 } }), this.matrix = new Matrix4, this.matrixWorld = new Matrix4, this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Layers, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } Object3D.DefaultUp = new Vector3(0, 1, 0), Object3D.DefaultMatrixAutoUpdate = !0, Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), { constructor: Object3D, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix4: function (e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function (e) { return this.quaternion.premultiply(e), this }, setRotationFromAxisAngle: function (e, t) { this.quaternion.setFromAxisAngle(e, t) }, setRotationFromEuler: function (e) { this.quaternion.setFromEuler(e, !0) }, setRotationFromMatrix: function (e) { this.quaternion.setFromRotationMatrix(e) }, setRotationFromQuaternion: function (e) { this.quaternion.copy(e) }, rotateOnAxis: function (e, t) { return _q1.setFromAxisAngle(e, t), this.quaternion.multiply(_q1), this }, rotateOnWorldAxis: function (e, t) { return _q1.setFromAxisAngle(e, t), this.quaternion.premultiply(_q1), this }, rotateX: function (e) { return this.rotateOnAxis(_xAxis, e) }, rotateY: function (e) { return this.rotateOnAxis(_yAxis, e) }, rotateZ: function (e) { return this.rotateOnAxis(_zAxis, e) }, translateOnAxis: function (e, t) { return _v1$2.copy(e).applyQuaternion(this.quaternion), this.position.add(_v1$2.multiplyScalar(t)), this }, translateX: function (e) { return this.translateOnAxis(_xAxis, e) }, translateY: function (e) { return this.translateOnAxis(_yAxis, e) }, translateZ: function (e) { return this.translateOnAxis(_zAxis, e) }, localToWorld: function (e) { return e.applyMatrix4(this.matrixWorld) }, worldToLocal: function (e) { return e.applyMatrix4(_m1$1.copy(this.matrixWorld).invert()) }, lookAt: function (e, t, i) { e.isVector3 ? _target.copy(e) : _target.set(e, t, i); const r = this.parent; this.updateWorldMatrix(!0, !1), _position.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _m1$1.lookAt(_position, _target, this.up) : _m1$1.lookAt(_target, _position, this.up), this.quaternion.setFromRotationMatrix(_m1$1), r && (_m1$1.extractRotation(r.matrixWorld), _q1.setFromRotationMatrix(_m1$1), this.quaternion.premultiply(_q1.invert())) }, add: function (e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(_addedEvent)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) }, remove: function (e) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } const t = this.children.indexOf(e); return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(_removedEvent)), this }, clear: function () { for (let e = 0; e < this.children.length; e++) { const t = this.children[e]; t.parent = null, t.dispatchEvent(_removedEvent) } return this.children.length = 0, this }, attach: function (e) { return this.updateWorldMatrix(!0, !1), _m1$1.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), _m1$1.multiply(e.parent.matrixWorld)), e.applyMatrix4(_m1$1), this.add(e), e.updateWorldMatrix(!1, !0), this }, getObjectById: function (e) { return this.getObjectByProperty("id", e) }, getObjectByName: function (e) { return this.getObjectByProperty("name", e) }, getObjectByProperty: function (e, t) { if (this[e] === t) return this; for (let i = 0, r = this.children.length; i < r; i++) { const r = this.children[i].getObjectByProperty(e, t); if (void 0 !== r) return r } }, getWorldPosition: function (e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new Vector3), this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: function (e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new Quaternion), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position, e, _scale), e }, getWorldScale: function (e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), e = new Vector3), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position, _quaternion$2, e), e }, getWorldDirection: function (e) { void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new Vector3), this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() }, raycast: function () { }, traverse: function (e) { e(this); const t = this.children; for (let i = 0, r = t.length; i < r; i++)t[i].traverse(e) }, traverseVisible: function (e) { if (!1 === this.visible) return; e(this); const t = this.children; for (let i = 0, r = t.length; i < r; i++)t[i].traverseVisible(e) }, traverseAncestors: function (e) { const t = this.parent; null !== t && (e(t), t.traverseAncestors(e)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); const t = this.children; for (let i = 0, r = t.length; i < r; i++)t[i].updateMatrixWorld(e) }, updateWorldMatrix: function (e, t) { const i = this.parent; if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) { const e = this.children; for (let t = 0, i = e.length; t < i; t++)e[t].updateWorldMatrix(!1, !0) } }, toJSON: function (e) { const t = void 0 === e || "string" == typeof e, i = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, i.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const r = {}; function n(t, i) { return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid } if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) { r.geometry = n(e.geometries, this.geometry); const t = this.geometry.parameters; if (void 0 !== t && void 0 !== t.shapes) { const i = t.shapes; if (Array.isArray(i)) for (let t = 0, r = i.length; t < r; t++) { const r = i[t]; n(e.shapes, r) } else n(e.shapes, i) } } if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (n(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const t = []; for (let i = 0, r = this.material.length; i < r; i++)t.push(n(e.materials, this.material[i])); r.material = t } else r.material = n(e.materials, this.material); if (this.children.length > 0) { r.children = []; for (let t = 0; t < this.children.length; t++)r.children.push(this.children[t].toJSON(e).object) } if (this.animations.length > 0) { r.animations = []; for (let t = 0; t < this.animations.length; t++) { const i = this.animations[t]; r.animations.push(n(e.animations, i)) } } if (t) { const t = a(e.geometries), r = a(e.materials), n = a(e.textures), o = a(e.images), s = a(e.shapes), l = a(e.skeletons), c = a(e.animations); t.length > 0 && (i.geometries = t), r.length > 0 && (i.materials = r), n.length > 0 && (i.textures = n), o.length > 0 && (i.images = o), s.length > 0 && (i.shapes = s), l.length > 0 && (i.skeletons = l), c.length > 0 && (i.animations = c) } return i.object = r, i; function a(e) { const t = []; for (const i in e) { const r = e[i]; delete r.metadata, t.push(r) } return t } }, clone: function (e) { return (new this.constructor).copy(this, e) }, copy: function (e, t = !0) { if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t) for (let t = 0; t < e.children.length; t++) { const i = e.children[t]; this.add(i.clone()) } return this } }); const _vector1 = new Vector3, _vector2 = new Vector3, _normalMatrix = new Matrix3; class Plane { constructor(e = new Vector3(1, 0, 0), t = 0) { this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, i, r) { return this.normal.set(e, t, i), this.constant = r, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, i) { const r = _vector1.subVectors(i, t).cross(_vector2.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(r, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { const e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new Vector3), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) } intersectLine(e, t) { void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"), t = new Vector3); const i = e.delta(_vector1), r = this.normal.dot(i); if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0; const n = -(e.start.dot(this.normal) + this.constant) / r; return n < 0 || n > 1 ? void 0 : t.copy(i).multiplyScalar(n).add(e.start) } intersectsLine(e) { const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end); return t < 0 && i > 0 || i < 0 && t > 0 } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new Vector3), e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const i = t || _normalMatrix.getNormalMatrix(e), r = this.coplanarPoint(_vector1).applyMatrix4(e), n = this.normal.applyMatrix3(i).normalize(); return this.constant = -r.dot(n), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return (new this.constructor).copy(this) } } Plane.prototype.isPlane = !0; const _v0$1 = new Vector3, _v1$3 = new Vector3, _v2$1$1 = new Vector3, _v3$1 = new Vector3, _vab = new Vector3, _vac = new Vector3, _vbc = new Vector3, _vap = new Vector3, _vbp = new Vector3, _vcp = new Vector3; class Triangle { constructor(e = new Vector3, t = new Vector3, i = new Vector3) { this.a = e, this.b = t, this.c = i } static getNormal(e, t, i, r) { void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new Vector3), r.subVectors(i, t), _v0$1.subVectors(e, t), r.cross(_v0$1); const n = r.lengthSq(); return n > 0 ? r.multiplyScalar(1 / Math.sqrt(n)) : r.set(0, 0, 0) } static getBarycoord(e, t, i, r, n) { _v0$1.subVectors(r, t), _v1$3.subVectors(i, t), _v2$1$1.subVectors(e, t); const a = _v0$1.dot(_v0$1), o = _v0$1.dot(_v1$3), s = _v0$1.dot(_v2$1$1), l = _v1$3.dot(_v1$3), c = _v1$3.dot(_v2$1$1), h = a * l - o * o; if (void 0 === n && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), n = new Vector3), 0 === h) return n.set(-2, -1, -1); const u = 1 / h, d = (l * s - o * c) * u, p = (a * c - o * s) * u; return n.set(1 - d - p, p, d) } static containsPoint(e, t, i, r) { return this.getBarycoord(e, t, i, r, _v3$1), _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1 } static getUV(e, t, i, r, n, a, o, s) { return this.getBarycoord(e, t, i, r, _v3$1), s.set(0, 0), s.addScaledVector(n, _v3$1.x), s.addScaledVector(a, _v3$1.y), s.addScaledVector(o, _v3$1.z), s } static isFrontFacing(e, t, i, r) { return _v0$1.subVectors(i, t), _v1$3.subVectors(e, t), _v0$1.cross(_v1$3).dot(r) < 0 } set(e, t, i) { return this.a.copy(e), this.b.copy(t), this.c.copy(i), this } setFromPointsAndIndices(e, t, i, r) { return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return _v0$1.subVectors(this.c, this.b), _v1$3.subVectors(this.a, this.b), .5 * _v0$1.cross(_v1$3).length() } getMidpoint(e) { return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new Vector3), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return Triangle.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new Plane), e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return Triangle.getBarycoord(e, this.a, this.b, this.c, t) } getUV(e, t, i, r, n) { return Triangle.getUV(e, this.a, this.b, this.c, t, i, r, n) } containsPoint(e) { return Triangle.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return Triangle.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new Vector3); const i = this.a, r = this.b, n = this.c; let a, o; _vab.subVectors(r, i), _vac.subVectors(n, i), _vap.subVectors(e, i); const s = _vab.dot(_vap), l = _vac.dot(_vap); if (s <= 0 && l <= 0) return t.copy(i); _vbp.subVectors(e, r); const c = _vab.dot(_vbp), h = _vac.dot(_vbp); if (c >= 0 && h <= c) return t.copy(r); const u = s * h - c * l; if (u <= 0 && s >= 0 && c <= 0) return a = s / (s - c), t.copy(i).addScaledVector(_vab, a); _vcp.subVectors(e, n); const d = _vab.dot(_vcp), p = _vac.dot(_vcp); if (p >= 0 && d <= p) return t.copy(n); const f = d * l - s * p; if (f <= 0 && l >= 0 && p <= 0) return o = l / (l - p), t.copy(i).addScaledVector(_vac, o); const m = c * p - d * h; if (m <= 0 && h - c >= 0 && d - p >= 0) return _vbc.subVectors(n, r), o = (h - c) / (h - c + (d - p)), t.copy(r).addScaledVector(_vbc, o); const g = 1 / (m + f + u); return a = f * g, o = u * g, t.copy(i).addScaledVector(_vab, a).addScaledVector(_vac, o) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let materialId = 0; function Material$1() { Object.defineProperty(this, "id", { value: materialId++ }), this.uuid = MathUtils.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = NormalBlending, this.side = FrontSide, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = SrcAlphaFactor, this.blendDst = OneMinusSrcAlphaFactor, this.blendEquation = AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = LessEqualDepth, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = AlwaysStencilFunc, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = KeepStencilOp, this.stencilZFail = KeepStencilOp, this.stencilZPass = KeepStencilOp, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 } Material$1.prototype = Object.assign(Object.create(EventDispatcher.prototype), { constructor: Material$1, isMaterial: !0, onBeforeCompile: function () { }, customProgramCacheKey: function () { return this.onBeforeCompile.toString() }, setValues: function (e) { if (void 0 !== e) for (const t in e) { const i = e[t]; if (void 0 === i) { console.warn("THREE.Material: '" + t + "' parameter is undefined."); continue } if ("shading" === t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i === FlatShading; continue } const r = this[t]; void 0 !== r ? r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") } }, toJSON: function (e) { const t = void 0 === e || "string" == typeof e; t && (e = { textures: {}, images: {} }); const i = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function r(e) { const t = []; for (const i in e) { const r = e[i]; delete r.metadata, t.push(r) } return t } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.sheen && this.sheen.isColor && (i.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, i.reflectivity = this.reflectivity, i.refractionRatio = this.refractionRatio, void 0 !== this.combine && (i.combine = this.combine), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== NormalBlending && (i.blending = this.blending), this.side !== FrontSide && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (i.morphTargets = !0), !0 === this.morphNormals && (i.morphNormals = !0), !0 === this.skinning && (i.skinning = !0), !0 === this.flatShading && (i.flatShading = this.flatShading), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), t) { const t = r(e.textures), n = r(e.images); t.length > 0 && (i.textures = t), n.length > 0 && (i.images = n) } return i }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { this.name = e.name, this.fog = e.fog, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite; const t = e.clippingPlanes; let i = null; if (null !== t) { const e = t.length; i = new Array(e); for (let r = 0; r !== e; ++r)i[r] = t[r].clone() } return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(Material$1.prototype, "needsUpdate", { set: function (e) { !0 === e && this.version++ } }); const _colorKeywords = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, _hslA = { h: 0, s: 0, l: 0 }, _hslB = { h: 0, s: 0, l: 0 }; function hue2rgb(e, t, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e } function SRGBToLinear(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } function LinearToSRGB(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } class Color$1 { constructor(e, t, i) { return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i) } set(e) { return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this } setRGB(e, t, i) { return this.r = e, this.g = t, this.b = i, this } setHSL(e, t, i) { if (e = MathUtils.euclideanModulo(e, 1), t = MathUtils.clamp(t, 0, 1), i = MathUtils.clamp(i, 0, 1), 0 === t) this.r = this.g = this.b = i; else { const r = i <= .5 ? i * (1 + t) : i + t - i * t, n = 2 * i - r; this.r = hue2rgb(n, r, e + 1 / 3), this.g = hue2rgb(n, r, e), this.b = hue2rgb(n, r, e - 1 / 3) } return this } setStyle(e) { function t(t) { void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } let i; if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) { let e; const r = i[1], n = i[2]; switch (r) { case "rgb": case "rgba": if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, t(e[4]), this; if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, t(e[4]), this; break; case "hsl": case "hsla": if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n)) { const i = parseFloat(e[1]) / 360, r = parseInt(e[2], 10) / 100, n = parseInt(e[3], 10) / 100; return t(e[4]), this.setHSL(i, r, n) } } } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) { const e = i[1], t = e.length; if (3 === t) return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255, this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255, this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255, this; if (6 === t) return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255, this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255, this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255, this } return e && e.length > 0 ? this.setColorName(e) : this } setColorName(e) { const t = _colorKeywords[e]; return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copyGammaToLinear(e, t = 2) { return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this } copyLinearToGamma(e, t = 2) { const i = t > 0 ? 1 / t : 1; return this.r = Math.pow(e.r, i), this.g = Math.pow(e.g, i), this.b = Math.pow(e.b, i), this } convertGammaToLinear(e) { return this.copyGammaToLinear(this, e), this } convertLinearToGamma(e) { return this.copyLinearToGamma(this, e), this } copySRGBToLinear(e) { return this.r = SRGBToLinear(e.r), this.g = SRGBToLinear(e.g), this.b = SRGBToLinear(e.b), this } copyLinearToSRGB(e) { return this.r = LinearToSRGB(e.r), this.g = LinearToSRGB(e.g), this.b = LinearToSRGB(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 } getHexString() { return ("000000" + this.getHex().toString(16)).slice(-6) } getHSL(e) { void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = { h: 0, s: 0, l: 0 }); const t = this.r, i = this.g, r = this.b, n = Math.max(t, i, r), a = Math.min(t, i, r); let o, s; const l = (a + n) / 2; if (a === n) o = 0, s = 0; else { const e = n - a; switch (s = l <= .5 ? e / (n + a) : e / (2 - n - a), n) { case t: o = (i - r) / e + (i < r ? 6 : 0); break; case i: o = (r - t) / e + 2; break; case r: o = (t - i) / e + 4 }o /= 6 } return e.h = o, e.s = s, e.l = l, e } getStyle() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" } offsetHSL(e, t, i) { return this.getHSL(_hslA), _hslA.h += e, _hslA.s += t, _hslA.l += i, this.setHSL(_hslA.h, _hslA.s, _hslA.l), this } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, i) { return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this } lerpHSL(e, t) { this.getHSL(_hslA), e.getHSL(_hslB); const i = MathUtils.lerp(_hslA.h, _hslB.h, t), r = MathUtils.lerp(_hslA.s, _hslB.s, t), n = MathUtils.lerp(_hslA.l, _hslB.l, t); return this.setHSL(i, r, n), this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this } toJSON() { return this.getHex() } } Color$1.NAMES = _colorKeywords, Color$1.prototype.isColor = !0, Color$1.prototype.r = 1, Color$1.prototype.g = 1, Color$1.prototype.b = 1; class MeshBasicMaterial extends Material$1 { constructor(e) { super(), this.type = "MeshBasicMaterial", this.color = new Color$1(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this } } MeshBasicMaterial.prototype.isMeshBasicMaterial = !0; const _vector$3 = new Vector3, _vector2$1 = new Vector2; function BufferAttribute(e, t, i) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === i, this.usage = StaticDrawUsage, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function Int8BufferAttribute(e, t, i) { BufferAttribute.call(this, new Int8Array(e), t, i) } function Uint8BufferAttribute(e, t, i) { BufferAttribute.call(this, new Uint8Array(e), t, i) } function Uint8ClampedBufferAttribute(e, t, i) { BufferAttribute.call(this, new Uint8ClampedArray(e), t, i) } function Int16BufferAttribute(e, t, i) { BufferAttribute.call(this, new Int16Array(e), t, i) } function Uint16BufferAttribute(e, t, i) { BufferAttribute.call(this, new Uint16Array(e), t, i) } function Int32BufferAttribute(e, t, i) { BufferAttribute.call(this, new Int32Array(e), t, i) } function Uint32BufferAttribute(e, t, i) { BufferAttribute.call(this, new Uint32Array(e), t, i) } function Float16BufferAttribute(e, t, i) { BufferAttribute.call(this, new Uint16Array(e), t, i) } function Float32BufferAttribute(e, t, i) { BufferAttribute.call(this, new Float32Array(e), t, i) } function Float64BufferAttribute(e, t, i) { BufferAttribute.call(this, new Float64Array(e), t, i) } function arrayMax(e) { if (0 === e.length) return -1 / 0; let t = e[0]; for (let i = 1, r = e.length; i < r; ++i)e[i] > t && (t = e[i]); return t } Object.defineProperty(BufferAttribute.prototype, "needsUpdate", { set: function (e) { !0 === e && this.version++ } }), Object.assign(BufferAttribute.prototype, { isBufferAttribute: !0, onUploadCallback: function () { }, setUsage: function (e) { return this.usage = e, this }, copy: function (e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this }, copyAt: function (e, t, i) { e *= this.itemSize, i *= t.itemSize; for (let r = 0, n = this.itemSize; r < n; r++)this.array[e + r] = t.array[i + r]; return this }, copyArray: function (e) { return this.array.set(e), this }, copyColorsArray: function (e) { const t = this.array; let i = 0; for (let r = 0, n = e.length; r < n; r++) { let n = e[r]; void 0 === n && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), n = new Color$1), t[i++] = n.r, t[i++] = n.g, t[i++] = n.b } return this }, copyVector2sArray: function (e) { const t = this.array; let i = 0; for (let r = 0, n = e.length; r < n; r++) { let n = e[r]; void 0 === n && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), n = new Vector2), t[i++] = n.x, t[i++] = n.y } return this }, copyVector3sArray: function (e) { const t = this.array; let i = 0; for (let r = 0, n = e.length; r < n; r++) { let n = e[r]; void 0 === n && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), n = new Vector3), t[i++] = n.x, t[i++] = n.y, t[i++] = n.z } return this }, copyVector4sArray: function (e) { const t = this.array; let i = 0; for (let r = 0, n = e.length; r < n; r++) { let n = e[r]; void 0 === n && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), n = new Vector4), t[i++] = n.x, t[i++] = n.y, t[i++] = n.z, t[i++] = n.w } return this }, applyMatrix3: function (e) { if (2 === this.itemSize) for (let t = 0, i = this.count; t < i; t++)_vector2$1.fromBufferAttribute(this, t), _vector2$1.applyMatrix3(e), this.setXY(t, _vector2$1.x, _vector2$1.y); else if (3 === this.itemSize) for (let t = 0, i = this.count; t < i; t++)_vector$3.fromBufferAttribute(this, t), _vector$3.applyMatrix3(e), this.setXYZ(t, _vector$3.x, _vector$3.y, _vector$3.z); return this }, applyMatrix4: function (e) { for (let t = 0, i = this.count; t < i; t++)_vector$3.x = this.getX(t), _vector$3.y = this.getY(t), _vector$3.z = this.getZ(t), _vector$3.applyMatrix4(e), this.setXYZ(t, _vector$3.x, _vector$3.y, _vector$3.z); return this }, applyNormalMatrix: function (e) { for (let t = 0, i = this.count; t < i; t++)_vector$3.x = this.getX(t), _vector$3.y = this.getY(t), _vector$3.z = this.getZ(t), _vector$3.applyNormalMatrix(e), this.setXYZ(t, _vector$3.x, _vector$3.y, _vector$3.z); return this }, transformDirection: function (e) { for (let t = 0, i = this.count; t < i; t++)_vector$3.x = this.getX(t), _vector$3.y = this.getY(t), _vector$3.z = this.getZ(t), _vector$3.transformDirection(e), this.setXYZ(t, _vector$3.x, _vector$3.y, _vector$3.z); return this }, set: function (e, t = 0) { return this.array.set(e, t), this }, getX: function (e) { return this.array[e * this.itemSize] }, setX: function (e, t) { return this.array[e * this.itemSize] = t, this }, getY: function (e) { return this.array[e * this.itemSize + 1] }, setY: function (e, t) { return this.array[e * this.itemSize + 1] = t, this }, getZ: function (e) { return this.array[e * this.itemSize + 2] }, setZ: function (e, t) { return this.array[e * this.itemSize + 2] = t, this }, getW: function (e) { return this.array[e * this.itemSize + 3] }, setW: function (e, t) { return this.array[e * this.itemSize + 3] = t, this }, setXY: function (e, t, i) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this }, setXYZ: function (e, t, i, r) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this }, setXYZW: function (e, t, i, r, n) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = n, this }, onUpload: function (e) { return this.onUploadCallback = e, this }, clone: function () { return new this.constructor(this.array, this.itemSize).copy(this) }, toJSON: function () { return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized } } }), Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Int8BufferAttribute.prototype.constructor = Int8BufferAttribute, Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute, Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute, Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Int16BufferAttribute.prototype.constructor = Int16BufferAttribute, Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute, Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Int32BufferAttribute.prototype.constructor = Int32BufferAttribute, Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute, Float16BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Float16BufferAttribute.prototype.constructor = Float16BufferAttribute, Float16BufferAttribute.prototype.isFloat16BufferAttribute = !0, Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Float32BufferAttribute.prototype.constructor = Float32BufferAttribute, Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype), Float64BufferAttribute.prototype.constructor = Float64BufferAttribute; const TYPED_ARRAYS = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: Uint8ClampedArray, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function getTypedArray(e, t) { return new TYPED_ARRAYS[e](t) } let _id = 0; const _m1$2 = new Matrix4, _obj = new Object3D, _offset = new Vector3, _box$2 = new Box3, _boxMorphTargets = new Box3, _vector$4 = new Vector3; function BufferGeometry() { Object.defineProperty(this, "id", { value: _id++ }), this.uuid = MathUtils.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), { constructor: BufferGeometry, isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (e) { return Array.isArray(e) ? this.index = new (arrayMax(e) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(e, 1) : this.index = e, this }, getAttribute: function (e) { return this.attributes[e] }, setAttribute: function (e, t) { return this.attributes[e] = t, this }, deleteAttribute: function (e) { return delete this.attributes[e], this }, hasAttribute: function (e) { return void 0 !== this.attributes[e] }, addGroup: function (e, t, i = 0) { this.groups.push({ start: e, count: t, materialIndex: i }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (e, t) { this.drawRange.start = e, this.drawRange.count = t }, applyMatrix4: function (e) { const t = this.attributes.position; void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0); const i = this.attributes.normal; if (void 0 !== i) { const t = (new Matrix3).getNormalMatrix(e); i.applyNormalMatrix(t), i.needsUpdate = !0 } const r = this.attributes.tangent; return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: function (e) { return _m1$2.makeRotationX(e), this.applyMatrix4(_m1$2), this }, rotateY: function (e) { return _m1$2.makeRotationY(e), this.applyMatrix4(_m1$2), this }, rotateZ: function (e) { return _m1$2.makeRotationZ(e), this.applyMatrix4(_m1$2), this }, translate: function (e, t, i) { return _m1$2.makeTranslation(e, t, i), this.applyMatrix4(_m1$2), this }, scale: function (e, t, i) { return _m1$2.makeScale(e, t, i), this.applyMatrix4(_m1$2), this }, lookAt: function (e) { return _obj.lookAt(e), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this }, center: function () { return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x, _offset.y, _offset.z), this }, setFromPoints: function (e) { const t = []; for (let i = 0, r = e.length; i < r; i++) { const r = e[i]; t.push(r.x, r.y, r.z || 0) } return this.setAttribute("position", new Float32BufferAttribute(t, 3)), this }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new Box3); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Vector3(-1 / 0, -1 / 0, -1 / 0), new Vector3(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), t) for (let e = 0, i = t.length; e < i; e++) { const i = t[e]; _box$2.setFromBufferAttribute(i), this.morphTargetsRelative ? (_vector$4.addVectors(this.boundingBox.min, _box$2.min), this.boundingBox.expandByPoint(_vector$4), _vector$4.addVectors(this.boundingBox.max, _box$2.max), this.boundingBox.expandByPoint(_vector$4)) : (this.boundingBox.expandByPoint(_box$2.min), this.boundingBox.expandByPoint(_box$2.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Sphere); const e = this.attributes.position, t = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Vector3, 1 / 0); if (e) { const i = this.boundingSphere.center; if (_box$2.setFromBufferAttribute(e), t) for (let e = 0, i = t.length; e < i; e++) { const i = t[e]; _boxMorphTargets.setFromBufferAttribute(i), this.morphTargetsRelative ? (_vector$4.addVectors(_box$2.min, _boxMorphTargets.min), _box$2.expandByPoint(_vector$4), _vector$4.addVectors(_box$2.max, _boxMorphTargets.max), _box$2.expandByPoint(_vector$4)) : (_box$2.expandByPoint(_boxMorphTargets.min), _box$2.expandByPoint(_boxMorphTargets.max)) } _box$2.getCenter(i); let r = 0; for (let t = 0, n = e.count; t < n; t++)_vector$4.fromBufferAttribute(e, t), r = Math.max(r, i.distanceToSquared(_vector$4)); if (t) for (let n = 0, a = t.length; n < a; n++) { const a = t[n], o = this.morphTargetsRelative; for (let t = 0, n = a.count; t < n; t++)_vector$4.fromBufferAttribute(a, t), o && (_offset.fromBufferAttribute(e, t), _vector$4.add(_offset)), r = Math.max(r, i.distanceToSquared(_vector$4)) } this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } }, computeFaceNormals: function () { }, computeTangents: function () { const e = this.index, t = this.attributes; if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); const i = e.array, r = t.position.array, n = t.normal.array, a = t.uv.array, o = r.length / 3; void 0 === t.tangent && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * o), 4)); const s = t.tangent.array, l = [], c = []; for (let e = 0; e < o; e++)l[e] = new Vector3, c[e] = new Vector3; const h = new Vector3, u = new Vector3, d = new Vector3, p = new Vector2, f = new Vector2, m = new Vector2, g = new Vector3, y = new Vector3; function v(e, t, i) { h.fromArray(r, 3 * e), u.fromArray(r, 3 * t), d.fromArray(r, 3 * i), p.fromArray(a, 2 * e), f.fromArray(a, 2 * t), m.fromArray(a, 2 * i), u.sub(h), d.sub(h), f.sub(p), m.sub(p); const n = 1 / (f.x * m.y - m.x * f.y); isFinite(n) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(n), y.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(n), l[e].add(g), l[t].add(g), l[i].add(g), c[e].add(y), c[t].add(y), c[i].add(y)) } let _ = this.groups; 0 === _.length && (_ = [{ start: 0, count: i.length }]); for (let e = 0, t = _.length; e < t; ++e) { const t = _[e], r = t.start; for (let e = r, n = r + t.count; e < n; e += 3)v(i[e + 0], i[e + 1], i[e + 2]) } const b = new Vector3, x = new Vector3, w = new Vector3, S = new Vector3; function M(e) { w.fromArray(n, 3 * e), S.copy(w); const t = l[e]; b.copy(t), b.sub(w.multiplyScalar(w.dot(t))).normalize(), x.crossVectors(S, t); const i = x.dot(c[e]) < 0 ? -1 : 1; s[4 * e] = b.x, s[4 * e + 1] = b.y, s[4 * e + 2] = b.z, s[4 * e + 3] = i } for (let e = 0, t = _.length; e < t; ++e) { const t = _[e], r = t.start; for (let e = r, n = r + t.count; e < n; e += 3)M(i[e + 0]), M(i[e + 1]), M(i[e + 2]) } }, computeVertexNormals: function () { const e = this.index, t = this.getAttribute("position"); if (void 0 !== t) { let i = this.getAttribute("normal"); if (void 0 === i) i = new BufferAttribute(new Float32Array(3 * t.count), 3), this.setAttribute("normal", i); else for (let e = 0, t = i.count; e < t; e++)i.setXYZ(e, 0, 0, 0); const r = new Vector3, n = new Vector3, a = new Vector3, o = new Vector3, s = new Vector3, l = new Vector3, c = new Vector3, h = new Vector3; if (e) for (let u = 0, d = e.count; u < d; u += 3) { const d = e.getX(u + 0), p = e.getX(u + 1), f = e.getX(u + 2); r.fromBufferAttribute(t, d), n.fromBufferAttribute(t, p), a.fromBufferAttribute(t, f), c.subVectors(a, n), h.subVectors(r, n), c.cross(h), o.fromBufferAttribute(i, d), s.fromBufferAttribute(i, p), l.fromBufferAttribute(i, f), o.add(c), s.add(c), l.add(c), i.setXYZ(d, o.x, o.y, o.z), i.setXYZ(p, s.x, s.y, s.z), i.setXYZ(f, l.x, l.y, l.z) } else for (let e = 0, o = t.count; e < o; e += 3)r.fromBufferAttribute(t, e + 0), n.fromBufferAttribute(t, e + 1), a.fromBufferAttribute(t, e + 2), c.subVectors(a, n), h.subVectors(r, n), c.cross(h), i.setXYZ(e + 0, c.x, c.y, c.z), i.setXYZ(e + 1, c.x, c.y, c.z), i.setXYZ(e + 2, c.x, c.y, c.z); this.normalizeNormals(), i.needsUpdate = !0 } }, merge: function (e, t) { if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e); void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); const i = this.attributes; for (const r in i) { if (void 0 === e.attributes[r]) continue; const n = i[r].array, a = e.attributes[r], o = a.array, s = a.itemSize * t, l = Math.min(o.length, n.length - s); for (let e = 0, t = s; e < l; e++, t++)n[t] = o[e] } return this }, normalizeNormals: function () { const e = this.attributes.normal; for (let t = 0, i = e.count; t < i; t++)_vector$4.fromBufferAttribute(e, t), _vector$4.normalize(), e.setXYZ(t, _vector$4.x, _vector$4.y, _vector$4.z) }, toNonIndexed: function () { function e(e, t) { const i = e.array, r = e.itemSize, n = e.normalized, a = new i.constructor(t.length * r); let o = 0, s = 0; for (let e = 0, n = t.length; e < n; e++) { o = t[e] * r; for (let e = 0; e < r; e++)a[s++] = i[o++] } return new BufferAttribute(a, r, n) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const t = new BufferGeometry, i = this.index.array, r = this.attributes; for (const n in r) { const a = e(r[n], i); t.setAttribute(n, a) } const n = this.morphAttributes; for (const r in n) { const a = [], o = n[r]; for (let t = 0, r = o.length; t < r; t++) { const r = e(o[t], i); a.push(r) } t.morphAttributes[r] = a } t.morphTargetsRelative = this.morphTargetsRelative; const a = this.groups; for (let e = 0, i = a.length; e < i; e++) { const i = a[e]; t.addGroup(i.start, i.count, i.materialIndex) } return t }, toJSON: function () { const e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) { const t = this.parameters; for (const i in t) void 0 !== t[i] && (e[i] = t[i]); return e } e.data = { attributes: {} }; const t = this.index; null !== t && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) }); const i = this.attributes; for (const t in i) { const r = i[t], n = r.toJSON(e.data); "" !== r.name && (n.name = r.name), e.data.attributes[t] = n } const r = {}; let n = !1; for (const t in this.morphAttributes) { const i = this.morphAttributes[t], a = []; for (let t = 0, r = i.length; t < r; t++) { const r = i[t], n = r.toJSON(e.data); "" !== r.name && (n.name = r.name), a.push(n) } a.length > 0 && (r[t] = a, n = !0) } n && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative); const a = this.groups; a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a))); const o = this.boundingSphere; return null !== o && (e.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), e }, clone: function () { return (new BufferGeometry).copy(this) }, copy: function (e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const t = {}; this.name = e.name; const i = e.index; null !== i && this.setIndex(i.clone(t)); const r = e.attributes; for (const e in r) { const i = r[e]; this.setAttribute(e, i.clone(t)) } const n = e.morphAttributes; for (const e in n) { const i = [], r = n[e]; for (let e = 0, n = r.length; e < n; e++)i.push(r[e].clone(t)); this.morphAttributes[e] = i } this.morphTargetsRelative = e.morphTargetsRelative; const a = e.groups; for (let e = 0, t = a.length; e < t; e++) { const t = a[e]; this.addGroup(t.start, t.count, t.materialIndex) } const o = e.boundingBox; null !== o && (this.boundingBox = o.clone()); const s = e.boundingSphere; return null !== s && (this.boundingSphere = s.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); const _inverseMatrix = new Matrix4, _ray$1 = new Ray, _sphere$1 = new Sphere, _vA = new Vector3, _vB = new Vector3, _vC = new Vector3, _tempA = new Vector3, _tempB = new Vector3, _tempC = new Vector3, _morphA = new Vector3, _morphB = new Vector3, _morphC = new Vector3, _uvA = new Vector2, _uvB = new Vector2, _uvC = new Vector2, _intersectionPoint = new Vector3, _intersectionPointWorld = new Vector3; function Mesh(e = new BufferGeometry, t = new MeshBasicMaterial) { Object3D.call(this), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } function checkIntersection(e, t, i, r, n, a, o, s) { let l; if (l = t.side === BackSide ? r.intersectTriangle(o, a, n, !0, s) : r.intersectTriangle(n, a, o, t.side !== DoubleSide, s), null === l) return null; _intersectionPointWorld.copy(s), _intersectionPointWorld.applyMatrix4(e.matrixWorld); const c = i.ray.origin.distanceTo(_intersectionPointWorld); return c < i.near || c > i.far ? null : { distance: c, point: _intersectionPointWorld.clone(), object: e } } function checkBufferGeometryIntersection(e, t, i, r, n, a, o, s, l, c, h, u) { _vA.fromBufferAttribute(n, c), _vB.fromBufferAttribute(n, h), _vC.fromBufferAttribute(n, u); const d = e.morphTargetInfluences; if (t.morphTargets && a && d) { _morphA.set(0, 0, 0), _morphB.set(0, 0, 0), _morphC.set(0, 0, 0); for (let e = 0, t = a.length; e < t; e++) { const t = d[e], i = a[e]; 0 !== t && (_tempA.fromBufferAttribute(i, c), _tempB.fromBufferAttribute(i, h), _tempC.fromBufferAttribute(i, u), o ? (_morphA.addScaledVector(_tempA, t), _morphB.addScaledVector(_tempB, t), _morphC.addScaledVector(_tempC, t)) : (_morphA.addScaledVector(_tempA.sub(_vA), t), _morphB.addScaledVector(_tempB.sub(_vB), t), _morphC.addScaledVector(_tempC.sub(_vC), t))) } _vA.add(_morphA), _vB.add(_morphB), _vC.add(_morphC) } e.isSkinnedMesh && t.skinning && (e.boneTransform(c, _vA), e.boneTransform(h, _vB), e.boneTransform(u, _vC)); const p = checkIntersection(e, t, i, r, _vA, _vB, _vC, _intersectionPoint); if (p) { s && (_uvA.fromBufferAttribute(s, c), _uvB.fromBufferAttribute(s, h), _uvC.fromBufferAttribute(s, u), p.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2)), l && (_uvA.fromBufferAttribute(l, c), _uvB.fromBufferAttribute(l, h), _uvC.fromBufferAttribute(l, u), p.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2)); const e = { a: c, b: h, c: u, normal: new Vector3, materialIndex: 0 }; Triangle.getNormal(_vA, _vB, _vC, e.normal), p.face = e } return p } Mesh.prototype = Object.assign(Object.create(Object3D.prototype), { constructor: Mesh, isMesh: !0, copy: function (e) { return Object3D.prototype.copy.call(this, e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this }, updateMorphTargets: function () { const e = this.geometry; if (e.isBufferGeometry) { const t = e.morphAttributes, i = Object.keys(t); if (i.length > 0) { const e = t[i[0]]; if (void 0 !== e) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, i = e.length; t < i; t++) { const i = e[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t } } } } else { const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } }, raycast: function (e, t) { const i = this.geometry, r = this.material, n = this.matrixWorld; if (void 0 === r) return; if (null === i.boundingSphere && i.computeBoundingSphere(), _sphere$1.copy(i.boundingSphere), _sphere$1.applyMatrix4(n), !1 === e.ray.intersectsSphere(_sphere$1)) return; if (_inverseMatrix.copy(n).invert(), _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix), null !== i.boundingBox && !1 === _ray$1.intersectsBox(i.boundingBox)) return; let a; if (i.isBufferGeometry) { const n = i.index, o = i.attributes.position, s = i.morphAttributes.position, l = i.morphTargetsRelative, c = i.attributes.uv, h = i.attributes.uv2, u = i.groups, d = i.drawRange; if (null !== n) if (Array.isArray(r)) for (let i = 0, p = u.length; i < p; i++) { const p = u[i], f = r[p.materialIndex]; for (let i = Math.max(p.start, d.start), r = Math.min(p.start + p.count, d.start + d.count); i < r; i += 3) { const r = n.getX(i), u = n.getX(i + 1), d = n.getX(i + 2); a = checkBufferGeometryIntersection(this, f, e, _ray$1, o, s, l, c, h, r, u, d), a && (a.faceIndex = Math.floor(i / 3), a.face.materialIndex = p.materialIndex, t.push(a)) } } else { for (let i = Math.max(0, d.start), u = Math.min(n.count, d.start + d.count); i < u; i += 3) { const u = n.getX(i), d = n.getX(i + 1), p = n.getX(i + 2); a = checkBufferGeometryIntersection(this, r, e, _ray$1, o, s, l, c, h, u, d, p), a && (a.faceIndex = Math.floor(i / 3), t.push(a)) } } else if (void 0 !== o) if (Array.isArray(r)) for (let i = 0, n = u.length; i < n; i++) { const n = u[i], p = r[n.materialIndex]; for (let i = Math.max(n.start, d.start), r = Math.min(n.start + n.count, d.start + d.count); i < r; i += 3) { a = checkBufferGeometryIntersection(this, p, e, _ray$1, o, s, l, c, h, i, i + 1, i + 2), a && (a.faceIndex = Math.floor(i / 3), a.face.materialIndex = n.materialIndex, t.push(a)) } } else { for (let i = Math.max(0, d.start), n = Math.min(o.count, d.start + d.count); i < n; i += 3) { a = checkBufferGeometryIntersection(this, r, e, _ray$1, o, s, l, c, h, i, i + 1, i + 2), a && (a.faceIndex = Math.floor(i / 3), t.push(a)) } } } else i.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } }); class BoxGeometry extends BufferGeometry { constructor(e = 1, t = 1, i = 1, r = 1, n = 1, a = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: r, heightSegments: n, depthSegments: a }; const o = this; r = Math.floor(r), n = Math.floor(n), a = Math.floor(a); const s = [], l = [], c = [], h = []; let u = 0, d = 0; function p(e, t, i, r, n, a, p, f, m, g, y) { const v = a / m, _ = p / g, b = a / 2, x = p / 2, w = f / 2, S = m + 1, M = g + 1; let T = 0, A = 0; const E = new Vector3; for (let a = 0; a < M; a++) { const o = a * _ - x; for (let s = 0; s < S; s++) { const u = s * v - b; E[e] = u * r, E[t] = o * n, E[i] = w, l.push(E.x, E.y, E.z), E[e] = 0, E[t] = 0, E[i] = f > 0 ? 1 : -1, c.push(E.x, E.y, E.z), h.push(s / m), h.push(1 - a / g), T += 1 } } for (let e = 0; e < g; e++)for (let t = 0; t < m; t++) { const i = u + t + S * e, r = u + t + S * (e + 1), n = u + (t + 1) + S * (e + 1), a = u + (t + 1) + S * e; s.push(i, r, a), s.push(r, n, a), A += 6 } o.addGroup(d, A, y), d += A, u += T } p("z", "y", "x", -1, -1, i, t, e, a, n, 0), p("z", "y", "x", 1, -1, i, t, -e, a, n, 1), p("x", "z", "y", 1, 1, e, i, t, r, a, 2), p("x", "z", "y", 1, -1, e, i, -t, r, a, 3), p("x", "y", "z", 1, -1, e, t, i, r, n, 4), p("x", "y", "z", -1, -1, e, t, -i, r, n, 5), this.setIndex(s), this.setAttribute("position", new Float32BufferAttribute(l, 3)), this.setAttribute("normal", new Float32BufferAttribute(c, 3)), this.setAttribute("uv", new Float32BufferAttribute(h, 2)) } } function cloneUniforms(e) { const t = {}; for (const i in e) { t[i] = {}; for (const r in e[i]) { const n = e[i][r]; n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? t[i][r] = n.clone() : Array.isArray(n) ? t[i][r] = n.slice() : t[i][r] = n } } return t } function mergeUniforms(e) { const t = {}; for (let i = 0; i < e.length; i++) { const r = cloneUniforms(e[i]); for (const e in r) t[e] = r[e] } return t } const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms }; var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"; function ShaderMaterial(e) { Material$1.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = default_vertex, this.fragmentShader = default_fragment, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e)) } function Camera$1$1() { Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new Matrix4, this.projectionMatrix = new Matrix4, this.projectionMatrixInverse = new Matrix4 } function PerspectiveCamera(e = 50, t = 1, i = .1, r = 2e3) { Camera$1$1.call(this), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } ShaderMaterial.prototype = Object.create(Material$1.prototype), ShaderMaterial.prototype.constructor = ShaderMaterial, ShaderMaterial.prototype.isShaderMaterial = !0, ShaderMaterial.prototype.copy = function (e) { return Material$1.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = cloneUniforms(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this }, ShaderMaterial.prototype.toJSON = function (e) { const t = Material$1.prototype.toJSON.call(this, e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const i in this.uniforms) { const r = this.uniforms[i].value; r && r.isTexture ? t.uniforms[i] = { type: "t", value: r.toJSON(e).uuid } : r && r.isColor ? t.uniforms[i] = { type: "c", value: r.getHex() } : r && r.isVector2 ? t.uniforms[i] = { type: "v2", value: r.toArray() } : r && r.isVector3 ? t.uniforms[i] = { type: "v3", value: r.toArray() } : r && r.isVector4 ? t.uniforms[i] = { type: "v4", value: r.toArray() } : r && r.isMatrix3 ? t.uniforms[i] = { type: "m3", value: r.toArray() } : r && r.isMatrix4 ? t.uniforms[i] = { type: "m4", value: r.toArray() } : t.uniforms[i] = { value: r } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; const i = {}; for (const e in this.extensions) !0 === this.extensions[e] && (i[e] = !0); return Object.keys(i).length > 0 && (t.extensions = i), t }, Camera$1$1.prototype = Object.assign(Object.create(Object3D.prototype), { constructor: Camera$1$1, isCamera: !0, copy: function (e, t) { return Object3D.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this }, getWorldDirection: function (e) { void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new Vector3), this.updateWorldMatrix(!0, !1); const t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() }, updateMatrixWorld: function (e) { Object3D.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.copy(this.matrixWorld).invert() }, updateWorldMatrix: function (e, t) { Object3D.prototype.updateWorldMatrix.call(this, e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() }, clone: function () { return (new this.constructor).copy(this) } }), PerspectiveCamera.prototype = Object.assign(Object.create(Camera$1$1.prototype), { constructor: PerspectiveCamera, isPerspectiveCamera: !0, copy: function (e, t) { return Camera$1$1.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this }, setFocalLength: function (e) { const t = .5 * this.getFilmHeight() / e; this.fov = 2 * MathUtils.RAD2DEG * Math.atan(t), this.updateProjectionMatrix() }, getFocalLength: function () { const e = Math.tan(.5 * MathUtils.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / e }, getEffectiveFOV: function () { return 2 * MathUtils.RAD2DEG * Math.atan(Math.tan(.5 * MathUtils.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (e, t, i, r, n, a) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = n, this.view.height = a, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { const e = this.near; let t = e * Math.tan(.5 * MathUtils.DEG2RAD * this.fov) / this.zoom, i = 2 * t, r = this.aspect * i, n = -.5 * r; const a = this.view; if (null !== this.view && this.view.enabled) { const e = a.fullWidth, o = a.fullHeight; n += a.offsetX * r / e, t -= a.offsetY * i / o, r *= a.width / e, i *= a.height / o } const o = this.filmOffset; 0 !== o && (n += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(n, n + r, t, t - i, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() }, toJSON: function (e) { const t = Object3D.prototype.toJSON.call(this, e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } }); const fov = 90, aspect = 1; class CubeCamera extends Object3D { constructor(e, t, i) { if (super(), this.type = "CubeCamera", !0 !== i.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); this.renderTarget = i; const r = new PerspectiveCamera(fov, aspect, e, t); r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Vector3(1, 0, 0)), this.add(r); const n = new PerspectiveCamera(fov, aspect, e, t); n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new Vector3(-1, 0, 0)), this.add(n); const a = new PerspectiveCamera(fov, aspect, e, t); a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(new Vector3(0, 1, 0)), this.add(a); const o = new PerspectiveCamera(fov, aspect, e, t); o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new Vector3(0, -1, 0)), this.add(o); const s = new PerspectiveCamera(fov, aspect, e, t); s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new Vector3(0, 0, 1)), this.add(s); const l = new PerspectiveCamera(fov, aspect, e, t); l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Vector3(0, 0, -1)), this.add(l) } update(e, t) { null === this.parent && this.updateMatrixWorld(); const i = this.renderTarget, [r, n, a, o, s, l] = this.children, c = e.xr.enabled, h = e.getRenderTarget(); e.xr.enabled = !1; const u = i.texture.generateMipmaps; i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, r), e.setRenderTarget(i, 1), e.render(t, n), e.setRenderTarget(i, 2), e.render(t, a), e.setRenderTarget(i, 3), e.render(t, o), e.setRenderTarget(i, 4), e.render(t, s), i.texture.generateMipmaps = u, e.setRenderTarget(i, 5), e.render(t, l), e.setRenderTarget(h), e.xr.enabled = c } } class CubeTexture extends Texture$1 { constructor(e, t, i, r, n, a, o, s, l, c) { super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : CubeReflectionMapping, i, r, n, a, o = void 0 !== o ? o : RGBFormat, s, l, c), this._needsFlipEnvMap = !0, this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } CubeTexture.prototype.isCubeTexture = !0; class WebGLCubeRenderTarget extends WebGLRenderTarget { constructor(e, t, i) { Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = i), super(e, e, t), t = t || {}, this.texture = new CubeTexture(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : LinearFilter, this.texture._needsFlipEnvMap = !1 } fromEquirectangularTexture(e, t) { this.texture.type = t.type, this.texture.format = RGBAFormat, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const i = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t" }, r = new BoxGeometry(5, 5, 5), n = new ShaderMaterial({ name: "CubemapFromEquirect", uniforms: cloneUniforms(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: BackSide, blending: NoBlending }); n.uniforms.tEquirect.value = t; const a = new Mesh(r, n), o = t.minFilter; t.minFilter === LinearMipmapLinearFilter && (t.minFilter = LinearFilter); return new CubeCamera(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this } clear(e, t, i, r) { const n = e.getRenderTarget(); for (let n = 0; n < 6; n++)e.setRenderTarget(this, n), e.clear(t, i, r); e.setRenderTarget(n) } } WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = !0; class DataTexture extends Texture$1 { constructor(e, t, i, r, n, a, o, s, l, c, h, u) { super(null, a, o, s, l, c, r, n, h, u), this.image = { data: e || null, width: t || 1, height: i || 1 }, this.magFilter = void 0 !== l ? l : NearestFilter, this.minFilter = void 0 !== c ? c : NearestFilter, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } DataTexture.prototype.isDataTexture = !0; const _sphere$1$1 = new Sphere, _vector$5 = new Vector3; class Frustum { constructor(e = new Plane, t = new Plane, i = new Plane, r = new Plane, n = new Plane, a = new Plane) { this.planes = [e, t, i, r, n, a] } set(e, t, i, r, n, a) { const o = this.planes; return o[0].copy(e), o[1].copy(t), o[2].copy(i), o[3].copy(r), o[4].copy(n), o[5].copy(a), this } copy(e) { const t = this.planes; for (let i = 0; i < 6; i++)t[i].copy(e.planes[i]); return this } setFromProjectionMatrix(e) { const t = this.planes, i = e.elements, r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], l = i[5], c = i[6], h = i[7], u = i[8], d = i[9], p = i[10], f = i[11], m = i[12], g = i[13], y = i[14], v = i[15]; return t[0].setComponents(o - r, h - s, f - u, v - m).normalize(), t[1].setComponents(o + r, h + s, f + u, v + m).normalize(), t[2].setComponents(o + n, h + l, f + d, v + g).normalize(), t[3].setComponents(o - n, h - l, f - d, v - g).normalize(), t[4].setComponents(o - a, h - c, f - p, v - y).normalize(), t[5].setComponents(o + a, h + c, f + p, v + y).normalize(), this } intersectsObject(e) { const t = e.geometry; return null === t.boundingSphere && t.computeBoundingSphere(), _sphere$1$1.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(_sphere$1$1) } intersectsSprite(e) { return _sphere$1$1.center.set(0, 0, 0), _sphere$1$1.radius = .7071067811865476, _sphere$1$1.applyMatrix4(e.matrixWorld), this.intersectsSphere(_sphere$1$1) } intersectsSphere(e) { const t = this.planes, i = e.center, r = -e.radius; for (let e = 0; e < 6; e++) { if (t[e].distanceToPoint(i) < r) return !1 } return !0 } intersectsBox(e) { const t = this.planes; for (let i = 0; i < 6; i++) { const r = t[i]; if (_vector$5.x = r.normal.x > 0 ? e.max.x : e.min.x, _vector$5.y = r.normal.y > 0 ? e.max.y : e.min.y, _vector$5.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(_vector$5) < 0) return !1 } return !0 } containsPoint(e) { const t = this.planes; for (let i = 0; i < 6; i++)if (t[i].distanceToPoint(e) < 0) return !1; return !0 } clone() { return (new this.constructor).copy(this) } } function WebGLAnimation() { let e = null, t = !1, i = null, r = null; function n(t, a) { i(t, a), r = e.requestAnimationFrame(n) } return { start: function () { !0 !== t && null !== i && (r = e.requestAnimationFrame(n), t = !0) }, stop: function () { e.cancelAnimationFrame(r), t = !1 }, setAnimationLoop: function (e) { i = e }, setContext: function (t) { e = t } } } function WebGLAttributes(e, t) { const i = t.isWebGL2, r = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), r.get(e) }, remove: function (t) { t.isInterleavedBufferAttribute && (t = t.data); const i = r.get(t); i && (e.deleteBuffer(i.buffer), r.delete(t)) }, update: function (t, n) { if (t.isGLBufferAttribute) { const e = r.get(t); return void ((!e || e.version < t.version) && r.set(t, { buffer: t.buffer, type: t.type, bytesPerElement: t.elementSize, version: t.version })) } t.isInterleavedBufferAttribute && (t = t.data); const a = r.get(t); void 0 === a ? r.set(t, function (t, r) { const n = t.array, a = t.usage, o = e.createBuffer(); e.bindBuffer(r, o), e.bufferData(r, n, a), t.onUploadCallback(); let s = 5126; return n instanceof Float32Array ? s = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? t.isFloat16BufferAttribute ? i ? s = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : s = 5123 : n instanceof Int16Array ? s = 5122 : n instanceof Uint32Array ? s = 5125 : n instanceof Int32Array ? s = 5124 : n instanceof Int8Array ? s = 5120 : n instanceof Uint8Array && (s = 5121), { buffer: o, type: s, bytesPerElement: n.BYTES_PER_ELEMENT, version: t.version } }(t, n)) : a.version < t.version && (!function (t, r, n) { const a = r.array, o = r.updateRange; e.bindBuffer(n, t), -1 === o.count ? e.bufferSubData(n, 0, a) : (i ? e.bufferSubData(n, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : e.bufferSubData(n, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1) }(a.buffer, t, n), a.version = t.version) } } } class PlaneGeometry extends BufferGeometry { constructor(e = 1, t = 1, i = 1, r = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: r }; const n = e / 2, a = t / 2, o = Math.floor(i), s = Math.floor(r), l = o + 1, c = s + 1, h = e / o, u = t / s, d = [], p = [], f = [], m = []; for (let e = 0; e < c; e++) { const t = e * u - a; for (let i = 0; i < l; i++) { const r = i * h - n; p.push(r, -t, 0), f.push(0, 0, 1), m.push(i / o), m.push(1 - e / s) } } for (let e = 0; e < s; e++)for (let t = 0; t < o; t++) { const i = t + l * e, r = t + l * (e + 1), n = t + 1 + l * (e + 1), a = t + 1 + l * e; d.push(i, r, a), d.push(r, n, a) } this.setIndex(d), this.setAttribute("position", new Float32BufferAttribute(p, 3)), this.setAttribute("normal", new Float32BufferAttribute(f, 3)), this.setAttribute("uv", new Float32BufferAttribute(m, 2)) } } var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex = "vec3 transformed = vec3( position );", beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common$1 = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif", clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif", clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif", transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif", uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"; const ShaderChunk = { alphamap_fragment: alphamap_fragment, alphamap_pars_fragment: alphamap_pars_fragment, alphatest_fragment: alphatest_fragment, aomap_fragment: aomap_fragment, aomap_pars_fragment: aomap_pars_fragment, begin_vertex: begin_vertex, beginnormal_vertex: beginnormal_vertex, bsdfs: bsdfs, bumpmap_pars_fragment: bumpmap_pars_fragment, clipping_planes_fragment: clipping_planes_fragment, clipping_planes_pars_fragment: clipping_planes_pars_fragment, clipping_planes_pars_vertex: clipping_planes_pars_vertex, clipping_planes_vertex: clipping_planes_vertex, color_fragment: color_fragment, color_pars_fragment: color_pars_fragment, color_pars_vertex: color_pars_vertex, color_vertex: color_vertex, common: common$1, cube_uv_reflection_fragment: cube_uv_reflection_fragment, defaultnormal_vertex: defaultnormal_vertex, displacementmap_pars_vertex: displacementmap_pars_vertex, displacementmap_vertex: displacementmap_vertex, emissivemap_fragment: emissivemap_fragment, emissivemap_pars_fragment: emissivemap_pars_fragment, encodings_fragment: encodings_fragment, encodings_pars_fragment: encodings_pars_fragment, envmap_fragment: envmap_fragment, envmap_common_pars_fragment: envmap_common_pars_fragment, envmap_pars_fragment: envmap_pars_fragment, envmap_pars_vertex: envmap_pars_vertex, envmap_physical_pars_fragment: envmap_physical_pars_fragment, envmap_vertex: envmap_vertex, fog_vertex: fog_vertex, fog_pars_vertex: fog_pars_vertex, fog_fragment: fog_fragment, fog_pars_fragment: fog_pars_fragment, gradientmap_pars_fragment: gradientmap_pars_fragment, lightmap_fragment: lightmap_fragment, lightmap_pars_fragment: lightmap_pars_fragment, lights_lambert_vertex: lights_lambert_vertex, lights_pars_begin: lights_pars_begin, lights_toon_fragment: lights_toon_fragment, lights_toon_pars_fragment: lights_toon_pars_fragment, lights_phong_fragment: lights_phong_fragment, lights_phong_pars_fragment: lights_phong_pars_fragment, lights_physical_fragment: lights_physical_fragment, lights_physical_pars_fragment: lights_physical_pars_fragment, lights_fragment_begin: lights_fragment_begin, lights_fragment_maps: lights_fragment_maps, lights_fragment_end: lights_fragment_end, logdepthbuf_fragment: logdepthbuf_fragment, logdepthbuf_pars_fragment: logdepthbuf_pars_fragment, logdepthbuf_pars_vertex: logdepthbuf_pars_vertex, logdepthbuf_vertex: logdepthbuf_vertex, map_fragment: map_fragment, map_pars_fragment: map_pars_fragment, map_particle_fragment: map_particle_fragment, map_particle_pars_fragment: map_particle_pars_fragment, metalnessmap_fragment: metalnessmap_fragment, metalnessmap_pars_fragment: metalnessmap_pars_fragment, morphnormal_vertex: morphnormal_vertex, morphtarget_pars_vertex: morphtarget_pars_vertex, morphtarget_vertex: morphtarget_vertex, normal_fragment_begin: normal_fragment_begin, normal_fragment_maps: normal_fragment_maps, normalmap_pars_fragment: normalmap_pars_fragment, clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps, clearcoat_pars_fragment: clearcoat_pars_fragment, packing: packing, premultiplied_alpha_fragment: premultiplied_alpha_fragment, project_vertex: project_vertex, dithering_fragment: dithering_fragment, dithering_pars_fragment: dithering_pars_fragment, roughnessmap_fragment: roughnessmap_fragment, roughnessmap_pars_fragment: roughnessmap_pars_fragment, shadowmap_pars_fragment: shadowmap_pars_fragment, shadowmap_pars_vertex: shadowmap_pars_vertex, shadowmap_vertex: shadowmap_vertex, shadowmask_pars_fragment: shadowmask_pars_fragment, skinbase_vertex: skinbase_vertex, skinning_pars_vertex: skinning_pars_vertex, skinning_vertex: skinning_vertex, skinnormal_vertex: skinnormal_vertex, specularmap_fragment: specularmap_fragment, specularmap_pars_fragment: specularmap_pars_fragment, tonemapping_fragment: tonemapping_fragment, tonemapping_pars_fragment: tonemapping_pars_fragment, transmissionmap_fragment: transmissionmap_fragment, transmissionmap_pars_fragment: transmissionmap_pars_fragment, uv_pars_fragment: uv_pars_fragment, uv_pars_vertex: uv_pars_vertex, uv_vertex: uv_vertex, uv2_pars_fragment: uv2_pars_fragment, uv2_pars_vertex: uv2_pars_vertex, uv2_vertex: uv2_vertex, worldpos_vertex: worldpos_vertex, background_frag: background_frag, background_vert: background_vert, cube_frag: cube_frag, cube_vert: cube_vert, depth_frag: depth_frag, depth_vert: depth_vert, distanceRGBA_frag: distanceRGBA_frag, distanceRGBA_vert: distanceRGBA_vert, equirect_frag: equirect_frag, equirect_vert: equirect_vert, linedashed_frag: linedashed_frag, linedashed_vert: linedashed_vert, meshbasic_frag: meshbasic_frag, meshbasic_vert: meshbasic_vert, meshlambert_frag: meshlambert_frag, meshlambert_vert: meshlambert_vert, meshmatcap_frag: meshmatcap_frag, meshmatcap_vert: meshmatcap_vert, meshtoon_frag: meshtoon_frag, meshtoon_vert: meshtoon_vert, meshphong_frag: meshphong_frag, meshphong_vert: meshphong_vert, meshphysical_frag: meshphysical_frag, meshphysical_vert: meshphysical_vert, normal_frag: normal_frag, normal_vert: normal_vert, points_frag: points_frag, points_vert: points_vert, shadow_frag: shadow_frag, shadow_vert: shadow_vert, sprite_frag: sprite_frag, sprite_vert: sprite_vert }, UniformsLib = { common: { diffuse: { value: new Color$1(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Matrix3 }, uv2Transform: { value: new Matrix3 }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Vector2(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Color$1(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Color$1(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Matrix3 } }, sprite: { diffuse: { value: new Color$1(15658734) }, opacity: { value: 1 }, center: { value: new Vector2(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new Matrix3 } } }, ShaderLib = { basic: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]), vertexShader: ShaderChunk.meshbasic_vert, fragmentShader: ShaderChunk.meshbasic_frag }, lambert: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color$1(0) } }]), vertexShader: ShaderChunk.meshlambert_vert, fragmentShader: ShaderChunk.meshlambert_frag }, phong: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color$1(0) }, specular: { value: new Color$1(1118481) }, shininess: { value: 30 } }]), vertexShader: ShaderChunk.meshphong_vert, fragmentShader: ShaderChunk.meshphong_frag }, standard: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color$1(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }, toon: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color$1(0) } }]), vertexShader: ShaderChunk.meshtoon_vert, fragmentShader: ShaderChunk.meshtoon_frag }, matcap: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, { matcap: { value: null } }]), vertexShader: ShaderChunk.meshmatcap_vert, fragmentShader: ShaderChunk.meshmatcap_frag }, points: { uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]), vertexShader: ShaderChunk.points_vert, fragmentShader: ShaderChunk.points_frag }, dashed: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: ShaderChunk.linedashed_vert, fragmentShader: ShaderChunk.linedashed_frag }, depth: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]), vertexShader: ShaderChunk.depth_vert, fragmentShader: ShaderChunk.depth_frag }, normal: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, { opacity: { value: 1 } }]), vertexShader: ShaderChunk.normal_vert, fragmentShader: ShaderChunk.normal_frag }, sprite: { uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]), vertexShader: ShaderChunk.sprite_vert, fragmentShader: ShaderChunk.sprite_frag }, background: { uniforms: { uvTransform: { value: new Matrix3 }, t2D: { value: null } }, vertexShader: ShaderChunk.background_vert, fragmentShader: ShaderChunk.background_frag }, cube: { uniforms: mergeUniforms([UniformsLib.envmap, { opacity: { value: 1 }, cubeMapRotationY: { value: 0 } }]), vertexShader: ShaderChunk.cube_vert, fragmentShader: ShaderChunk.cube_frag }, equirect: { uniforms: { tEquirect: { value: null }, cubeMapRotationY: { value: 0 } }, vertexShader: ShaderChunk.equirect_vert, fragmentShader: ShaderChunk.equirect_frag }, distanceRGBA: { uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, { referencePosition: { value: new Vector3 }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: ShaderChunk.distanceRGBA_vert, fragmentShader: ShaderChunk.distanceRGBA_frag }, shadow: { uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, { color: { value: new Color$1(0) }, opacity: { value: 1 } }]), vertexShader: ShaderChunk.shadow_vert, fragmentShader: ShaderChunk.shadow_frag } }; function WebGLBackground(e, t, i, r, n) { const a = new Color$1(0); let o, s, l = 0, c = null, h = 0, u = null; function d(e, t) { i.buffers.color.setClear(e.r, e.g, e.b, t, n) } return { getClearColor: function () { return a }, setClearColor: function (e, t = 1) { a.set(e), l = t, d(a, l) }, getClearAlpha: function () { return l }, setClearAlpha: function (e) { l = e, d(a, l) }, render: function (i, n, p, f) { let m = !0 === n.isScene ? n.background : null; m && m.isTexture && (m = t.get(m)); const g = e.xr, y = g.getSession && g.getSession(); y && "additive" === y.environmentBlendMode && (m = null), null === m ? d(a, l) : m && m.isColor && (d(m, 1), f = !0), (e.autoClear || f) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), m && (m.isCubeTexture || m.isWebGLCubeRenderTarget || m.mapping === CubeUVReflectionMapping) ? (void 0 === s && (s = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({ name: "BackgroundCubeMaterial", uniforms: cloneUniforms(ShaderLib.cube.uniforms), vertexShader: ShaderLib.cube.vertexShader, fragmentShader: ShaderLib.cube.fragmentShader, side: BackSide, depthTest: !1, depthWrite: !1, fog: !1 })), s.geometry.deleteAttribute("normal"), s.geometry.deleteAttribute("uv"), s.onBeforeRender = function (e, t, i) { this.matrixWorld.copyPosition(i.matrixWorld) }, Object.defineProperty(s.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(s)), m.isWebGLCubeRenderTarget && (m = m.texture), s.material.uniforms.envMap.value = m, s.material.uniforms.flipEnvMap.value = m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1, c === m && h === m.version && u === e.toneMapping || (s.material.needsUpdate = !0, c = m, h = m.version, u = e.toneMapping), i.unshift(s, s.geometry, s.material, 0, 0, null)) : m && m.isTexture && (void 0 === o && (o = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({ name: "BackgroundMaterial", uniforms: cloneUniforms(ShaderLib.background.uniforms), vertexShader: ShaderLib.background.vertexShader, fragmentShader: ShaderLib.background.fragmentShader, side: FrontSide, depthTest: !1, depthWrite: !1, fog: !1 })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(o)), o.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), o.material.uniforms.uvTransform.value.copy(m.matrix), c === m && h === m.version && u === e.toneMapping || (o.material.needsUpdate = !0, c = m, h = m.version, u = e.toneMapping), i.unshift(o, o.geometry, o.material, 0, 0, null)) } } } function WebGLBindingStates(e, t, i, r) { const n = e.getParameter(34921), a = r.isWebGL2 ? null : t.get("OES_vertex_array_object"), o = r.isWebGL2 || null !== a, s = {}, l = d(null); let c = l; function h(t) { return r.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t) } function u(t) { return r.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t) } function d(e) { const t = [], i = [], r = []; for (let e = 0; e < n; e++)t[e] = 0, i[e] = 0, r[e] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: t, enabledAttributes: i, attributeDivisors: r, object: e, attributes: {}, index: null } } function p() { const e = c.newAttributes; for (let t = 0, i = e.length; t < i; t++)e[t] = 0 } function f(e) { m(e, 0) } function m(i, n) { const a = c.newAttributes, o = c.enabledAttributes, s = c.attributeDivisors; if (a[i] = 1, 0 === o[i] && (e.enableVertexAttribArray(i), o[i] = 1), s[i] !== n) { (r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, n), s[i] = n } } function g() { const t = c.newAttributes, i = c.enabledAttributes; for (let r = 0, n = i.length; r < n; r++)i[r] !== t[r] && (e.disableVertexAttribArray(r), i[r] = 0) } function y(t, i, n, a, o, s) { !0 !== r.isWebGL2 || 5124 !== n && 5125 !== n ? e.vertexAttribPointer(t, i, n, a, o, s) : e.vertexAttribIPointer(t, i, n, o, s) } function v() { _(), c !== l && (c = l, h(c.object)) } function _() { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: function (n, l, u, v, _) { let b = !1; if (o) { const t = function (t, i, n) { const o = !0 === n.wireframe; let l = s[t.id]; void 0 === l && (l = {}, s[t.id] = l); let c = l[i.id]; void 0 === c && (c = {}, l[i.id] = c); let h = c[o]; void 0 === h && (h = d(r.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()), c[o] = h); return h }(v, u, l); c !== t && (c = t, h(c.object)), b = function (e, t) { const i = c.attributes, r = e.attributes; let n = 0; for (const e in r) { const t = i[e], a = r[e]; if (void 0 === t) return !0; if (t.attribute !== a) return !0; if (t.data !== a.data) return !0; n++ } return c.attributesNum !== n || c.index !== t }(v, _), b && function (e, t) { const i = {}, r = e.attributes; let n = 0; for (const e in r) { const t = r[e], a = {}; a.attribute = t, t.data && (a.data = t.data), i[e] = a, n++ } c.attributes = i, c.attributesNum = n, c.index = t }(v, _) } else { const e = !0 === l.wireframe; c.geometry === v.id && c.program === u.id && c.wireframe === e || (c.geometry = v.id, c.program = u.id, c.wireframe = e, b = !0) } !0 === n.isInstancedMesh && (b = !0), null !== _ && i.update(_, 34963), b && (!function (n, a, o, s) { if (!1 === r.isWebGL2 && (n.isInstancedMesh || s.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return; p(); const l = s.attributes, c = o.getAttributes(), h = a.defaultAttributeValues; for (const t in c) { const r = c[t]; if (r >= 0) { const a = l[t]; if (void 0 !== a) { const t = a.normalized, n = a.itemSize, o = i.get(a); if (void 0 === o) continue; const l = o.buffer, c = o.type, h = o.bytesPerElement; if (a.isInterleavedBufferAttribute) { const i = a.data, o = i.stride, u = a.offset; i && i.isInstancedInterleavedBuffer ? (m(r, i.meshPerAttribute), void 0 === s._maxInstanceCount && (s._maxInstanceCount = i.meshPerAttribute * i.count)) : f(r), e.bindBuffer(34962, l), y(r, n, c, t, o * h, u * h) } else a.isInstancedBufferAttribute ? (m(r, a.meshPerAttribute), void 0 === s._maxInstanceCount && (s._maxInstanceCount = a.meshPerAttribute * a.count)) : f(r), e.bindBuffer(34962, l), y(r, n, c, t, 0, 0) } else if ("instanceMatrix" === t) { const t = i.get(n.instanceMatrix); if (void 0 === t) continue; const a = t.buffer, o = t.type; m(r + 0, 1), m(r + 1, 1), m(r + 2, 1), m(r + 3, 1), e.bindBuffer(34962, a), e.vertexAttribPointer(r + 0, 4, o, !1, 64, 0), e.vertexAttribPointer(r + 1, 4, o, !1, 64, 16), e.vertexAttribPointer(r + 2, 4, o, !1, 64, 32), e.vertexAttribPointer(r + 3, 4, o, !1, 64, 48) } else if ("instanceColor" === t) { const t = i.get(n.instanceColor); if (void 0 === t) continue; const a = t.buffer, o = t.type; m(r, 1), e.bindBuffer(34962, a), e.vertexAttribPointer(r, 3, o, !1, 12, 0) } else if (void 0 !== h) { const i = h[t]; if (void 0 !== i) switch (i.length) { case 2: e.vertexAttrib2fv(r, i); break; case 3: e.vertexAttrib3fv(r, i); break; case 4: e.vertexAttrib4fv(r, i); break; default: e.vertexAttrib1fv(r, i) } } } } g() }(n, l, u, v), null !== _ && e.bindBuffer(34963, i.get(_).buffer)) }, reset: v, resetDefaultState: _, dispose: function () { v(); for (const e in s) { const t = s[e]; for (const e in t) { const i = t[e]; for (const e in i) u(i[e].object), delete i[e]; delete t[e] } delete s[e] } }, releaseStatesOfGeometry: function (e) { if (void 0 === s[e.id]) return; const t = s[e.id]; for (const e in t) { const i = t[e]; for (const e in i) u(i[e].object), delete i[e]; delete t[e] } delete s[e.id] }, releaseStatesOfProgram: function (e) { for (const t in s) { const i = s[t]; if (void 0 === i[e.id]) continue; const r = i[e.id]; for (const e in r) u(r[e].object), delete r[e]; delete i[e.id] } }, initAttributes: p, enableAttribute: f, disableUnusedAttributes: g } } function WebGLBufferRenderer(e, t, i, r) { const n = r.isWebGL2; let a; this.setMode = function (e) { a = e }, this.render = function (t, r) { e.drawArrays(a, t, r), i.update(r, a, 1) }, this.renderInstances = function (r, o, s) { if (0 === s) return; let l, c; if (n) l = e, c = "drawArraysInstanced"; else if (l = t.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[c](a, r, o, s), i.update(o, a, s) } } function WebGLCapabilities(e, t, i) { let r; function n(t) { if ("highp" === t) { if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; t = "mediump" } return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext; let o = void 0 !== i.precision ? i.precision : "highp"; const s = n(o); s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s); const l = !0 === i.logarithmicDepthBuffer, c = e.getParameter(34930), h = e.getParameter(35660), u = e.getParameter(3379), d = e.getParameter(34076), p = e.getParameter(34921), f = e.getParameter(36347), m = e.getParameter(36348), g = e.getParameter(36349), y = h > 0, v = a || t.has("OES_texture_float"); return { isWebGL2: a, getMaxAnisotropy: function () { if (void 0 !== r) return r; if (!0 === t.has("EXT_texture_filter_anisotropic")) { const i = t.get("EXT_texture_filter_anisotropic"); r = e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else r = 0; return r }, getMaxPrecision: n, precision: o, logarithmicDepthBuffer: l, maxTextures: c, maxVertexTextures: h, maxTextureSize: u, maxCubemapSize: d, maxAttributes: p, maxVertexUniforms: f, maxVaryings: m, maxFragmentUniforms: g, vertexTextures: y, floatFragmentTextures: v, floatVertexTextures: y && v, maxSamples: a ? e.getParameter(36183) : 0 } } function WebGLClipping(e) { const t = this; let i = null, r = 0, n = !1, a = !1; const o = new Plane, s = new Matrix3, l = { value: null, needsUpdate: !1 }; function c() { l.value !== i && (l.value = i, l.needsUpdate = r > 0), t.numPlanes = r, t.numIntersection = 0 } function h(e, i, r, n) { const a = null !== e ? e.length : 0; let c = null; if (0 !== a) { if (c = l.value, !0 !== n || null === c) { const t = r + 4 * a, n = i.matrixWorldInverse; s.getNormalMatrix(n), (null === c || c.length < t) && (c = new Float32Array(t)); for (let t = 0, i = r; t !== a; ++t, i += 4)o.copy(e[t]).applyMatrix4(n, s), o.normal.toArray(c, i), c[i + 3] = o.constant } l.value = c, l.needsUpdate = !0 } return t.numPlanes = a, t.numIntersection = 0, c } this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, a) { const o = 0 !== e.length || t || 0 !== r || n; return n = t, i = h(e, a, 0), r = e.length, o }, this.beginShadows = function () { a = !0, h(null) }, this.endShadows = function () { a = !1, c() }, this.setState = function (t, o, s) { const u = t.clippingPlanes, d = t.clipIntersection, p = t.clipShadows, f = e.get(t); if (!n || null === u || 0 === u.length || a && !p) a ? h(null) : c(); else { const e = a ? 0 : r, t = 4 * e; let n = f.clippingState || null; l.value = n, n = h(u, o, t, s); for (let e = 0; e !== t; ++e)n[e] = i[e]; f.clippingState = n, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += e } } } function WebGLCubeMaps(e) { let t = new WeakMap; function i(e, t) { return t === EquirectangularReflectionMapping ? e.mapping = CubeReflectionMapping : t === EquirectangularRefractionMapping && (e.mapping = CubeRefractionMapping), e } function r(e) { const i = e.target; i.removeEventListener("dispose", r); const n = t.get(i); void 0 !== n && (t.delete(i), n.dispose()) } return { get: function (n) { if (n && n.isTexture) { const a = n.mapping; if (a === EquirectangularReflectionMapping || a === EquirectangularRefractionMapping) { if (t.has(n)) { return i(t.get(n).texture, n.mapping) } { const a = n.image; if (a && a.height > 0) { const o = e.getRenderTarget(), s = new WebGLCubeRenderTarget(a.height / 2); return s.fromEquirectangularTexture(e, n), t.set(n, s), e.setRenderTarget(o), n.addEventListener("dispose", r), i(s.texture, n.mapping) } return null } } } return n }, dispose: function () { t = new WeakMap } } } function WebGLExtensions(e) { const t = {}; function i(i) { if (void 0 !== t[i]) return t[i]; let r; switch (i) { case "WEBGL_depth_texture": r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: r = e.getExtension(i) }return t[i] = r, r } return { has: function (e) { return null !== i(e) }, init: function (e) { e.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"), i("OES_texture_float"), i("OES_texture_half_float"), i("OES_texture_half_float_linear"), i("OES_standard_derivatives"), i("OES_element_index_uint"), i("OES_vertex_array_object"), i("ANGLE_instanced_arrays")), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float") }, get: function (e) { const t = i(e); return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t } } } function WebGLGeometries(e, t, i, r) { const n = {}, a = new WeakMap; function o(e) { const s = e.target; null !== s.index && t.remove(s.index); for (const e in s.attributes) t.remove(s.attributes[e]); s.removeEventListener("dispose", o), delete n[s.id]; const l = a.get(s); l && (t.remove(l), a.delete(s)), r.releaseStatesOfGeometry(s), !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, i.memory.geometries-- } function s(e) { const i = [], r = e.index, n = e.attributes.position; let o = 0; if (null !== r) { const e = r.array; o = r.version; for (let t = 0, r = e.length; t < r; t += 3) { const r = e[t + 0], n = e[t + 1], a = e[t + 2]; i.push(r, n, n, a, a, r) } } else { const e = n.array; o = n.version; for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) { const e = t + 0, r = t + 1, n = t + 2; i.push(e, r, r, n, n, e) } } const s = new (arrayMax(i) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(i, 1); s.version = o; const l = a.get(e); l && t.remove(l), a.set(e, s) } return { get: function (e, t) { return !0 === n[t.id] || (t.addEventListener("dispose", o), n[t.id] = !0, i.memory.geometries++), t }, update: function (e) { const i = e.attributes; for (const e in i) t.update(i[e], 34962); const r = e.morphAttributes; for (const e in r) { const i = r[e]; for (let e = 0, r = i.length; e < r; e++)t.update(i[e], 34962) } }, getWireframeAttribute: function (e) { const t = a.get(e); if (t) { const i = e.index; null !== i && t.version < i.version && s(e) } else s(e); return a.get(e) } } } function WebGLIndexedBufferRenderer(e, t, i, r) { const n = r.isWebGL2; let a, o, s; this.setMode = function (e) { a = e }, this.setIndex = function (e) { o = e.type, s = e.bytesPerElement }, this.render = function (t, r) { e.drawElements(a, r, o, t * s), i.update(r, a, 1) }, this.renderInstances = function (r, l, c) { if (0 === c) return; let h, u; if (n) h = e, u = "drawElementsInstanced"; else if (h = t.get("ANGLE_instanced_arrays"), u = "drawElementsInstancedANGLE", null === h) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); h[u](a, l, o, r * s, c), i.update(l, a, c) } } function WebGLInfo(e) { const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: !0, reset: function () { t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 }, update: function (e, i, r) { switch (t.calls++, i) { case 4: t.triangles += r * (e / 3); break; case 1: t.lines += r * (e / 2); break; case 3: t.lines += r * (e - 1); break; case 2: t.lines += r * e; break; case 0: t.points += r * e; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", i) } } } } function numericalSort(e, t) { return e[0] - t[0] } function absNumericalSort(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) } function WebGLMorphtargets(e) { const t = {}, i = new Float32Array(8), r = []; for (let e = 0; e < 8; e++)r[e] = [e, 0]; return { update: function (n, a, o, s) { const l = n.morphTargetInfluences, c = void 0 === l ? 0 : l.length; let h = t[a.id]; if (void 0 === h) { h = []; for (let e = 0; e < c; e++)h[e] = [e, 0]; t[a.id] = h } for (let e = 0; e < c; e++) { const t = h[e]; t[0] = e, t[1] = l[e] } h.sort(absNumericalSort); for (let e = 0; e < 8; e++)e < c && h[e][1] ? (r[e][0] = h[e][0], r[e][1] = h[e][1]) : (r[e][0] = Number.MAX_SAFE_INTEGER, r[e][1] = 0); r.sort(numericalSort); const u = o.morphTargets && a.morphAttributes.position, d = o.morphNormals && a.morphAttributes.normal; let p = 0; for (let e = 0; e < 8; e++) { const t = r[e], n = t[0], o = t[1]; n !== Number.MAX_SAFE_INTEGER && o ? (u && a.getAttribute("morphTarget" + e) !== u[n] && a.setAttribute("morphTarget" + e, u[n]), d && a.getAttribute("morphNormal" + e) !== d[n] && a.setAttribute("morphNormal" + e, d[n]), i[e] = o, p += o) : (u && !0 === a.hasAttribute("morphTarget" + e) && a.deleteAttribute("morphTarget" + e), d && !0 === a.hasAttribute("morphNormal" + e) && a.deleteAttribute("morphNormal" + e), i[e] = 0) } const f = a.morphTargetsRelative ? 1 : 1 - p; s.getUniforms().setValue(e, "morphTargetBaseInfluence", f), s.getUniforms().setValue(e, "morphTargetInfluences", i) } } } function WebGLObjects(e, t, i, r) { let n = new WeakMap; function a(e) { const t = e.target; t.removeEventListener("dispose", a), i.remove(t.instanceMatrix), null !== t.instanceColor && i.remove(t.instanceColor) } return { update: function (e) { const o = r.render.frame, s = e.geometry, l = t.get(e, s); return n.get(l) !== o && (t.update(l), n.set(l, o)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", a) && e.addEventListener("dispose", a), i.update(e.instanceMatrix, 34962), null !== e.instanceColor && i.update(e.instanceColor, 34962)), l }, dispose: function () { n = new WeakMap } } } ShaderLib.physical = { uniforms: mergeUniforms([ShaderLib.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new Vector2(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new Color$1(0) }, transmission: { value: 0 }, transmissionMap: { value: null } }]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }; class DataTexture2DArray extends Texture$1 { constructor(e = null, t = 1, i = 1, r = 1) { super(null), this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } } DataTexture2DArray.prototype.isDataTexture2DArray = !0; class DataTexture3D extends Texture$1 { constructor(e = null, t = 1, i = 1, r = 1) { super(null), this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = ClampToEdgeWrapping, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } } DataTexture3D.prototype.isDataTexture3D = !0; const emptyTexture = new Texture$1, emptyTexture2dArray = new DataTexture2DArray, emptyTexture3d = new DataTexture3D, emptyCubeTexture = new CubeTexture, arrayCacheF32 = [], arrayCacheI32 = [], mat4array = new Float32Array(16), mat3array = new Float32Array(9), mat2array = new Float32Array(4); function flatten(e, t, i) { const r = e[0]; if (r <= 0 || r > 0) return e; const n = t * i; let a = arrayCacheF32[n]; if (void 0 === a && (a = new Float32Array(n), arrayCacheF32[n] = a), 0 !== t) { r.toArray(a, 0); for (let r = 1, n = 0; r !== t; ++r)n += i, e[r].toArray(a, n) } return a } function arraysEqual(e, t) { if (e.length !== t.length) return !1; for (let i = 0, r = e.length; i < r; i++)if (e[i] !== t[i]) return !1; return !0 } function copyArray(e, t) { for (let i = 0, r = t.length; i < r; i++)e[i] = t[i] } function allocTexUnits(e, t) { let i = arrayCacheI32[t]; void 0 === i && (i = new Int32Array(t), arrayCacheI32[t] = i); for (let r = 0; r !== t; ++r)i[r] = e.allocateTextureUnit(); return i } function setValueV1f(e, t) { const i = this.cache; i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t) } function setValueV2f(e, t) { const i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y); else { if (arraysEqual(i, t)) return; e.uniform2fv(this.addr, t), copyArray(i, t) } } function setValueV3f(e, t) { const i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z); else if (void 0 !== t.r) i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b); else { if (arraysEqual(i, t)) return; e.uniform3fv(this.addr, t), copyArray(i, t) } } function setValueV4f(e, t) { const i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w); else { if (arraysEqual(i, t)) return; e.uniform4fv(this.addr, t), copyArray(i, t) } } function setValueM2(e, t) { const i = this.cache, r = t.elements; if (void 0 === r) { if (arraysEqual(i, t)) return; e.uniformMatrix2fv(this.addr, !1, t), copyArray(i, t) } else { if (arraysEqual(i, r)) return; mat2array.set(r), e.uniformMatrix2fv(this.addr, !1, mat2array), copyArray(i, r) } } function setValueM3(e, t) { const i = this.cache, r = t.elements; if (void 0 === r) { if (arraysEqual(i, t)) return; e.uniformMatrix3fv(this.addr, !1, t), copyArray(i, t) } else { if (arraysEqual(i, r)) return; mat3array.set(r), e.uniformMatrix3fv(this.addr, !1, mat3array), copyArray(i, r) } } function setValueM4(e, t) { const i = this.cache, r = t.elements; if (void 0 === r) { if (arraysEqual(i, t)) return; e.uniformMatrix4fv(this.addr, !1, t), copyArray(i, t) } else { if (arraysEqual(i, r)) return; mat4array.set(r), e.uniformMatrix4fv(this.addr, !1, mat4array), copyArray(i, r) } } function setValueT1(e, t, i) { const r = this.cache, n = i.allocateTextureUnit(); r[0] !== n && (e.uniform1i(this.addr, n), r[0] = n), i.safeSetTexture2D(t || emptyTexture, n) } function setValueT2DArray1(e, t, i) { const r = this.cache, n = i.allocateTextureUnit(); r[0] !== n && (e.uniform1i(this.addr, n), r[0] = n), i.setTexture2DArray(t || emptyTexture2dArray, n) } function setValueT3D1(e, t, i) { const r = this.cache, n = i.allocateTextureUnit(); r[0] !== n && (e.uniform1i(this.addr, n), r[0] = n), i.setTexture3D(t || emptyTexture3d, n) } function setValueT6(e, t, i) { const r = this.cache, n = i.allocateTextureUnit(); r[0] !== n && (e.uniform1i(this.addr, n), r[0] = n), i.safeSetTextureCube(t || emptyCubeTexture, n) } function setValueV1i(e, t) { const i = this.cache; i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t) } function setValueV2i(e, t) { const i = this.cache; arraysEqual(i, t) || (e.uniform2iv(this.addr, t), copyArray(i, t)) } function setValueV3i(e, t) { const i = this.cache; arraysEqual(i, t) || (e.uniform3iv(this.addr, t), copyArray(i, t)) } function setValueV4i(e, t) { const i = this.cache; arraysEqual(i, t) || (e.uniform4iv(this.addr, t), copyArray(i, t)) } function setValueV1ui(e, t) { const i = this.cache; i[0] !== t && (e.uniform1ui(this.addr, t), i[0] = t) } function getSingularSetter(e) { switch (e) { case 5126: return setValueV1f; case 35664: return setValueV2f; case 35665: return setValueV3f; case 35666: return setValueV4f; case 35674: return setValueM2; case 35675: return setValueM3; case 35676: return setValueM4; case 5124: case 35670: return setValueV1i; case 35667: case 35671: return setValueV2i; case 35668: case 35672: return setValueV3i; case 35669: case 35673: return setValueV4i; case 5125: return setValueV1ui; case 35678: case 36198: case 36298: case 36306: case 35682: return setValueT1; case 35679: case 36299: case 36307: return setValueT3D1; case 35680: case 36300: case 36308: case 36293: return setValueT6; case 36289: case 36303: case 36311: case 36292: return setValueT2DArray1 } } function setValueV1fArray(e, t) { e.uniform1fv(this.addr, t) } function setValueV1iArray(e, t) { e.uniform1iv(this.addr, t) } function setValueV2iArray(e, t) { e.uniform2iv(this.addr, t) } function setValueV3iArray(e, t) { e.uniform3iv(this.addr, t) } function setValueV4iArray(e, t) { e.uniform4iv(this.addr, t) } function setValueV2fArray(e, t) { const i = flatten(t, this.size, 2); e.uniform2fv(this.addr, i) } function setValueV3fArray(e, t) { const i = flatten(t, this.size, 3); e.uniform3fv(this.addr, i) } function setValueV4fArray(e, t) { const i = flatten(t, this.size, 4); e.uniform4fv(this.addr, i) } function setValueM2Array(e, t) { const i = flatten(t, this.size, 4); e.uniformMatrix2fv(this.addr, !1, i) } function setValueM3Array(e, t) { const i = flatten(t, this.size, 9); e.uniformMatrix3fv(this.addr, !1, i) } function setValueM4Array(e, t) { const i = flatten(t, this.size, 16); e.uniformMatrix4fv(this.addr, !1, i) } function setValueT1Array(e, t, i) { const r = t.length, n = allocTexUnits(i, r); e.uniform1iv(this.addr, n); for (let e = 0; e !== r; ++e)i.safeSetTexture2D(t[e] || emptyTexture, n[e]) } function setValueT6Array(e, t, i) { const r = t.length, n = allocTexUnits(i, r); e.uniform1iv(this.addr, n); for (let e = 0; e !== r; ++e)i.safeSetTextureCube(t[e] || emptyCubeTexture, n[e]) } function getPureArraySetter(e) { switch (e) { case 5126: return setValueV1fArray; case 35664: return setValueV2fArray; case 35665: return setValueV3fArray; case 35666: return setValueV4fArray; case 35674: return setValueM2Array; case 35675: return setValueM3Array; case 35676: return setValueM4Array; case 5124: case 35670: return setValueV1iArray; case 35667: case 35671: return setValueV2iArray; case 35668: case 35672: return setValueV3iArray; case 35669: case 35673: return setValueV4iArray; case 35678: case 36198: case 36298: case 36306: case 35682: return setValueT1Array; case 35680: case 36300: case 36308: case 36293: return setValueT6Array } } function SingleUniform(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.setValue = getSingularSetter(t.type) } function PureArrayUniform(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = getPureArraySetter(t.type) } function StructuredUniform(e) { this.id = e, this.seq = [], this.map = {} } PureArrayUniform.prototype.updateCache = function (e) { const t = this.cache; e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), copyArray(t, e) }, StructuredUniform.prototype.setValue = function (e, t, i) { const r = this.seq; for (let n = 0, a = r.length; n !== a; ++n) { const a = r[n]; a.setValue(e, t[a.id], i) } }; const RePathPart = /(\w+)(\])?(\[|\.)?/g; function addUniform(e, t) { e.seq.push(t), e.map[t.id] = t } function parseUniform(e, t, i) { const r = e.name, n = r.length; for (RePathPart.lastIndex = 0; ;) { const a = RePathPart.exec(r), o = RePathPart.lastIndex; let s = a[1]; const l = "]" === a[2], c = a[3]; if (l && (s |= 0), void 0 === c || "[" === c && o + 2 === n) { addUniform(i, void 0 === c ? new SingleUniform(s, e, t) : new PureArrayUniform(s, e, t)); break } { let e = i.map[s]; void 0 === e && (e = new StructuredUniform(s), addUniform(i, e)), i = e } } } function WebGLUniforms(e, t) { this.seq = [], this.map = {}; const i = e.getProgramParameter(t, 35718); for (let r = 0; r < i; ++r) { const i = e.getActiveUniform(t, r); parseUniform(i, e.getUniformLocation(t, i.name), this) } } function WebGLShader(e, t, i) { const r = e.createShader(t); return e.shaderSource(r, i), e.compileShader(r), r } WebGLUniforms.prototype.setValue = function (e, t, i, r) { const n = this.map[t]; void 0 !== n && n.setValue(e, i, r) }, WebGLUniforms.prototype.setOptional = function (e, t, i) { const r = t[i]; void 0 !== r && this.setValue(e, i, r) }, WebGLUniforms.upload = function (e, t, i, r) { for (let n = 0, a = t.length; n !== a; ++n) { const a = t[n], o = i[a.id]; !1 !== o.needsUpdate && a.setValue(e, o.value, r) } }, WebGLUniforms.seqWithValue = function (e, t) { const i = []; for (let r = 0, n = e.length; r !== n; ++r) { const n = e[r]; n.id in t && i.push(n) } return i }; let programIdCount = 0; function addLineNumbers(e) { const t = e.split("\n"); for (let e = 0; e < t.length; e++)t[e] = e + 1 + ": " + t[e]; return t.join("\n") } function getEncodingComponents(e) { switch (e) { case LinearEncoding: return ["Linear", "( value )"]; case sRGBEncoding: return ["sRGB", "( value )"]; case RGBEEncoding: return ["RGBE", "( value )"]; case RGBM7Encoding: return ["RGBM", "( value, 7.0 )"]; case RGBM16Encoding: return ["RGBM", "( value, 16.0 )"]; case RGBDEncoding: return ["RGBD", "( value, 256.0 )"]; case GammaEncoding: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case LogLuvEncoding: return ["LogLuv", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"] } } function getShaderErrors(e, t, i) { const r = e.getShaderParameter(t, 35713), n = e.getShaderInfoLog(t).trim(); if (r && "" === n) return ""; return "THREE.WebGLShader: gl.getShaderInfoLog() " + i + "\n" + n + addLineNumbers(e.getShaderSource(t)) } function getTexelDecodingFunction(e, t) { const i = getEncodingComponents(t); return "vec4 " + e + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }" } function getTexelEncodingFunction(e, t) { const i = getEncodingComponents(t); return "vec4 " + e + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }" } function getToneMappingFunction(e, t) { let i; switch (t) { case LinearToneMapping: i = "Linear"; break; case ReinhardToneMapping: i = "Reinhard"; break; case CineonToneMapping: i = "OptimizedCineon"; break; case ACESFilmicToneMapping: i = "ACESFilmic"; break; case CustomToneMapping: i = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), i = "Linear" }return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }" } function generateExtensions(e) { return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(filterEmptyLine).join("\n") } function generateDefines(e) { const t = []; for (const i in e) { const r = e[i]; !1 !== r && t.push("#define " + i + " " + r) } return t.join("\n") } function fetchAttributeLocations(e, t) { const i = {}, r = e.getProgramParameter(t, 35721); for (let n = 0; n < r; n++) { const r = e.getActiveAttrib(t, n).name; i[r] = e.getAttribLocation(t, r) } return i } function filterEmptyLine(e) { return "" !== e } function replaceLightNums(e, t) { return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function replaceClippingPlaneNums(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm; function resolveIncludes(e) { return e.replace(includePattern, includeReplacer) } function includeReplacer(e, t) { const i = ShaderChunk[t]; if (void 0 === i) throw new Error("Can not resolve #include <" + t + ">"); return resolveIncludes(i) } const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function unrollLoops(e) { return e.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer) } function deprecatedLoopReplacer(e, t, i, r) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), loopReplacer(e, t, i, r) } function loopReplacer(e, t, i, r) { let n = ""; for (let e = parseInt(t); e < parseInt(i); e++)n += r.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e); return n } function generatePrecision(e) { let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;"; return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t } function generateShadowMapTypeDefine(e) { let t = "SHADOWMAP_TYPE_BASIC"; return e.shadowMapType === PCFShadowMap ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === PCFSoftShadowMap ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === VSMShadowMap && (t = "SHADOWMAP_TYPE_VSM"), t } function generateEnvMapTypeDefine(e) { let t = "ENVMAP_TYPE_CUBE"; if (e.envMap) switch (e.envMapMode) { case CubeReflectionMapping: case CubeRefractionMapping: t = "ENVMAP_TYPE_CUBE"; break; case CubeUVReflectionMapping: case CubeUVRefractionMapping: t = "ENVMAP_TYPE_CUBE_UV" }return t } function generateEnvMapModeDefine(e) { let t = "ENVMAP_MODE_REFLECTION"; if (e.envMap) switch (e.envMapMode) { case CubeRefractionMapping: case CubeUVRefractionMapping: t = "ENVMAP_MODE_REFRACTION" }return t } function generateEnvMapBlendingDefine(e) { let t = "ENVMAP_BLENDING_NONE"; if (e.envMap) switch (e.combine) { case MultiplyOperation: t = "ENVMAP_BLENDING_MULTIPLY"; break; case MixOperation: t = "ENVMAP_BLENDING_MIX"; break; case AddOperation: t = "ENVMAP_BLENDING_ADD" }return t } function WebGLProgram(e, t, i, r) { const n = e.getContext(), a = i.defines; let o = i.vertexShader, s = i.fragmentShader; const l = generateShadowMapTypeDefine(i), c = generateEnvMapTypeDefine(i), h = generateEnvMapModeDefine(i), u = generateEnvMapBlendingDefine(i), d = e.gammaFactor > 0 ? e.gammaFactor : 1, p = i.isWebGL2 ? "" : generateExtensions(i), f = generateDefines(a), m = n.createProgram(); let g, y, v = i.glslVersion ? "#version " + i.glslVersion + "\n" : ""; i.isRawShaderMaterial ? (g = [f].filter(filterEmptyLine).join("\n"), g.length > 0 && (g += "\n"), y = [p, f].filter(filterEmptyLine).join("\n"), y.length > 0 && (y += "\n")) : (g = [generatePrecision(i), "#define SHADER_NAME " + i.shaderName, f, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + i.maxBones, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + h : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine).join("\n"), y = [p, generatePrecision(i), "#define SHADER_NAME " + i.shaderName, f, i.alphaTest ? "#define ALPHATEST " + i.alphaTest + (i.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + c : "", i.envMap ? "#define " + h : "", i.envMap ? "#define " + u : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.sheen ? "#define USE_SHEEN" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (i.extensionShaderTextureLOD || i.envMap) && i.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", i.toneMapping !== NoToneMapping ? ShaderChunk.tonemapping_pars_fragment : "", i.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", ShaderChunk.encodings_pars_fragment, i.map ? getTexelDecodingFunction("mapTexelToLinear", i.mapEncoding) : "", i.matcap ? getTexelDecodingFunction("matcapTexelToLinear", i.matcapEncoding) : "", i.envMap ? getTexelDecodingFunction("envMapTexelToLinear", i.envMapEncoding) : "", i.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "", i.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", i.lightMapEncoding) : "", getTexelEncodingFunction("linearToOutputTexel", i.outputEncoding), i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(filterEmptyLine).join("\n")), o = resolveIncludes(o), o = replaceLightNums(o, i), o = replaceClippingPlaneNums(o, i), s = resolveIncludes(s), s = replaceLightNums(s, i), s = replaceClippingPlaneNums(s, i), o = unrollLoops(o), s = unrollLoops(s), i.isWebGL2 && !0 !== i.isRawShaderMaterial && (v = "#version 300 es\n", g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, y = ["#define varying in", i.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;", i.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y); const _ = v + y + s, b = WebGLShader(n, 35633, v + g + o), x = WebGLShader(n, 35632, _); if (n.attachShader(m, b), n.attachShader(m, x), void 0 !== i.index0AttributeName ? n.bindAttribLocation(m, 0, i.index0AttributeName) : !0 === i.morphTargets && n.bindAttribLocation(m, 0, "position"), n.linkProgram(m), e.debug.checkShaderErrors) { const e = n.getProgramInfoLog(m).trim(), t = n.getShaderInfoLog(b).trim(), i = n.getShaderInfoLog(x).trim(); let r = !0, a = !0; if (!1 === n.getProgramParameter(m, 35714)) { r = !1; const t = getShaderErrors(n, b, "vertex"), i = getShaderErrors(n, x, "fragment"); console.error("THREE.WebGLProgram: shader error: ", n.getError(), "35715", n.getProgramParameter(m, 35715), "gl.getProgramInfoLog", e, t, i) } else "" !== e ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e) : "" !== t && "" !== i || (a = !1); a && (this.diagnostics = { runnable: r, programLog: e, vertexShader: { log: t, prefix: g }, fragmentShader: { log: i, prefix: y } }) } let w, S; return n.deleteShader(b), n.deleteShader(x), this.getUniforms = function () { return void 0 === w && (w = new WebGLUniforms(n, m)), w }, this.getAttributes = function () { return void 0 === S && (S = fetchAttributeLocations(n, m)), S }, this.destroy = function () { r.releaseStatesOfProgram(this), n.deleteProgram(m), this.program = void 0 }, this.name = i.shaderName, this.id = programIdCount++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = b, this.fragmentShader = x, this } function WebGLPrograms(e, t, i, r, n, a) { const o = [], s = r.isWebGL2, l = r.logarithmicDepthBuffer, c = r.floatVertexTextures, h = r.maxVertexUniforms, u = r.vertexTextures; let d = r.precision; const p = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"]; function m(e) { let t; return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = LinearEncoding, t } return { getParameters: function (n, o, f, g, y) { const v = g.fog, _ = n.isMeshStandardMaterial ? g.environment : null, b = t.get(n.envMap || _), x = p[n.type], w = y.isSkinnedMesh ? function (e) { const t = e.skeleton.bones; if (c) return 1024; { const e = h, i = Math.floor((e - 20) / 4), r = Math.min(i, t.length); return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."), 0) : r } }(y) : 0; let S, M; if (null !== n.precision && (d = r.getMaxPrecision(n.precision), d !== n.precision && console.warn("THREE.WebGLProgram.getParameters:", n.precision, "not supported, using", d, "instead.")), x) { const e = ShaderLib[x]; S = e.vertexShader, M = e.fragmentShader } else S = n.vertexShader, M = n.fragmentShader; const T = e.getRenderTarget(); return { isWebGL2: s, shaderID: x, shaderName: n.type, vertexShader: S, fragmentShader: M, defines: n.defines, isRawShaderMaterial: !0 === n.isRawShaderMaterial, glslVersion: n.glslVersion, precision: d, instancing: !0 === y.isInstancedMesh, instancingColor: !0 === y.isInstancedMesh && null !== y.instanceColor, supportsVertexTextures: u, outputEncoding: null !== T ? m(T.texture) : e.outputEncoding, map: !!n.map, mapEncoding: m(n.map), matcap: !!n.matcap, matcapEncoding: m(n.matcap), envMap: !!b, envMapMode: b && b.mapping, envMapEncoding: m(b), envMapCubeUV: !!b && (b.mapping === CubeUVReflectionMapping || b.mapping === CubeUVRefractionMapping), lightMap: !!n.lightMap, lightMapEncoding: m(n.lightMap), aoMap: !!n.aoMap, emissiveMap: !!n.emissiveMap, emissiveMapEncoding: m(n.emissiveMap), bumpMap: !!n.bumpMap, normalMap: !!n.normalMap, objectSpaceNormalMap: n.normalMapType === ObjectSpaceNormalMap, tangentSpaceNormalMap: n.normalMapType === TangentSpaceNormalMap, clearcoatMap: !!n.clearcoatMap, clearcoatRoughnessMap: !!n.clearcoatRoughnessMap, clearcoatNormalMap: !!n.clearcoatNormalMap, displacementMap: !!n.displacementMap, roughnessMap: !!n.roughnessMap, metalnessMap: !!n.metalnessMap, specularMap: !!n.specularMap, alphaMap: !!n.alphaMap, gradientMap: !!n.gradientMap, sheen: !!n.sheen, transmissionMap: !!n.transmissionMap, combine: n.combine, vertexTangents: n.normalMap && n.vertexTangents, vertexColors: n.vertexColors, vertexUvs: !!(n.map || n.bumpMap || n.normalMap || n.specularMap || n.alphaMap || n.emissiveMap || n.roughnessMap || n.metalnessMap || n.clearcoatMap || n.clearcoatRoughnessMap || n.clearcoatNormalMap || n.displacementMap || n.transmissionMap), uvsVertexOnly: !(n.map || n.bumpMap || n.normalMap || n.specularMap || n.alphaMap || n.emissiveMap || n.roughnessMap || n.metalnessMap || n.clearcoatNormalMap || n.transmissionMap || !n.displacementMap), fog: !!v, useFog: n.fog, fogExp2: v && v.isFogExp2, flatShading: !!n.flatShading, sizeAttenuation: n.sizeAttenuation, logarithmicDepthBuffer: l, skinning: n.skinning && w > 0, maxBones: w, useVertexTexture: c, morphTargets: n.morphTargets, morphNormals: n.morphNormals, maxMorphTargets: e.maxMorphTargets, maxMorphNormals: e.maxMorphNormals, numDirLights: o.directional.length, numPointLights: o.point.length, numSpotLights: o.spot.length, numRectAreaLights: o.rectArea.length, numHemiLights: o.hemi.length, numDirLightShadows: o.directionalShadowMap.length, numPointLightShadows: o.pointShadowMap.length, numSpotLightShadows: o.spotShadowMap.length, numClippingPlanes: a.numPlanes, numClipIntersection: a.numIntersection, dithering: n.dithering, shadowMapEnabled: e.shadowMap.enabled && f.length > 0, shadowMapType: e.shadowMap.type, toneMapping: n.toneMapped ? e.toneMapping : NoToneMapping, physicallyCorrectLights: e.physicallyCorrectLights, premultipliedAlpha: n.premultipliedAlpha, alphaTest: n.alphaTest, doubleSided: n.side === DoubleSide, flipSided: n.side === BackSide, depthPacking: void 0 !== n.depthPacking && n.depthPacking, index0AttributeName: n.index0AttributeName, extensionDerivatives: n.extensions && n.extensions.derivatives, extensionFragDepth: n.extensions && n.extensions.fragDepth, extensionDrawBuffers: n.extensions && n.extensions.drawBuffers, extensionShaderTextureLOD: n.extensions && n.extensions.shaderTextureLOD, rendererExtensionFragDepth: s || i.has("EXT_frag_depth"), rendererExtensionDrawBuffers: s || i.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: s || i.has("EXT_shader_texture_lod"), customProgramCacheKey: n.customProgramCacheKey() } }, getProgramCacheKey: function (t) { const i = []; if (t.shaderID ? i.push(t.shaderID) : (i.push(t.fragmentShader), i.push(t.vertexShader)), void 0 !== t.defines) for (const e in t.defines) i.push(e), i.push(t.defines[e]); if (!1 === t.isRawShaderMaterial) { for (let e = 0; e < f.length; e++)i.push(t[f[e]]); i.push(e.outputEncoding), i.push(e.gammaFactor) } return i.push(t.customProgramCacheKey), i.join() }, getUniforms: function (e) { const t = p[e.type]; let i; if (t) { const e = ShaderLib[t]; i = UniformsUtils.clone(e.uniforms) } else i = e.uniforms; return i }, acquireProgram: function (t, i) { let r; for (let e = 0, t = o.length; e < t; e++) { const t = o[e]; if (t.cacheKey === i) { r = t, ++r.usedTimes; break } } return void 0 === r && (r = new WebGLProgram(e, i, t, n), o.push(r)), r }, releaseProgram: function (e) { if (0 == --e.usedTimes) { const t = o.indexOf(e); o[t] = o[o.length - 1], o.pop(), e.destroy() } }, programs: o } } function WebGLProperties() { let e = new WeakMap; return { get: function (t) { let i = e.get(t); return void 0 === i && (i = {}, e.set(t, i)), i }, remove: function (t) { e.delete(t) }, update: function (t, i, r) { e.get(t)[i] = r }, dispose: function () { e = new WeakMap } } } function painterSortStable(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id } function reversePainterSortStable(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id } function WebGLRenderList(e) { const t = []; let i = 0; const r = [], n = [], a = { id: -1 }; function o(r, n, o, s, l, c) { let h = t[i]; const u = e.get(o); return void 0 === h ? (h = { id: r.id, object: r, geometry: n, material: o, program: u.program || a, groupOrder: s, renderOrder: r.renderOrder, z: l, group: c }, t[i] = h) : (h.id = r.id, h.object = r, h.geometry = n, h.material = o, h.program = u.program || a, h.groupOrder = s, h.renderOrder = r.renderOrder, h.z = l, h.group = c), i++, h } return { opaque: r, transparent: n, init: function () { i = 0, r.length = 0, n.length = 0 }, push: function (e, t, i, a, s, l) { const c = o(e, t, i, a, s, l); (!0 === i.transparent ? n : r).push(c) }, unshift: function (e, t, i, a, s, l) { const c = o(e, t, i, a, s, l); (!0 === i.transparent ? n : r).unshift(c) }, finish: function () { for (let e = i, r = t.length; e < r; e++) { const i = t[e]; if (null === i.id) break; i.id = null, i.object = null, i.geometry = null, i.material = null, i.program = null, i.group = null } }, sort: function (e, t) { r.length > 1 && r.sort(e || painterSortStable), n.length > 1 && n.sort(t || reversePainterSortStable) } } } function WebGLRenderLists(e) { let t = new WeakMap; return { get: function (i, r) { let n; return !1 === t.has(i) ? (n = new WebGLRenderList(e), t.set(i, [n])) : r >= t.get(i).length ? (n = new WebGLRenderList(e), t.get(i).push(n)) : n = t.get(i)[r], n }, dispose: function () { t = new WeakMap } } } function UniformsCache() { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let i; switch (t.type) { case "DirectionalLight": i = { direction: new Vector3, color: new Color$1 }; break; case "SpotLight": i = { position: new Vector3, direction: new Vector3, color: new Color$1, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": i = { position: new Vector3, color: new Color$1, distance: 0, decay: 0 }; break; case "HemisphereLight": i = { direction: new Vector3, skyColor: new Color$1, groundColor: new Color$1 }; break; case "RectAreaLight": i = { color: new Color$1, position: new Vector3, halfWidth: new Vector3, halfHeight: new Vector3 } }return e[t.id] = i, i } } } function ShadowUniformsCache() { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let i; switch (t.type) { case "DirectionalLight": case "SpotLight": i = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2 }; break; case "PointLight": i = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Vector2, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return e[t.id] = i, i } } } let nextVersion = 0; function shadowCastingLightsFirst(e, t) { return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0) } function WebGLLights(e, t) { const i = new UniformsCache, r = ShadowUniformsCache(), n = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let e = 0; e < 9; e++)n.probe.push(new Vector3); const a = new Vector3, o = new Matrix4, s = new Matrix4; return { setup: function (a) { let o = 0, s = 0, l = 0; for (let e = 0; e < 9; e++)n.probe[e].set(0, 0, 0); let c = 0, h = 0, u = 0, d = 0, p = 0, f = 0, m = 0, g = 0; a.sort(shadowCastingLightsFirst); for (let e = 0, t = a.length; e < t; e++) { const t = a[e], y = t.color, v = t.intensity, _ = t.distance, b = t.shadow && t.shadow.map ? t.shadow.map.texture : null; if (t.isAmbientLight) o += y.r * v, s += y.g * v, l += y.b * v; else if (t.isLightProbe) for (let e = 0; e < 9; e++)n.probe[e].addScaledVector(t.sh.coefficients[e], v); else if (t.isDirectionalLight) { const e = i.get(t); if (e.color.copy(t.color).multiplyScalar(t.intensity), t.castShadow) { const e = t.shadow, i = r.get(t); i.shadowBias = e.bias, i.shadowNormalBias = e.normalBias, i.shadowRadius = e.radius, i.shadowMapSize = e.mapSize, n.directionalShadow[c] = i, n.directionalShadowMap[c] = b, n.directionalShadowMatrix[c] = t.shadow.matrix, f++ } n.directional[c] = e, c++ } else if (t.isSpotLight) { const e = i.get(t); if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(y).multiplyScalar(v), e.distance = _, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) { const e = t.shadow, i = r.get(t); i.shadowBias = e.bias, i.shadowNormalBias = e.normalBias, i.shadowRadius = e.radius, i.shadowMapSize = e.mapSize, n.spotShadow[u] = i, n.spotShadowMap[u] = b, n.spotShadowMatrix[u] = t.shadow.matrix, g++ } n.spot[u] = e, u++ } else if (t.isRectAreaLight) { const e = i.get(t); e.color.copy(y).multiplyScalar(v), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), n.rectArea[d] = e, d++ } else if (t.isPointLight) { const e = i.get(t); if (e.color.copy(t.color).multiplyScalar(t.intensity), e.distance = t.distance, e.decay = t.decay, t.castShadow) { const e = t.shadow, i = r.get(t); i.shadowBias = e.bias, i.shadowNormalBias = e.normalBias, i.shadowRadius = e.radius, i.shadowMapSize = e.mapSize, i.shadowCameraNear = e.camera.near, i.shadowCameraFar = e.camera.far, n.pointShadow[h] = i, n.pointShadowMap[h] = b, n.pointShadowMatrix[h] = t.shadow.matrix, m++ } n.point[h] = e, h++ } else if (t.isHemisphereLight) { const e = i.get(t); e.skyColor.copy(t.color).multiplyScalar(v), e.groundColor.copy(t.groundColor).multiplyScalar(v), n.hemi[p] = e, p++ } } d > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (n.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, n.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (n.rectAreaLTC1 = UniformsLib.LTC_HALF_1, n.rectAreaLTC2 = UniformsLib.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), n.ambient[0] = o, n.ambient[1] = s, n.ambient[2] = l; const y = n.hash; y.directionalLength === c && y.pointLength === h && y.spotLength === u && y.rectAreaLength === d && y.hemiLength === p && y.numDirectionalShadows === f && y.numPointShadows === m && y.numSpotShadows === g || (n.directional.length = c, n.spot.length = u, n.rectArea.length = d, n.point.length = h, n.hemi.length = p, n.directionalShadow.length = f, n.directionalShadowMap.length = f, n.pointShadow.length = m, n.pointShadowMap.length = m, n.spotShadow.length = g, n.spotShadowMap.length = g, n.directionalShadowMatrix.length = f, n.pointShadowMatrix.length = m, n.spotShadowMatrix.length = g, y.directionalLength = c, y.pointLength = h, y.spotLength = u, y.rectAreaLength = d, y.hemiLength = p, y.numDirectionalShadows = f, y.numPointShadows = m, y.numSpotShadows = g, n.version = nextVersion++) }, setupView: function (e, t) { let i = 0, r = 0, l = 0, c = 0, h = 0; const u = t.matrixWorldInverse; for (let t = 0, d = e.length; t < d; t++) { const d = e[t]; if (d.isDirectionalLight) { const e = n.directional[i]; e.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(a), e.direction.transformDirection(u), i++ } else if (d.isSpotLight) { const e = n.spot[l]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), e.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(a), e.direction.transformDirection(u), l++ } else if (d.isRectAreaLight) { const e = n.rectArea[c]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), s.identity(), o.copy(d.matrixWorld), o.premultiply(u), s.extractRotation(o), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(s), e.halfHeight.applyMatrix4(s), c++ } else if (d.isPointLight) { const e = n.point[r]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), r++ } else if (d.isHemisphereLight) { const e = n.hemi[h]; e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(u), e.direction.normalize(), h++ } } }, state: n } } function WebGLRenderState(e, t) { const i = new WebGLLights(e, t), r = [], n = []; return { init: function () { r.length = 0, n.length = 0 }, state: { lightsArray: r, shadowsArray: n, lights: i }, setupLights: function () { i.setup(r) }, setupLightsView: function (e) { i.setupView(r, e) }, pushLight: function (e) { r.push(e) }, pushShadow: function (e) { n.push(e) } } } function WebGLRenderStates(e, t) { let i = new WeakMap; return { get: function (r, n = 0) { let a; return !1 === i.has(r) ? (a = new WebGLRenderState(e, t), i.set(r, [a])) : n >= i.get(r).length ? (a = new WebGLRenderState(e, t), i.get(r).push(a)) : a = i.get(r)[n], a }, dispose: function () { i = new WeakMap } } } class MeshDepthMaterial extends Material$1 { constructor(e) { super(), this.type = "MeshDepthMaterial", this.depthPacking = BasicDepthPacking, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } MeshDepthMaterial.prototype.isMeshDepthMaterial = !0; class MeshDistanceMaterial extends Material$1 { constructor(e) { super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Vector3, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e) } copy(e) { return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } MeshDistanceMaterial.prototype.isMeshDistanceMaterial = !0; var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}", vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}"; function WebGLShadowMap(e, t, i) { let r = new Frustum; const n = new Vector2, a = new Vector2, o = new Vector4, s = [], l = [], c = {}, h = { 0: BackSide, 1: FrontSide, 2: DoubleSide }, u = new ShaderMaterial({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Vector2 }, radius: { value: 4 } }, vertexShader: vsm_vert, fragmentShader: vsm_frag }), d = u.clone(); d.defines.HORIZONTAL_PASS = 1; const p = new BufferGeometry; p.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const f = new Mesh(p, u), m = this; function g(i, r) { const n = t.update(f); u.uniforms.shadow_pass.value = i.map.texture, u.uniforms.resolution.value = i.mapSize, u.uniforms.radius.value = i.radius, e.setRenderTarget(i.mapPass), e.clear(), e.renderBufferDirect(r, null, n, u, f, null), d.uniforms.shadow_pass.value = i.mapPass.texture, d.uniforms.resolution.value = i.mapSize, d.uniforms.radius.value = i.radius, e.setRenderTarget(i.map), e.clear(), e.renderBufferDirect(r, null, n, d, f, null) } function y(e, t, i) { const r = e << 0 | t << 1 | i << 2; let n = s[r]; return void 0 === n && (n = new MeshDepthMaterial({ depthPacking: RGBADepthPacking, morphTargets: e, skinning: t }), s[r] = n), n } function v(e, t, i) { const r = e << 0 | t << 1 | i << 2; let n = l[r]; return void 0 === n && (n = new MeshDistanceMaterial({ morphTargets: e, skinning: t }), l[r] = n), n } function _(t, i, r, n, a, o, s) { let l = null, u = y, d = t.customDepthMaterial; if (!0 === n.isPointLight && (u = v, d = t.customDistanceMaterial), void 0 === d) { let e = !1; !0 === r.morphTargets && (e = i.morphAttributes && i.morphAttributes.position && i.morphAttributes.position.length > 0); let n = !1; !0 === t.isSkinnedMesh && (!0 === r.skinning ? n = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t)); l = u(e, n, !0 === t.isInstancedMesh) } else l = d; if (e.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) { const e = l.uuid, t = r.uuid; let i = c[e]; void 0 === i && (i = {}, c[e] = i); let n = i[t]; void 0 === n && (n = l.clone(), i[t] = n), l = n } return l.visible = r.visible, l.wireframe = r.wireframe, l.side = s === VSMShadowMap ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : h[r.side], l.clipShadows = r.clipShadows, l.clippingPlanes = r.clippingPlanes, l.clipIntersection = r.clipIntersection, l.wireframeLinewidth = r.wireframeLinewidth, l.linewidth = r.linewidth, !0 === n.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(n.matrixWorld), l.nearDistance = a, l.farDistance = o), l } function b(i, n, a, o, s) { if (!1 === i.visible) return; if (i.layers.test(n.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && s === VSMShadowMap) && (!i.frustumCulled || r.intersectsObject(i))) { i.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, i.matrixWorld); const r = t.update(i), n = i.material; if (Array.isArray(n)) { const t = r.groups; for (let l = 0, c = t.length; l < c; l++) { const c = t[l], h = n[c.materialIndex]; if (h && h.visible) { const t = _(i, r, h, o, a.near, a.far, s); e.renderBufferDirect(a, null, r, t, i, c) } } } else if (n.visible) { const t = _(i, r, n, o, a.near, a.far, s); e.renderBufferDirect(a, null, r, t, i, null) } } const l = i.children; for (let e = 0, t = l.length; e < t; e++)b(l[e], n, a, o, s) } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = PCFShadowMap, this.render = function (t, s, l) { if (!1 === m.enabled) return; if (!1 === m.autoUpdate && !1 === m.needsUpdate) return; if (0 === t.length) return; const c = e.getRenderTarget(), h = e.getActiveCubeFace(), u = e.getActiveMipmapLevel(), d = e.state; d.setBlending(NoBlending), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1); for (let c = 0, h = t.length; c < h; c++) { const h = t[c], u = h.shadow; if (void 0 === u) { console.warn("THREE.WebGLShadowMap:", h, "has no shadow."); continue } if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue; n.copy(u.mapSize); const p = u.getFrameExtents(); if (n.multiply(p), a.copy(u.mapSize), (n.x > i || n.y > i) && (n.x > i && (a.x = Math.floor(i / p.x), n.x = a.x * p.x, u.mapSize.x = a.x), n.y > i && (a.y = Math.floor(i / p.y), n.y = a.y * p.y, u.mapSize.y = a.y)), null === u.map && !u.isPointLightShadow && this.type === VSMShadowMap) { const e = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat }; u.map = new WebGLRenderTarget(n.x, n.y, e), u.map.texture.name = h.name + ".shadowMap", u.mapPass = new WebGLRenderTarget(n.x, n.y, e), u.camera.updateProjectionMatrix() } if (null === u.map) { const e = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat }; u.map = new WebGLRenderTarget(n.x, n.y, e), u.map.texture.name = h.name + ".shadowMap", u.camera.updateProjectionMatrix() } e.setRenderTarget(u.map), e.clear(); const f = u.getViewportCount(); for (let e = 0; e < f; e++) { const t = u.getViewport(e); o.set(a.x * t.x, a.y * t.y, a.x * t.z, a.y * t.w), d.viewport(o), u.updateMatrices(h, e), r = u.getFrustum(), b(s, l, u.camera, h, this.type) } u.isPointLightShadow || this.type !== VSMShadowMap || g(u, l), u.needsUpdate = !1 } m.needsUpdate = !1, e.setRenderTarget(c, h, u) } } function WebGLState(e, t, i) { const r = i.isWebGL2; const n = new function () { let t = !1; const i = new Vector4; let r = null; const n = new Vector4(0, 0, 0, 0); return { setMask: function (i) { r === i || t || (e.colorMask(i, i, i, i), r = i) }, setLocked: function (e) { t = e }, setClear: function (t, r, a, o, s) { !0 === s && (t *= o, r *= o, a *= o), i.set(t, r, a, o), !1 === n.equals(i) && (e.clearColor(t, r, a, o), n.copy(i)) }, reset: function () { t = !1, r = null, n.set(-1, 0, 0, 0) } } }, a = new function () { let t = !1, i = null, r = null, n = null; return { setTest: function (e) { e ? O(2929) : I(2929) }, setMask: function (r) { i === r || t || (e.depthMask(r), i = r) }, setFunc: function (t) { if (r !== t) { if (t) switch (t) { case NeverDepth: e.depthFunc(512); break; case AlwaysDepth: e.depthFunc(519); break; case LessDepth: e.depthFunc(513); break; case LessEqualDepth: e.depthFunc(515); break; case EqualDepth: e.depthFunc(514); break; case GreaterEqualDepth: e.depthFunc(518); break; case GreaterDepth: e.depthFunc(516); break; case NotEqualDepth: e.depthFunc(517); break; default: e.depthFunc(515) } else e.depthFunc(515); r = t } }, setLocked: function (e) { t = e }, setClear: function (t) { n !== t && (e.clearDepth(t), n = t) }, reset: function () { t = !1, i = null, r = null, n = null } } }, o = new function () { let t = !1, i = null, r = null, n = null, a = null, o = null, s = null, l = null, c = null; return { setTest: function (e) { t || (e ? O(2960) : I(2960)) }, setMask: function (r) { i === r || t || (e.stencilMask(r), i = r) }, setFunc: function (t, i, o) { r === t && n === i && a === o || (e.stencilFunc(t, i, o), r = t, n = i, a = o) }, setOp: function (t, i, r) { o === t && s === i && l === r || (e.stencilOp(t, i, r), o = t, s = i, l = r) }, setLocked: function (e) { t = e }, setClear: function (t) { c !== t && (e.clearStencil(t), c = t) }, reset: function () { t = !1, i = null, r = null, n = null, a = null, o = null, s = null, l = null, c = null } } }; let s = {}, l = null, c = !1, h = null, u = null, d = null, p = null, f = null, m = null, g = null, y = !1, v = null, _ = null, b = null, x = null, w = null; const S = e.getParameter(35661); let M = !1, T = 0; const A = e.getParameter(7938); -1 !== A.indexOf("WebGL") ? (T = parseFloat(/^WebGL (\d)/.exec(A)[1]), M = T >= 1) : -1 !== A.indexOf("OpenGL ES") && (T = parseFloat(/^OpenGL ES (\d)/.exec(A)[1]), M = T >= 2); let E = null, C = {}; const L = new Vector4, R = new Vector4; function D(t, i, r) { const n = new Uint8Array(4), a = e.createTexture(); e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728); for (let t = 0; t < r; t++)e.texImage2D(i + t, 0, 6408, 1, 1, 0, 6408, 5121, n); return a } const P = {}; function O(t) { !0 !== s[t] && (e.enable(t), s[t] = !0) } function I(t) { !1 !== s[t] && (e.disable(t), s[t] = !1) } P[3553] = D(3553, 3553, 1), P[34067] = D(34067, 34069, 6), n.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), O(2929), a.setFunc(LessEqualDepth), F(!1), U(CullFaceBack), O(2884), N(NoBlending); const k = { [AddEquation]: 32774, [SubtractEquation]: 32778, [ReverseSubtractEquation]: 32779 }; if (r) k[MinEquation] = 32775, k[MaxEquation] = 32776; else { const e = t.get("EXT_blend_minmax"); null !== e && (k[MinEquation] = e.MIN_EXT, k[MaxEquation] = e.MAX_EXT) } const B = { [ZeroFactor]: 0, [OneFactor]: 1, [SrcColorFactor]: 768, [SrcAlphaFactor]: 770, [SrcAlphaSaturateFactor]: 776, [DstColorFactor]: 774, [DstAlphaFactor]: 772, [OneMinusSrcColorFactor]: 769, [OneMinusSrcAlphaFactor]: 771, [OneMinusDstColorFactor]: 775, [OneMinusDstAlphaFactor]: 773 }; function N(t, i, r, n, a, o, s, l) { if (t !== NoBlending) { if (!1 === c && (O(3042), c = !0), t === CustomBlending) a = a || i, o = o || r, s = s || n, i === u && a === f || (e.blendEquationSeparate(k[i], k[a]), u = i, f = a), r === d && n === p && o === m && s === g || (e.blendFuncSeparate(B[r], B[n], B[o], B[s]), d = r, p = n, m = o, g = s), h = t, y = null; else if (t !== h || l !== y) { if (u === AddEquation && f === AddEquation || (e.blendEquation(32774), u = AddEquation, f = AddEquation), l) switch (t) { case NormalBlending: e.blendFuncSeparate(1, 771, 1, 771); break; case AdditiveBlending: e.blendFunc(1, 1); break; case SubtractiveBlending: e.blendFuncSeparate(0, 0, 769, 771); break; case MultiplyBlending: e.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) } else switch (t) { case NormalBlending: e.blendFuncSeparate(770, 771, 1, 771); break; case AdditiveBlending: e.blendFunc(770, 1); break; case SubtractiveBlending: e.blendFunc(0, 769); break; case MultiplyBlending: e.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) }d = null, p = null, m = null, g = null, h = t, y = l } } else !0 === c && (I(3042), c = !1) } function F(t) { v !== t && (t ? e.frontFace(2304) : e.frontFace(2305), v = t) } function U(t) { t !== CullFaceNone ? (O(2884), t !== _ && (t === CullFaceBack ? e.cullFace(1029) : t === CullFaceFront ? e.cullFace(1028) : e.cullFace(1032))) : I(2884), _ = t } function z(t, i, r) { t ? (O(32823), x === i && w === r || (e.polygonOffset(i, r), x = i, w = r)) : I(32823) } function G(t) { void 0 === t && (t = 33984 + S - 1), E !== t && (e.activeTexture(t), E = t) } return { buffers: { color: n, depth: a, stencil: o }, enable: O, disable: I, useProgram: function (t) { return l !== t && (e.useProgram(t), l = t, !0) }, setBlending: N, setMaterial: function (e, t) { e.side === DoubleSide ? I(2884) : O(2884); let i = e.side === BackSide; t && (i = !i), F(i), e.blending === NormalBlending && !1 === e.transparent ? N(NoBlending) : N(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), n.setMask(e.colorWrite); const r = e.stencilWrite; o.setTest(r), r && (o.setMask(e.stencilWriteMask), o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), z(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits) }, setFlipSided: F, setCullFace: U, setLineWidth: function (t) { t !== b && (M && e.lineWidth(t), b = t) }, setPolygonOffset: z, setScissorTest: function (e) { e ? O(3089) : I(3089) }, activeTexture: G, bindTexture: function (t, i) { null === E && G(); let r = C[E]; void 0 === r && (r = { type: void 0, texture: void 0 }, C[E] = r), r.type === t && r.texture === i || (e.bindTexture(t, i || P[t]), r.type = t, r.texture = i) }, unbindTexture: function () { const t = C[E]; void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0) }, compressedTexImage2D: function () { try { e.compressedTexImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { e.texImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { e.texImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (t) { !1 === L.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), L.copy(t)) }, viewport: function (t) { !1 === R.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), R.copy(t)) }, reset: function () { e.disable(3042), e.disable(2884), e.disable(2929), e.disable(32823), e.disable(3089), e.disable(2960), e.blendEquation(32774), e.blendFunc(1, 0), e.blendFuncSeparate(1, 0, 1, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(513), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(519, 0, 4294967295), e.stencilOp(7680, 7680, 7680), e.clearStencil(0), e.cullFace(1029), e.frontFace(2305), e.polygonOffset(0, 0), e.activeTexture(33984), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), s = {}, E = null, C = {}, l = null, c = !1, h = null, u = null, d = null, p = null, f = null, m = null, g = null, y = !1, v = null, _ = null, b = null, x = null, w = null, n.reset(), a.reset(), o.reset() } } } function WebGLTextures(e, t, i, r, n, a, o) { const s = n.isWebGL2, l = n.maxTextures, c = n.maxCubemapSize, h = n.maxTextureSize, u = n.maxSamples, d = new WeakMap; let p, f = !1; try { f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (e) { } function m(e, t) { return f ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function g(e, t, i, r) { let n = 1; if ((e.width > r || e.height > r) && (n = r / Math.max(e.width, e.height)), n < 1 || !0 === t) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { const r = t ? MathUtils.floorPowerOfTwo : Math.floor, a = r(n * e.width), o = r(n * e.height); void 0 === p && (p = m(a, o)); const s = i ? m(a, o) : p; s.width = a, s.height = o; return s.getContext("2d").drawImage(e, 0, 0, a, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + o + ")."), s } return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e } return e } function y(e) { return MathUtils.isPowerOfTwo(e.width) && MathUtils.isPowerOfTwo(e.height) } function v(e, t) { return e.generateMipmaps && t && e.minFilter !== NearestFilter && e.minFilter !== LinearFilter } function _(t, i, n, a) { e.generateMipmap(t); r.get(i).__maxMipLevel = Math.log2(Math.max(n, a)) } function b(i, r, n) { if (!1 === s) return r; if (null !== i) { if (void 0 !== e[i]) return e[i]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'") } let a = r; return 6403 === r && (5126 === n && (a = 33326), 5131 === n && (a = 33325), 5121 === n && (a = 33321)), 6407 === r && (5126 === n && (a = 34837), 5131 === n && (a = 34843), 5121 === n && (a = 32849)), 6408 === r && (5126 === n && (a = 34836), 5131 === n && (a = 34842), 5121 === n && (a = 32856)), 33325 !== a && 33326 !== a && 34842 !== a && 34836 !== a || t.get("EXT_color_buffer_float"), a } function x(e) { return e === NearestFilter || e === NearestMipmapNearestFilter || e === NearestMipmapLinearFilter ? 9728 : 9729 } function w(t) { const i = t.target; i.removeEventListener("dispose", w), function (t) { const i = r.get(t); if (void 0 === i.__webglInit) return; e.deleteTexture(i.__webglTexture), r.remove(t) }(i), i.isVideoTexture && d.delete(i), o.memory.textures-- } function S(t) { const i = t.target; i.removeEventListener("dispose", S), function (t) { const i = t.texture, n = r.get(t), a = r.get(i); if (!t) return; void 0 !== a.__webglTexture && e.deleteTexture(a.__webglTexture); t.depthTexture && t.depthTexture.dispose(); if (t.isWebGLCubeRenderTarget) for (let t = 0; t < 6; t++)e.deleteFramebuffer(n.__webglFramebuffer[t]), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t]); else e.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && e.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer); r.remove(i), r.remove(t) }(i), o.memory.textures-- } let M = 0; function T(e, t) { const n = r.get(e); if (e.isVideoTexture && function (e) { const t = o.render.frame; d.get(e) !== t && (d.set(e, t), e.update()) }(e), e.version > 0 && n.__version !== e.version) { const i = e.image; if (void 0 === i) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== i.complete) return void D(n, e, t); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } i.activeTexture(33984 + t), i.bindTexture(3553, n.__webglTexture) } function A(t, n) { const o = r.get(t); t.version > 0 && o.__version !== t.version ? function (t, r, n) { if (6 !== r.image.length) return; R(t, r), i.activeTexture(33984 + n), i.bindTexture(34067, t.__webglTexture), e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), e.pixelStorei(37443, 0); const o = r && (r.isCompressedTexture || r.image[0].isCompressedTexture), l = r.image[0] && r.image[0].isDataTexture, h = []; for (let e = 0; e < 6; e++)h[e] = o || l ? l ? r.image[e].image : r.image[e] : g(r.image[e], !1, !0, c); const u = h[0], d = y(u) || s, p = a.convert(r.format), f = a.convert(r.type), m = b(r.internalFormat, p, f); let x; if (L(34067, r, d), o) { for (let e = 0; e < 6; e++) { x = h[e].mipmaps; for (let t = 0; t < x.length; t++) { const n = x[t]; r.format !== RGBAFormat && r.format !== RGBFormat ? null !== p ? i.compressedTexImage2D(34069 + e, t, m, n.width, n.height, 0, n.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + e, t, m, n.width, n.height, 0, p, f, n.data) } } t.__maxMipLevel = x.length - 1 } else { x = r.mipmaps; for (let e = 0; e < 6; e++)if (l) { i.texImage2D(34069 + e, 0, m, h[e].width, h[e].height, 0, p, f, h[e].data); for (let t = 0; t < x.length; t++) { const r = x[t].image[e].image; i.texImage2D(34069 + e, t + 1, m, r.width, r.height, 0, p, f, r.data) } } else { i.texImage2D(34069 + e, 0, m, p, f, h[e]); for (let t = 0; t < x.length; t++) { const r = x[t]; i.texImage2D(34069 + e, t + 1, m, p, f, r.image[e]) } } t.__maxMipLevel = x.length } v(r, d) && _(34067, r, u.width, u.height); t.__version = r.version, r.onUpdate && r.onUpdate(r) }(o, t, n) : (i.activeTexture(33984 + n), i.bindTexture(34067, o.__webglTexture)) } const E = { [RepeatWrapping]: 10497, [ClampToEdgeWrapping]: 33071, [MirroredRepeatWrapping]: 33648 }, C = { [NearestFilter]: 9728, [NearestMipmapNearestFilter]: 9984, [NearestMipmapLinearFilter]: 9986, [LinearFilter]: 9729, [LinearMipmapNearestFilter]: 9985, [LinearMipmapLinearFilter]: 9987 }; function L(i, a, o) { if (o ? (e.texParameteri(i, 10242, E[a.wrapS]), e.texParameteri(i, 10243, E[a.wrapT]), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, E[a.wrapR]), e.texParameteri(i, 10240, C[a.magFilter]), e.texParameteri(i, 10241, C[a.minFilter])) : (e.texParameteri(i, 10242, 33071), e.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, 33071), a.wrapS === ClampToEdgeWrapping && a.wrapT === ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(i, 10240, x(a.magFilter)), e.texParameteri(i, 10241, x(a.minFilter)), a.minFilter !== NearestFilter && a.minFilter !== LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) { const o = t.get("EXT_texture_filter_anisotropic"); if (a.type === FloatType && !1 === t.has("OES_texture_float_linear")) return; if (!1 === s && a.type === HalfFloatType && !1 === t.has("OES_texture_half_float_linear")) return; (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (e.texParameterf(i, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, n.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy) } } function R(t, i) { void 0 === t.__webglInit && (t.__webglInit = !0, i.addEventListener("dispose", w), t.__webglTexture = e.createTexture(), o.memory.textures++) } function D(t, r, n) { let o = 3553; r.isDataTexture2DArray && (o = 35866), r.isDataTexture3D && (o = 32879), R(t, r), i.activeTexture(33984 + n), i.bindTexture(o, t.__webglTexture), e.pixelStorei(37440, r.flipY), e.pixelStorei(37441, r.premultiplyAlpha), e.pixelStorei(3317, r.unpackAlignment), e.pixelStorei(37443, 0); const l = function (e) { return !s && (e.wrapS !== ClampToEdgeWrapping || e.wrapT !== ClampToEdgeWrapping || e.minFilter !== NearestFilter && e.minFilter !== LinearFilter) }(r) && !1 === y(r.image), c = g(r.image, l, !1, h), u = y(c) || s, d = a.convert(r.format); let p, f = a.convert(r.type), m = b(r.internalFormat, d, f); L(o, r, u); const x = r.mipmaps; if (r.isDepthTexture) m = 6402, s ? m = r.type === FloatType ? 36012 : r.type === UnsignedIntType ? 33190 : r.type === UnsignedInt248Type ? 35056 : 33189 : r.type === FloatType && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === DepthFormat && 6402 === m && r.type !== UnsignedShortType && r.type !== UnsignedIntType && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = UnsignedShortType, f = a.convert(r.type)), r.format === DepthStencilFormat && 6402 === m && (m = 34041, r.type !== UnsignedInt248Type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = UnsignedInt248Type, f = a.convert(r.type))), i.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null); else if (r.isDataTexture) if (x.length > 0 && u) { for (let e = 0, t = x.length; e < t; e++)p = x[e], i.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data); r.generateMipmaps = !1, t.__maxMipLevel = x.length - 1 } else i.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data), t.__maxMipLevel = 0; else if (r.isCompressedTexture) { for (let e = 0, t = x.length; e < t; e++)p = x[e], r.format !== RGBAFormat && r.format !== RGBFormat ? null !== d ? i.compressedTexImage2D(3553, e, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, e, m, p.width, p.height, 0, d, f, p.data); t.__maxMipLevel = x.length - 1 } else if (r.isDataTexture2DArray) i.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), t.__maxMipLevel = 0; else if (r.isDataTexture3D) i.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), t.__maxMipLevel = 0; else if (x.length > 0 && u) { for (let e = 0, t = x.length; e < t; e++)p = x[e], i.texImage2D(3553, e, m, d, f, p); r.generateMipmaps = !1, t.__maxMipLevel = x.length - 1 } else i.texImage2D(3553, 0, m, d, f, c), t.__maxMipLevel = 0; v(r, u) && _(o, r, c.width, c.height), t.__version = r.version, r.onUpdate && r.onUpdate(r) } function P(t, n, o, s) { const l = n.texture, c = a.convert(l.format), h = a.convert(l.type), u = b(l.internalFormat, c, h); 32879 === s || 35866 === s ? i.texImage3D(s, 0, u, n.width, n.height, n.depth, 0, c, h, null) : i.texImage2D(s, 0, u, n.width, n.height, 0, c, h, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, o, s, r.get(l).__webglTexture, 0), e.bindFramebuffer(36160, null) } function O(t, i, r) { if (e.bindRenderbuffer(36161, t), i.depthBuffer && !i.stencilBuffer) { let n = 33189; if (r) { const t = i.depthTexture; t && t.isDepthTexture && (t.type === FloatType ? n = 36012 : t.type === UnsignedIntType && (n = 33190)); const r = k(i); e.renderbufferStorageMultisample(36161, r, n, i.width, i.height) } else e.renderbufferStorage(36161, n, i.width, i.height); e.framebufferRenderbuffer(36160, 36096, 36161, t) } else if (i.depthBuffer && i.stencilBuffer) { if (r) { const t = k(i); e.renderbufferStorageMultisample(36161, t, 35056, i.width, i.height) } else e.renderbufferStorage(36161, 34041, i.width, i.height); e.framebufferRenderbuffer(36160, 33306, 36161, t) } else { const t = i.texture, n = a.convert(t.format), o = a.convert(t.type), s = b(t.internalFormat, n, o); if (r) { const t = k(i); e.renderbufferStorageMultisample(36161, t, s, i.width, i.height) } else e.renderbufferStorage(36161, s, i.width, i.height) } e.bindRenderbuffer(36161, null) } function I(t) { const i = r.get(t), n = !0 === t.isWebGLCubeRenderTarget; if (t.depthTexture) { if (n) throw new Error("target.depthTexture not supported in Cube render targets"); !function (t, i) { if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (e.bindFramebuffer(36160, t), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), T(i.depthTexture, 0); const n = r.get(i.depthTexture).__webglTexture; if (i.depthTexture.format === DepthFormat) e.framebufferTexture2D(36160, 36096, 3553, n, 0); else { if (i.depthTexture.format !== DepthStencilFormat) throw new Error("Unknown depthTexture format"); e.framebufferTexture2D(36160, 33306, 3553, n, 0) } }(i.__webglFramebuffer, t) } else if (n) { i.__webglDepthbuffer = []; for (let r = 0; r < 6; r++)e.bindFramebuffer(36160, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = e.createRenderbuffer(), O(i.__webglDepthbuffer[r], t, !1) } else e.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = e.createRenderbuffer(), O(i.__webglDepthbuffer, t, !1); e.bindFramebuffer(36160, null) } function k(e) { return s && e.isWebGLMultisampleRenderTarget ? Math.min(u, e.samples) : 0 } let B = !1, N = !1; this.allocateTextureUnit = function () { const e = M; return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l), M += 1, e }, this.resetTextureUnits = function () { M = 0 }, this.setTexture2D = T, this.setTexture2DArray = function (e, t) { const n = r.get(e); e.version > 0 && n.__version !== e.version ? D(n, e, t) : (i.activeTexture(33984 + t), i.bindTexture(35866, n.__webglTexture)) }, this.setTexture3D = function (e, t) { const n = r.get(e); e.version > 0 && n.__version !== e.version ? D(n, e, t) : (i.activeTexture(33984 + t), i.bindTexture(32879, n.__webglTexture)) }, this.setTextureCube = A, this.setupRenderTarget = function (t) { const n = t.texture, l = r.get(t), c = r.get(n); t.addEventListener("dispose", S), c.__webglTexture = e.createTexture(), o.memory.textures++; const h = !0 === t.isWebGLCubeRenderTarget, u = !0 === t.isWebGLMultisampleRenderTarget, d = n.isDataTexture3D || n.isDataTexture2DArray, p = y(t) || s; if (!s || n.format !== RGBFormat || n.type !== FloatType && n.type !== HalfFloatType || (n.format = RGBAFormat, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h) { l.__webglFramebuffer = []; for (let t = 0; t < 6; t++)l.__webglFramebuffer[t] = e.createFramebuffer() } else if (l.__webglFramebuffer = e.createFramebuffer(), u) if (s) { l.__webglMultisampledFramebuffer = e.createFramebuffer(), l.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, l.__webglColorRenderbuffer); const i = a.convert(n.format), r = a.convert(n.type), o = b(n.internalFormat, i, r), s = k(t); e.renderbufferStorageMultisample(36161, s, o, t.width, t.height), e.bindFramebuffer(36160, l.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (l.__webglDepthRenderbuffer = e.createRenderbuffer(), O(l.__webglDepthRenderbuffer, t, !0)), e.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (h) { i.bindTexture(34067, c.__webglTexture), L(34067, n, p); for (let e = 0; e < 6; e++)P(l.__webglFramebuffer[e], t, 36064, 34069 + e); v(n, p) && _(34067, n, t.width, t.height), i.bindTexture(34067, null) } else { let e = 3553; if (d) if (s) { e = n.isDataTexture3D ? 32879 : 35866 } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."); i.bindTexture(e, c.__webglTexture), L(e, n, p), P(l.__webglFramebuffer, t, 36064, e), v(n, p) && _(3553, n, t.width, t.height), i.bindTexture(3553, null) } t.depthBuffer && I(t) }, this.updateRenderTargetMipmap = function (e) { const t = e.texture; if (v(t, y(e) || s)) { const n = e.isWebGLCubeRenderTarget ? 34067 : 3553, a = r.get(t).__webglTexture; i.bindTexture(n, a), _(n, t, e.width, e.height), i.bindTexture(n, null) } }, this.updateMultisampleRenderTarget = function (t) { if (t.isWebGLMultisampleRenderTarget) if (s) { const i = r.get(t); e.bindFramebuffer(36008, i.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, i.__webglFramebuffer); const n = t.width, a = t.height; let o = 16384; t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024), e.blitFramebuffer(0, 0, n, a, 0, 0, n, a, o, 9728), e.bindFramebuffer(36160, i.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (e, t) { e && e.isWebGLRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), B = !0), e = e.texture), T(e, t) }, this.safeSetTextureCube = function (e, t) { e && e.isWebGLCubeRenderTarget && (!1 === N && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), N = !0), e = e.texture), A(e, t) } } function WebGLUtils(e, t, i) { const r = i.isWebGL2; return { convert: function (e) { let i; if (e === UnsignedByteType) return 5121; if (e === UnsignedShort4444Type) return 32819; if (e === UnsignedShort5551Type) return 32820; if (e === UnsignedShort565Type) return 33635; if (e === ByteType) return 5120; if (e === ShortType) return 5122; if (e === UnsignedShortType) return 5123; if (e === IntType) return 5124; if (e === UnsignedIntType) return 5125; if (e === FloatType) return 5126; if (e === HalfFloatType) return r ? 5131 : (i = t.get("OES_texture_half_float"), null !== i ? i.HALF_FLOAT_OES : null); if (e === AlphaFormat) return 6406; if (e === RGBFormat) return 6407; if (e === RGBAFormat) return 6408; if (e === LuminanceFormat) return 6409; if (e === LuminanceAlphaFormat) return 6410; if (e === DepthFormat) return 6402; if (e === DepthStencilFormat) return 34041; if (e === RedFormat) return 6403; if (e === RedIntegerFormat) return 36244; if (e === RGFormat) return 33319; if (e === RGIntegerFormat) return 33320; if (e === RGBIntegerFormat) return 36248; if (e === RGBAIntegerFormat) return 36249; if (e === RGB_S3TC_DXT1_Format || e === RGBA_S3TC_DXT1_Format || e === RGBA_S3TC_DXT3_Format || e === RGBA_S3TC_DXT5_Format) { if (i = t.get("WEBGL_compressed_texture_s3tc"), null === i) return null; if (e === RGB_S3TC_DXT1_Format) return i.COMPRESSED_RGB_S3TC_DXT1_EXT; if (e === RGBA_S3TC_DXT1_Format) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (e === RGBA_S3TC_DXT3_Format) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (e === RGBA_S3TC_DXT5_Format) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (e === RGB_PVRTC_4BPPV1_Format || e === RGB_PVRTC_2BPPV1_Format || e === RGBA_PVRTC_4BPPV1_Format || e === RGBA_PVRTC_2BPPV1_Format) { if (i = t.get("WEBGL_compressed_texture_pvrtc"), null === i) return null; if (e === RGB_PVRTC_4BPPV1_Format) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (e === RGB_PVRTC_2BPPV1_Format) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (e === RGBA_PVRTC_4BPPV1_Format) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (e === RGBA_PVRTC_2BPPV1_Format) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (e === RGB_ETC1_Format) return i = t.get("WEBGL_compressed_texture_etc1"), null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null; if ((e === RGB_ETC2_Format || e === RGBA_ETC2_EAC_Format) && (i = t.get("WEBGL_compressed_texture_etc"), null !== i)) { if (e === RGB_ETC2_Format) return i.COMPRESSED_RGB8_ETC2; if (e === RGBA_ETC2_EAC_Format) return i.COMPRESSED_RGBA8_ETC2_EAC } return e === RGBA_ASTC_4x4_Format || e === RGBA_ASTC_5x4_Format || e === RGBA_ASTC_5x5_Format || e === RGBA_ASTC_6x5_Format || e === RGBA_ASTC_6x6_Format || e === RGBA_ASTC_8x5_Format || e === RGBA_ASTC_8x6_Format || e === RGBA_ASTC_8x8_Format || e === RGBA_ASTC_10x5_Format || e === RGBA_ASTC_10x6_Format || e === RGBA_ASTC_10x8_Format || e === RGBA_ASTC_10x10_Format || e === RGBA_ASTC_12x10_Format || e === RGBA_ASTC_12x12_Format || e === SRGB8_ALPHA8_ASTC_4x4_Format || e === SRGB8_ALPHA8_ASTC_5x4_Format || e === SRGB8_ALPHA8_ASTC_5x5_Format || e === SRGB8_ALPHA8_ASTC_6x5_Format || e === SRGB8_ALPHA8_ASTC_6x6_Format || e === SRGB8_ALPHA8_ASTC_8x5_Format || e === SRGB8_ALPHA8_ASTC_8x6_Format || e === SRGB8_ALPHA8_ASTC_8x8_Format || e === SRGB8_ALPHA8_ASTC_10x5_Format || e === SRGB8_ALPHA8_ASTC_10x6_Format || e === SRGB8_ALPHA8_ASTC_10x8_Format || e === SRGB8_ALPHA8_ASTC_10x10_Format || e === SRGB8_ALPHA8_ASTC_12x10_Format || e === SRGB8_ALPHA8_ASTC_12x12_Format ? (i = t.get("WEBGL_compressed_texture_astc"), null !== i ? e : null) : e === RGBA_BPTC_Format ? (i = t.get("EXT_texture_compression_bptc"), null !== i ? e : null) : e === UnsignedInt248Type ? r ? 34042 : (i = t.get("WEBGL_depth_texture"), null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null) : void 0 } } } function ArrayCamera(e = []) { PerspectiveCamera.call(this), this.cameras = e } ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), { constructor: ArrayCamera, isArrayCamera: !0 }); class Group extends Object3D { constructor() { super(), this.type = "Group" } } function WebXRController() { this._targetRay = null, this._grip = null, this._hand = null } function WebXRManager(e, t) { const i = this; let r = null, n = 1, a = null, o = "local-floor", s = null; const l = [], c = new Map, h = new PerspectiveCamera; h.layers.enable(1), h.viewport = new Vector4; const u = new PerspectiveCamera; u.layers.enable(2), u.viewport = new Vector4; const d = [h, u], p = new ArrayCamera; p.layers.enable(1), p.layers.enable(2); let f = null, m = null; function g(e) { const t = c.get(e.inputSource); t && t.dispatchEvent({ type: e.type, data: e.inputSource }) } function y() { c.forEach((function (e, t) { e.disconnect(t) })), c.clear(), f = null, m = null, e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), S.stop(), i.isPresenting = !1, i.dispatchEvent({ type: "sessionend" }) } function v(e) { const t = r.inputSources; for (let e = 0; e < l.length; e++)c.set(t[e], l[e]); for (let t = 0; t < e.removed.length; t++) { const i = e.removed[t], r = c.get(i); r && (r.dispatchEvent({ type: "disconnected", data: i }), c.delete(i)) } for (let t = 0; t < e.added.length; t++) { const i = e.added[t], r = c.get(i); r && r.dispatchEvent({ type: "connected", data: i }) } } this.enabled = !1, this.isPresenting = !1, this.getController = function (e) { let t = l[e]; return void 0 === t && (t = new WebXRController, l[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function (e) { let t = l[e]; return void 0 === t && (t = new WebXRController, l[e] = t), t.getGripSpace() }, this.getHand = function (e) { let t = l[e]; return void 0 === t && (t = new WebXRController, l[e] = t), t.getHandSpace() }, this.setFramebufferScaleFactor = function (e) { n = e, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (e) { o = e, !0 === i.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return a }, this.getSession = function () { return r }, this.setSession = async function (e) { if (r = e, null !== r) { r.addEventListener("select", g), r.addEventListener("selectstart", g), r.addEventListener("selectend", g), r.addEventListener("squeeze", g), r.addEventListener("squeezestart", g), r.addEventListener("squeezeend", g), r.addEventListener("end", y), r.addEventListener("inputsourceschange", v); const e = t.getContextAttributes(); !0 !== e.xrCompatible && await t.makeXRCompatible(); const s = { antialias: e.antialias, alpha: e.alpha, depth: e.depth, stencil: e.stencil, framebufferScaleFactor: n }, l = new XRWebGLLayer(r, t, s); r.updateRenderState({ baseLayer: l }), a = await r.requestReferenceSpace(o), S.setContext(r), S.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" }) } }; const _ = new Vector3, b = new Vector3; function x(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert() } this.getCamera = function (e) { p.near = u.near = h.near = e.near, p.far = u.far = h.far = e.far, f === p.near && m === p.far || (r.updateRenderState({ depthNear: p.near, depthFar: p.far }), f = p.near, m = p.far); const t = e.parent, i = p.cameras; x(p, t); for (let e = 0; e < i.length; e++)x(i[e], t); e.matrixWorld.copy(p.matrixWorld), e.matrix.copy(p.matrix), e.matrix.decompose(e.position, e.quaternion, e.scale); const n = e.children; for (let e = 0, t = n.length; e < t; e++)n[e].updateMatrixWorld(!0); return 2 === i.length ? function (e, t, i) { _.setFromMatrixPosition(t.matrixWorld), b.setFromMatrixPosition(i.matrixWorld); const r = _.distanceTo(b), n = t.projectionMatrix.elements, a = i.projectionMatrix.elements, o = n[14] / (n[10] - 1), s = n[14] / (n[10] + 1), l = (n[9] + 1) / n[5], c = (n[9] - 1) / n[5], h = (n[8] - 1) / n[0], u = (a[8] + 1) / a[0], d = o * h, p = o * u, f = r / (-h + u), m = f * -h; t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(); const g = o + f, y = s + f, v = d - m, x = p + (r - m), w = l * s / y * g, S = c * s / y * g; e.projectionMatrix.makePerspective(v, x, w, S, g, y) }(p, h, u) : p.projectionMatrix.copy(h.projectionMatrix), p }; let w = null; const S = new WebGLAnimation; S.setAnimationLoop((function (t, i) { if (s = i.getViewerPose(a), null !== s) { const t = s.views, i = r.renderState.baseLayer; e.setFramebuffer(i.framebuffer); let n = !1; t.length !== p.cameras.length && (p.cameras.length = 0, n = !0); for (let e = 0; e < t.length; e++) { const r = t[e], a = i.getViewport(r), o = d[e]; o.matrix.fromArray(r.transform.matrix), o.projectionMatrix.fromArray(r.projectionMatrix), o.viewport.set(a.x, a.y, a.width, a.height), 0 === e && p.matrix.copy(o.matrix), !0 === n && p.cameras.push(o) } } const n = r.inputSources; for (let e = 0; e < l.length; e++) { const t = l[e], r = n[e]; t.update(r, i, a) } w && w(t, i) })), this.setAnimationLoop = function (e) { w = e }, this.dispose = function () { } } function WebGLMaterials(e) { function t(t, i) { t.opacity.value = i.opacity, i.color && t.diffuse.value.copy(i.color), i.emissive && t.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (t.map.value = i.map), i.alphaMap && (t.alphaMap.value = i.alphaMap), i.specularMap && (t.specularMap.value = i.specularMap); const r = e.get(i).envMap; if (r) { t.envMap.value = r, t.flipEnvMap.value = r.isCubeTexture && r._needsFlipEnvMap ? -1 : 1, t.reflectivity.value = i.reflectivity, t.refractionRatio.value = i.refractionRatio; const n = e.get(r).__maxMipLevel; void 0 !== n && (t.maxMipLevel.value = n) } let n, a; i.lightMap && (t.lightMap.value = i.lightMap, t.lightMapIntensity.value = i.lightMapIntensity), i.aoMap && (t.aoMap.value = i.aoMap, t.aoMapIntensity.value = i.aoMapIntensity), i.map ? n = i.map : i.specularMap ? n = i.specularMap : i.displacementMap ? n = i.displacementMap : i.normalMap ? n = i.normalMap : i.bumpMap ? n = i.bumpMap : i.roughnessMap ? n = i.roughnessMap : i.metalnessMap ? n = i.metalnessMap : i.alphaMap ? n = i.alphaMap : i.emissiveMap ? n = i.emissiveMap : i.clearcoatMap ? n = i.clearcoatMap : i.clearcoatNormalMap ? n = i.clearcoatNormalMap : i.clearcoatRoughnessMap && (n = i.clearcoatRoughnessMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix)), i.aoMap ? a = i.aoMap : i.lightMap && (a = i.lightMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), t.uv2Transform.value.copy(a.matrix)) } function i(t, i) { t.roughness.value = i.roughness, t.metalness.value = i.metalness, i.roughnessMap && (t.roughnessMap.value = i.roughnessMap), i.metalnessMap && (t.metalnessMap.value = i.metalnessMap), i.emissiveMap && (t.emissiveMap.value = i.emissiveMap), i.bumpMap && (t.bumpMap.value = i.bumpMap, t.bumpScale.value = i.bumpScale, i.side === BackSide && (t.bumpScale.value *= -1)), i.normalMap && (t.normalMap.value = i.normalMap, t.normalScale.value.copy(i.normalScale), i.side === BackSide && t.normalScale.value.negate()), i.displacementMap && (t.displacementMap.value = i.displacementMap, t.displacementScale.value = i.displacementScale, t.displacementBias.value = i.displacementBias); e.get(i).envMap && (t.envMapIntensity.value = i.envMapIntensity) } return { refreshFogUniforms: function (e, t) { e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density) }, refreshMaterialUniforms: function (e, r, n, a) { r.isMeshBasicMaterial ? t(e, r) : r.isMeshLambertMaterial ? (t(e, r), function (e, t) { t.emissiveMap && (e.emissiveMap.value = t.emissiveMap) }(e, r)) : r.isMeshToonMaterial ? (t(e, r), function (e, t) { t.gradientMap && (e.gradientMap.value = t.gradientMap); t.emissiveMap && (e.emissiveMap.value = t.emissiveMap); t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === BackSide && (e.bumpScale.value *= -1)); t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === BackSide && e.normalScale.value.negate()); t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isMeshPhongMaterial ? (t(e, r), function (e, t) { e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap); t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === BackSide && (e.bumpScale.value *= -1)); t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === BackSide && e.normalScale.value.negate()); t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isMeshStandardMaterial ? (t(e, r), r.isMeshPhysicalMaterial ? function (e, t) { i(e, t), e.reflectivity.value = t.reflectivity, e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.sheen && e.sheen.value.copy(t.sheen); t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap); t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap); t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === BackSide && e.clearcoatNormalScale.value.negate()); e.transmission.value = t.transmission, t.transmissionMap && (e.transmissionMap.value = t.transmissionMap) }(e, r) : i(e, r)) : r.isMeshMatcapMaterial ? (t(e, r), function (e, t) { t.matcap && (e.matcap.value = t.matcap); t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === BackSide && (e.bumpScale.value *= -1)); t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === BackSide && e.normalScale.value.negate()); t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isMeshDepthMaterial ? (t(e, r), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isMeshDistanceMaterial ? (t(e, r), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias); e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance }(e, r)) : r.isMeshNormalMaterial ? (t(e, r), function (e, t) { t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === BackSide && (e.bumpScale.value *= -1)); t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === BackSide && e.normalScale.value.negate()); t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, r)) : r.isLineBasicMaterial ? (function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity }(e, r), r.isLineDashedMaterial && function (e, t) { e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale }(e, r)) : r.isPointsMaterial ? function (e, t, i, r) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * i, e.scale.value = .5 * r, t.map && (e.map.value = t.map); t.alphaMap && (e.alphaMap.value = t.alphaMap); let n; t.map ? n = t.map : t.alphaMap && (n = t.alphaMap); void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix)) }(e, r, n, a) : r.isSpriteMaterial ? function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map); t.alphaMap && (e.alphaMap.value = t.alphaMap); let i; t.map ? i = t.map : t.alphaMap && (i = t.alphaMap); void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix)) }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1) } } } function createCanvasElement() { const e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); return e.style.display = "block", e } function WebGLRenderer(e) { const t = void 0 !== (e = e || {}).canvas ? e.canvas : createCanvasElement(), i = void 0 !== e.context ? e.context : null, r = void 0 !== e.alpha && e.alpha, n = void 0 === e.depth || e.depth, a = void 0 === e.stencil || e.stencil, o = void 0 !== e.antialias && e.antialias, s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, c = void 0 !== e.powerPreference ? e.powerPreference : "default", h = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat; let u = null, d = null; const p = [], f = []; this.domElement = t, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = LinearEncoding, this.physicallyCorrectLights = !1, this.toneMapping = NoToneMapping, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; const m = this; let g = !1, y = null, v = 0, _ = 0, b = null, x = null, w = -1, S = null; const M = new Vector4, T = new Vector4; let A = null, E = t.width, C = t.height, L = 1, R = null, D = null; const P = new Vector4(0, 0, E, C), O = new Vector4(0, 0, E, C); let I = !1; const k = new Frustum; let B = !1, N = !1; const F = new Matrix4, U = new Vector3, z = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function G() { return null === b ? L : 1 } let H, V, j, W, $, Y, X, Z, q, J, K, Q, ee, te, ie, re, ne, ae, oe, se, le, ce = i; function he(e, i) { for (let r = 0; r < e.length; r++) { const n = e[r], a = t.getContext(n, i); if (null !== a) return a } return null } try { const e = { alpha: r, depth: n, stencil: a, antialias: o, premultipliedAlpha: s, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: h }; if (t.addEventListener("webglcontextlost", fe, !1), t.addEventListener("webglcontextrestored", me, !1), null === ce) { const t = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === m.isWebGL1Renderer && t.shift(), ce = he(t, e), null === ce) throw he(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === ce.getShaderPrecisionFormat && (ce.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e } function ue() { H = new WebGLExtensions(ce), V = new WebGLCapabilities(ce, H, e), H.init(V), se = new WebGLUtils(ce, H, V), j = new WebGLState(ce, H, V), j.scissor(T.copy(O).multiplyScalar(L).floor()), j.viewport(M.copy(P).multiplyScalar(L).floor()), W = new WebGLInfo(ce), $ = new WebGLProperties, Y = new WebGLTextures(ce, H, j, $, V, se, W), X = new WebGLCubeMaps(m), Z = new WebGLAttributes(ce, V), le = new WebGLBindingStates(ce, H, Z, V), q = new WebGLGeometries(ce, Z, W, le), J = new WebGLObjects(ce, q, Z, W), ne = new WebGLMorphtargets(ce), ie = new WebGLClipping($), K = new WebGLPrograms(m, X, H, V, le, ie), Q = new WebGLMaterials($), ee = new WebGLRenderLists($), te = new WebGLRenderStates(H, V), re = new WebGLBackground(m, X, j, J, s), ae = new WebGLBufferRenderer(ce, H, W, V), oe = new WebGLIndexedBufferRenderer(ce, H, W, V), W.programs = K.programs, m.capabilities = V, m.extensions = H, m.properties = $, m.renderLists = ee, m.state = j, m.info = W } ue(); const de = new WebXRManager(m, ce); this.xr = de; const pe = new WebGLShadowMap(m, J, V.maxTextureSize); function fe(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0 } function me() { console.log("THREE.WebGLRenderer: Context Restored."), g = !1, ue() } function ge(e) { const t = e.target; t.removeEventListener("dispose", ge), function (e) { ye(e), $.remove(e) }(t) } function ye(e) { const t = $.get(e).program; void 0 !== t && K.releaseProgram(t) } this.shadowMap = pe, this.getContext = function () { return ce }, this.getContextAttributes = function () { return ce.getContextAttributes() }, this.forceContextLoss = function () { const e = H.get("WEBGL_lose_context"); e && e.loseContext() }, this.forceContextRestore = function () { const e = H.get("WEBGL_lose_context"); e && e.restoreContext() }, this.getPixelRatio = function () { return L }, this.setPixelRatio = function (e) { void 0 !== e && (L = e, this.setSize(E, C, !1)) }, this.getSize = function (e) { return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new Vector2), e.set(E, C) }, this.setSize = function (e, i, r) { de.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (E = e, C = i, t.width = Math.floor(e * L), t.height = Math.floor(i * L), !1 !== r && (t.style.width = e + "px", t.style.height = i + "px"), this.setViewport(0, 0, e, i)) }, this.getDrawingBufferSize = function (e) { return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new Vector2), e.set(E * L, C * L).floor() }, this.setDrawingBufferSize = function (e, i, r) { E = e, C = i, L = r, t.width = Math.floor(e * r), t.height = Math.floor(i * r), this.setViewport(0, 0, e, i) }, this.getCurrentViewport = function (e) { return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new Vector4), e.copy(M) }, this.getViewport = function (e) { return e.copy(P) }, this.setViewport = function (e, t, i, r) { e.isVector4 ? P.set(e.x, e.y, e.z, e.w) : P.set(e, t, i, r), j.viewport(M.copy(P).multiplyScalar(L).floor()) }, this.getScissor = function (e) { return e.copy(O) }, this.setScissor = function (e, t, i, r) { e.isVector4 ? O.set(e.x, e.y, e.z, e.w) : O.set(e, t, i, r), j.scissor(T.copy(O).multiplyScalar(L).floor()) }, this.getScissorTest = function () { return I }, this.setScissorTest = function (e) { j.setScissorTest(I = e) }, this.setOpaqueSort = function (e) { R = e }, this.setTransparentSort = function (e) { D = e }, this.getClearColor = function (e) { return void 0 === e && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), e = new Color$1), e.copy(re.getClearColor()) }, this.setClearColor = function () { re.setClearColor.apply(re, arguments) }, this.getClearAlpha = function () { return re.getClearAlpha() }, this.setClearAlpha = function () { re.setClearAlpha.apply(re, arguments) }, this.clear = function (e, t, i) { let r = 0; (void 0 === e || e) && (r |= 16384), (void 0 === t || t) && (r |= 256), (void 0 === i || i) && (r |= 1024), ce.clear(r) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", fe, !1), t.removeEventListener("webglcontextrestored", me, !1), ee.dispose(), te.dispose(), $.dispose(), X.dispose(), J.dispose(), le.dispose(), de.dispose(), _e.stop() }, this.renderBufferImmediate = function (e, t) { le.initAttributes(); const i = $.get(e); e.hasPositions && !i.position && (i.position = ce.createBuffer()), e.hasNormals && !i.normal && (i.normal = ce.createBuffer()), e.hasUvs && !i.uv && (i.uv = ce.createBuffer()), e.hasColors && !i.color && (i.color = ce.createBuffer()); const r = t.getAttributes(); e.hasPositions && (ce.bindBuffer(34962, i.position), ce.bufferData(34962, e.positionArray, 35048), le.enableAttribute(r.position), ce.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), e.hasNormals && (ce.bindBuffer(34962, i.normal), ce.bufferData(34962, e.normalArray, 35048), le.enableAttribute(r.normal), ce.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (ce.bindBuffer(34962, i.uv), ce.bufferData(34962, e.uvArray, 35048), le.enableAttribute(r.uv), ce.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), e.hasColors && (ce.bindBuffer(34962, i.color), ce.bufferData(34962, e.colorArray, 35048), le.enableAttribute(r.color), ce.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), le.disableUnusedAttributes(), ce.drawArrays(4, 0, e.count), e.count = 0 }, this.renderBufferDirect = function (e, t, i, r, n, a) { null === t && (t = z); const o = n.isMesh && n.matrixWorld.determinant() < 0, s = Me(e, t, r, n); j.setMaterial(r, o); let l = i.index; const c = i.attributes.position; if (null === l) { if (void 0 === c || 0 === c.count) return } else if (0 === l.count) return; let h, u = 1; !0 === r.wireframe && (l = q.getWireframeAttribute(i), u = 2), (r.morphTargets || r.morphNormals) && ne.update(n, i, r, s), le.setup(n, r, s, i, l); let d = ae; null !== l && (h = Z.get(l), d = oe, d.setIndex(h)); const p = null !== l ? l.count : c.count, f = i.drawRange.start * u, m = i.drawRange.count * u, g = null !== a ? a.start * u : 0, y = null !== a ? a.count * u : 1 / 0, v = Math.max(f, g), _ = Math.min(p, f + m, g + y) - 1, b = Math.max(0, _ - v + 1); if (0 !== b) { if (n.isMesh) !0 === r.wireframe ? (j.setLineWidth(r.wireframeLinewidth * G()), d.setMode(1)) : d.setMode(4); else if (n.isLine) { let e = r.linewidth; void 0 === e && (e = 1), j.setLineWidth(e * G()), n.isLineSegments ? d.setMode(1) : n.isLineLoop ? d.setMode(2) : d.setMode(3) } else n.isPoints ? d.setMode(0) : n.isSprite && d.setMode(4); if (n.isInstancedMesh) d.renderInstances(v, b, n.count); else if (i.isInstancedBufferGeometry) { const e = Math.min(i.instanceCount, i._maxInstanceCount); d.renderInstances(v, b, e) } else d.render(v, b) } }, this.compile = function (e, t) { d = te.get(e), d.init(), e.traverseVisible((function (e) { e.isLight && e.layers.test(t.layers) && (d.pushLight(e), e.castShadow && d.pushShadow(e)) })), d.setupLights(); const i = new WeakMap; e.traverse((function (t) { const r = t.material; if (r) if (Array.isArray(r)) for (let n = 0; n < r.length; n++) { const a = r[n]; !1 === i.has(a) && (Se(a, e, t), i.set(a)) } else !1 === i.has(r) && (Se(r, e, t), i.set(r)) })) }; let ve = null; const _e = new WebGLAnimation; function be(e, t, i, r) { if (!1 === e.visible) return; if (e.layers.test(t.layers)) if (e.isGroup) i = e.renderOrder; else if (e.isLOD) !0 === e.autoUpdate && e.update(t); else if (e.isLight) d.pushLight(e), e.castShadow && d.pushShadow(e); else if (e.isSprite) { if (!e.frustumCulled || k.intersectsSprite(e)) { r && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F); const t = J.update(e), n = e.material; n.visible && u.push(e, t, n, i, U.z, null) } } else if (e.isImmediateRenderObject) r && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F), u.push(e, null, e.material, i, U.z, null); else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== W.render.frame && (e.skeleton.update(), e.skeleton.frame = W.render.frame), !e.frustumCulled || k.intersectsObject(e))) { r && U.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F); const t = J.update(e), n = e.material; if (Array.isArray(n)) { const r = t.groups; for (let a = 0, o = r.length; a < o; a++) { const o = r[a], s = n[o.materialIndex]; s && s.visible && u.push(e, t, s, i, U.z, o) } } else n.visible && u.push(e, t, n, i, U.z, null) } const n = e.children; for (let e = 0, a = n.length; e < a; e++)be(n[e], t, i, r) } function xe(e, t, i) { const r = !0 === t.isScene ? t.overrideMaterial : null; for (let n = 0, a = e.length; n < a; n++) { const a = e[n], o = a.object, s = a.geometry, l = null === r ? a.material : r, c = a.group; if (i.isArrayCamera) { const e = i.cameras; for (let i = 0, r = e.length; i < r; i++) { const r = e[i]; o.layers.test(r.layers) && (j.viewport(M.copy(r.viewport)), d.setupLightsView(r), we(o, t, r, s, l, c)) } } else we(o, t, i, s, l, c) } } function we(e, t, i, r, n, a) { if (e.onBeforeRender(m, t, i, r, n, a), e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) { const r = Me(i, t, n, e); j.setMaterial(n), le.reset(), function (e, t) { e.render((function (e) { m.renderBufferImmediate(e, t) })) }(e, r) } else m.renderBufferDirect(i, t, r, n, e, a); e.onAfterRender(m, t, i, r, n, a) } function Se(e, t, i) { !0 !== t.isScene && (t = z); const r = $.get(e), n = d.state.lights, a = d.state.shadowsArray, o = n.state.version, s = K.getParameters(e, n.state, a, t, i), l = K.getProgramCacheKey(s); let c = r.program, h = !0; if (r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = X.get(e.envMap || r.environment), void 0 === c) e.addEventListener("dispose", ge); else if (c.cacheKey !== l) ye(e); else if (r.lightsStateVersion !== o) h = !1; else { if (void 0 !== s.shaderID) return; h = !1 } h && (s.uniforms = K.getUniforms(e), e.onBeforeCompile(s, m), c = K.acquireProgram(s, l), r.program = c, r.uniforms = s.uniforms, r.outputEncoding = s.outputEncoding); const u = r.uniforms; (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (r.numClippingPlanes = ie.numPlanes, r.numIntersection = ie.numIntersection, u.clippingPlanes = ie.uniform), r.needsLights = function (e) { return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights }(e), r.lightsStateVersion = o, r.needsLights && (u.ambientLightColor.value = n.state.ambient, u.lightProbe.value = n.state.probe, u.directionalLights.value = n.state.directional, u.directionalLightShadows.value = n.state.directionalShadow, u.spotLights.value = n.state.spot, u.spotLightShadows.value = n.state.spotShadow, u.rectAreaLights.value = n.state.rectArea, u.ltc_1.value = n.state.rectAreaLTC1, u.ltc_2.value = n.state.rectAreaLTC2, u.pointLights.value = n.state.point, u.pointLightShadows.value = n.state.pointShadow, u.hemisphereLights.value = n.state.hemi, u.directionalShadowMap.value = n.state.directionalShadowMap, u.directionalShadowMatrix.value = n.state.directionalShadowMatrix, u.spotShadowMap.value = n.state.spotShadowMap, u.spotShadowMatrix.value = n.state.spotShadowMatrix, u.pointShadowMap.value = n.state.pointShadowMap, u.pointShadowMatrix.value = n.state.pointShadowMatrix); const p = r.program.getUniforms(), f = WebGLUniforms.seqWithValue(p.seq, u); r.uniformsList = f } function Me(e, t, i, r) { !0 !== t.isScene && (t = z), Y.resetTextureUnits(); const n = t.fog, a = i.isMeshStandardMaterial ? t.environment : null, o = null === b ? m.outputEncoding : b.texture.encoding, s = X.get(i.envMap || a), l = $.get(i), c = d.state.lights; if (!0 === B && (!0 === N || e !== S)) { const t = e === S && i.id === w; ie.setState(i, e, t) } i.version === l.__version ? i.fog && l.fog !== n || l.environment !== a || l.needsLights && l.lightsStateVersion !== c.state.version ? Se(i, t, r) : void 0 === l.numClippingPlanes || l.numClippingPlanes === ie.numPlanes && l.numIntersection === ie.numIntersection ? (l.outputEncoding !== o || l.envMap !== s) && Se(i, t, r) : Se(i, t, r) : (Se(i, t, r), l.__version = i.version); let h = !1, u = !1, p = !1; const f = l.program, g = f.getUniforms(), y = l.uniforms; if (j.useProgram(f.program) && (h = !0, u = !0, p = !0), i.id !== w && (w = i.id, u = !0), h || S !== e) { if (g.setValue(ce, "projectionMatrix", e.projectionMatrix), V.logarithmicDepthBuffer && g.setValue(ce, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), S !== e && (S = e, u = !0, p = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) { const t = g.map.cameraPosition; void 0 !== t && t.setValue(ce, U.setFromMatrixPosition(e.matrixWorld)) } (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && g.setValue(ce, "isOrthographic", !0 === e.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || i.skinning) && g.setValue(ce, "viewMatrix", e.matrixWorldInverse) } if (i.skinning) { g.setOptional(ce, r, "bindMatrix"), g.setOptional(ce, r, "bindMatrixInverse"); const e = r.skeleton; if (e) { const t = e.bones; if (V.floatVertexTextures) { if (null === e.boneTexture) { let i = Math.sqrt(4 * t.length); i = MathUtils.ceilPowerOfTwo(i), i = Math.max(i, 4); const r = new Float32Array(i * i * 4); r.set(e.boneMatrices); const n = new DataTexture(r, i, i, RGBAFormat, FloatType); e.boneMatrices = r, e.boneTexture = n, e.boneTextureSize = i } g.setValue(ce, "boneTexture", e.boneTexture, Y), g.setValue(ce, "boneTextureSize", e.boneTextureSize) } else g.setOptional(ce, e, "boneMatrices") } } var v, _; return (u || l.receiveShadow !== r.receiveShadow) && (l.receiveShadow = r.receiveShadow, g.setValue(ce, "receiveShadow", r.receiveShadow)), u && (g.setValue(ce, "toneMappingExposure", m.toneMappingExposure), l.needsLights && (_ = p, (v = y).ambientLightColor.needsUpdate = _, v.lightProbe.needsUpdate = _, v.directionalLights.needsUpdate = _, v.directionalLightShadows.needsUpdate = _, v.pointLights.needsUpdate = _, v.pointLightShadows.needsUpdate = _, v.spotLights.needsUpdate = _, v.spotLightShadows.needsUpdate = _, v.rectAreaLights.needsUpdate = _, v.hemisphereLights.needsUpdate = _), n && i.fog && Q.refreshFogUniforms(y, n), Q.refreshMaterialUniforms(y, i, L, C), WebGLUniforms.upload(ce, l.uniformsList, y, Y)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (WebGLUniforms.upload(ce, l.uniformsList, y, Y), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && g.setValue(ce, "center", r.center), g.setValue(ce, "modelViewMatrix", r.modelViewMatrix), g.setValue(ce, "normalMatrix", r.normalMatrix), g.setValue(ce, "modelMatrix", r.matrixWorld), f } _e.setAnimationLoop((function (e) { de.isPresenting || ve && ve(e) })), "undefined" != typeof window && _e.setContext(window), this.setAnimationLoop = function (e) { ve = e, de.setAnimationLoop(e), null === e ? _e.stop() : _e.start() }, this.render = function (e, t) { let i, r; if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), i = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r = arguments[3]), void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === g) return; le.resetDefaultState(), w = -1, S = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === de.enabled && !0 === de.isPresenting && (t = de.getCamera(t)), !0 === e.isScene && e.onBeforeRender(m, e, t, i || b), d = te.get(e, f.length), d.init(), f.push(d), F.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), k.setFromProjectionMatrix(F), N = this.localClippingEnabled, B = ie.init(this.clippingPlanes, N, t), u = ee.get(e, p.length), u.init(), p.push(u), be(e, t, 0, m.sortObjects), u.finish(), !0 === m.sortObjects && u.sort(R, D), !0 === B && ie.beginShadows(); const n = d.state.shadowsArray; pe.render(n, e, t), d.setupLights(), d.setupLightsView(t), !0 === B && ie.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== i && this.setRenderTarget(i), re.render(u, e, t, r); const a = u.opaque, o = u.transparent; a.length > 0 && xe(a, e, t), o.length > 0 && xe(o, e, t), !0 === e.isScene && e.onAfterRender(m, e, t), null !== b && (Y.updateRenderTargetMipmap(b), Y.updateMultisampleRenderTarget(b)), j.buffers.depth.setTest(!0), j.buffers.depth.setMask(!0), j.buffers.color.setMask(!0), j.setPolygonOffset(!1), f.pop(), d = f.length > 0 ? f[f.length - 1] : null, p.pop(), u = p.length > 0 ? p[p.length - 1] : null }, this.setFramebuffer = function (e) { y !== e && null === b && ce.bindFramebuffer(36160, e), y = e }, this.getActiveCubeFace = function () { return v }, this.getActiveMipmapLevel = function () { return _ }, this.getRenderTarget = function () { return b }, this.setRenderTarget = function (e, t = 0, i = 0) { b = e, v = t, _ = i, e && void 0 === $.get(e).__webglFramebuffer && Y.setupRenderTarget(e); let r = y, n = !1, a = !1; if (e) { const i = e.texture; (i.isDataTexture3D || i.isDataTexture2DArray) && (a = !0); const o = $.get(e).__webglFramebuffer; e.isWebGLCubeRenderTarget ? (r = o[t], n = !0) : r = e.isWebGLMultisampleRenderTarget ? $.get(e).__webglMultisampledFramebuffer : o, M.copy(e.viewport), T.copy(e.scissor), A = e.scissorTest } else M.copy(P).multiplyScalar(L).floor(), T.copy(O).multiplyScalar(L).floor(), A = I; if (x !== r && (ce.bindFramebuffer(36160, r), x = r), j.viewport(M), j.scissor(T), j.setScissorTest(A), n) { const r = $.get(e.texture); ce.framebufferTexture2D(36160, 36064, 34069 + t, r.__webglTexture, i) } else if (a) { const r = $.get(e.texture), n = t || 0; ce.framebufferTextureLayer(36160, 36064, r.__webglTexture, i || 0, n) } }, this.readRenderTargetPixels = function (e, t, i, r, n, a, o) { if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let s = $.get(e).__webglFramebuffer; if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) { let o = !1; s !== x && (ce.bindFramebuffer(36160, s), o = !0); try { const s = e.texture, l = s.format, c = s.type; if (l !== RGBAFormat && se.convert(l) !== ce.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); const h = c === HalfFloatType && (H.has("EXT_color_buffer_half_float") || V.isWebGL2 && H.has("EXT_color_buffer_float")); if (!(c === UnsignedByteType || se.convert(c) === ce.getParameter(35738) || c === FloatType && (V.isWebGL2 || H.has("OES_texture_float") || H.has("WEBGL_color_buffer_float")) || h)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === ce.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - r && i >= 0 && i <= e.height - n && ce.readPixels(t, i, r, n, se.convert(l), se.convert(c), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { o && ce.bindFramebuffer(36160, x) } } }, this.copyFramebufferToTexture = function (e, t, i = 0) { const r = Math.pow(2, -i), n = Math.floor(t.image.width * r), a = Math.floor(t.image.height * r), o = se.convert(t.format); Y.setTexture2D(t, 0), ce.copyTexImage2D(3553, i, o, e.x, e.y, n, a, 0), j.unbindTexture() }, this.copyTextureToTexture = function (e, t, i, r = 0) { const n = t.image.width, a = t.image.height, o = se.convert(i.format), s = se.convert(i.type); Y.setTexture2D(i, 0), ce.pixelStorei(37440, i.flipY), ce.pixelStorei(37441, i.premultiplyAlpha), ce.pixelStorei(3317, i.unpackAlignment), t.isDataTexture ? ce.texSubImage2D(3553, r, e.x, e.y, n, a, o, s, t.image.data) : t.isCompressedTexture ? ce.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : ce.texSubImage2D(3553, r, e.x, e.y, o, s, t.image), 0 === r && i.generateMipmaps && ce.generateMipmap(3553), j.unbindTexture() }, this.copyTextureToTexture3D = function (e, t, i, r, n = 0) { if (m.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); const { width: a, height: o, data: s } = i.image, l = se.convert(r.format), c = se.convert(r.type); let h; if (r.isDataTexture3D) Y.setTexture3D(r, 0), h = 32879; else { if (!r.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); Y.setTexture2DArray(r, 0), h = 35866 } ce.pixelStorei(37440, r.flipY), ce.pixelStorei(37441, r.premultiplyAlpha), ce.pixelStorei(3317, r.unpackAlignment); const u = ce.getParameter(3314), d = ce.getParameter(32878), p = ce.getParameter(3316), f = ce.getParameter(3315), g = ce.getParameter(32877); ce.pixelStorei(3314, a), ce.pixelStorei(32878, o), ce.pixelStorei(3316, e.min.x), ce.pixelStorei(3315, e.min.y), ce.pixelStorei(32877, e.min.z), ce.texSubImage3D(h, n, t.x, t.y, t.z, e.max.x - e.min.x + 1, e.max.y - e.min.y + 1, e.max.z - e.min.z + 1, l, c, s), ce.pixelStorei(3314, u), ce.pixelStorei(32878, d), ce.pixelStorei(3316, p), ce.pixelStorei(3315, f), ce.pixelStorei(32877, g), 0 === n && r.generateMipmaps && ce.generateMipmap(h), j.unbindTexture() }, this.initTexture = function (e) { Y.setTexture2D(e, 0), j.unbindTexture() }, this.resetState = function () { j.reset(), le.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } Group.prototype.isGroup = !0, Object.assign(WebXRController.prototype, { constructor: WebXRController, getHandSpace: function () { return null === this._hand && (this._hand = new Group, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand }, getTargetRaySpace: function () { return null === this._targetRay && (this._targetRay = new Group, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay }, getGripSpace: function () { return null === this._grip && (this._grip = new Group, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip }, dispatchEvent: function (e) { return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this }, disconnect: function (e) { return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this }, update: function (e, t, i) { let r = null, n = null, a = null; const o = this._targetRay, s = this._grip, l = this._hand; if (e && "visible-blurred" !== t.session.visibilityState) if (l && e.hand) { a = !0; for (const r of e.hand.values()) { const e = t.getJointPose(r, i); if (void 0 === l.joints[r.jointName]) { const e = new Group; e.matrixAutoUpdate = !1, e.visible = !1, l.joints[r.jointName] = e, l.add(e) } const n = l.joints[r.jointName]; null !== e && (n.matrix.fromArray(e.transform.matrix), n.matrix.decompose(n.position, n.rotation, n.scale), n.jointRadius = e.radius), n.visible = null !== e } const r = l.joints["index-finger-tip"], n = l.joints["thumb-tip"], o = r.position.distanceTo(n.position), s = .02, c = .005; l.inputState.pinching && o > s + c ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !l.inputState.pinching && o <= s - c && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else null !== o && (r = t.getPose(e.targetRaySpace, i), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale))), null !== s && e.gripSpace && (n = t.getPose(e.gripSpace, i), null !== n && (s.matrix.fromArray(n.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale))); return null !== o && (o.visible = null !== r), null !== s && (s.visible = null !== n), null !== l && (l.visible = null !== a), this } }), Object.assign(WebXRManager.prototype, EventDispatcher.prototype); class WebGL1Renderer extends WebGLRenderer { } WebGL1Renderer.prototype.isWebGL1Renderer = !0; class FogExp2 { constructor(e, t) { this.name = "", this.color = new Color$1(e), this.density = void 0 !== t ? t : 25e-5 } clone() { return new FogExp2(this.color, this.density) } toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } } FogExp2.prototype.isFogExp2 = !0; class Fog { constructor(e, t, i) { this.name = "", this.color = new Color$1(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== i ? i : 1e3 } clone() { return new Fog(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } } Fog.prototype.isFog = !0; class Scene extends Object3D { constructor() { super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.environment && (t.object.environment = this.environment.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t } } function InterleavedBuffer(e, t) { this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = StaticDrawUsage, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = MathUtils.generateUUID() } Scene.prototype.isScene = !0, Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", { set: function (e) { !0 === e && this.version++ } }), Object.assign(InterleavedBuffer.prototype, { isInterleavedBuffer: !0, onUploadCallback: function () { }, setUsage: function (e) { return this.usage = e, this }, copy: function (e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this }, copyAt: function (e, t, i) { e *= this.stride, i *= t.stride; for (let r = 0, n = this.stride; r < n; r++)this.array[e + r] = t.array[i + r]; return this }, set: function (e, t = 0) { return this.array.set(e, t), this }, clone: function (e) { void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = MathUtils.generateUUID()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new InterleavedBuffer(new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), this.stride); return t.setUsage(this.usage), t }, onUpload: function (e) { return this.onUploadCallback = e, this }, toJSON: function (e) { return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = MathUtils.generateUUID()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } }); const _vector$6 = new Vector3; function InterleavedBufferAttribute(e, t, i, r) { this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = !0 === r } Object.defineProperties(InterleavedBufferAttribute.prototype, { count: { get: function () { return this.data.count } }, array: { get: function () { return this.data.array } }, needsUpdate: { set: function (e) { this.data.needsUpdate = e } } }), Object.assign(InterleavedBufferAttribute.prototype, { isInterleavedBufferAttribute: !0, applyMatrix4: function (e) { for (let t = 0, i = this.data.count; t < i; t++)_vector$6.x = this.getX(t), _vector$6.y = this.getY(t), _vector$6.z = this.getZ(t), _vector$6.applyMatrix4(e), this.setXYZ(t, _vector$6.x, _vector$6.y, _vector$6.z); return this }, setX: function (e, t) { return this.data.array[e * this.data.stride + this.offset] = t, this }, setY: function (e, t) { return this.data.array[e * this.data.stride + this.offset + 1] = t, this }, setZ: function (e, t) { return this.data.array[e * this.data.stride + this.offset + 2] = t, this }, setW: function (e, t) { return this.data.array[e * this.data.stride + this.offset + 3] = t, this }, getX: function (e) { return this.data.array[e * this.data.stride + this.offset] }, getY: function (e) { return this.data.array[e * this.data.stride + this.offset + 1] }, getZ: function (e) { return this.data.array[e * this.data.stride + this.offset + 2] }, getW: function (e) { return this.data.array[e * this.data.stride + this.offset + 3] }, setXY: function (e, t, i) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this }, setXYZ: function (e, t, i, r) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this }, setXYZW: function (e, t, i, r, n) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = n, this }, clone: function (e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const e = []; for (let t = 0; t < this.count; t++) { const i = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[i + t]) } return new BufferAttribute(new this.array.constructor(e), this.itemSize, this.normalized) } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) }, toJSON: function (e) { if (void 0 === e) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const e = []; for (let t = 0; t < this.count; t++) { const i = t * this.data.stride + this.offset; for (let t = 0; t < this.itemSize; t++)e.push(this.data.array[i + t]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized } } return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } }); class SpriteMaterial extends Material$1 { constructor(e) { super(), this.type = "SpriteMaterial", this.color = new Color$1(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this } } let _geometry; SpriteMaterial.prototype.isSpriteMaterial = !0; const _intersectPoint = new Vector3, _worldScale = new Vector3, _mvPosition = new Vector3, _alignedPosition = new Vector2, _rotatedPosition = new Vector2, _viewWorldMatrix = new Matrix4, _vA$1 = new Vector3, _vB$1 = new Vector3, _vC$1 = new Vector3, _uvA$1 = new Vector2, _uvB$1 = new Vector2, _uvC$1 = new Vector2; class Sprite extends Object3D { constructor(e) { if (super(), this.type = "Sprite", void 0 === _geometry) { _geometry = new BufferGeometry; const e = new InterleavedBuffer(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5); _geometry.setIndex([0, 1, 2, 0, 2, 3]), _geometry.setAttribute("position", new InterleavedBufferAttribute(e, 3, 0, !1)), _geometry.setAttribute("uv", new InterleavedBufferAttribute(e, 2, 3, !1)) } this.geometry = _geometry, this.material = void 0 !== e ? e : new SpriteMaterial, this.center = new Vector2(.5, .5) } raycast(e, t) { null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), _worldScale.setFromMatrixScale(this.matrixWorld), _viewWorldMatrix.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), _mvPosition.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && _worldScale.multiplyScalar(-_mvPosition.z); const i = this.material.rotation; let r, n; 0 !== i && (n = Math.cos(i), r = Math.sin(i)); const a = this.center; transformVertex(_vA$1.set(-.5, -.5, 0), _mvPosition, a, _worldScale, r, n), transformVertex(_vB$1.set(.5, -.5, 0), _mvPosition, a, _worldScale, r, n), transformVertex(_vC$1.set(.5, .5, 0), _mvPosition, a, _worldScale, r, n), _uvA$1.set(0, 0), _uvB$1.set(1, 0), _uvC$1.set(1, 1); let o = e.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, !1, _intersectPoint); if (null === o && (transformVertex(_vB$1.set(-.5, .5, 0), _mvPosition, a, _worldScale, r, n), _uvB$1.set(0, 1), o = e.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, !1, _intersectPoint), null === o)) return; const s = e.ray.origin.distanceTo(_intersectPoint); s < e.near || s > e.far || t.push({ distance: s, point: _intersectPoint.clone(), uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2), face: null, object: this }) } copy(e) { return super.copy(e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this } } function transformVertex(e, t, i, r, n, a) { _alignedPosition.subVectors(e, i).addScalar(.5).multiply(r), void 0 !== n ? (_rotatedPosition.x = a * _alignedPosition.x - n * _alignedPosition.y, _rotatedPosition.y = n * _alignedPosition.x + a * _alignedPosition.y) : _rotatedPosition.copy(_alignedPosition), e.copy(t), e.x += _rotatedPosition.x, e.y += _rotatedPosition.y, e.applyMatrix4(_viewWorldMatrix) } Sprite.prototype.isSprite = !0; const _v1$4 = new Vector3, _v2$2 = new Vector3; class LOD extends Object3D { constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 } copy(e) { super.copy(e, !1); const t = e.levels; for (let e = 0, i = t.length; e < i; e++) { const i = t[e]; this.addLevel(i.object.clone(), i.distance) } return this.autoUpdate = e.autoUpdate, this } addLevel(e, t = 0) { t = Math.abs(t); const i = this.levels; let r; for (r = 0; r < i.length && !(t < i[r].distance); r++); return i.splice(r, 0, { distance: t, object: e }), this.add(e), this } getCurrentLevel() { return this._currentLevel } getObjectForDistance(e) { const t = this.levels; if (t.length > 0) { let i, r; for (i = 1, r = t.length; i < r && !(e < t[i].distance); i++); return t[i - 1].object } return null } raycast(e, t) { if (this.levels.length > 0) { _v1$4.setFromMatrixPosition(this.matrixWorld); const i = e.ray.origin.distanceTo(_v1$4); this.getObjectForDistance(i).raycast(e, t) } } update(e) { const t = this.levels; if (t.length > 1) { _v1$4.setFromMatrixPosition(e.matrixWorld), _v2$2.setFromMatrixPosition(this.matrixWorld); const i = _v1$4.distanceTo(_v2$2) / e.zoom; let r, n; for (t[0].object.visible = !0, r = 1, n = t.length; r < n && i >= t[r].distance; r++)t[r - 1].object.visible = !1, t[r].object.visible = !0; for (this._currentLevel = r - 1; r < n; r++)t[r].object.visible = !1 } } toJSON(e) { const t = super.toJSON(e); !1 === this.autoUpdate && (t.object.autoUpdate = !1), t.object.levels = []; const i = this.levels; for (let e = 0, r = i.length; e < r; e++) { const r = i[e]; t.object.levels.push({ object: r.object.uuid, distance: r.distance }) } return t } } const _basePosition = new Vector3, _skinIndex = new Vector4, _skinWeight = new Vector4, _vector$7 = new Vector3, _matrix$1 = new Matrix4; function SkinnedMesh(e, t) { Mesh.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Matrix4, this.bindMatrixInverse = new Matrix4 } function Bone() { Object3D.call(this), this.type = "Bone" } SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), { constructor: SkinnedMesh, isSkinnedMesh: !0, copy: function (e) { return Mesh.prototype.copy.call(this, e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this }, bind: function (e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { const e = new Vector4, t = this.geometry.attributes.skinWeight; for (let i = 0, r = t.count; i < r; i++) { e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.w = t.getW(i); const r = 1 / e.manhattanLength(); r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w) } }, updateMatrixWorld: function (e) { Mesh.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, boneTransform: function (e, t) { const i = this.skeleton, r = this.geometry; _skinIndex.fromBufferAttribute(r.attributes.skinIndex, e), _skinWeight.fromBufferAttribute(r.attributes.skinWeight, e), _basePosition.fromBufferAttribute(r.attributes.position, e).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let e = 0; e < 4; e++) { const r = _skinWeight.getComponent(e); if (0 !== r) { const n = _skinIndex.getComponent(e); _matrix$1.multiplyMatrices(i.bones[n].matrixWorld, i.boneInverses[n]), t.addScaledVector(_vector$7.copy(_basePosition).applyMatrix4(_matrix$1), r) } } return t.applyMatrix4(this.bindMatrixInverse) } }), Bone.prototype = Object.assign(Object.create(Object3D.prototype), { constructor: Bone, isBone: !0 }); const _offsetMatrix = new Matrix4, _identityMatrix = new Matrix4; class Skeleton { constructor(e = [], t = []) { this.uuid = MathUtils.generateUUID(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } init() { const e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let e = 0, t = this.bones.length; e < t; e++)this.boneInverses.push(new Matrix4) } } calculateInverses() { this.boneInverses.length = 0; for (let e = 0, t = this.bones.length; e < t; e++) { const t = new Matrix4; this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && t.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const t = this.bones[e]; t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) } } update() { const e = this.bones, t = this.boneInverses, i = this.boneMatrices, r = this.boneTexture; for (let r = 0, n = e.length; r < n; r++) { const n = e[r] ? e[r].matrixWorld : _identityMatrix; _offsetMatrix.multiplyMatrices(n, t[r]), _offsetMatrix.toArray(i, 16 * r) } null !== r && (r.needsUpdate = !0) } clone() { return new Skeleton(this.bones, this.boneInverses) } getBoneByName(e) { for (let t = 0, i = this.bones.length; t < i; t++) { const i = this.bones[t]; if (i.name === e) return i } } dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(e, t) { this.uuid = e.uuid; for (let i = 0, r = e.bones.length; i < r; i++) { const r = e.bones[i]; let n = t[r]; void 0 === n && (console.warn("THREE.Skeleton: No bone found with UUID:", r), n = new Bone), this.bones.push(n), this.boneInverses.push((new Matrix4).fromArray(e.boneInverses[i])) } return this.init(), this } toJSON() { const e = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; e.uuid = this.uuid; const t = this.bones, i = this.boneInverses; for (let r = 0, n = t.length; r < n; r++) { const n = t[r]; e.bones.push(n.uuid); const a = i[r]; e.boneInverses.push(a.toArray()) } return e } } const _instanceLocalMatrix = new Matrix4, _instanceWorldMatrix = new Matrix4, _instanceIntersects = [], _mesh = new Mesh; function InstancedMesh(e, t, i) { Mesh.call(this, e, t), this.instanceMatrix = new BufferAttribute(new Float32Array(16 * i), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1 } InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), { constructor: InstancedMesh, isInstancedMesh: !0, copy: function (e) { return Mesh.prototype.copy.call(this, e), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this }, getColorAt: function (e, t) { t.fromArray(this.instanceColor.array, 3 * e) }, getMatrixAt: function (e, t) { t.fromArray(this.instanceMatrix.array, 16 * e) }, raycast: function (e, t) { const i = this.matrixWorld, r = this.count; if (_mesh.geometry = this.geometry, _mesh.material = this.material, void 0 !== _mesh.material) for (let n = 0; n < r; n++) { this.getMatrixAt(n, _instanceLocalMatrix), _instanceWorldMatrix.multiplyMatrices(i, _instanceLocalMatrix), _mesh.matrixWorld = _instanceWorldMatrix, _mesh.raycast(e, _instanceIntersects); for (let e = 0, i = _instanceIntersects.length; e < i; e++) { const i = _instanceIntersects[e]; i.instanceId = n, i.object = this, t.push(i) } _instanceIntersects.length = 0 } }, setColorAt: function (e, t) { null === this.instanceColor && (this.instanceColor = new BufferAttribute(new Float32Array(3 * this.count), 3)), t.toArray(this.instanceColor.array, 3 * e) }, setMatrixAt: function (e, t) { t.toArray(this.instanceMatrix.array, 16 * e) }, updateMorphTargets: function () { }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); class LineBasicMaterial extends Material$1 { constructor(e) { super(), this.type = "LineBasicMaterial", this.color = new Color$1(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.morphTargets = e.morphTargets, this } } LineBasicMaterial.prototype.isLineBasicMaterial = !0; const _start = new Vector3, _end = new Vector3, _inverseMatrix$1 = new Matrix4, _ray$1$1 = new Ray, _sphere$2 = new Sphere; function Line(e = new BufferGeometry, t = new LineBasicMaterial) { Object3D.call(this), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } Line.prototype = Object.assign(Object.create(Object3D.prototype), { constructor: Line, isLine: !0, copy: function (e) { return Object3D.prototype.copy.call(this, e), this.material = e.material, this.geometry = e.geometry, this }, computeLineDistances: function () { const e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { const t = e.attributes.position, i = [0]; for (let e = 1, r = t.count; e < r; e++)_start.fromBufferAttribute(t, e - 1), _end.fromBufferAttribute(t, e), i[e] = i[e - 1], i[e] += _start.distanceTo(_end); e.setAttribute("lineDistance", new Float32BufferAttribute(i, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this }, raycast: function (e, t) { const i = this.geometry, r = this.matrixWorld, n = e.params.Line.threshold; if (null === i.boundingSphere && i.computeBoundingSphere(), _sphere$2.copy(i.boundingSphere), _sphere$2.applyMatrix4(r), _sphere$2.radius += n, !1 === e.ray.intersectsSphere(_sphere$2)) return; _inverseMatrix$1.copy(r).invert(), _ray$1$1.copy(e.ray).applyMatrix4(_inverseMatrix$1); const a = n / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a, s = new Vector3, l = new Vector3, c = new Vector3, h = new Vector3, u = this.isLineSegments ? 2 : 1; if (i.isBufferGeometry) { const r = i.index, n = i.attributes.position; if (null !== r) { const i = r.array; for (let r = 0, a = i.length - 1; r < a; r += u) { const a = i[r], u = i[r + 1]; s.fromBufferAttribute(n, a), l.fromBufferAttribute(n, u); if (_ray$1$1.distanceSqToSegment(s, l, h, c) > o) continue; h.applyMatrix4(this.matrixWorld); const d = e.ray.origin.distanceTo(h); d < e.near || d > e.far || t.push({ distance: d, point: c.clone().applyMatrix4(this.matrixWorld), index: r, face: null, faceIndex: null, object: this }) } } else for (let i = 0, r = n.count - 1; i < r; i += u) { s.fromBufferAttribute(n, i), l.fromBufferAttribute(n, i + 1); if (_ray$1$1.distanceSqToSegment(s, l, h, c) > o) continue; h.applyMatrix4(this.matrixWorld); const r = e.ray.origin.distanceTo(h); r < e.near || r > e.far || t.push({ distance: r, point: c.clone().applyMatrix4(this.matrixWorld), index: i, face: null, faceIndex: null, object: this }) } } else i.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") }, updateMorphTargets: function () { const e = this.geometry; if (e.isBufferGeometry) { const t = e.morphAttributes, i = Object.keys(t); if (i.length > 0) { const e = t[i[0]]; if (void 0 !== e) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, i = e.length; t < i; t++) { const i = e[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t } } } } else { const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } }); const _start$1 = new Vector3, _end$1 = new Vector3; function LineSegments(e, t) { Line.call(this, e, t), this.type = "LineSegments" } LineSegments.prototype = Object.assign(Object.create(Line.prototype), { constructor: LineSegments, isLineSegments: !0, computeLineDistances: function () { const e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { const t = e.attributes.position, i = []; for (let e = 0, r = t.count; e < r; e += 2)_start$1.fromBufferAttribute(t, e), _end$1.fromBufferAttribute(t, e + 1), i[e] = 0 === e ? 0 : i[e - 1], i[e + 1] = i[e] + _start$1.distanceTo(_end$1); e.setAttribute("lineDistance", new Float32BufferAttribute(i, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } }); class LineLoop extends Line { constructor(e, t) { super(e, t), this.type = "LineLoop" } } LineLoop.prototype.isLineLoop = !0; class PointsMaterial extends Material$1 { constructor(e) { super(), this.type = "PointsMaterial", this.color = new Color$1(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this } } PointsMaterial.prototype.isPointsMaterial = !0; const _inverseMatrix$2 = new Matrix4, _ray$2 = new Ray, _sphere$3 = new Sphere, _position$1 = new Vector3; function Points(e = new BufferGeometry, t = new PointsMaterial) { Object3D.call(this), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } function testPoint(e, t, i, r, n, a, o) { const s = _ray$2.distanceSqToPoint(e); if (s < i) { const i = new Vector3; _ray$2.closestPointToPoint(e, i), i.applyMatrix4(r); const l = n.ray.origin.distanceTo(i); if (l < n.near || l > n.far) return; a.push({ distance: l, distanceToRay: Math.sqrt(s), point: i, index: t, face: null, object: o }) } } Points.prototype = Object.assign(Object.create(Object3D.prototype), { constructor: Points, isPoints: !0, copy: function (e) { return Object3D.prototype.copy.call(this, e), this.material = e.material, this.geometry = e.geometry, this }, raycast: function (e, t) { const i = this.geometry, r = this.matrixWorld, n = e.params.Points.threshold; if (null === i.boundingSphere && i.computeBoundingSphere(), _sphere$3.copy(i.boundingSphere), _sphere$3.applyMatrix4(r), _sphere$3.radius += n, !1 === e.ray.intersectsSphere(_sphere$3)) return; _inverseMatrix$2.copy(r).invert(), _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2); const a = n / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a; if (i.isBufferGeometry) { const n = i.index, a = i.attributes.position; if (null !== n) { const i = n.array; for (let n = 0, s = i.length; n < s; n++) { const s = i[n]; _position$1.fromBufferAttribute(a, s), testPoint(_position$1, s, o, r, e, t, this) } } else for (let i = 0, n = a.count; i < n; i++)_position$1.fromBufferAttribute(a, i), testPoint(_position$1, i, o, r, e, t, this) } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") }, updateMorphTargets: function () { const e = this.geometry; if (e.isBufferGeometry) { const t = e.morphAttributes, i = Object.keys(t); if (i.length > 0) { const e = t[i[0]]; if (void 0 !== e) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let t = 0, i = e.length; t < i; t++) { const i = e[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t } } } } else { const t = e.morphTargets; void 0 !== t && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } }); class VideoTexture extends Texture$1 { constructor(e, t, i, r, n, a, o, s, l) { super(e, t, i, r, n, a, o, s, l), this.format = void 0 !== o ? o : RGBFormat, this.minFilter = void 0 !== a ? a : LinearFilter, this.magFilter = void 0 !== n ? n : LinearFilter, this.generateMipmaps = !1; const c = this; "requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function t() { c.needsUpdate = !0, e.requestVideoFrameCallback(t) })) } clone() { return new this.constructor(this.image).copy(this) } update() { const e = this.image; !1 === "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } VideoTexture.prototype.isVideoTexture = !0; class CompressedTexture extends Texture$1 { constructor(e, t, i, r, n, a, o, s, l, c, h, u) { super(null, a, o, s, l, c, r, n, h, u), this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } CompressedTexture.prototype.isCompressedTexture = !0; class CanvasTexture extends Texture$1 { constructor(e, t, i, r, n, a, o, s, l) { super(e, t, i, r, n, a, o, s, l), this.needsUpdate = !0 } } CanvasTexture.prototype.isCanvasTexture = !0; class DepthTexture extends Texture$1 { constructor(e, t, i, r, n, a, o, s, l, c) { if ((c = void 0 !== c ? c : DepthFormat) !== DepthFormat && c !== DepthStencilFormat) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === i && c === DepthFormat && (i = UnsignedShortType), void 0 === i && c === DepthStencilFormat && (i = UnsignedInt248Type), super(null, r, n, a, o, s, c, i, l), this.image = { width: e, height: t }, this.magFilter = void 0 !== o ? o : NearestFilter, this.minFilter = void 0 !== s ? s : NearestFilter, this.flipY = !1, this.generateMipmaps = !1 } } DepthTexture.prototype.isDepthTexture = !0; class CircleGeometry extends BufferGeometry { constructor(e = 1, t = 8, i = 0, r = 2 * Math.PI) { super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: r }, t = Math.max(3, t); const n = [], a = [], o = [], s = [], l = new Vector3, c = new Vector2; a.push(0, 0, 0), o.push(0, 0, 1), s.push(.5, .5); for (let n = 0, h = 3; n <= t; n++, h += 3) { const u = i + n / t * r; l.x = e * Math.cos(u), l.y = e * Math.sin(u), a.push(l.x, l.y, l.z), o.push(0, 0, 1), c.x = (a[h] / e + 1) / 2, c.y = (a[h + 1] / e + 1) / 2, s.push(c.x, c.y) } for (let e = 1; e <= t; e++)n.push(e, e + 1, 0); this.setIndex(n), this.setAttribute("position", new Float32BufferAttribute(a, 3)), this.setAttribute("normal", new Float32BufferAttribute(o, 3)), this.setAttribute("uv", new Float32BufferAttribute(s, 2)) } } class CylinderGeometry extends BufferGeometry { constructor(e = 1, t = 1, i = 1, r = 8, n = 1, a = !1, o = 0, s = 2 * Math.PI) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: r, heightSegments: n, openEnded: a, thetaStart: o, thetaLength: s }; const l = this; r = Math.floor(r), n = Math.floor(n); const c = [], h = [], u = [], d = []; let p = 0; const f = [], m = i / 2; let g = 0; function y(i) { const n = p, a = new Vector2, f = new Vector3; let y = 0; const v = !0 === i ? e : t, _ = !0 === i ? 1 : -1; for (let e = 1; e <= r; e++)h.push(0, m * _, 0), u.push(0, _, 0), d.push(.5, .5), p++; const b = p; for (let e = 0; e <= r; e++) { const t = e / r * s + o, i = Math.cos(t), n = Math.sin(t); f.x = v * n, f.y = m * _, f.z = v * i, h.push(f.x, f.y, f.z), u.push(0, _, 0), a.x = .5 * i + .5, a.y = .5 * n * _ + .5, d.push(a.x, a.y), p++ } for (let e = 0; e < r; e++) { const t = n + e, r = b + e; !0 === i ? c.push(r, r + 1, t) : c.push(r + 1, r, t), y += 3 } l.addGroup(g, y, !0 === i ? 1 : 2), g += y } !function () { const a = new Vector3, y = new Vector3; let v = 0; const _ = (t - e) / i; for (let l = 0; l <= n; l++) { const c = [], g = l / n, v = g * (t - e) + e; for (let e = 0; e <= r; e++) { const t = e / r, n = t * s + o, l = Math.sin(n), f = Math.cos(n); y.x = v * l, y.y = -g * i + m, y.z = v * f, h.push(y.x, y.y, y.z), a.set(l, _, f).normalize(), u.push(a.x, a.y, a.z), d.push(t, 1 - g), c.push(p++) } f.push(c) } for (let e = 0; e < r; e++)for (let t = 0; t < n; t++) { const i = f[t][e], r = f[t + 1][e], n = f[t + 1][e + 1], a = f[t][e + 1]; c.push(i, r, a), c.push(r, n, a), v += 6 } l.addGroup(g, v, 0), g += v }(), !1 === a && (e > 0 && y(!0), t > 0 && y(!1)), this.setIndex(c), this.setAttribute("position", new Float32BufferAttribute(h, 3)), this.setAttribute("normal", new Float32BufferAttribute(u, 3)), this.setAttribute("uv", new Float32BufferAttribute(d, 2)) } } class ConeGeometry extends CylinderGeometry { constructor(e = 1, t = 1, i = 8, r = 1, n = !1, a = 0, o = 2 * Math.PI) { super(0, e, t, i, r, n, a, o), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: r, openEnded: n, thetaStart: a, thetaLength: o } } } class PolyhedronGeometry extends BufferGeometry { constructor(e, t, i = 1, r = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: i, detail: r }; const n = [], a = []; function o(e, t, i, r) { const n = r + 1, a = []; for (let r = 0; r <= n; r++) { a[r] = []; const o = e.clone().lerp(i, r / n), s = t.clone().lerp(i, r / n), l = n - r; for (let e = 0; e <= l; e++)a[r][e] = 0 === e && r === n ? o : o.clone().lerp(s, e / l) } for (let e = 0; e < n; e++)for (let t = 0; t < 2 * (n - e) - 1; t++) { const i = Math.floor(t / 2); t % 2 == 0 ? (s(a[e][i + 1]), s(a[e + 1][i]), s(a[e][i])) : (s(a[e][i + 1]), s(a[e + 1][i + 1]), s(a[e + 1][i])) } } function s(e) { n.push(e.x, e.y, e.z) } function l(t, i) { const r = 3 * t; i.x = e[r + 0], i.y = e[r + 1], i.z = e[r + 2] } function c(e, t, i, r) { r < 0 && 1 === e.x && (a[t] = e.x - 1), 0 === i.x && 0 === i.z && (a[t] = r / 2 / Math.PI + .5) } function h(e) { return Math.atan2(e.z, -e.x) } !function (e) { const i = new Vector3, r = new Vector3, n = new Vector3; for (let a = 0; a < t.length; a += 3)l(t[a + 0], i), l(t[a + 1], r), l(t[a + 2], n), o(i, r, n, e) }(r), function (e) { const t = new Vector3; for (let i = 0; i < n.length; i += 3)t.x = n[i + 0], t.y = n[i + 1], t.z = n[i + 2], t.normalize().multiplyScalar(e), n[i + 0] = t.x, n[i + 1] = t.y, n[i + 2] = t.z }(i), function () { const e = new Vector3; for (let i = 0; i < n.length; i += 3) { e.x = n[i + 0], e.y = n[i + 1], e.z = n[i + 2]; const r = h(e) / 2 / Math.PI + .5, o = (t = e, Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5); a.push(r, 1 - o) } var t; (function () { const e = new Vector3, t = new Vector3, i = new Vector3, r = new Vector3, o = new Vector2, s = new Vector2, l = new Vector2; for (let u = 0, d = 0; u < n.length; u += 9, d += 6) { e.set(n[u + 0], n[u + 1], n[u + 2]), t.set(n[u + 3], n[u + 4], n[u + 5]), i.set(n[u + 6], n[u + 7], n[u + 8]), o.set(a[d + 0], a[d + 1]), s.set(a[d + 2], a[d + 3]), l.set(a[d + 4], a[d + 5]), r.copy(e).add(t).add(i).divideScalar(3); const p = h(r); c(o, d + 0, e, p), c(s, d + 2, t, p), c(l, d + 4, i, p) } })(), function () { for (let e = 0; e < a.length; e += 6) { const t = a[e + 0], i = a[e + 2], r = a[e + 4], n = Math.max(t, i, r), o = Math.min(t, i, r); n > .9 && o < .1 && (t < .2 && (a[e + 0] += 1), i < .2 && (a[e + 2] += 1), r < .2 && (a[e + 4] += 1)) } }() }(), this.setAttribute("position", new Float32BufferAttribute(n, 3)), this.setAttribute("normal", new Float32BufferAttribute(n.slice(), 3)), this.setAttribute("uv", new Float32BufferAttribute(a, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals() } } class DodecahedronGeometry extends PolyhedronGeometry { constructor(e = 1, t = 0) { const i = (1 + Math.sqrt(5)) / 2, r = 1 / i; super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t } } } const _v0$2 = new Vector3, _v1$5 = new Vector3, _normal$1 = new Vector3, _triangle = new Triangle; class EdgesGeometry extends BufferGeometry { constructor(e, t) { if (super(), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: t }, t = void 0 !== t ? t : 1, !0 === e.isGeometry) return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); const i = Math.pow(10, 4), r = Math.cos(MathUtils.DEG2RAD * t), n = e.getIndex(), a = e.getAttribute("position"), o = n ? n.count : a.count, s = [0, 0, 0], l = ["a", "b", "c"], c = new Array(3), h = {}, u = []; for (let e = 0; e < o; e += 3) { n ? (s[0] = n.getX(e), s[1] = n.getX(e + 1), s[2] = n.getX(e + 2)) : (s[0] = e, s[1] = e + 1, s[2] = e + 2); const { a: t, b: o, c: d } = _triangle; if (t.fromBufferAttribute(a, s[0]), o.fromBufferAttribute(a, s[1]), d.fromBufferAttribute(a, s[2]), _triangle.getNormal(_normal$1), c[0] = `${Math.round(t.x * i)},${Math.round(t.y * i)},${Math.round(t.z * i)}`, c[1] = `${Math.round(o.x * i)},${Math.round(o.y * i)},${Math.round(o.z * i)}`, c[2] = `${Math.round(d.x * i)},${Math.round(d.y * i)},${Math.round(d.z * i)}`, c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0]) for (let e = 0; e < 3; e++) { const t = (e + 1) % 3, i = c[e], n = c[t], a = _triangle[l[e]], o = _triangle[l[t]], d = `${i}_${n}`, p = `${n}_${i}`; p in h && h[p] ? (_normal$1.dot(h[p].normal) <= r && (u.push(a.x, a.y, a.z), u.push(o.x, o.y, o.z)), h[p] = null) : d in h || (h[d] = { index0: s[e], index1: s[t], normal: _normal$1.clone() }) } } for (const e in h) if (h[e]) { const { index0: t, index1: i } = h[e]; _v0$2.fromBufferAttribute(a, t), _v1$5.fromBufferAttribute(a, i), u.push(_v0$2.x, _v0$2.y, _v0$2.z), u.push(_v1$5.x, _v1$5.y, _v1$5.z) } this.setAttribute("position", new Float32BufferAttribute(u, 3)) } } const Earcut = { triangulate: function (e, t, i) { i = i || 2; const r = t && t.length, n = r ? t[0] * i : e.length; let a = linkedList(e, 0, n, i, !0); const o = []; if (!a || a.next === a.prev) return o; let s, l, c, h, u, d, p; if (r && (a = eliminateHoles(e, t, a, i)), e.length > 80 * i) { s = c = e[0], l = h = e[1]; for (let t = i; t < n; t += i)u = e[t], d = e[t + 1], u < s && (s = u), d < l && (l = d), u > c && (c = u), d > h && (h = d); p = Math.max(c - s, h - l), p = 0 !== p ? 1 / p : 0 } return earcutLinked(a, o, i, s, l, p), o } }; function linkedList(e, t, i, r, n) { let a, o; if (n === signedArea(e, t, i, r) > 0) for (a = t; a < i; a += r)o = insertNode(a, e[a], e[a + 1], o); else for (a = i - r; a >= t; a -= r)o = insertNode(a, e[a], e[a + 1], o); return o && equals(o, o.next) && (removeNode(o), o = o.next), o } function filterPoints(e, t) { if (!e) return e; t || (t = e); let i, r = e; do { if (i = !1, r.steiner || !equals(r, r.next) && 0 !== area$1(r.prev, r, r.next)) r = r.next; else { if (removeNode(r), r = t = r.prev, r === r.next) break; i = !0 } } while (i || r !== t); return t } function earcutLinked(e, t, i, r, n, a, o) { if (!e) return; !o && a && indexCurve(e, r, n, a); let s, l, c = e; for (; e.prev !== e.next;)if (s = e.prev, l = e.next, a ? isEarHashed(e, r, n, a) : isEar(e)) t.push(s.i / i), t.push(e.i / i), t.push(l.i / i), removeNode(e), e = l.next, c = l.next; else if ((e = l) === c) { o ? 1 === o ? earcutLinked(e = cureLocalIntersections(filterPoints(e), t, i), t, i, r, n, a, 2) : 2 === o && splitEarcut(e, t, i, r, n, a) : earcutLinked(filterPoints(e), t, i, r, n, a, 1); break } } function isEar(e) { const t = e.prev, i = e, r = e.next; if (area$1(t, i, r) >= 0) return !1; let n = e.next.next; for (; n !== e.prev;) { if (pointInTriangle(t.x, t.y, i.x, i.y, r.x, r.y, n.x, n.y) && area$1(n.prev, n, n.next) >= 0) return !1; n = n.next } return !0 } function isEarHashed(e, t, i, r) { const n = e.prev, a = e, o = e.next; if (area$1(n, a, o) >= 0) return !1; const s = n.x < a.x ? n.x < o.x ? n.x : o.x : a.x < o.x ? a.x : o.x, l = n.y < a.y ? n.y < o.y ? n.y : o.y : a.y < o.y ? a.y : o.y, c = n.x > a.x ? n.x > o.x ? n.x : o.x : a.x > o.x ? a.x : o.x, h = n.y > a.y ? n.y > o.y ? n.y : o.y : a.y > o.y ? a.y : o.y, u = zOrder(s, l, t, i, r), d = zOrder(c, h, t, i, r); let p = e.prevZ, f = e.nextZ; for (; p && p.z >= u && f && f.z <= d;) { if (p !== e.prev && p !== e.next && pointInTriangle(n.x, n.y, a.x, a.y, o.x, o.y, p.x, p.y) && area$1(p.prev, p, p.next) >= 0) return !1; if (p = p.prevZ, f !== e.prev && f !== e.next && pointInTriangle(n.x, n.y, a.x, a.y, o.x, o.y, f.x, f.y) && area$1(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } for (; p && p.z >= u;) { if (p !== e.prev && p !== e.next && pointInTriangle(n.x, n.y, a.x, a.y, o.x, o.y, p.x, p.y) && area$1(p.prev, p, p.next) >= 0) return !1; p = p.prevZ } for (; f && f.z <= d;) { if (f !== e.prev && f !== e.next && pointInTriangle(n.x, n.y, a.x, a.y, o.x, o.y, f.x, f.y) && area$1(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } return !0 } function cureLocalIntersections(e, t, i) { let r = e; do { const n = r.prev, a = r.next.next; !equals(n, a) && intersects(n, r, r.next, a) && locallyInside(n, a) && locallyInside(a, n) && (t.push(n.i / i), t.push(r.i / i), t.push(a.i / i), removeNode(r), removeNode(r.next), r = e = a), r = r.next } while (r !== e); return filterPoints(r) } function splitEarcut(e, t, i, r, n, a) { let o = e; do { let e = o.next.next; for (; e !== o.prev;) { if (o.i !== e.i && isValidDiagonal(o, e)) { let s = splitPolygon(o, e); return o = filterPoints(o, o.next), s = filterPoints(s, s.next), earcutLinked(o, t, i, r, n, a), void earcutLinked(s, t, i, r, n, a) } e = e.next } o = o.next } while (o !== e) } function eliminateHoles(e, t, i, r) { const n = []; let a, o, s, l, c; for (a = 0, o = t.length; a < o; a++)s = t[a] * r, l = a < o - 1 ? t[a + 1] * r : e.length, c = linkedList(e, s, l, r, !1), c === c.next && (c.steiner = !0), n.push(getLeftmost(c)); for (n.sort(compareX), a = 0; a < n.length; a++)eliminateHole(n[a], i), i = filterPoints(i, i.next); return i } function compareX(e, t) { return e.x - t.x } function eliminateHole(e, t) { if (t = findHoleBridge(e, t)) { const i = splitPolygon(t, e); filterPoints(t, t.next), filterPoints(i, i.next) } } function findHoleBridge(e, t) { let i = t; const r = e.x, n = e.y; let a, o = -1 / 0; do { if (n <= i.y && n >= i.next.y && i.next.y !== i.y) { const e = i.x + (n - i.y) * (i.next.x - i.x) / (i.next.y - i.y); if (e <= r && e > o) { if (o = e, e === r) { if (n === i.y) return i; if (n === i.next.y) return i.next } a = i.x < i.next.x ? i : i.next } } i = i.next } while (i !== t); if (!a) return null; if (r === o) return a; const s = a, l = a.x, c = a.y; let h, u = 1 / 0; i = a; do { r >= i.x && i.x >= l && r !== i.x && pointInTriangle(n < c ? r : o, n, l, c, n < c ? o : r, n, i.x, i.y) && (h = Math.abs(n - i.y) / (r - i.x), locallyInside(i, e) && (h < u || h === u && (i.x > a.x || i.x === a.x && sectorContainsSector(a, i))) && (a = i, u = h)), i = i.next } while (i !== s); return a } function sectorContainsSector(e, t) { return area$1(e.prev, e, t.prev) < 0 && area$1(t.next, e, e.next) < 0 } function indexCurve(e, t, i, r) { let n = e; do { null === n.z && (n.z = zOrder(n.x, n.y, t, i, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next } while (n !== e); n.prevZ.nextZ = null, n.prevZ = null, sortLinked(n) } function sortLinked(e) { let t, i, r, n, a, o, s, l, c = 1; do { for (i = e, e = null, a = null, o = 0; i;) { for (o++, r = i, s = 0, t = 0; t < c && (s++, r = r.nextZ, r); t++); for (l = c; s > 0 || l > 0 && r;)0 !== s && (0 === l || !r || i.z <= r.z) ? (n = i, i = i.nextZ, s--) : (n = r, r = r.nextZ, l--), a ? a.nextZ = n : e = n, n.prevZ = a, a = n; i = r } a.nextZ = null, c *= 2 } while (o > 1); return e } function zOrder(e, t, i, r, n) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 } function getLeftmost(e) { let t = e, i = e; do { (t.x < i.x || t.x === i.x && t.y < i.y) && (i = t), t = t.next } while (t !== e); return i } function pointInTriangle(e, t, i, r, n, a, o, s) { return (n - o) * (t - s) - (e - o) * (a - s) >= 0 && (e - o) * (r - s) - (i - o) * (t - s) >= 0 && (i - o) * (a - s) - (n - o) * (r - s) >= 0 } function isValidDiagonal(e, t) { return e.next.i !== t.i && e.prev.i !== t.i && !intersectsPolygon(e, t) && (locallyInside(e, t) && locallyInside(t, e) && middleInside(e, t) && (area$1(e.prev, e, t.prev) || area$1(e, t.prev, t)) || equals(e, t) && area$1(e.prev, e, e.next) > 0 && area$1(t.prev, t, t.next) > 0) } function area$1(e, t, i) { return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y) } function equals(e, t) { return e.x === t.x && e.y === t.y } function intersects(e, t, i, r) { const n = sign$1(area$1(e, t, i)), a = sign$1(area$1(e, t, r)), o = sign$1(area$1(i, r, e)), s = sign$1(area$1(i, r, t)); return n !== a && o !== s || (!(0 !== n || !onSegment(e, i, t)) || (!(0 !== a || !onSegment(e, r, t)) || (!(0 !== o || !onSegment(i, e, r)) || !(0 !== s || !onSegment(i, t, r))))) } function onSegment(e, t, i) { return t.x <= Math.max(e.x, i.x) && t.x >= Math.min(e.x, i.x) && t.y <= Math.max(e.y, i.y) && t.y >= Math.min(e.y, i.y) } function sign$1(e) { return e > 0 ? 1 : e < 0 ? -1 : 0 } function intersectsPolygon(e, t) { let i = e; do { if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && intersects(i, i.next, e, t)) return !0; i = i.next } while (i !== e); return !1 } function locallyInside(e, t) { return area$1(e.prev, e, e.next) < 0 ? area$1(e, t, e.next) >= 0 && area$1(e, e.prev, t) >= 0 : area$1(e, t, e.prev) < 0 || area$1(e, e.next, t) < 0 } function middleInside(e, t) { let i = e, r = !1; const n = (e.x + t.x) / 2, a = (e.y + t.y) / 2; do { i.y > a != i.next.y > a && i.next.y !== i.y && n < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (r = !r), i = i.next } while (i !== e); return r } function splitPolygon(e, t) { const i = new Node$1(e.i, e.x, e.y), r = new Node$1(t.i, t.x, t.y), n = e.next, a = t.prev; return e.next = t, t.prev = e, i.next = n, n.prev = i, r.next = i, i.prev = r, a.next = r, r.prev = a, r } function insertNode(e, t, i, r) { const n = new Node$1(e, t, i); return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n } function removeNode(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function Node$1(e, t, i) { this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function signedArea(e, t, i, r) { let n = 0; for (let a = t, o = i - r; a < i; a += r)n += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a; return n } const ShapeUtils = { area: function (e) { const t = e.length; let i = 0; for (let r = t - 1, n = 0; n < t; r = n++)i += e[r].x * e[n].y - e[n].x * e[r].y; return .5 * i }, isClockWise: function (e) { return ShapeUtils.area(e) < 0 }, triangulateShape: function (e, t) { const i = [], r = [], n = []; removeDupEndPts(e), addContour(i, e); let a = e.length; t.forEach(removeDupEndPts); for (let e = 0; e < t.length; e++)r.push(a), a += t[e].length, addContour(i, t[e]); const o = Earcut.triangulate(i, r); for (let e = 0; e < o.length; e += 3)n.push(o.slice(e, e + 3)); return n } }; function removeDupEndPts(e) { const t = e.length; t > 2 && e[t - 1].equals(e[0]) && e.pop() } function addContour(e, t) { for (let i = 0; i < t.length; i++)e.push(t[i].x), e.push(t[i].y) } class ExtrudeGeometry extends BufferGeometry { constructor(e, t) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; const i = this, r = [], n = []; for (let t = 0, i = e.length; t < i; t++) { a(e[t]) } function a(e) { const a = [], o = void 0 !== t.curveSegments ? t.curveSegments : 12, s = void 0 !== t.steps ? t.steps : 1; let l = void 0 !== t.depth ? t.depth : 100, c = void 0 === t.bevelEnabled || t.bevelEnabled, h = void 0 !== t.bevelThickness ? t.bevelThickness : 6, u = void 0 !== t.bevelSize ? t.bevelSize : h - 2, d = void 0 !== t.bevelOffset ? t.bevelOffset : 0, p = void 0 !== t.bevelSegments ? t.bevelSegments : 3; const f = t.extrudePath, m = void 0 !== t.UVGenerator ? t.UVGenerator : WorldUVGenerator; void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = t.amount); let g, y, v, _, b, x = !1; f && (g = f.getSpacedPoints(s), x = !0, c = !1, y = f.computeFrenetFrames(s, !1), v = new Vector3, _ = new Vector3, b = new Vector3), c || (p = 0, h = 0, u = 0, d = 0); const w = e.extractPoints(o); let S = w.shape; const M = w.holes; if (!ShapeUtils.isClockWise(S)) { S = S.reverse(); for (let e = 0, t = M.length; e < t; e++) { const t = M[e]; ShapeUtils.isClockWise(t) && (M[e] = t.reverse()) } } const T = ShapeUtils.triangulateShape(S, M), A = S; for (let e = 0, t = M.length; e < t; e++) { const t = M[e]; S = S.concat(t) } function E(e, t, i) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e) } const C = S.length, L = T.length; function R(e, t, i) { let r, n, a; const o = e.x - t.x, s = e.y - t.y, l = i.x - e.x, c = i.y - e.y, h = o * o + s * s, u = o * c - s * l; if (Math.abs(u) > Number.EPSILON) { const u = Math.sqrt(h), d = Math.sqrt(l * l + c * c), p = t.x - s / u, f = t.y + o / u, m = ((i.x - c / d - p) * c - (i.y + l / d - f) * l) / (o * c - s * l); r = p + o * m - e.x, n = f + s * m - e.y; const g = r * r + n * n; if (g <= 2) return new Vector2(r, n); a = Math.sqrt(g / 2) } else { let e = !1; o > Number.EPSILON ? l > Number.EPSILON && (e = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(s) === Math.sign(c) && (e = !0), e ? (r = -s, n = o, a = Math.sqrt(h)) : (r = o, n = s, a = Math.sqrt(h / 2)) } return new Vector2(r / a, n / a) } const D = []; for (let e = 0, t = A.length, i = t - 1, r = e + 1; e < t; e++, i++, r++)i === t && (i = 0), r === t && (r = 0), D[e] = R(A[e], A[i], A[r]); const P = []; let O, I = D.concat(); for (let e = 0, t = M.length; e < t; e++) { const t = M[e]; O = []; for (let e = 0, i = t.length, r = i - 1, n = e + 1; e < i; e++, r++, n++)r === i && (r = 0), n === i && (n = 0), O[e] = R(t[e], t[r], t[n]); P.push(O), I = I.concat(O) } for (let e = 0; e < p; e++) { const t = e / p, i = h * Math.cos(t * Math.PI / 2), r = u * Math.sin(t * Math.PI / 2) + d; for (let e = 0, t = A.length; e < t; e++) { const t = E(A[e], D[e], r); N(t.x, t.y, -i) } for (let e = 0, t = M.length; e < t; e++) { const t = M[e]; O = P[e]; for (let e = 0, n = t.length; e < n; e++) { const n = E(t[e], O[e], r); N(n.x, n.y, -i) } } } const k = u + d; for (let e = 0; e < C; e++) { const t = c ? E(S[e], I[e], k) : S[e]; x ? (_.copy(y.normals[0]).multiplyScalar(t.x), v.copy(y.binormals[0]).multiplyScalar(t.y), b.copy(g[0]).add(_).add(v), N(b.x, b.y, b.z)) : N(t.x, t.y, 0) } for (let e = 1; e <= s; e++)for (let t = 0; t < C; t++) { const i = c ? E(S[t], I[t], k) : S[t]; x ? (_.copy(y.normals[e]).multiplyScalar(i.x), v.copy(y.binormals[e]).multiplyScalar(i.y), b.copy(g[e]).add(_).add(v), N(b.x, b.y, b.z)) : N(i.x, i.y, l / s * e) } for (let e = p - 1; e >= 0; e--) { const t = e / p, i = h * Math.cos(t * Math.PI / 2), r = u * Math.sin(t * Math.PI / 2) + d; for (let e = 0, t = A.length; e < t; e++) { const t = E(A[e], D[e], r); N(t.x, t.y, l + i) } for (let e = 0, t = M.length; e < t; e++) { const t = M[e]; O = P[e]; for (let e = 0, n = t.length; e < n; e++) { const n = E(t[e], O[e], r); x ? N(n.x, n.y + g[s - 1].y, g[s - 1].x + i) : N(n.x, n.y, l + i) } } } function B(e, t) { let i = e.length; for (; --i >= 0;) { const r = i; let n = i - 1; n < 0 && (n = e.length - 1); for (let e = 0, i = s + 2 * p; e < i; e++) { const i = C * e, a = C * (e + 1); U(t + r + i, t + n + i, t + n + a, t + r + a) } } } function N(e, t, i) { a.push(e), a.push(t), a.push(i) } function F(e, t, n) { z(e), z(t), z(n); const a = r.length / 3, o = m.generateTopUV(i, r, a - 3, a - 2, a - 1); G(o[0]), G(o[1]), G(o[2]) } function U(e, t, n, a) { z(e), z(t), z(a), z(t), z(n), z(a); const o = r.length / 3, s = m.generateSideWallUV(i, r, o - 6, o - 3, o - 2, o - 1); G(s[0]), G(s[1]), G(s[3]), G(s[1]), G(s[2]), G(s[3]) } function z(e) { r.push(a[3 * e + 0]), r.push(a[3 * e + 1]), r.push(a[3 * e + 2]) } function G(e) { n.push(e.x), n.push(e.y) } !function () { const e = r.length / 3; if (c) { let e = 0, t = C * e; for (let e = 0; e < L; e++) { const i = T[e]; F(i[2] + t, i[1] + t, i[0] + t) } e = s + 2 * p, t = C * e; for (let e = 0; e < L; e++) { const i = T[e]; F(i[0] + t, i[1] + t, i[2] + t) } } else { for (let e = 0; e < L; e++) { const t = T[e]; F(t[2], t[1], t[0]) } for (let e = 0; e < L; e++) { const t = T[e]; F(t[0] + C * s, t[1] + C * s, t[2] + C * s) } } i.addGroup(e, r.length / 3 - e, 0) }(), function () { const e = r.length / 3; let t = 0; B(A, t), t += A.length; for (let e = 0, i = M.length; e < i; e++) { const i = M[e]; B(i, t), t += i.length } i.addGroup(e, r.length / 3 - e, 1) }() } this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("uv", new Float32BufferAttribute(n, 2)), this.computeVertexNormals() } toJSON() { const e = BufferGeometry.prototype.toJSON.call(this); return toJSON(this.parameters.shapes, this.parameters.options, e) } } const WorldUVGenerator = { generateTopUV: function (e, t, i, r, n) { const a = t[3 * i], o = t[3 * i + 1], s = t[3 * r], l = t[3 * r + 1], c = t[3 * n], h = t[3 * n + 1]; return [new Vector2(a, o), new Vector2(s, l), new Vector2(c, h)] }, generateSideWallUV: function (e, t, i, r, n, a) { const o = t[3 * i], s = t[3 * i + 1], l = t[3 * i + 2], c = t[3 * r], h = t[3 * r + 1], u = t[3 * r + 2], d = t[3 * n], p = t[3 * n + 1], f = t[3 * n + 2], m = t[3 * a], g = t[3 * a + 1], y = t[3 * a + 2]; return Math.abs(s - h) < .01 ? [new Vector2(o, 1 - l), new Vector2(c, 1 - u), new Vector2(d, 1 - f), new Vector2(m, 1 - y)] : [new Vector2(s, 1 - l), new Vector2(h, 1 - u), new Vector2(p, 1 - f), new Vector2(g, 1 - y)] } }; function toJSON(e, t, i) { if (i.shapes = [], Array.isArray(e)) for (let t = 0, r = e.length; t < r; t++) { const r = e[t]; i.shapes.push(r.uuid) } else i.shapes.push(e.uuid); return void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON()), i } class IcosahedronGeometry extends PolyhedronGeometry { constructor(e = 1, t = 0) { const i = (1 + Math.sqrt(5)) / 2; super([-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t } } } class LatheGeometry extends BufferGeometry { constructor(e, t = 12, i = 0, r = 2 * Math.PI) { super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }, t = Math.floor(t), r = MathUtils.clamp(r, 0, 2 * Math.PI); const n = [], a = [], o = [], s = 1 / t, l = new Vector3, c = new Vector2; for (let n = 0; n <= t; n++) { const h = i + n * s * r, u = Math.sin(h), d = Math.cos(h); for (let i = 0; i <= e.length - 1; i++)l.x = e[i].x * u, l.y = e[i].y, l.z = e[i].x * d, a.push(l.x, l.y, l.z), c.x = n / t, c.y = i / (e.length - 1), o.push(c.x, c.y) } for (let i = 0; i < t; i++)for (let t = 0; t < e.length - 1; t++) { const r = t + i * e.length, a = r, o = r + e.length, s = r + e.length + 1, l = r + 1; n.push(a, o, l), n.push(o, s, l) } if (this.setIndex(n), this.setAttribute("position", new Float32BufferAttribute(a, 3)), this.setAttribute("uv", new Float32BufferAttribute(o, 2)), this.computeVertexNormals(), r === 2 * Math.PI) { const i = this.attributes.normal.array, r = new Vector3, n = new Vector3, a = new Vector3, o = t * e.length * 3; for (let t = 0, s = 0; t < e.length; t++, s += 3)r.x = i[s + 0], r.y = i[s + 1], r.z = i[s + 2], n.x = i[o + s + 0], n.y = i[o + s + 1], n.z = i[o + s + 2], a.addVectors(r, n).normalize(), i[s + 0] = i[o + s + 0] = a.x, i[s + 1] = i[o + s + 1] = a.y, i[s + 2] = i[o + s + 2] = a.z } } } class OctahedronGeometry extends PolyhedronGeometry { constructor(e = 1, t = 0) { super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t } } } function ParametricGeometry(e, t, i) { BufferGeometry.call(this), this.type = "ParametricGeometry", this.parameters = { func: e, slices: t, stacks: i }; const r = [], n = [], a = [], o = [], s = 1e-5, l = new Vector3, c = new Vector3, h = new Vector3, u = new Vector3, d = new Vector3; e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); const p = t + 1; for (let r = 0; r <= i; r++) { const p = r / i; for (let i = 0; i <= t; i++) { const r = i / t; e(r, p, c), n.push(c.x, c.y, c.z), r - s >= 0 ? (e(r - s, p, h), u.subVectors(c, h)) : (e(r + s, p, h), u.subVectors(h, c)), p - s >= 0 ? (e(r, p - s, h), d.subVectors(c, h)) : (e(r, p + s, h), d.subVectors(h, c)), l.crossVectors(u, d).normalize(), a.push(l.x, l.y, l.z), o.push(r, p) } } for (let e = 0; e < i; e++)for (let i = 0; i < t; i++) { const t = e * p + i, n = e * p + i + 1, a = (e + 1) * p + i + 1, o = (e + 1) * p + i; r.push(t, n, o), r.push(n, a, o) } this.setIndex(r), this.setAttribute("position", new Float32BufferAttribute(n, 3)), this.setAttribute("normal", new Float32BufferAttribute(a, 3)), this.setAttribute("uv", new Float32BufferAttribute(o, 2)) } ParametricGeometry.prototype = Object.create(BufferGeometry.prototype), ParametricGeometry.prototype.constructor = ParametricGeometry; class RingGeometry extends BufferGeometry { constructor(e = .5, t = 1, i = 8, r = 1, n = 0, a = 2 * Math.PI) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: r, thetaStart: n, thetaLength: a }, i = Math.max(3, i); const o = [], s = [], l = [], c = []; let h = e; const u = (t - e) / (r = Math.max(1, r)), d = new Vector3, p = new Vector2; for (let e = 0; e <= r; e++) { for (let e = 0; e <= i; e++) { const r = n + e / i * a; d.x = h * Math.cos(r), d.y = h * Math.sin(r), s.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / t + 1) / 2, p.y = (d.y / t + 1) / 2, c.push(p.x, p.y) } h += u } for (let e = 0; e < r; e++) { const t = e * (i + 1); for (let e = 0; e < i; e++) { const r = e + t, n = r, a = r + i + 1, s = r + i + 2, l = r + 1; o.push(n, a, l), o.push(a, s, l) } } this.setIndex(o), this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("normal", new Float32BufferAttribute(l, 3)), this.setAttribute("uv", new Float32BufferAttribute(c, 2)) } } class ShapeGeometry extends BufferGeometry { constructor(e, t = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t }; const i = [], r = [], n = [], a = []; let o = 0, s = 0; if (!1 === Array.isArray(e)) l(e); else for (let t = 0; t < e.length; t++)l(e[t]), this.addGroup(o, s, t), o += s, s = 0; function l(e) { const o = r.length / 3, l = e.extractPoints(t); let c = l.shape; const h = l.holes; !1 === ShapeUtils.isClockWise(c) && (c = c.reverse()); for (let e = 0, t = h.length; e < t; e++) { const t = h[e]; !0 === ShapeUtils.isClockWise(t) && (h[e] = t.reverse()) } const u = ShapeUtils.triangulateShape(c, h); for (let e = 0, t = h.length; e < t; e++) { const t = h[e]; c = c.concat(t) } for (let e = 0, t = c.length; e < t; e++) { const t = c[e]; r.push(t.x, t.y, 0), n.push(0, 0, 1), a.push(t.x, t.y) } for (let e = 0, t = u.length; e < t; e++) { const t = u[e], r = t[0] + o, n = t[1] + o, a = t[2] + o; i.push(r, n, a), s += 3 } } this.setIndex(i), this.setAttribute("position", new Float32BufferAttribute(r, 3)), this.setAttribute("normal", new Float32BufferAttribute(n, 3)), this.setAttribute("uv", new Float32BufferAttribute(a, 2)) } toJSON() { const e = BufferGeometry.prototype.toJSON.call(this); return toJSON$1(this.parameters.shapes, e) } } function toJSON$1(e, t) { if (t.shapes = [], Array.isArray(e)) for (let i = 0, r = e.length; i < r; i++) { const r = e[i]; t.shapes.push(r.uuid) } else t.shapes.push(e.uuid); return t } class SphereGeometry extends BufferGeometry { constructor(e = 1, t = 8, i = 6, r = 0, n = 2 * Math.PI, a = 0, o = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: r, phiLength: n, thetaStart: a, thetaLength: o }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i)); const s = Math.min(a + o, Math.PI); let l = 0; const c = [], h = new Vector3, u = new Vector3, d = [], p = [], f = [], m = []; for (let d = 0; d <= i; d++) { const g = [], y = d / i; let v = 0; 0 == d && 0 == a ? v = .5 / t : d == i && s == Math.PI && (v = -.5 / t); for (let i = 0; i <= t; i++) { const s = i / t; h.x = -e * Math.cos(r + s * n) * Math.sin(a + y * o), h.y = e * Math.cos(a + y * o), h.z = e * Math.sin(r + s * n) * Math.sin(a + y * o), p.push(h.x, h.y, h.z), u.copy(h).normalize(), f.push(u.x, u.y, u.z), m.push(s + v, 1 - y), g.push(l++) } c.push(g) } for (let e = 0; e < i; e++)for (let r = 0; r < t; r++) { const t = c[e][r + 1], n = c[e][r], o = c[e + 1][r], l = c[e + 1][r + 1]; (0 !== e || a > 0) && d.push(t, n, l), (e !== i - 1 || s < Math.PI) && d.push(n, o, l) } this.setIndex(d), this.setAttribute("position", new Float32BufferAttribute(p, 3)), this.setAttribute("normal", new Float32BufferAttribute(f, 3)), this.setAttribute("uv", new Float32BufferAttribute(m, 2)) } } class TetrahedronGeometry extends PolyhedronGeometry { constructor(e = 1, t = 0) { super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t } } } class TextGeometry extends ExtrudeGeometry { constructor(e, t = {}) { const i = t.font; if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new BufferGeometry; const r = i.generateShapes(e, t.size); t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), super(r, t), this.type = "TextGeometry" } } class TorusGeometry extends BufferGeometry { constructor(e = 1, t = .4, i = 8, r = 6, n = 2 * Math.PI) { super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: i, tubularSegments: r, arc: n }, i = Math.floor(i), r = Math.floor(r); const a = [], o = [], s = [], l = [], c = new Vector3, h = new Vector3, u = new Vector3; for (let a = 0; a <= i; a++)for (let d = 0; d <= r; d++) { const p = d / r * n, f = a / i * Math.PI * 2; h.x = (e + t * Math.cos(f)) * Math.cos(p), h.y = (e + t * Math.cos(f)) * Math.sin(p), h.z = t * Math.sin(f), o.push(h.x, h.y, h.z), c.x = e * Math.cos(p), c.y = e * Math.sin(p), u.subVectors(h, c).normalize(), s.push(u.x, u.y, u.z), l.push(d / r), l.push(a / i) } for (let e = 1; e <= i; e++)for (let t = 1; t <= r; t++) { const i = (r + 1) * e + t - 1, n = (r + 1) * (e - 1) + t - 1, o = (r + 1) * (e - 1) + t, s = (r + 1) * e + t; a.push(i, n, s), a.push(n, o, s) } this.setIndex(a), this.setAttribute("position", new Float32BufferAttribute(o, 3)), this.setAttribute("normal", new Float32BufferAttribute(s, 3)), this.setAttribute("uv", new Float32BufferAttribute(l, 2)) } } class TorusKnotGeometry extends BufferGeometry { constructor(e = 1, t = .4, i = 64, r = 8, n = 2, a = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: i, radialSegments: r, p: n, q: a }, i = Math.floor(i), r = Math.floor(r); const o = [], s = [], l = [], c = [], h = new Vector3, u = new Vector3, d = new Vector3, p = new Vector3, f = new Vector3, m = new Vector3, g = new Vector3; for (let o = 0; o <= i; ++o) { const v = o / i * n * Math.PI * 2; y(v, n, a, e, d), y(v + .01, n, a, e, p), m.subVectors(p, d), g.addVectors(p, d), f.crossVectors(m, g), g.crossVectors(f, m), f.normalize(), g.normalize(); for (let e = 0; e <= r; ++e) { const n = e / r * Math.PI * 2, a = -t * Math.cos(n), p = t * Math.sin(n); h.x = d.x + (a * g.x + p * f.x), h.y = d.y + (a * g.y + p * f.y), h.z = d.z + (a * g.z + p * f.z), s.push(h.x, h.y, h.z), u.subVectors(h, d).normalize(), l.push(u.x, u.y, u.z), c.push(o / i), c.push(e / r) } } for (let e = 1; e <= i; e++)for (let t = 1; t <= r; t++) { const i = (r + 1) * (e - 1) + (t - 1), n = (r + 1) * e + (t - 1), a = (r + 1) * e + t, s = (r + 1) * (e - 1) + t; o.push(i, n, s), o.push(n, a, s) } function y(e, t, i, r, n) { const a = Math.cos(e), o = Math.sin(e), s = i / t * e, l = Math.cos(s); n.x = r * (2 + l) * .5 * a, n.y = r * (2 + l) * o * .5, n.z = r * Math.sin(s) * .5 } this.setIndex(o), this.setAttribute("position", new Float32BufferAttribute(s, 3)), this.setAttribute("normal", new Float32BufferAttribute(l, 3)), this.setAttribute("uv", new Float32BufferAttribute(c, 2)) } } class TubeGeometry extends BufferGeometry { constructor(e, t = 64, i = 1, r = 8, n = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: i, radialSegments: r, closed: n }; const a = e.computeFrenetFrames(t, n); this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals; const o = new Vector3, s = new Vector3, l = new Vector2; let c = new Vector3; const h = [], u = [], d = [], p = []; function f(n) { c = e.getPointAt(n / t, c); const l = a.normals[n], d = a.binormals[n]; for (let e = 0; e <= r; e++) { const t = e / r * Math.PI * 2, n = Math.sin(t), a = -Math.cos(t); s.x = a * l.x + n * d.x, s.y = a * l.y + n * d.y, s.z = a * l.z + n * d.z, s.normalize(), u.push(s.x, s.y, s.z), o.x = c.x + i * s.x, o.y = c.y + i * s.y, o.z = c.z + i * s.z, h.push(o.x, o.y, o.z) } } !function () { for (let e = 0; e < t; e++)f(e); f(!1 === n ? t : 0), function () { for (let e = 0; e <= t; e++)for (let i = 0; i <= r; i++)l.x = e / t, l.y = i / r, d.push(l.x, l.y) }(), function () { for (let e = 1; e <= t; e++)for (let t = 1; t <= r; t++) { const i = (r + 1) * (e - 1) + (t - 1), n = (r + 1) * e + (t - 1), a = (r + 1) * e + t, o = (r + 1) * (e - 1) + t; p.push(i, n, o), p.push(n, a, o) } }() }(), this.setIndex(p), this.setAttribute("position", new Float32BufferAttribute(h, 3)), this.setAttribute("normal", new Float32BufferAttribute(u, 3)), this.setAttribute("uv", new Float32BufferAttribute(d, 2)) } toJSON() { const e = BufferGeometry.prototype.toJSON.call(this); return e.path = this.parameters.path.toJSON(), e } } class WireframeGeometry extends BufferGeometry { constructor(e) { if (super(), this.type = "WireframeGeometry", !0 === e.isGeometry) return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); const t = [], i = [0, 0], r = {}, n = new Vector3; if (null !== e.index) { const a = e.attributes.position, o = e.index; let s = e.groups; 0 === s.length && (s = [{ start: 0, count: o.count, materialIndex: 0 }]); for (let e = 0, t = s.length; e < t; ++e) { const t = s[e], n = t.start; for (let e = n, a = n + t.count; e < a; e += 3)for (let t = 0; t < 3; t++) { const n = o.getX(e + t), a = o.getX(e + (t + 1) % 3); i[0] = Math.min(n, a), i[1] = Math.max(n, a); const s = i[0] + "," + i[1]; void 0 === r[s] && (r[s] = { index1: i[0], index2: i[1] }) } } for (const e in r) { const i = r[e]; n.fromBufferAttribute(a, i.index1), t.push(n.x, n.y, n.z), n.fromBufferAttribute(a, i.index2), t.push(n.x, n.y, n.z) } } else { const i = e.attributes.position; for (let e = 0, r = i.count / 3; e < r; e++)for (let r = 0; r < 3; r++) { const a = 3 * e + r; n.fromBufferAttribute(i, a), t.push(n.x, n.y, n.z); const o = 3 * e + (r + 1) % 3; n.fromBufferAttribute(i, o), t.push(n.x, n.y, n.z) } } this.setAttribute("position", new Float32BufferAttribute(t, 3)) } } var Geometries = Object.freeze({ __proto__: null, BoxGeometry: BoxGeometry, BoxBufferGeometry: BoxGeometry, CircleGeometry: CircleGeometry, CircleBufferGeometry: CircleGeometry, ConeGeometry: ConeGeometry, ConeBufferGeometry: ConeGeometry, CylinderGeometry: CylinderGeometry, CylinderBufferGeometry: CylinderGeometry, DodecahedronGeometry: DodecahedronGeometry, DodecahedronBufferGeometry: DodecahedronGeometry, EdgesGeometry: EdgesGeometry, ExtrudeGeometry: ExtrudeGeometry, ExtrudeBufferGeometry: ExtrudeGeometry, IcosahedronGeometry: IcosahedronGeometry, IcosahedronBufferGeometry: IcosahedronGeometry, LatheGeometry: LatheGeometry, LatheBufferGeometry: LatheGeometry, OctahedronGeometry: OctahedronGeometry, OctahedronBufferGeometry: OctahedronGeometry, ParametricGeometry: ParametricGeometry, ParametricBufferGeometry: ParametricGeometry, PlaneGeometry: PlaneGeometry, PlaneBufferGeometry: PlaneGeometry, PolyhedronGeometry: PolyhedronGeometry, PolyhedronBufferGeometry: PolyhedronGeometry, RingGeometry: RingGeometry, RingBufferGeometry: RingGeometry, ShapeGeometry: ShapeGeometry, ShapeBufferGeometry: ShapeGeometry, SphereGeometry: SphereGeometry, SphereBufferGeometry: SphereGeometry, TetrahedronGeometry: TetrahedronGeometry, TetrahedronBufferGeometry: TetrahedronGeometry, TextGeometry: TextGeometry, TextBufferGeometry: TextGeometry, TorusGeometry: TorusGeometry, TorusBufferGeometry: TorusGeometry, TorusKnotGeometry: TorusKnotGeometry, TorusKnotBufferGeometry: TorusKnotGeometry, TubeGeometry: TubeGeometry, TubeBufferGeometry: TubeGeometry, WireframeGeometry: WireframeGeometry }); class ShadowMaterial extends Material$1 { constructor(e) { super(), this.type = "ShadowMaterial", this.color = new Color$1(0), this.transparent = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this } } ShadowMaterial.prototype.isShadowMaterial = !0; class RawShaderMaterial extends ShaderMaterial { constructor(e) { super(e), this.type = "RawShaderMaterial" } } function MeshStandardMaterial(e) { Material$1.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Color$1(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color$1(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(e) } function MeshPhysicalMaterial(e) { MeshStandardMaterial.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", { get: function () { return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity) }, set: function (e) { this.reflectivity = MathUtils.clamp(2.5 * (e - 1) / (e + 1), 0, 1) } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(e) } RawShaderMaterial.prototype.isRawShaderMaterial = !0, MeshStandardMaterial.prototype = Object.create(Material$1.prototype), MeshStandardMaterial.prototype.constructor = MeshStandardMaterial, MeshStandardMaterial.prototype.isMeshStandardMaterial = !0, MeshStandardMaterial.prototype.copy = function (e) { return Material$1.prototype.copy.call(this, e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this.vertexTangents = e.vertexTangents, this }, MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype), MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial, MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = !0, MeshPhysicalMaterial.prototype.copy = function (e) { return MeshStandardMaterial.prototype.copy.call(this, e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = (this.sheen || new Color$1).copy(e.sheen) : this.sheen = null, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this }; class MeshPhongMaterial extends Material$1 { constructor(e) { super(), this.type = "MeshPhongMaterial", this.color = new Color$1(16777215), this.specular = new Color$1(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color$1(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this } } MeshPhongMaterial.prototype.isMeshPhongMaterial = !0; class MeshToonMaterial extends Material$1 { constructor(e) { super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Color$1(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color$1(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this } } MeshToonMaterial.prototype.isMeshToonMaterial = !0; class MeshNormalMaterial extends Material$1 { constructor(e) { super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this } } MeshNormalMaterial.prototype.isMeshNormalMaterial = !0; class MeshLambertMaterial extends Material$1 { constructor(e) { super(), this.type = "MeshLambertMaterial", this.color = new Color$1(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color$1(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this } } MeshLambertMaterial.prototype.isMeshLambertMaterial = !0; class MeshMatcapMaterial extends Material$1 { constructor(e) { super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Color$1(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.flatShading = e.flatShading, this } } MeshMatcapMaterial.prototype.isMeshMatcapMaterial = !0; class LineDashedMaterial extends LineBasicMaterial { constructor(e) { super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } LineDashedMaterial.prototype.isLineDashedMaterial = !0; var Materials = Object.freeze({ __proto__: null, ShadowMaterial: ShadowMaterial, SpriteMaterial: SpriteMaterial, RawShaderMaterial: RawShaderMaterial, ShaderMaterial: ShaderMaterial, PointsMaterial: PointsMaterial, MeshPhysicalMaterial: MeshPhysicalMaterial, MeshStandardMaterial: MeshStandardMaterial, MeshPhongMaterial: MeshPhongMaterial, MeshToonMaterial: MeshToonMaterial, MeshNormalMaterial: MeshNormalMaterial, MeshLambertMaterial: MeshLambertMaterial, MeshDepthMaterial: MeshDepthMaterial, MeshDistanceMaterial: MeshDistanceMaterial, MeshBasicMaterial: MeshBasicMaterial, MeshMatcapMaterial: MeshMatcapMaterial, LineDashedMaterial: LineDashedMaterial, LineBasicMaterial: LineBasicMaterial, Material: Material$1 }); const AnimationUtils = { arraySlice: function (e, t, i) { return AnimationUtils.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i) }, convertArray: function (e, t, i) { return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) }, isTypedArray: function (e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) }, getKeyframeOrder: function (e) { const t = e.length, i = new Array(t); for (let e = 0; e !== t; ++e)i[e] = e; return i.sort((function (t, i) { return e[t] - e[i] })), i }, sortedArray: function (e, t, i) { const r = e.length, n = new e.constructor(r); for (let a = 0, o = 0; o !== r; ++a) { const r = i[a] * t; for (let i = 0; i !== t; ++i)n[o++] = e[r + i] } return n }, flattenJSON: function (e, t, i, r) { let n = 1, a = e[0]; for (; void 0 !== a && void 0 === a[r];)a = e[n++]; if (void 0 === a) return; let o = a[r]; if (void 0 !== o) if (Array.isArray(o)) do { o = a[r], void 0 !== o && (t.push(a.time), i.push.apply(i, o)), a = e[n++] } while (void 0 !== a); else if (void 0 !== o.toArray) do { o = a[r], void 0 !== o && (t.push(a.time), o.toArray(i, i.length)), a = e[n++] } while (void 0 !== a); else do { o = a[r], void 0 !== o && (t.push(a.time), i.push(o)), a = e[n++] } while (void 0 !== a) }, subclip: function (e, t, i, r, n = 30) { const a = e.clone(); a.name = t; const o = []; for (let e = 0; e < a.tracks.length; ++e) { const t = a.tracks[e], s = t.getValueSize(), l = [], c = []; for (let e = 0; e < t.times.length; ++e) { const a = t.times[e] * n; if (!(a < i || a >= r)) { l.push(t.times[e]); for (let i = 0; i < s; ++i)c.push(t.values[e * s + i]) } } 0 !== l.length && (t.times = AnimationUtils.convertArray(l, t.times.constructor), t.values = AnimationUtils.convertArray(c, t.values.constructor), o.push(t)) } a.tracks = o; let s = 1 / 0; for (let e = 0; e < a.tracks.length; ++e)s > a.tracks[e].times[0] && (s = a.tracks[e].times[0]); for (let e = 0; e < a.tracks.length; ++e)a.tracks[e].shift(-1 * s); return a.resetDuration(), a }, makeClipAdditive: function (e, t = 0, i = e, r = 30) { r <= 0 && (r = 30); const n = i.tracks.length, a = t / r; for (let t = 0; t < n; ++t) { const r = i.tracks[t], n = r.ValueTypeName; if ("bool" === n || "string" === n) continue; const o = e.tracks.find((function (e) { return e.name === r.name && e.ValueTypeName === n })); if (void 0 === o) continue; let s = 0; const l = r.getValueSize(); r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s = l / 3); let c = 0; const h = o.getValueSize(); o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3); const u = r.times.length - 1; let d; if (a <= r.times[0]) { const e = s, t = l - s; d = AnimationUtils.arraySlice(r.values, e, t) } else if (a >= r.times[u]) { const e = u * l + s, t = e + l - s; d = AnimationUtils.arraySlice(r.values, e, t) } else { const e = r.createInterpolant(), t = s, i = l - s; e.evaluate(a), d = AnimationUtils.arraySlice(e.resultBuffer, t, i) } if ("quaternion" === n) { (new Quaternion).fromArray(d).normalize().conjugate().toArray(d) } const p = o.times.length; for (let e = 0; e < p; ++e) { const t = e * h + c; if ("quaternion" === n) Quaternion.multiplyQuaternionsFlat(o.values, t, d, 0, o.values, t); else { const e = h - 2 * c; for (let i = 0; i < e; ++i)o.values[t + i] -= d[i] } } } return e.blendMode = AdditiveAnimationBlendMode, e } }; function Interpolant(e, t, i, r) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i } function CubicInterpolant(e, t, i, r) { Interpolant.call(this, e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 } function LinearInterpolant(e, t, i, r) { Interpolant.call(this, e, t, i, r) } function DiscreteInterpolant(e, t, i, r) { Interpolant.call(this, e, t, i, r) } Object.assign(Interpolant.prototype, { evaluate: function (e) { const t = this.parameterPositions; let i = this._cachedIndex, r = t[i], n = t[i - 1]; e: { t: { let a; i: { r: if (!(e < r)) { for (let a = i + 2; ;) { if (void 0 === r) { if (e < n) break r; return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, e, n) } if (i === a) break; if (n = r, r = t[++i], e < r) break t } a = t.length; break i } if (e >= n) break e; { const o = t[1]; e < o && (i = 2, n = o); for (let a = i - 2; ;) { if (void 0 === n) return this._cachedIndex = 0, this.beforeStart_(0, e, r); if (i === a) break; if (r = n, n = t[--i - 1], e >= n) break t } a = i, i = 0 } } for (; i < a;) { const r = i + a >>> 1; e < t[r] ? a = r : i = r + 1 } if (r = t[i], n = t[i - 1], void 0 === n) return this._cachedIndex = 0, this.beforeStart_(0, e, r); if (void 0 === r) return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, n, e) } this._cachedIndex = i, this.intervalChanged_(i, n, r) } return this.interpolate_(i, n, e, r) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (e) { const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, n = e * r; for (let e = 0; e !== r; ++e)t[e] = i[n + e]; return t }, interpolate_: function () { throw new Error("call to abstract method") }, intervalChanged_: function () { } }), Object.assign(Interpolant.prototype, { beforeStart_: Interpolant.prototype.copySampleValue_, afterEnd_: Interpolant.prototype.copySampleValue_ }), CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), { constructor: CubicInterpolant, DefaultSettings_: { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding }, intervalChanged_: function (e, t, i) { const r = this.parameterPositions; let n = e - 2, a = e + 1, o = r[n], s = r[a]; if (void 0 === o) switch (this.getSettings_().endingStart) { case ZeroSlopeEnding: n = e, o = 2 * t - i; break; case WrapAroundEnding: n = r.length - 2, o = t + r[n] - r[n + 1]; break; default: n = e, o = i }if (void 0 === s) switch (this.getSettings_().endingEnd) { case ZeroSlopeEnding: a = e, s = 2 * i - t; break; case WrapAroundEnding: a = 1, s = i + r[1] - r[0]; break; default: a = e - 1, s = t }const l = .5 * (i - t), c = this.valueSize; this._weightPrev = l / (t - o), this._weightNext = l / (s - i), this._offsetPrev = n * c, this._offsetNext = a * c }, interpolate_: function (e, t, i, r) { const n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (i - t) / (r - t), f = p * p, m = f * p, g = -u * m + 2 * u * f - u * p, y = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1, v = (-1 - d) * m + (1.5 + d) * f + .5 * p, _ = d * m - d * f; for (let e = 0; e !== o; ++e)n[e] = g * a[c + e] + y * a[l + e] + v * a[s + e] + _ * a[h + e]; return n } }), LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), { constructor: LinearInterpolant, interpolate_: function (e, t, i, r) { const n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = (i - t) / (r - t), h = 1 - c; for (let e = 0; e !== o; ++e)n[e] = a[l + e] * h + a[s + e] * c; return n } }), DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), { constructor: DiscreteInterpolant, interpolate_: function (e) { return this.copySampleValue_(e - 1) } }); class KeyframeTrack { constructor(e, t, i, r) { if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = AnimationUtils.convertArray(t, this.TimeBufferType), this.values = AnimationUtils.convertArray(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let i; if (t.toJSON !== this.toJSON) i = t.toJSON(e); else { i = { name: e.name, times: AnimationUtils.convertArray(e.times, Array), values: AnimationUtils.convertArray(e.values, Array) }; const t = e.getInterpolation(); t !== e.DefaultInterpolation && (i.interpolation = t) } return i.type = e.ValueTypeName, i } InterpolantFactoryMethodDiscrete(e) { return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new LinearInterpolant(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new CubicInterpolant(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case InterpolateDiscrete: t = this.InterpolantFactoryMethodDiscrete; break; case InterpolateLinear: t = this.InterpolantFactoryMethodLinear; break; case InterpolateSmooth: t = this.InterpolantFactoryMethodSmooth }if (void 0 === t) { const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw new Error(t); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", t), this } return this.createInterpolant = t, this } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return InterpolateDiscrete; case this.InterpolantFactoryMethodLinear: return InterpolateLinear; case this.InterpolantFactoryMethodSmooth: return InterpolateSmooth } } getValueSize() { return this.values.length / this.times.length } shift(e) { if (0 !== e) { const t = this.times; for (let i = 0, r = t.length; i !== r; ++i)t[i] += e } return this } scale(e) { if (1 !== e) { const t = this.times; for (let i = 0, r = t.length; i !== r; ++i)t[i] *= e } return this } trim(e, t) { const i = this.times, r = i.length; let n = 0, a = r - 1; for (; n !== r && i[n] < e;)++n; for (; -1 !== a && i[a] > t;)--a; if (++a, 0 !== n || a !== r) { n >= a && (a = Math.max(a, 1), n = a - 1); const e = this.getValueSize(); this.times = AnimationUtils.arraySlice(i, n, a), this.values = AnimationUtils.arraySlice(this.values, n * e, a * e) } return this } validate() { let e = !0; const t = this.getValueSize(); t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); const i = this.times, r = this.values, n = i.length; 0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); let a = null; for (let t = 0; t !== n; t++) { const r = i[t]; if ("number" == typeof r && isNaN(r)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, r), e = !1; break } if (null !== a && a > r) { console.error("THREE.KeyframeTrack: Out of order keys.", this, t, r, a), e = !1; break } a = r } if (void 0 !== r && AnimationUtils.isTypedArray(r)) for (let t = 0, i = r.length; t !== i; ++t) { const i = r[t]; if (isNaN(i)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, i), e = !1; break } } return e } optimize() { const e = AnimationUtils.arraySlice(this.times), t = AnimationUtils.arraySlice(this.values), i = this.getValueSize(), r = this.getInterpolation() === InterpolateSmooth, n = e.length - 1; let a = 1; for (let o = 1; o < n; ++o) { let n = !1; const s = e[o]; if (s !== e[o + 1] && (1 !== o || s !== e[0])) if (r) n = !0; else { const e = o * i, r = e - i, a = e + i; for (let o = 0; o !== i; ++o) { const i = t[e + o]; if (i !== t[r + o] || i !== t[a + o]) { n = !0; break } } } if (n) { if (o !== a) { e[a] = e[o]; const r = o * i, n = a * i; for (let e = 0; e !== i; ++e)t[n + e] = t[r + e] } ++a } } if (n > 0) { e[a] = e[n]; for (let e = n * i, r = a * i, o = 0; o !== i; ++o)t[r + o] = t[e + o]; ++a } return a !== e.length ? (this.times = AnimationUtils.arraySlice(e, 0, a), this.values = AnimationUtils.arraySlice(t, 0, a * i)) : (this.times = e, this.values = t), this } clone() { const e = AnimationUtils.arraySlice(this.times, 0), t = AnimationUtils.arraySlice(this.values, 0), i = new (0, this.constructor)(this.name, e, t); return i.createInterpolant = this.createInterpolant, i } } KeyframeTrack.prototype.TimeBufferType = Float32Array, KeyframeTrack.prototype.ValueBufferType = Float32Array, KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear; class BooleanKeyframeTrack extends KeyframeTrack { } BooleanKeyframeTrack.prototype.ValueTypeName = "bool", BooleanKeyframeTrack.prototype.ValueBufferType = Array, BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0; class ColorKeyframeTrack extends KeyframeTrack { } ColorKeyframeTrack.prototype.ValueTypeName = "color"; class NumberKeyframeTrack extends KeyframeTrack { } function QuaternionLinearInterpolant(e, t, i, r) { Interpolant.call(this, e, t, i, r) } NumberKeyframeTrack.prototype.ValueTypeName = "number", QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), { constructor: QuaternionLinearInterpolant, interpolate_: function (e, t, i, r) { const n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = (i - t) / (r - t); let l = e * o; for (let e = l + o; l !== e; l += 4)Quaternion.slerpFlat(n, 0, a, l - o, a, l, s); return n } }); class QuaternionKeyframeTrack extends KeyframeTrack { InterpolantFactoryMethodLinear(e) { return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), e) } } QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion", QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear, QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0; class StringKeyframeTrack extends KeyframeTrack { } StringKeyframeTrack.prototype.ValueTypeName = "string", StringKeyframeTrack.prototype.ValueBufferType = Array, StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete, StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0; class VectorKeyframeTrack extends KeyframeTrack { } VectorKeyframeTrack.prototype.ValueTypeName = "vector"; class AnimationClip { constructor(e, t = -1, i, r = NormalAnimationBlendMode) { this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = MathUtils.generateUUID(), this.duration < 0 && this.resetDuration() } static parse(e) { const t = [], i = e.tracks, r = 1 / (e.fps || 1); for (let e = 0, n = i.length; e !== n; ++e)t.push(parseKeyframeTrack(i[e]).scale(r)); const n = new this(e.name, e.duration, t, e.blendMode); return n.uuid = e.uuid, n } static toJSON(e) { const t = [], i = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode }; for (let e = 0, r = i.length; e !== r; ++e)t.push(KeyframeTrack.toJSON(i[e])); return r } static CreateFromMorphTargetSequence(e, t, i, r) { const n = t.length, a = []; for (let e = 0; e < n; e++) { let o = [], s = []; o.push((e + n - 1) % n, e, (e + 1) % n), s.push(0, 1, 0); const l = AnimationUtils.getKeyframeOrder(o); o = AnimationUtils.sortedArray(o, 1, l), s = AnimationUtils.sortedArray(s, 1, l), r || 0 !== o[0] || (o.push(n), s.push(s[0])), a.push(new NumberKeyframeTrack(".morphTargetInfluences[" + t[e].name + "]", o, s).scale(1 / i)) } return new this(e, -1, a) } static findByName(e, t) { let i = e; if (!Array.isArray(e)) { const t = e; i = t.geometry && t.geometry.animations || t.animations } for (let e = 0; e < i.length; e++)if (i[e].name === t) return i[e]; return null } static CreateClipsFromMorphTargetSequences(e, t, i) { const r = {}, n = /^([\w-]*?)([\d]+)$/; for (let t = 0, i = e.length; t < i; t++) { const i = e[t], a = i.name.match(n); if (a && a.length > 1) { const e = a[1]; let t = r[e]; t || (r[e] = t = []), t.push(i) } } const a = []; for (const e in r) a.push(this.CreateFromMorphTargetSequence(e, r[e], t, i)); return a } static parseAnimation(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const i = function (e, t, i, r, n) { if (0 !== i.length) { const a = [], o = []; AnimationUtils.flattenJSON(i, a, o, r), 0 !== a.length && n.push(new e(t, a, o)) } }, r = [], n = e.name || "default", a = e.fps || 30, o = e.blendMode; let s = e.length || -1; const l = e.hierarchy || []; for (let e = 0; e < l.length; e++) { const n = l[e].keys; if (n && 0 !== n.length) if (n[0].morphTargets) { const e = {}; let t; for (t = 0; t < n.length; t++)if (n[t].morphTargets) for (let i = 0; i < n[t].morphTargets.length; i++)e[n[t].morphTargets[i]] = -1; for (const i in e) { const e = [], a = []; for (let r = 0; r !== n[t].morphTargets.length; ++r) { const r = n[t]; e.push(r.time), a.push(r.morphTarget === i ? 1 : 0) } r.push(new NumberKeyframeTrack(".morphTargetInfluence[" + i + "]", e, a)) } s = e.length * (a || 1) } else { const a = ".bones[" + t[e].name + "]"; i(VectorKeyframeTrack, a + ".position", n, "pos", r), i(QuaternionKeyframeTrack, a + ".quaternion", n, "rot", r), i(VectorKeyframeTrack, a + ".scale", n, "scl", r) } } if (0 === r.length) return null; return new this(n, s, r, o) } resetDuration() { let e = 0; for (let t = 0, i = this.tracks.length; t !== i; ++t) { const i = this.tracks[t]; e = Math.max(e, i.times[i.times.length - 1]) } return this.duration = e, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let e = !0; for (let t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const e = []; for (let t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new this.constructor(this.name, this.duration, e, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } function getTrackTypeForValueTypeName(e) { switch (e.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return NumberKeyframeTrack; case "vector": case "vector2": case "vector3": case "vector4": return VectorKeyframeTrack; case "color": return ColorKeyframeTrack; case "quaternion": return QuaternionKeyframeTrack; case "bool": case "boolean": return BooleanKeyframeTrack; case "string": return StringKeyframeTrack }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e) } function parseKeyframeTrack(e) { if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const t = getTrackTypeForValueTypeName(e.type); if (void 0 === e.times) { const t = [], i = []; AnimationUtils.flattenJSON(e.keys, t, i, "value"), e.times = t, e.values = i } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) } const Cache = { enabled: !1, files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }, ImageBitMapCache = new Map; function LoadingManager(e, t, i) { const r = this; let n, a = !1, o = 0, s = 0; const l = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (e) { s++, !1 === a && void 0 !== r.onStart && r.onStart(e, o, s), a = !0 }, this.itemEnd = function (e) { o++, void 0 !== r.onProgress && r.onProgress(e, o, s), o === s && (a = !1, void 0 !== r.onLoad && r.onLoad()) }, this.itemError = function (e) { void 0 !== r.onError && r.onError(e) }, this.resolveURL = function (e) { return n ? n(e) : e }, this.setURLModifier = function (e) { return n = e, this }, this.addHandler = function (e, t) { return l.push(e, t), this }, this.removeHandler = function (e) { const t = l.indexOf(e); return -1 !== t && l.splice(t, 2), this }, this.getHandler = function (e) { for (let t = 0, i = l.length; t < i; t += 2) { const i = l[t], r = l[t + 1]; if (i.global && (i.lastIndex = 0), i.test(e)) return r } return null } } const DefaultLoadingManager = new LoadingManager; function Loader(e) { this.manager = void 0 !== e ? e : DefaultLoadingManager, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } Object.assign(Loader.prototype, { load: function () { }, loadAsync: function (e, t) { const i = this; return new Promise((function (r, n) { i.load(e, r, t, n) })) }, parse: function () { }, setCrossOrigin: function (e) { return this.crossOrigin = e, this }, setWithCredentials: function (e) { return this.withCredentials = e, this }, setPath: function (e) { return this.path = e, this }, setResourcePath: function (e) { return this.resourcePath = e, this }, setRequestHeader: function (e) { return this.requestHeader = e, this } }); const loading = {}; function FileLoader(e) { Loader.call(this, e) } FileLoader.prototype = Object.assign(Object.create(Loader.prototype), { constructor: FileLoader, load: function (e, t, i, r) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const n = this, a = Cache.get(e); if (void 0 !== a) return n.manager.itemStart(e), setTimeout((function () { t && t(a), n.manager.itemEnd(e) }), 0), a; if (void 0 !== loading[e]) return void loading[e].push({ onLoad: t, onProgress: i, onError: r }); const o = e.match(/^data:(.*?)(;base64)?,(.*)$/); let s; if (o) { const i = o[1], a = !!o[2]; let s = o[3]; s = decodeURIComponent(s), a && (s = atob(s)); try { let r; const a = (this.responseType || "").toLowerCase(); switch (a) { case "arraybuffer": case "blob": const e = new Uint8Array(s.length); for (let t = 0; t < s.length; t++)e[t] = s.charCodeAt(t); r = "blob" === a ? new Blob([e.buffer], { type: i }) : e.buffer; break; case "document": const t = new DOMParser; r = t.parseFromString(s, i); break; case "json": r = JSON.parse(s); break; default: r = s }setTimeout((function () { t && t(r), n.manager.itemEnd(e) }), 0) } catch (t) { setTimeout((function () { r && r(t), n.manager.itemError(e), n.manager.itemEnd(e) }), 0) } } else { loading[e] = [], loading[e].push({ onLoad: t, onProgress: i, onError: r }), s = new XMLHttpRequest, s.open("GET", e, !0), s.addEventListener("load", (function (t) { const i = this.response, r = loading[e]; if (delete loading[e], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Cache.add(e, i); for (let e = 0, t = r.length; e < t; e++) { const t = r[e]; t.onLoad && t.onLoad(i) } n.manager.itemEnd(e) } else { for (let e = 0, i = r.length; e < i; e++) { const i = r[e]; i.onError && i.onError(t) } n.manager.itemError(e), n.manager.itemEnd(e) } }), !1), s.addEventListener("progress", (function (t) { const i = loading[e]; for (let e = 0, r = i.length; e < r; e++) { const r = i[e]; r.onProgress && r.onProgress(t) } }), !1), s.addEventListener("error", (function (t) { const i = loading[e]; delete loading[e]; for (let e = 0, r = i.length; e < r; e++) { const r = i[e]; r.onError && r.onError(t) } n.manager.itemError(e), n.manager.itemEnd(e) }), !1), s.addEventListener("abort", (function (t) { const i = loading[e]; delete loading[e]; for (let e = 0, r = i.length; e < r; e++) { const r = i[e]; r.onError && r.onError(t) } n.manager.itemError(e), n.manager.itemEnd(e) }), !1), void 0 !== this.responseType && (s.responseType = this.responseType), void 0 !== this.withCredentials && (s.withCredentials = this.withCredentials), s.overrideMimeType && s.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (const e in this.requestHeader) s.setRequestHeader(e, this.requestHeader[e]); s.send(null) } return n.manager.itemStart(e), s }, setResponseType: function (e) { return this.responseType = e, this }, setMimeType: function (e) { return this.mimeType = e, this } }); class AnimationLoader extends Loader { constructor(e) { super(e) } load(e, t, i, r) { const n = this, a = new FileLoader(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function (i) { try { t(n.parse(JSON.parse(i))) } catch (t) { r ? r(t) : console.error(t), n.manager.itemError(e) } }), i, r) } parse(e) { const t = []; for (let i = 0; i < e.length; i++) { const r = AnimationClip.parse(e[i]); t.push(r) } return t } } function CompressedTextureLoader(e) { Loader.call(this, e) } CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), { constructor: CompressedTextureLoader, load: function (e, t, i, r) { const n = this, a = [], o = new CompressedTexture, s = new FileLoader(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(n.withCredentials); let l = 0; function c(c) { s.load(e[c], (function (e) { const i = n.parse(e, !0); a[c] = { width: i.width, height: i.height, format: i.format, mipmaps: i.mipmaps }, l += 1, 6 === l && (1 === i.mipmapCount && (o.minFilter = LinearFilter), o.image = a, o.format = i.format, o.needsUpdate = !0, t && t(o)) }), i, r) } if (Array.isArray(e)) for (let t = 0, i = e.length; t < i; ++t)c(t); else s.load(e, (function (e) { const i = n.parse(e, !0); if (i.isCubemap) { const e = i.mipmaps.length / i.mipmapCount; for (let t = 0; t < e; t++) { a[t] = { mipmaps: [] }; for (let e = 0; e < i.mipmapCount; e++)a[t].mipmaps.push(i.mipmaps[t * i.mipmapCount + e]), a[t].format = i.format, a[t].width = i.width, a[t].height = i.height } o.image = a } else o.image.width = i.width, o.image.height = i.height, o.mipmaps = i.mipmaps; 1 === i.mipmapCount && (o.minFilter = LinearFilter), o.format = i.format, o.needsUpdate = !0, t && t(o) }), i, r); return o } }); class ImageLoader$2 extends Loader { constructor(e) { super(e) } load(e, t, i, r) { void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const n = this, a = Cache.get(e); if (void 0 !== a) return n.manager.itemStart(e), setTimeout((function () { t && t(a), n.manager.itemEnd(e) }), 0), a; const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function s() { o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), Cache.add(e, this), t && t(this), n.manager.itemEnd(e) } function l(t) { o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), r && r(t), n.manager.itemError(e), n.manager.itemEnd(e) } return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), n.manager.itemStart(e), o.src = e, o } } class CubeTextureLoader extends Loader { constructor(e) { super(e) } load(e, t, i, r) { const n = new CubeTexture, a = new ImageLoader$2(this.manager); a.setCrossOrigin(this.crossOrigin), a.setPath(this.path); let o = 0; function s(i) { a.load(e[i], (function (e) { n.images[i] = e, o++, 6 === o && (n.needsUpdate = !0, t && t(n)) }), void 0, r) } for (let t = 0; t < e.length; ++t)s(t); return n } } function DataTextureLoader(e) { Loader.call(this, e) } function TextureLoader(e) { Loader.call(this, e) } function Curve() { this.type = "Curve", this.arcLengthDivisions = 200 } DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), { constructor: DataTextureLoader, load: function (e, t, i, r) { const n = this, a = new DataTexture, o = new FileLoader(this.manager); return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(n.withCredentials), o.load(e, (function (e) { const i = n.parse(e); i && (void 0 !== i.image ? a.image = i.image : void 0 !== i.data && (a.image.width = i.width, a.image.height = i.height, a.image.data = i.data), a.wrapS = void 0 !== i.wrapS ? i.wrapS : ClampToEdgeWrapping, a.wrapT = void 0 !== i.wrapT ? i.wrapT : ClampToEdgeWrapping, a.magFilter = void 0 !== i.magFilter ? i.magFilter : LinearFilter, a.minFilter = void 0 !== i.minFilter ? i.minFilter : LinearFilter, a.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.encoding && (a.encoding = i.encoding), void 0 !== i.flipY && (a.flipY = i.flipY), void 0 !== i.format && (a.format = i.format), void 0 !== i.type && (a.type = i.type), void 0 !== i.mipmaps && (a.mipmaps = i.mipmaps, a.minFilter = LinearMipmapLinearFilter), 1 === i.mipmapCount && (a.minFilter = LinearFilter), a.needsUpdate = !0, t && t(a, i)) }), i, r), a } }), TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), { constructor: TextureLoader, load: function (e, t, i, r) { const n = new Texture$1, a = new ImageLoader$2(this.manager); return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, (function (i) { n.image = i; const r = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/); n.format = r ? RGBFormat : RGBAFormat, n.needsUpdate = !0, void 0 !== t && t(n) }), i, r), n } }), Object.assign(Curve.prototype, { getPoint: function () { return console.warn("THREE.Curve: .getPoint() not implemented."), null }, getPointAt: function (e, t) { const i = this.getUtoTmapping(e); return this.getPoint(i, t) }, getPoints: function (e = 5) { const t = []; for (let i = 0; i <= e; i++)t.push(this.getPoint(i / e)); return t }, getSpacedPoints: function (e = 5) { const t = []; for (let i = 0; i <= e; i++)t.push(this.getPointAt(i / e)); return t }, getLength: function () { const e = this.getLengths(); return e[e.length - 1] }, getLengths: function (e) { if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const t = []; let i, r = this.getPoint(0), n = 0; t.push(0); for (let a = 1; a <= e; a++)i = this.getPoint(a / e), n += i.distanceTo(r), t.push(n), r = i; return this.cacheArcLengths = t, t }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function (e, t) { const i = this.getLengths(); let r = 0; const n = i.length; let a; a = t || e * i[n - 1]; let o, s = 0, l = n - 1; for (; s <= l;)if (r = Math.floor(s + (l - s) / 2), o = i[r] - a, o < 0) s = r + 1; else { if (!(o > 0)) { l = r; break } l = r - 1 } if (r = l, i[r] === a) return r / (n - 1); const c = i[r]; return (r + (a - c) / (i[r + 1] - c)) / (n - 1) }, getTangent: function (e, t) { const i = 1e-4; let r = e - i, n = e + i; r < 0 && (r = 0), n > 1 && (n = 1); const a = this.getPoint(r), o = this.getPoint(n), s = t || (a.isVector2 ? new Vector2 : new Vector3); return s.copy(o).sub(a).normalize(), s }, getTangentAt: function (e, t) { const i = this.getUtoTmapping(e); return this.getTangent(i, t) }, computeFrenetFrames: function (e, t) { const i = new Vector3, r = [], n = [], a = [], o = new Vector3, s = new Matrix4; for (let t = 0; t <= e; t++) { const i = t / e; r[t] = this.getTangentAt(i, new Vector3), r[t].normalize() } n[0] = new Vector3, a[0] = new Vector3; let l = Number.MAX_VALUE; const c = Math.abs(r[0].x), h = Math.abs(r[0].y), u = Math.abs(r[0].z); c <= l && (l = c, i.set(1, 0, 0)), h <= l && (l = h, i.set(0, 1, 0)), u <= l && i.set(0, 0, 1), o.crossVectors(r[0], i).normalize(), n[0].crossVectors(r[0], o), a[0].crossVectors(r[0], n[0]); for (let t = 1; t <= e; t++) { if (n[t] = n[t - 1].clone(), a[t] = a[t - 1].clone(), o.crossVectors(r[t - 1], r[t]), o.length() > Number.EPSILON) { o.normalize(); const e = Math.acos(MathUtils.clamp(r[t - 1].dot(r[t]), -1, 1)); n[t].applyMatrix4(s.makeRotationAxis(o, e)) } a[t].crossVectors(r[t], n[t]) } if (!0 === t) { let t = Math.acos(MathUtils.clamp(n[0].dot(n[e]), -1, 1)); t /= e, r[0].dot(o.crossVectors(n[0], n[e])) > 0 && (t = -t); for (let i = 1; i <= e; i++)n[i].applyMatrix4(s.makeRotationAxis(r[i], t * i)), a[i].crossVectors(r[i], n[i]) } return { tangents: r, normals: n, binormals: a } }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.arcLengthDivisions = e.arcLengthDivisions, this }, toJSON: function () { const e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e }, fromJSON: function (e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } }); class EllipseCurve extends Curve { constructor(e = 0, t = 0, i = 1, r = 1, n = 0, a = 2 * Math.PI, o = !1, s = 0) { super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = n, this.aEndAngle = a, this.aClockwise = o, this.aRotation = s } getPoint(e, t) { const i = t || new Vector2, r = 2 * Math.PI; let n = this.aEndAngle - this.aStartAngle; const a = Math.abs(n) < Number.EPSILON; for (; n < 0;)n += r; for (; n > r;)n -= r; n < Number.EPSILON && (n = a ? 0 : r), !0 !== this.aClockwise || a || (n === r ? n = -r : n -= r); const o = this.aStartAngle + e * n; let s = this.aX + this.xRadius * Math.cos(o), l = this.aY + this.yRadius * Math.sin(o); if (0 !== this.aRotation) { const e = Math.cos(this.aRotation), t = Math.sin(this.aRotation), i = s - this.aX, r = l - this.aY; s = i * e - r * t + this.aX, l = i * t + r * e + this.aY } return i.set(s, l) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } EllipseCurve.prototype.isEllipseCurve = !0; class ArcCurve extends EllipseCurve { constructor(e, t, i, r, n, a) { super(e, t, i, i, r, n, a), this.type = "ArcCurve" } } function CubicPoly() { let e = 0, t = 0, i = 0, r = 0; function n(n, a, o, s) { e = n, t = o, i = -3 * n + 3 * a - 2 * o - s, r = 2 * n - 2 * a + o + s } return { initCatmullRom: function (e, t, i, r, a) { n(t, i, a * (i - e), a * (r - t)) }, initNonuniformCatmullRom: function (e, t, i, r, a, o, s) { let l = (t - e) / a - (i - e) / (a + o) + (i - t) / o, c = (i - t) / o - (r - t) / (o + s) + (r - i) / s; l *= o, c *= o, n(t, i, l, c) }, calc: function (n) { const a = n * n; return e + t * n + i * a + r * (a * n) } } } ArcCurve.prototype.isArcCurve = !0; const tmp = new Vector3, px = new CubicPoly, py = new CubicPoly, pz = new CubicPoly; class CatmullRomCurve3 extends Curve { constructor(e = [], t = !1, i = "centripetal", r = .5) { super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r } getPoint(e, t = new Vector3) { const i = t, r = this.points, n = r.length, a = (n - (this.closed ? 0 : 1)) * e; let o, s, l = Math.floor(a), c = a - l; this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / n) + 1) * n : 0 === c && l === n - 1 && (l = n - 2, c = 1), this.closed || l > 0 ? o = r[(l - 1) % n] : (tmp.subVectors(r[0], r[1]).add(r[0]), o = tmp); const h = r[l % n], u = r[(l + 1) % n]; if (this.closed || l + 2 < n ? s = r[(l + 2) % n] : (tmp.subVectors(r[n - 1], r[n - 2]).add(r[n - 1]), s = tmp), "centripetal" === this.curveType || "chordal" === this.curveType) { const e = "chordal" === this.curveType ? .5 : .25; let t = Math.pow(o.distanceToSquared(h), e), i = Math.pow(h.distanceToSquared(u), e), r = Math.pow(u.distanceToSquared(s), e); i < 1e-4 && (i = 1), t < 1e-4 && (t = i), r < 1e-4 && (r = i), px.initNonuniformCatmullRom(o.x, h.x, u.x, s.x, t, i, r), py.initNonuniformCatmullRom(o.y, h.y, u.y, s.y, t, i, r), pz.initNonuniformCatmullRom(o.z, h.z, u.z, s.z, t, i, r) } else "catmullrom" === this.curveType && (px.initCatmullRom(o.x, h.x, u.x, s.x, this.tension), py.initCatmullRom(o.y, h.y, u.y, s.y, this.tension), pz.initCatmullRom(o.z, h.z, u.z, s.z, this.tension)); return i.set(px.calc(c), py.calc(c), pz.calc(c)), i } copy(e) { super.copy(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { const i = e.points[t]; this.points.push(i.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, i = this.points.length; t < i; t++) { const i = this.points[t]; e.points.push(i.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { const i = e.points[t]; this.points.push((new Vector3).fromArray(i)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this } } function CatmullRom(e, t, i, r, n) { const a = .5 * (r - t), o = .5 * (n - i), s = e * e; return (2 * i - 2 * r + a + o) * (e * s) + (-3 * i + 3 * r - 2 * a - o) * s + a * e + i } function QuadraticBezierP0(e, t) { const i = 1 - e; return i * i * t } function QuadraticBezierP1(e, t) { return 2 * (1 - e) * e * t } function QuadraticBezierP2(e, t) { return e * e * t } function QuadraticBezier(e, t, i, r) { return QuadraticBezierP0(e, t) + QuadraticBezierP1(e, i) + QuadraticBezierP2(e, r) } function CubicBezierP0(e, t) { const i = 1 - e; return i * i * i * t } function CubicBezierP1(e, t) { const i = 1 - e; return 3 * i * i * e * t } function CubicBezierP2(e, t) { return 3 * (1 - e) * e * e * t } function CubicBezierP3(e, t) { return e * e * e * t } function CubicBezier(e, t, i, r, n) { return CubicBezierP0(e, t) + CubicBezierP1(e, i) + CubicBezierP2(e, r) + CubicBezierP3(e, n) } CatmullRomCurve3.prototype.isCatmullRomCurve3 = !0; class CubicBezierCurve extends Curve { constructor(e = new Vector2, t = new Vector2, i = new Vector2, r = new Vector2) { super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r } getPoint(e, t = new Vector2) { const i = t, r = this.v0, n = this.v1, a = this.v2, o = this.v3; return i.set(CubicBezier(e, r.x, n.x, a.x, o.x), CubicBezier(e, r.y, n.y, a.y, o.y)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } CubicBezierCurve.prototype.isCubicBezierCurve = !0; class CubicBezierCurve3 extends Curve { constructor(e = new Vector3, t = new Vector3, i = new Vector3, r = new Vector3) { super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r } getPoint(e, t = new Vector3) { const i = t, r = this.v0, n = this.v1, a = this.v2, o = this.v3; return i.set(CubicBezier(e, r.x, n.x, a.x, o.x), CubicBezier(e, r.y, n.y, a.y, o.y), CubicBezier(e, r.z, n.z, a.z, o.z)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } CubicBezierCurve3.prototype.isCubicBezierCurve3 = !0; class LineCurve extends Curve { constructor(e = new Vector2, t = new Vector2) { super(), this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new Vector2) { const i = t; return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t) { const i = t || new Vector2; return i.copy(this.v2).sub(this.v1).normalize(), i } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } LineCurve.prototype.isLineCurve = !0; class LineCurve3 extends Curve { constructor(e = new Vector3, t = new Vector3) { super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t } getPoint(e, t = new Vector3) { const i = t; return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i } getPointAt(e, t) { return this.getPoint(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class QuadraticBezierCurve extends Curve { constructor(e = new Vector2, t = new Vector2, i = new Vector2) { super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i } getPoint(e, t = new Vector2) { const i = t, r = this.v0, n = this.v1, a = this.v2; return i.set(QuadraticBezier(e, r.x, n.x, a.x), QuadraticBezier(e, r.y, n.y, a.y)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } QuadraticBezierCurve.prototype.isQuadraticBezierCurve = !0; class QuadraticBezierCurve3 extends Curve { constructor(e = new Vector3, t = new Vector3, i = new Vector3) { super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i } getPoint(e, t = new Vector3) { const i = t, r = this.v0, n = this.v1, a = this.v2; return i.set(QuadraticBezier(e, r.x, n.x, a.x), QuadraticBezier(e, r.y, n.y, a.y), QuadraticBezier(e, r.z, n.z, a.z)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = !0; class SplineCurve extends Curve { constructor(e = []) { super(), this.type = "SplineCurve", this.points = e } getPoint(e, t = new Vector2) { const i = t, r = this.points, n = (r.length - 1) * e, a = Math.floor(n), o = n - a, s = r[0 === a ? a : a - 1], l = r[a], c = r[a > r.length - 2 ? r.length - 1 : a + 1], h = r[a > r.length - 3 ? r.length - 1 : a + 2]; return i.set(CatmullRom(o, s.x, l.x, c.x, h.x), CatmullRom(o, s.y, l.y, c.y, h.y)), i } copy(e) { super.copy(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { const i = e.points[t]; this.points.push(i.clone()) } return this } toJSON() { const e = super.toJSON(); e.points = []; for (let t = 0, i = this.points.length; t < i; t++) { const i = this.points[t]; e.points.push(i.toArray()) } return e } fromJSON(e) { super.fromJSON(e), this.points = []; for (let t = 0, i = e.points.length; t < i; t++) { const i = e.points[t]; this.points.push((new Vector2).fromArray(i)) } return this } } SplineCurve.prototype.isSplineCurve = !0; var Curves = Object.freeze({ __proto__: null, ArcCurve: ArcCurve, CatmullRomCurve3: CatmullRomCurve3, CubicBezierCurve: CubicBezierCurve, CubicBezierCurve3: CubicBezierCurve3, EllipseCurve: EllipseCurve, LineCurve: LineCurve, LineCurve3: LineCurve3, QuadraticBezierCurve: QuadraticBezierCurve, QuadraticBezierCurve3: QuadraticBezierCurve3, SplineCurve: SplineCurve }); class CurvePath extends Curve { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new LineCurve(t, e)) } getPoint(e) { const t = e * this.getLength(), i = this.getCurveLengths(); let r = 0; for (; r < i.length;) { if (i[r] >= t) { const e = i[r] - t, n = this.curves[r], a = n.getLength(), o = 0 === a ? 0 : 1 - e / a; return n.getPointAt(o) } r++ } return null } getLength() { const e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const e = []; let t = 0; for (let i = 0, r = this.curves.length; i < r; i++)t += this.curves[i].getLength(), e.push(t); return this.cacheLengths = e, e } getSpacedPoints(e = 40) { const t = []; for (let i = 0; i <= e; i++)t.push(this.getPoint(i / e)); return this.autoClose && t.push(t[0]), t } getPoints(e = 12) { const t = []; let i; for (let r = 0, n = this.curves; r < n.length; r++) { const a = n[r], o = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e, s = a.getPoints(o); for (let e = 0; e < s.length; e++) { const r = s[e]; i && i.equals(r) || (t.push(r), i = r) } } return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t } copy(e) { super.copy(e), this.curves = []; for (let t = 0, i = e.curves.length; t < i; t++) { const i = e.curves[t]; this.curves.push(i.clone()) } return this.autoClose = e.autoClose, this } toJSON() { const e = super.toJSON(); e.autoClose = this.autoClose, e.curves = []; for (let t = 0, i = this.curves.length; t < i; t++) { const i = this.curves[t]; e.curves.push(i.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.autoClose = e.autoClose, this.curves = []; for (let t = 0, i = e.curves.length; t < i; t++) { const i = e.curves[t]; this.curves.push((new Curves[i.type]).fromJSON(i)) } return this } } class Path$1 extends CurvePath { constructor(e) { super(), this.type = "Path", this.currentPoint = new Vector2, e && this.setFromPoints(e) } setFromPoints(e) { this.moveTo(e[0].x, e[0].y); for (let t = 1, i = e.length; t < i; t++)this.lineTo(e[t].x, e[t].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { const i = new LineCurve(this.currentPoint.clone(), new Vector2(e, t)); return this.curves.push(i), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, i, r) { const n = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(e, t), new Vector2(i, r)); return this.curves.push(n), this.currentPoint.set(i, r), this } bezierCurveTo(e, t, i, r, n, a) { const o = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(e, t), new Vector2(i, r), new Vector2(n, a)); return this.curves.push(o), this.currentPoint.set(n, a), this } splineThru(e) { const t = [this.currentPoint.clone()].concat(e), i = new SplineCurve(t); return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, i, r, n, a) { const o = this.currentPoint.x, s = this.currentPoint.y; return this.absarc(e + o, t + s, i, r, n, a), this } absarc(e, t, i, r, n, a) { return this.absellipse(e, t, i, i, r, n, a), this } ellipse(e, t, i, r, n, a, o, s) { const l = this.currentPoint.x, c = this.currentPoint.y; return this.absellipse(e + l, t + c, i, r, n, a, o, s), this } absellipse(e, t, i, r, n, a, o, s) { const l = new EllipseCurve(e, t, i, r, n, a, o, s); if (this.curves.length > 0) { const e = l.getPoint(0); e.equals(this.currentPoint) || this.lineTo(e.x, e.y) } this.curves.push(l); const c = l.getPoint(1); return this.currentPoint.copy(c), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class Shape extends Path$1 { constructor(e) { super(e), this.uuid = MathUtils.generateUUID(), this.type = "Shape", this.holes = [] } getPointsHoles(e) { const t = []; for (let i = 0, r = this.holes.length; i < r; i++)t[i] = this.holes[i].getPoints(e); return t } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(e) { super.copy(e), this.holes = []; for (let t = 0, i = e.holes.length; t < i; t++) { const i = e.holes[t]; this.holes.push(i.clone()) } return this } toJSON() { const e = super.toJSON(); e.uuid = this.uuid, e.holes = []; for (let t = 0, i = this.holes.length; t < i; t++) { const i = this.holes[t]; e.holes.push(i.toJSON()) } return e } fromJSON(e) { super.fromJSON(e), this.uuid = e.uuid, this.holes = []; for (let t = 0, i = e.holes.length; t < i; t++) { const i = e.holes[t]; this.holes.push((new Path$1).fromJSON(i)) } return this } } class Light extends Object3D { constructor(e, t = 1) { super(), this.type = "Light", this.color = new Color$1(e), this.intensity = t } copy(e) { return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } } Light.prototype.isLight = !0; class HemisphereLight extends Light { constructor(e, t, i) { super(e, i), this.type = "HemisphereLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.groundColor = new Color$1(t) } copy(e) { return Light.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this } } HemisphereLight.prototype.isHemisphereLight = !0; const _projScreenMatrix = new Matrix4, _lightPositionWorld = new Vector3, _lookTarget = new Vector3; class LightShadow { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Frustum, this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [new Vector4(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, i = this.matrix; _lightPositionWorld.setFromMatrixPosition(e.matrixWorld), t.position.copy(_lightPositionWorld), _lookTarget.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(_lookTarget), t.updateMatrixWorld(), _projScreenMatrix.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(t.projectionMatrix), i.multiply(t.matrixWorldInverse) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = {}; return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class SpotLightShadow extends LightShadow { constructor() { super(new PerspectiveCamera(50, 1, .5, 500)), this.focus = 1 } updateMatrices(e) { const t = this.camera, i = 2 * MathUtils.RAD2DEG * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, n = e.distance || t.far; i === t.fov && r === t.aspect && n === t.far || (t.fov = i, t.aspect = r, t.far = n, t.updateProjectionMatrix()), super.updateMatrices(e) } } SpotLightShadow.prototype.isSpotLightShadow = !0; class SpotLight extends Light { constructor(e, t, i = 0, r = Math.PI / 3, n = 0, a = 1) { super(e, t), this.type = "SpotLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D, this.distance = i, this.angle = r, this.penumbra = n, this.decay = a, this.shadow = new SpotLightShadow } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } copy(e) { return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } SpotLight.prototype.isSpotLight = !0; const _projScreenMatrix$1 = new Matrix4, _lightPositionWorld$1 = new Vector3, _lookTarget$1 = new Vector3; class PointLightShadow extends LightShadow { constructor() { super(new PerspectiveCamera(90, 1, .5, 500)), this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)], this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)], this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)] } updateMatrices(e, t = 0) { const i = this.camera, r = this.matrix; _lightPositionWorld$1.setFromMatrixPosition(e.matrixWorld), i.position.copy(_lightPositionWorld$1), _lookTarget$1.copy(i.position), _lookTarget$1.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(_lookTarget$1), i.updateMatrixWorld(), r.makeTranslation(-_lightPositionWorld$1.x, -_lightPositionWorld$1.y, -_lightPositionWorld$1.z), _projScreenMatrix$1.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix$1) } } PointLightShadow.prototype.isPointLightShadow = !0; class PointLight extends Light { constructor(e, t, i = 0, r = 1) { super(e, t), this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new PointLightShadow } get power() { return 4 * this.intensity * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } copy(e) { return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } PointLight.prototype.isPointLight = !0; class OrthographicCamera extends Camera$1$1 { constructor(e = -1, t = 1, i = 1, r = -1, n = .1, a = 2e3) { super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = n, this.far = a, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this } setViewOffset(e, t, i, r, n, a) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = n, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2; let n = i - e, a = i + e, o = r + t, s = r - t; if (null !== this.view && this.view.enabled) { const e = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom; n += e * this.view.offsetX, a = n + e * this.view.width, o -= t * this.view.offsetY, s = o - t * this.view.height } this.projectionMatrix.makeOrthographic(n, a, o, s, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = Object3D.prototype.toJSON.call(this, e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } } OrthographicCamera.prototype.isOrthographicCamera = !0; class DirectionalLightShadow extends LightShadow { constructor() { super(new OrthographicCamera(-5, 5, 5, -5, .5, 500)) } } DirectionalLightShadow.prototype.isDirectionalLightShadow = !0; class DirectionalLight extends Light { constructor(e, t) { super(e, t), this.type = "DirectionalLight", this.position.copy(Object3D.DefaultUp), this.updateMatrix(), this.target = new Object3D, this.shadow = new DirectionalLightShadow } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } DirectionalLight.prototype.isDirectionalLight = !0; class AmbientLight extends Light { constructor(e, t) { super(e, t), this.type = "AmbientLight" } } AmbientLight.prototype.isAmbientLight = !0; class RectAreaLight extends Light { constructor(e, t, i = 10, r = 10) { super(e, t), this.type = "RectAreaLight", this.width = i, this.height = r } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } RectAreaLight.prototype.isRectAreaLight = !0; class SphericalHarmonics3 { constructor() { this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new Vector3) } set(e) { for (let t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { const i = e.x, r = e.y, n = e.z, a = this.coefficients; return t.copy(a[0]).multiplyScalar(.282095), t.addScaledVector(a[1], .488603 * r), t.addScaledVector(a[2], .488603 * n), t.addScaledVector(a[3], .488603 * i), t.addScaledVector(a[4], i * r * 1.092548), t.addScaledVector(a[5], r * n * 1.092548), t.addScaledVector(a[6], .315392 * (3 * n * n - 1)), t.addScaledVector(a[7], i * n * 1.092548), t.addScaledVector(a[8], .546274 * (i * i - r * r)), t } getIrradianceAt(e, t) { const i = e.x, r = e.y, n = e.z, a = this.coefficients; return t.copy(a[0]).multiplyScalar(.886227), t.addScaledVector(a[1], 1.023328 * r), t.addScaledVector(a[2], 1.023328 * n), t.addScaledVector(a[3], 1.023328 * i), t.addScaledVector(a[4], .858086 * i * r), t.addScaledVector(a[5], .858086 * r * n), t.addScaledVector(a[6], .743125 * n * n - .247708), t.addScaledVector(a[7], .858086 * i * n), t.addScaledVector(a[8], .429043 * (i * i - r * r)), t } add(e) { for (let t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this } addScaledSH(e, t) { for (let i = 0; i < 9; i++)this.coefficients[i].addScaledVector(e.coefficients[i], t); return this } scale(e) { for (let t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this } lerp(e, t) { for (let i = 0; i < 9; i++)this.coefficients[i].lerp(e.coefficients[i], t); return this } equals(e) { for (let t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return (new this.constructor).copy(this) } fromArray(e, t = 0) { const i = this.coefficients; for (let r = 0; r < 9; r++)i[r].fromArray(e, t + 3 * r); return this } toArray(e = [], t = 0) { const i = this.coefficients; for (let r = 0; r < 9; r++)i[r].toArray(e, t + 3 * r); return e } static getBasisAt(e, t) { const i = e.x, r = e.y, n = e.z; t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * n, t[3] = .488603 * i, t[4] = 1.092548 * i * r, t[5] = 1.092548 * r * n, t[6] = .315392 * (3 * n * n - 1), t[7] = 1.092548 * i * n, t[8] = .546274 * (i * i - r * r) } } SphericalHarmonics3.prototype.isSphericalHarmonics3 = !0; class LightProbe extends Light { constructor(e = new SphericalHarmonics3, t = 1) { super(void 0, t), this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } LightProbe.prototype.isLightProbe = !0; class MaterialLoader extends Loader { constructor(e) { super(e), this.textures = {} } load(e, t, i, r) { const n = this, a = new FileLoader(n.manager); a.setPath(n.path), a.setRequestHeader(n.requestHeader), a.setWithCredentials(n.withCredentials), a.load(e, (function (i) { try { t(n.parse(JSON.parse(i))) } catch (t) { r ? r(t) : console.error(t), n.manager.itemError(e) } }), i, r) } parse(e) { const t = this.textures; function i(e) { return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e] } const r = new Materials[e.type]; if (void 0 !== e.uuid && (r.uuid = e.uuid), void 0 !== e.name && (r.name = e.name), void 0 !== e.color && void 0 !== r.color && r.color.setHex(e.color), void 0 !== e.roughness && (r.roughness = e.roughness), void 0 !== e.metalness && (r.metalness = e.metalness), void 0 !== e.sheen && (r.sheen = (new Color$1).setHex(e.sheen)), void 0 !== e.emissive && void 0 !== r.emissive && r.emissive.setHex(e.emissive), void 0 !== e.specular && void 0 !== r.specular && r.specular.setHex(e.specular), void 0 !== e.shininess && (r.shininess = e.shininess), void 0 !== e.clearcoat && (r.clearcoat = e.clearcoat), void 0 !== e.clearcoatRoughness && (r.clearcoatRoughness = e.clearcoatRoughness), void 0 !== e.fog && (r.fog = e.fog), void 0 !== e.flatShading && (r.flatShading = e.flatShading), void 0 !== e.blending && (r.blending = e.blending), void 0 !== e.combine && (r.combine = e.combine), void 0 !== e.side && (r.side = e.side), void 0 !== e.opacity && (r.opacity = e.opacity), void 0 !== e.transparent && (r.transparent = e.transparent), void 0 !== e.alphaTest && (r.alphaTest = e.alphaTest), void 0 !== e.depthTest && (r.depthTest = e.depthTest), void 0 !== e.depthWrite && (r.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (r.colorWrite = e.colorWrite), void 0 !== e.stencilWrite && (r.stencilWrite = e.stencilWrite), void 0 !== e.stencilWriteMask && (r.stencilWriteMask = e.stencilWriteMask), void 0 !== e.stencilFunc && (r.stencilFunc = e.stencilFunc), void 0 !== e.stencilRef && (r.stencilRef = e.stencilRef), void 0 !== e.stencilFuncMask && (r.stencilFuncMask = e.stencilFuncMask), void 0 !== e.stencilFail && (r.stencilFail = e.stencilFail), void 0 !== e.stencilZFail && (r.stencilZFail = e.stencilZFail), void 0 !== e.stencilZPass && (r.stencilZPass = e.stencilZPass), void 0 !== e.wireframe && (r.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (r.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (r.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (r.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (r.rotation = e.rotation), 1 !== e.linewidth && (r.linewidth = e.linewidth), void 0 !== e.dashSize && (r.dashSize = e.dashSize), void 0 !== e.gapSize && (r.gapSize = e.gapSize), void 0 !== e.scale && (r.scale = e.scale), void 0 !== e.polygonOffset && (r.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (r.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (r.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (r.skinning = e.skinning), void 0 !== e.morphTargets && (r.morphTargets = e.morphTargets), void 0 !== e.morphNormals && (r.morphNormals = e.morphNormals), void 0 !== e.dithering && (r.dithering = e.dithering), void 0 !== e.vertexTangents && (r.vertexTangents = e.vertexTangents), void 0 !== e.visible && (r.visible = e.visible), void 0 !== e.toneMapped && (r.toneMapped = e.toneMapped), void 0 !== e.userData && (r.userData = e.userData), void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), void 0 !== e.uniforms) for (const t in e.uniforms) { const n = e.uniforms[t]; switch (r.uniforms[t] = {}, n.type) { case "t": r.uniforms[t].value = i(n.value); break; case "c": r.uniforms[t].value = (new Color$1).setHex(n.value); break; case "v2": r.uniforms[t].value = (new Vector2).fromArray(n.value); break; case "v3": r.uniforms[t].value = (new Vector3).fromArray(n.value); break; case "v4": r.uniforms[t].value = (new Vector4).fromArray(n.value); break; case "m3": r.uniforms[t].value = (new Matrix3).fromArray(n.value); break; case "m4": r.uniforms[t].value = (new Matrix4).fromArray(n.value); break; default: r.uniforms[t].value = n.value } } if (void 0 !== e.defines && (r.defines = e.defines), void 0 !== e.vertexShader && (r.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (r.fragmentShader = e.fragmentShader), void 0 !== e.extensions) for (const t in e.extensions) r.extensions[t] = e.extensions[t]; if (void 0 !== e.shading && (r.flatShading = 1 === e.shading), void 0 !== e.size && (r.size = e.size), void 0 !== e.sizeAttenuation && (r.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (r.map = i(e.map)), void 0 !== e.matcap && (r.matcap = i(e.matcap)), void 0 !== e.alphaMap && (r.alphaMap = i(e.alphaMap)), void 0 !== e.bumpMap && (r.bumpMap = i(e.bumpMap)), void 0 !== e.bumpScale && (r.bumpScale = e.bumpScale), void 0 !== e.normalMap && (r.normalMap = i(e.normalMap)), void 0 !== e.normalMapType && (r.normalMapType = e.normalMapType), void 0 !== e.normalScale) { let t = e.normalScale; !1 === Array.isArray(t) && (t = [t, t]), r.normalScale = (new Vector2).fromArray(t) } return void 0 !== e.displacementMap && (r.displacementMap = i(e.displacementMap)), void 0 !== e.displacementScale && (r.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (r.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (r.roughnessMap = i(e.roughnessMap)), void 0 !== e.metalnessMap && (r.metalnessMap = i(e.metalnessMap)), void 0 !== e.emissiveMap && (r.emissiveMap = i(e.emissiveMap)), void 0 !== e.emissiveIntensity && (r.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (r.specularMap = i(e.specularMap)), void 0 !== e.envMap && (r.envMap = i(e.envMap)), void 0 !== e.envMapIntensity && (r.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (r.reflectivity = e.reflectivity), void 0 !== e.refractionRatio && (r.refractionRatio = e.refractionRatio), void 0 !== e.lightMap && (r.lightMap = i(e.lightMap)), void 0 !== e.lightMapIntensity && (r.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (r.aoMap = i(e.aoMap)), void 0 !== e.aoMapIntensity && (r.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (r.gradientMap = i(e.gradientMap)), void 0 !== e.clearcoatMap && (r.clearcoatMap = i(e.clearcoatMap)), void 0 !== e.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), void 0 !== e.clearcoatNormalMap && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)), void 0 !== e.clearcoatNormalScale && (r.clearcoatNormalScale = (new Vector2).fromArray(e.clearcoatNormalScale)), void 0 !== e.transmission && (r.transmission = e.transmission), void 0 !== e.transmissionMap && (r.transmissionMap = i(e.transmissionMap)), r } setTextures(e) { return this.textures = e, this } } const LoaderUtils = { decodeText: function (e) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); let t = ""; for (let i = 0, r = e.length; i < r; i++)t += String.fromCharCode(e[i]); try { return decodeURIComponent(escape(t)) } catch (e) { return t } }, extractUrlBase: function (e) { const t = e.lastIndexOf("/"); return -1 === t ? "./" : e.substr(0, t + 1) } }; function InstancedBufferGeometry() { BufferGeometry.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } function InstancedBufferAttribute(e, t, i, r) { "number" == typeof i && (r = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), BufferAttribute.call(this, e, t, i), this.meshPerAttribute = r || 1 } InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), { constructor: InstancedBufferGeometry, isInstancedBufferGeometry: !0, copy: function (e) { return BufferGeometry.prototype.copy.call(this, e), this.instanceCount = e.instanceCount, this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { const e = BufferGeometry.prototype.toJSON.call(this); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } }), InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), { constructor: InstancedBufferAttribute, isInstancedBufferAttribute: !0, copy: function (e) { return BufferAttribute.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this }, toJSON: function () { const e = BufferAttribute.prototype.toJSON.call(this); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } }); class BufferGeometryLoader extends Loader { constructor(e) { super(e) } load(e, t, i, r) { const n = this, a = new FileLoader(n.manager); a.setPath(n.path), a.setRequestHeader(n.requestHeader), a.setWithCredentials(n.withCredentials), a.load(e, (function (i) { try { t(n.parse(JSON.parse(i))) } catch (t) { r ? r(t) : console.error(t), n.manager.itemError(e) } }), i, r) } parse(e) { const t = {}, i = {}; function r(e, r) { if (void 0 !== t[r]) return t[r]; const n = e.interleavedBuffers[r], a = function (e, t) { if (void 0 !== i[t]) return i[t]; const r = e.arrayBuffers[t], n = new Uint32Array(r).buffer; return i[t] = n, n }(e, n.buffer), o = new InterleavedBuffer(getTypedArray(n.type, a), n.stride); return o.uuid = n.uuid, t[r] = o, o } const n = e.isInstancedBufferGeometry ? new InstancedBufferGeometry : new BufferGeometry, a = e.data.index; if (void 0 !== a) { const e = getTypedArray(a.type, a.array); n.setIndex(new BufferAttribute(e, 1)) } const o = e.data.attributes; for (const t in o) { const i = o[t]; let a; if (i.isInterleavedBufferAttribute) { a = new InterleavedBufferAttribute(r(e.data, i.data), i.itemSize, i.offset, i.normalized) } else { const e = getTypedArray(i.type, i.array); a = new (i.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute)(e, i.itemSize, i.normalized) } void 0 !== i.name && (a.name = i.name), n.setAttribute(t, a) } const s = e.data.morphAttributes; if (s) for (const t in s) { const i = s[t], a = []; for (let t = 0, n = i.length; t < n; t++) { const n = i[t]; let o; if (n.isInterleavedBufferAttribute) { o = new InterleavedBufferAttribute(r(e.data, n.data), n.itemSize, n.offset, n.normalized) } else { o = new BufferAttribute(getTypedArray(n.type, n.array), n.itemSize, n.normalized) } void 0 !== n.name && (o.name = n.name), a.push(o) } n.morphAttributes[t] = a } e.data.morphTargetsRelative && (n.morphTargetsRelative = !0); const l = e.data.groups || e.data.drawcalls || e.data.offsets; if (void 0 !== l) for (let e = 0, t = l.length; e !== t; ++e) { const t = l[e]; n.addGroup(t.start, t.count, t.materialIndex) } const c = e.data.boundingSphere; if (void 0 !== c) { const e = new Vector3; void 0 !== c.center && e.fromArray(c.center), n.boundingSphere = new Sphere(e, c.radius) } return e.name && (n.name = e.name), e.userData && (n.userData = e.userData), n } } class ObjectLoader extends Loader { constructor(e) { super(e) } load(e, t, i, r) { const n = this, a = "" === this.path ? LoaderUtils.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || a; const o = new FileLoader(this.manager); o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function (i) { let a = null; try { a = JSON.parse(i) } catch (t) { return void 0 !== r && r(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message) } const o = a.metadata; void 0 !== o && void 0 !== o.type && "geometry" !== o.type.toLowerCase() ? n.parse(a, t) : console.error("THREE.ObjectLoader: Can't load " + e) }), i, r) } parse(e, t) { const i = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), n = this.parseGeometries(e.geometries, r), a = this.parseImages(e.images, (function () { void 0 !== t && t(l) })), o = this.parseTextures(e.textures, a), s = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, n, s, i), c = this.parseSkeletons(e.skeletons, l); if (this.bindSkeletons(l, c), void 0 !== t) { let e = !1; for (const t in a) if (a[t] instanceof HTMLImageElement) { e = !0; break } !1 === e && t(l) } return l } parseShapes(e) { const t = {}; if (void 0 !== e) for (let i = 0, r = e.length; i < r; i++) { const r = (new Shape).fromJSON(e[i]); t[r.uuid] = r } return t } parseSkeletons(e, t) { const i = {}, r = {}; if (t.traverse((function (e) { e.isBone && (r[e.uuid] = e) })), void 0 !== e) for (let t = 0, n = e.length; t < n; t++) { const n = (new Skeleton).fromJSON(e[t], r); i[n.uuid] = n } return i } parseGeometries(e, t) { const i = {}; let r; if (void 0 !== e) { const n = new BufferGeometryLoader; for (let a = 0, o = e.length; a < o; a++) { let o; const s = e[a]; switch (s.type) { case "PlaneGeometry": case "PlaneBufferGeometry": o = new Geometries[s.type](s.width, s.height, s.widthSegments, s.heightSegments); break; case "BoxGeometry": case "BoxBufferGeometry": o = new Geometries[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments); break; case "CircleGeometry": case "CircleBufferGeometry": o = new Geometries[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength); break; case "CylinderGeometry": case "CylinderBufferGeometry": o = new Geometries[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength); break; case "ConeGeometry": case "ConeBufferGeometry": o = new Geometries[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength); break; case "SphereGeometry": case "SphereBufferGeometry": o = new Geometries[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength); break; case "DodecahedronGeometry": case "DodecahedronBufferGeometry": case "IcosahedronGeometry": case "IcosahedronBufferGeometry": case "OctahedronGeometry": case "OctahedronBufferGeometry": case "TetrahedronGeometry": case "TetrahedronBufferGeometry": o = new Geometries[s.type](s.radius, s.detail); break; case "RingGeometry": case "RingBufferGeometry": o = new Geometries[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength); break; case "TorusGeometry": case "TorusBufferGeometry": o = new Geometries[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc); break; case "TorusKnotGeometry": case "TorusKnotBufferGeometry": o = new Geometries[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q); break; case "TubeGeometry": case "TubeBufferGeometry": o = new Geometries[s.type]((new Curves[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed); break; case "LatheGeometry": case "LatheBufferGeometry": o = new Geometries[s.type](s.points, s.segments, s.phiStart, s.phiLength); break; case "PolyhedronGeometry": case "PolyhedronBufferGeometry": o = new Geometries[s.type](s.vertices, s.indices, s.radius, s.details); break; case "ShapeGeometry": case "ShapeBufferGeometry": r = []; for (let e = 0, i = s.shapes.length; e < i; e++) { const i = t[s.shapes[e]]; r.push(i) } o = new Geometries[s.type](r, s.curveSegments); break; case "ExtrudeGeometry": case "ExtrudeBufferGeometry": r = []; for (let e = 0, i = s.shapes.length; e < i; e++) { const i = t[s.shapes[e]]; r.push(i) } const e = s.options.extrudePath; void 0 !== e && (s.options.extrudePath = (new Curves[e.type]).fromJSON(e)), o = new Geometries[s.type](r, s.options); break; case "BufferGeometry": case "InstancedBufferGeometry": o = n.parse(s); break; case "Geometry": console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'); break; default: console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"'); continue }o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), !0 === o.isBufferGeometry && void 0 !== s.userData && (o.userData = s.userData), i[s.uuid] = o } } return i } parseMaterials(e, t) { const i = {}, r = {}; if (void 0 !== e) { const n = new MaterialLoader; n.setTextures(t); for (let t = 0, a = e.length; t < a; t++) { const a = e[t]; if ("MultiMaterial" === a.type) { const e = []; for (let t = 0; t < a.materials.length; t++) { const r = a.materials[t]; void 0 === i[r.uuid] && (i[r.uuid] = n.parse(r)), e.push(i[r.uuid]) } r[a.uuid] = e } else void 0 === i[a.uuid] && (i[a.uuid] = n.parse(a)), r[a.uuid] = i[a.uuid] } } return r } parseAnimations(e) { const t = {}; if (void 0 !== e) for (let i = 0; i < e.length; i++) { const r = e[i], n = AnimationClip.parse(r); t[n.uuid] = n } return t } parseImages(e, t) { const i = this, r = {}; let n; function a(e) { if ("string" == typeof e) { const t = e; return function (e) { return i.manager.itemStart(e), n.load(e, (function () { i.manager.itemEnd(e) }), void 0, (function () { i.manager.itemError(e), i.manager.itemEnd(e) })) }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : i.resourcePath + t) } return e.data ? { data: getTypedArray(e.type, e.data), width: e.width, height: e.height } : null } if (void 0 !== e && e.length > 0) { const i = new LoadingManager(t); n = new ImageLoader$2(i), n.setCrossOrigin(this.crossOrigin); for (let t = 0, i = e.length; t < i; t++) { const i = e[t], n = i.url; if (Array.isArray(n)) { r[i.uuid] = []; for (let e = 0, t = n.length; e < t; e++) { const t = a(n[e]); null !== t && (t instanceof HTMLImageElement ? r[i.uuid].push(t) : r[i.uuid].push(new DataTexture(t.data, t.width, t.height))) } } else { const e = a(i.url); null !== e && (r[i.uuid] = e) } } } return r } parseTextures(e, t) { function i(e, t) { return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]) } const r = {}; if (void 0 !== e) for (let n = 0, a = e.length; n < a; n++) { const a = e[n]; let o; void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === t[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image); const s = t[a.image]; Array.isArray(s) ? (o = new CubeTexture(s), 6 === s.length && (o.needsUpdate = !0)) : (o = s && s.data ? new DataTexture(s.data, s.width, s.height) : new Texture$1(s), s && (o.needsUpdate = !0)), o.uuid = a.uuid, void 0 !== a.name && (o.name = a.name), void 0 !== a.mapping && (o.mapping = i(a.mapping, TEXTURE_MAPPING)), void 0 !== a.offset && o.offset.fromArray(a.offset), void 0 !== a.repeat && o.repeat.fromArray(a.repeat), void 0 !== a.center && o.center.fromArray(a.center), void 0 !== a.rotation && (o.rotation = a.rotation), void 0 !== a.wrap && (o.wrapS = i(a.wrap[0], TEXTURE_WRAPPING), o.wrapT = i(a.wrap[1], TEXTURE_WRAPPING)), void 0 !== a.format && (o.format = a.format), void 0 !== a.type && (o.type = a.type), void 0 !== a.encoding && (o.encoding = a.encoding), void 0 !== a.minFilter && (o.minFilter = i(a.minFilter, TEXTURE_FILTER)), void 0 !== a.magFilter && (o.magFilter = i(a.magFilter, TEXTURE_FILTER)), void 0 !== a.anisotropy && (o.anisotropy = a.anisotropy), void 0 !== a.flipY && (o.flipY = a.flipY), void 0 !== a.premultiplyAlpha && (o.premultiplyAlpha = a.premultiplyAlpha), void 0 !== a.unpackAlignment && (o.unpackAlignment = a.unpackAlignment), r[a.uuid] = o } return r } parseObject(e, t, i, r) { let n, a, o; function s(e) { return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e] } function l(e) { if (void 0 !== e) { if (Array.isArray(e)) { const t = []; for (let r = 0, n = e.length; r < n; r++) { const n = e[r]; void 0 === i[n] && console.warn("THREE.ObjectLoader: Undefined material", n), t.push(i[n]) } return t } return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined material", e), i[e] } } switch (e.type) { case "Scene": n = new Scene, void 0 !== e.background && Number.isInteger(e.background) && (n.background = new Color$1(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? n.fog = new Fog(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (n.fog = new FogExp2(e.fog.color, e.fog.density))); break; case "PerspectiveCamera": n = new PerspectiveCamera(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (n.focus = e.focus), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.filmGauge && (n.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (n.filmOffset = e.filmOffset), void 0 !== e.view && (n.view = Object.assign({}, e.view)); break; case "OrthographicCamera": n = new OrthographicCamera(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.view && (n.view = Object.assign({}, e.view)); break; case "AmbientLight": n = new AmbientLight(e.color, e.intensity); break; case "DirectionalLight": n = new DirectionalLight(e.color, e.intensity); break; case "PointLight": n = new PointLight(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": n = new RectAreaLight(e.color, e.intensity, e.width, e.height); break; case "SpotLight": n = new SpotLight(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case "HemisphereLight": n = new HemisphereLight(e.color, e.groundColor, e.intensity); break; case "LightProbe": n = (new LightProbe).fromJSON(e); break; case "SkinnedMesh": a = s(e.geometry), o = l(e.material), n = new SkinnedMesh(a, o), void 0 !== e.bindMode && (n.bindMode = e.bindMode), void 0 !== e.bindMatrix && n.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (n.skeleton = e.skeleton); break; case "Mesh": a = s(e.geometry), o = l(e.material), n = new Mesh(a, o); break; case "InstancedMesh": a = s(e.geometry), o = l(e.material); const t = e.count, i = e.instanceMatrix; n = new InstancedMesh(a, o, t), n.instanceMatrix = new BufferAttribute(new Float32Array(i.array), 16); break; case "LOD": n = new LOD; break; case "Line": n = new Line(s(e.geometry), l(e.material)); break; case "LineLoop": n = new LineLoop(s(e.geometry), l(e.material)); break; case "LineSegments": n = new LineSegments(s(e.geometry), l(e.material)); break; case "PointCloud": case "Points": n = new Points(s(e.geometry), l(e.material)); break; case "Sprite": n = new Sprite(l(e.material)); break; case "Group": n = new Group; break; case "Bone": n = new Bone; break; default: n = new Object3D }if (n.uuid = e.uuid, void 0 !== e.name && (n.name = e.name), void 0 !== e.matrix ? (n.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (n.matrixAutoUpdate = e.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== e.position && n.position.fromArray(e.position), void 0 !== e.rotation && n.rotation.fromArray(e.rotation), void 0 !== e.quaternion && n.quaternion.fromArray(e.quaternion), void 0 !== e.scale && n.scale.fromArray(e.scale)), void 0 !== e.castShadow && (n.castShadow = e.castShadow), void 0 !== e.receiveShadow && (n.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (n.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (n.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (n.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && n.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (n.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.frustumCulled && (n.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (n.renderOrder = e.renderOrder), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.layers && (n.layers.mask = e.layers), void 0 !== e.children) { const a = e.children; for (let e = 0; e < a.length; e++)n.add(this.parseObject(a[e], t, i, r)) } if (void 0 !== e.animations) { const t = e.animations; for (let e = 0; e < t.length; e++) { const i = t[e]; n.animations.push(r[i]) } } if ("LOD" === e.type) { void 0 !== e.autoUpdate && (n.autoUpdate = e.autoUpdate); const t = e.levels; for (let e = 0; e < t.length; e++) { const i = t[e], r = n.getObjectByProperty("uuid", i.object); void 0 !== r && n.addLevel(r, i.distance) } } return n } bindSkeletons(e, t) { 0 !== Object.keys(t).length && e.traverse((function (e) { if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) { const i = t[e.skeleton]; void 0 === i ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(i, e.bindMatrix) } })) } setTexturePath(e) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e) } } const TEXTURE_MAPPING = { UVMapping: UVMapping, CubeReflectionMapping: CubeReflectionMapping, CubeRefractionMapping: CubeRefractionMapping, EquirectangularReflectionMapping: EquirectangularReflectionMapping, EquirectangularRefractionMapping: EquirectangularRefractionMapping, CubeUVReflectionMapping: CubeUVReflectionMapping, CubeUVRefractionMapping: CubeUVRefractionMapping }, TEXTURE_WRAPPING = { RepeatWrapping: RepeatWrapping, ClampToEdgeWrapping: ClampToEdgeWrapping, MirroredRepeatWrapping: MirroredRepeatWrapping }, TEXTURE_FILTER = { NearestFilter: NearestFilter, NearestMipmapNearestFilter: NearestMipmapNearestFilter, NearestMipmapLinearFilter: NearestMipmapLinearFilter, LinearFilter: LinearFilter, LinearMipmapNearestFilter: LinearMipmapNearestFilter, LinearMipmapLinearFilter: LinearMipmapLinearFilter }; function ImageBitmapLoader(e) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), Loader.call(this, e), this.options = { premultiplyAlpha: "none" } } ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), { constructor: ImageBitmapLoader, isImageBitmapLoader: !0, setOptions: function (e) { return this.options = e, this }, load: function (e, t, i, r) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); const n = this, a = Cache.get(e); if (void 0 !== a) return n.manager.itemStart(e), setTimeout((function () { t && t(a), n.manager.itemEnd(e) }), 0), a; const o = {}; o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader; let s = null; fetch(e, o).then((function (e) { return e.blob() })).then((function (e) { return s = e, createImageBitmap(e, Object.assign(n.options, { colorSpaceConversion: "none" })) })).then((function (i) { Cache.get(e) ? (t && t(Cache.get(e)), n.manager.itemEnd(e)) : (Cache.add(e, i), s && ImageBitMapCache.set(i, s), t && t(i), n.manager.itemEnd(e)) })).catch((function (t) { r && r(t), n.manager.itemError(e), n.manager.itemEnd(e) })), n.manager.itemStart(e) } }); class ShapePath { constructor() { this.type = "ShapePath", this.color = new Color$1, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new Path$1, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, i, r) { return this.currentPath.quadraticCurveTo(e, t, i, r), this } bezierCurveTo(e, t, i, r, n, a) { return this.currentPath.bezierCurveTo(e, t, i, r, n, a), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(e, t) { function i(e) { const t = []; for (let i = 0, r = e.length; i < r; i++) { const r = e[i], n = new Shape; n.curves = r.curves, t.push(n) } return t } function r(e, t) { const i = t.length; let r = !1; for (let n = i - 1, a = 0; a < i; n = a++) { let i = t[n], o = t[a], s = o.x - i.x, l = o.y - i.y; if (Math.abs(l) > Number.EPSILON) { if (l < 0 && (i = t[a], s = -s, o = t[n], l = -l), e.y < i.y || e.y > o.y) continue; if (e.y === i.y) { if (e.x === i.x) return !0 } else { const t = l * (e.x - i.x) - s * (e.y - i.y); if (0 === t) return !0; if (t < 0) continue; r = !r } } else { if (e.y !== i.y) continue; if (o.x <= e.x && e.x <= i.x || i.x <= e.x && e.x <= o.x) return !0 } } return r } const n = ShapeUtils.isClockWise, a = this.subPaths; if (0 === a.length) return []; if (!0 === t) return i(a); let o, s, l; const c = []; if (1 === a.length) return s = a[0], l = new Shape, l.curves = s.curves, c.push(l), c; let h = !n(a[0].getPoints()); h = e ? !h : h; const u = [], d = []; let p, f, m = [], g = 0; d[g] = void 0, m[g] = []; for (let t = 0, i = a.length; t < i; t++)s = a[t], p = s.getPoints(), o = n(p), o = e ? !o : o, o ? (!h && d[g] && g++, d[g] = { s: new Shape, p: p }, d[g].s.curves = s.curves, h && g++, m[g] = []) : m[g].push({ h: s, p: p[0] }); if (!d[0]) return i(a); if (d.length > 1) { let e = !1; const t = []; for (let e = 0, t = d.length; e < t; e++)u[e] = []; for (let i = 0, n = d.length; i < n; i++) { const n = m[i]; for (let a = 0; a < n.length; a++) { const o = n[a]; let s = !0; for (let n = 0; n < d.length; n++)r(o.p, d[n].p) && (i !== n && t.push({ froms: i, tos: n, hole: a }), s ? (s = !1, u[n].push(o)) : e = !0); s && u[i].push(o) } } t.length > 0 && (e || (m = u)) } for (let e = 0, t = d.length; e < t; e++) { l = d[e].s, c.push(l), f = m[e]; for (let e = 0, t = f.length; e < t; e++)l.holes.push(f[e].h) } return c } } class Font { constructor(e) { this.type = "Font", this.data = e } generateShapes(e, t = 100) { const i = [], r = createPaths(e, t, this.data); for (let e = 0, t = r.length; e < t; e++)Array.prototype.push.apply(i, r[e].toShapes()); return i } } function createPaths(e, t, i) { const r = Array.from(e), n = t / i.resolution, a = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * n, o = []; let s = 0, l = 0; for (let e = 0; e < r.length; e++) { const t = r[e]; if ("\n" === t) s = 0, l -= a; else { const e = createPath(t, n, s, l, i); s += e.offsetX, o.push(e.path) } } return o } function createPath(e, t, i, r, n) { const a = n.glyphs[e] || n.glyphs["?"]; if (!a) return void console.error('THREE.Font: character "' + e + '" does not exists in font family ' + n.familyName + "."); const o = new ShapePath; let s, l, c, h, u, d, p, f; if (a.o) { const e = a._cachedOutline || (a._cachedOutline = a.o.split(" ")); for (let n = 0, a = e.length; n < a;) { switch (e[n++]) { case "m": s = e[n++] * t + i, l = e[n++] * t + r, o.moveTo(s, l); break; case "l": s = e[n++] * t + i, l = e[n++] * t + r, o.lineTo(s, l); break; case "q": c = e[n++] * t + i, h = e[n++] * t + r, u = e[n++] * t + i, d = e[n++] * t + r, o.quadraticCurveTo(u, d, c, h); break; case "b": c = e[n++] * t + i, h = e[n++] * t + r, u = e[n++] * t + i, d = e[n++] * t + r, p = e[n++] * t + i, f = e[n++] * t + r, o.bezierCurveTo(u, d, p, f, c, h) } } } return { offsetX: a.ha * t, path: o } } Font.prototype.isFont = !0; class FontLoader extends Loader { constructor(e) { super(e) } load(e, t, i, r) { const n = this, a = new FileLoader(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(n.withCredentials), a.load(e, (function (e) { let i; try { i = JSON.parse(e) } catch (t) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(e.substring(65, e.length - 2)) } const r = n.parse(i); t && t(r) }), i, r) } parse(e) { return new Font(e) } } let _context$1; const AudioContext = { getContext: function () { return void 0 === _context$1 && (_context$1 = new (window.AudioContext || window.webkitAudioContext)), _context$1 }, setContext: function (e) { _context$1 = e } }; class AudioLoader extends Loader { constructor(e) { super(e) } load(e, t, i, r) { const n = this, a = new FileLoader(this.manager); a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function (i) { try { const e = i.slice(0); AudioContext.getContext().decodeAudioData(e, (function (e) { t(e) })) } catch (t) { r ? r(t) : console.error(t), n.manager.itemError(e) } }), i, r) } } class HemisphereLightProbe extends LightProbe { constructor(e, t, i = 1) { super(void 0, i); const r = (new Color$1).set(e), n = (new Color$1).set(t), a = new Vector3(r.r, r.g, r.b), o = new Vector3(n.r, n.g, n.b), s = Math.sqrt(Math.PI), l = s * Math.sqrt(.75); this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s), this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(l) } } HemisphereLightProbe.prototype.isHemisphereLightProbe = !0; class AmbientLightProbe extends LightProbe { constructor(e, t = 1) { super(void 0, t); const i = (new Color$1).set(e); this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } } AmbientLightProbe.prototype.isAmbientLightProbe = !0; const _eyeRight = new Matrix4, _eyeLeft = new Matrix4; class StereoCamera { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new PerspectiveCamera, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new PerspectiveCamera, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { const t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep; const i = e.projectionMatrix.clone(), r = t.eyeSep / 2, n = r * t.near / t.focus, a = t.near * Math.tan(MathUtils.DEG2RAD * t.fov * .5) / t.zoom; let o, s; _eyeLeft.elements[12] = -r, _eyeRight.elements[12] = r, o = -a * t.aspect + n, s = a * t.aspect + n, i.elements[0] = 2 * t.near / (s - o), i.elements[8] = (s + o) / (s - o), this.cameraL.projectionMatrix.copy(i), o = -a * t.aspect - n, s = a * t.aspect - n, i.elements[0] = 2 * t.near / (s - o), i.elements[8] = (s + o) / (s - o), this.cameraR.projectionMatrix.copy(i) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(_eyeLeft), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_eyeRight) } } class Clock { constructor(e) { this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { const t = now(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } } function now() { return ("undefined" == typeof performance ? Date : performance).now() } const _position$2 = new Vector3, _quaternion$3 = new Quaternion, _scale$1 = new Vector3, _orientation = new Vector3; class AudioListener extends Object3D { constructor() { super(), this.type = "AudioListener", this.context = AudioContext.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Clock } getInput() { return this.gain } removeFilter() { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); const t = this.context.listener, i = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1), _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3), t.positionX) { const e = this.context.currentTime + this.timeDelta; t.positionX.linearRampToValueAtTime(_position$2.x, e), t.positionY.linearRampToValueAtTime(_position$2.y, e), t.positionZ.linearRampToValueAtTime(_position$2.z, e), t.forwardX.linearRampToValueAtTime(_orientation.x, e), t.forwardY.linearRampToValueAtTime(_orientation.y, e), t.forwardZ.linearRampToValueAtTime(_orientation.z, e), t.upX.linearRampToValueAtTime(i.x, e), t.upY.linearRampToValueAtTime(i.y, e), t.upZ.linearRampToValueAtTime(i.z, e) } else t.setPosition(_position$2.x, _position$2.y, _position$2.z), t.setOrientation(_orientation.x, _orientation.y, _orientation.z, i.x, i.y, i.z) } } class Audio extends Object3D { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing."); if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control."); this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") } stop() { if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } getFilters() { return this.filters } setFilters(e) { return e || (e = []), !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } } const _position$3 = new Vector3, _quaternion$4 = new Quaternion, _scale$2 = new Vector3, _orientation$1 = new Vector3; class PositionalAudio extends Audio { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, t, i) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return; this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2), _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4); const t = this.panner; if (t.positionX) { const e = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime(_position$3.x, e), t.positionY.linearRampToValueAtTime(_position$3.y, e), t.positionZ.linearRampToValueAtTime(_position$3.z, e), t.orientationX.linearRampToValueAtTime(_orientation$1.x, e), t.orientationY.linearRampToValueAtTime(_orientation$1.y, e), t.orientationZ.linearRampToValueAtTime(_orientation$1.z, e) } else t.setPosition(_position$3.x, _position$3.y, _position$3.z), t.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z) } } class AudioAnalyser { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let e = 0; const t = this.getFrequencyData(); for (let i = 0; i < t.length; i++)e += t[i]; return e / t.length } } class PropertyMixer { constructor(e, t, i) { let r, n, a; switch (this.binding = e, this.valueSize = i, t) { case "quaternion": r = this._slerp, n = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5; break; case "string": case "bool": r = this._select, n = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i); break; default: r = this._lerp, n = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = n, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const i = this.buffer, r = this.valueSize, n = e * r + r; let a = this.cumulativeWeight; if (0 === a) { for (let e = 0; e !== r; ++e)i[n + e] = i[e]; a = t } else { a += t; const e = t / a; this._mixBufferRegion(i, n, 0, e, r) } this.cumulativeWeight = a } accumulateAdditive(e) { const t = this.buffer, i = this.valueSize, r = i * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, i), this.cumulativeWeightAdditive += e } apply(e) { const t = this.valueSize, i = this.buffer, r = e * t + t, n = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, n < 1) { const e = t * this._origIndex; this._mixBufferRegion(i, r, e, 1 - n, t) } a > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t); for (let e = t, n = t + t; e !== n; ++e)if (i[e] !== i[e + t]) { o.setValue(i, r); break } } saveOriginalState() { const e = this.binding, t = this.buffer, i = this.valueSize, r = i * this._origIndex; e.getValue(t, r); for (let e = i, n = r; e !== n; ++e)t[e] = t[r + e % i]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { const e = 3 * this.valueSize; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { const e = this._addIndex * this.valueSize, t = e + this.valueSize; for (let i = e; i < t; i++)this.buffer[i] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize; for (let i = 0; i < this.valueSize; i++)this.buffer[t + i] = this.buffer[e + i] } _select(e, t, i, r, n) { if (r >= .5) for (let r = 0; r !== n; ++r)e[t + r] = e[i + r] } _slerp(e, t, i, r) { Quaternion.slerpFlat(e, t, e, t, e, i, r) } _slerpAdditive(e, t, i, r, n) { const a = this._workIndex * n; Quaternion.multiplyQuaternionsFlat(e, a, e, t, e, i), Quaternion.slerpFlat(e, t, e, t, e, a, r) } _lerp(e, t, i, r, n) { const a = 1 - r; for (let o = 0; o !== n; ++o) { const n = t + o; e[n] = e[n] * a + e[i + o] * r } } _lerpAdditive(e, t, i, r, n) { for (let a = 0; a !== n; ++a) { const n = t + a; e[n] = e[n] + e[i + a] * r } } } const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/", _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"), _wordChar = "[^" + _RESERVED_CHARS_RE + "]", _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]", _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar), _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot), _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar), _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar), _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"), _supportedObjectNames = ["material", "materials", "bones"]; function Composite(e, t, i) { const r = i || PropertyBinding.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, r) } function PropertyBinding(e, t, i) { this.path = t, this.parsedPath = i || PropertyBinding.parseTrackName(t), this.node = PropertyBinding.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e } Object.assign(Composite.prototype, { getValue: function (e, t) { this.bind(); const i = this._targetGroup.nCachedObjects_, r = this._bindings[i]; void 0 !== r && r.getValue(e, t) }, setValue: function (e, t) { const i = this._bindings; for (let r = this._targetGroup.nCachedObjects_, n = i.length; r !== n; ++r)i[r].setValue(e, t) }, bind: function () { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)e[t].bind() }, unbind: function () { const e = this._bindings; for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)e[t].unbind() } }), Object.assign(PropertyBinding, { Composite: Composite, create: function (e, t, i) { return e && e.isAnimationObjectGroup ? new PropertyBinding.Composite(e, t, i) : new PropertyBinding(e, t, i) }, sanitizeNodeName: function (e) { return e.replace(/\s/g, "_").replace(_reservedRe, "") }, parseTrackName: function (e) { const t = _trackRe.exec(e); if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = i.nodeName && i.nodeName.lastIndexOf("."); if (void 0 !== r && -1 !== r) { const e = i.nodeName.substring(r + 1); -1 !== _supportedObjectNames.indexOf(e) && (i.nodeName = i.nodeName.substring(0, r), i.objectName = e) } if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return i }, findNode: function (e, t) { if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e; if (e.skeleton) { const i = e.skeleton.getBoneByName(t); if (void 0 !== i) return i } if (e.children) { const i = function (e) { for (let r = 0; r < e.length; r++) { const n = e[r]; if (n.name === t || n.uuid === t) return n; const a = i(n.children); if (a) return a } return null }, r = i(e.children); if (r) return r } return null } }), Object.assign(PropertyBinding.prototype, { _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (e, t) { e[t] = this.node[this.propertyName] }, function (e, t) { const i = this.resolvedProperty; for (let r = 0, n = i.length; r !== n; ++r)e[t++] = i[r] }, function (e, t) { e[t] = this.resolvedProperty[this.propertyIndex] }, function (e, t) { this.resolvedProperty.toArray(e, t) }], SetterByBindingTypeAndVersioning: [[function (e, t) { this.targetObject[this.propertyName] = e[t] }, function (e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 }, function (e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (e, t) { const i = this.resolvedProperty; for (let r = 0, n = i.length; r !== n; ++r)i[r] = e[t++] }, function (e, t) { const i = this.resolvedProperty; for (let r = 0, n = i.length; r !== n; ++r)i[r] = e[t++]; this.targetObject.needsUpdate = !0 }, function (e, t) { const i = this.resolvedProperty; for (let r = 0, n = i.length; r !== n; ++r)i[r] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (e, t) { this.resolvedProperty[this.propertyIndex] = e[t] }, function (e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 }, function (e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (e, t) { this.resolvedProperty.fromArray(e, t) }, function (e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 }, function (e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 }]], getValue: function (e, t) { this.bind(), this.getValue(e, t) }, setValue: function (e, t) { this.bind(), this.setValue(e, t) }, bind: function () { let e = this.node; const t = this.parsedPath, i = t.objectName, r = t.propertyName; let n = t.propertyIndex; if (e || (e = PropertyBinding.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); if (i) { let r = t.objectIndex; switch (i) { case "materials": if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); e = e.material.materials; break; case "bones": if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); e = e.skeleton.bones; for (let t = 0; t < e.length; t++)if (e[t].name === r) { r = t; break } break; default: if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); e = e[i] }if (void 0 !== r) { if (void 0 === e[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); e = e[r] } } const a = e[r]; if (void 0 === a) { const i = t.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + r + " but it wasn't found.", e) } let o = this.Versioning.None; this.targetObject = e, void 0 !== e.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate); let s = this.BindingType.Direct; if (void 0 !== n) { if ("morphTargetInfluences" === r) { if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!e.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== e.morphTargetDictionary[n] && (n = e.morphTargetDictionary[n]) } s = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = n } else void 0 !== a.fromArray && void 0 !== a.toArray ? (s = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (s = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = r; this.getValue = this.GetterByBindingType[s], this.setValue = this.SetterByBindingTypeAndVersioning[s][o] }, unbind: function () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }), Object.assign(PropertyBinding.prototype, { _getValue_unbound: PropertyBinding.prototype.getValue, _setValue_unbound: PropertyBinding.prototype.setValue }); class AnimationObjectGroup { constructor() { this.uuid = MathUtils.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const e = {}; this._indicesByUUID = e; for (let t = 0, i = arguments.length; t !== i; ++t)e[arguments[t].uuid] = t; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const t = this; this.stats = { objects: { get total() { return t._objects.length }, get inUse() { return this.total - t.nCachedObjects_ } }, get bindingsPerObject() { return t._bindings.length } } } add() { const e = this._objects, t = this._indicesByUUID, i = this._paths, r = this._parsedPaths, n = this._bindings, a = n.length; let o, s = e.length, l = this.nCachedObjects_; for (let c = 0, h = arguments.length; c !== h; ++c) { const h = arguments[c], u = h.uuid; let d = t[u]; if (void 0 === d) { d = s++, t[u] = d, e.push(h); for (let e = 0, t = a; e !== t; ++e)n[e].push(new PropertyBinding(h, i[e], r[e])) } else if (d < l) { o = e[d]; const s = --l, c = e[s]; t[c.uuid] = d, e[d] = c, t[u] = s, e[s] = h; for (let e = 0, t = a; e !== t; ++e) { const t = n[e], a = t[s]; let o = t[d]; t[d] = a, void 0 === o && (o = new PropertyBinding(h, i[e], r[e])), t[s] = o } } else e[d] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = l } remove() { const e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length; let n = this.nCachedObjects_; for (let a = 0, o = arguments.length; a !== o; ++a) { const o = arguments[a], s = o.uuid, l = t[s]; if (void 0 !== l && l >= n) { const a = n++, c = e[a]; t[c.uuid] = l, e[l] = c, t[s] = a, e[a] = o; for (let e = 0, t = r; e !== t; ++e) { const t = i[e], r = t[a], n = t[l]; t[l] = r, t[a] = n } } } this.nCachedObjects_ = n } uncache() { const e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length; let n = this.nCachedObjects_, a = e.length; for (let o = 0, s = arguments.length; o !== s; ++o) { const s = arguments[o].uuid, l = t[s]; if (void 0 !== l) if (delete t[s], l < n) { const o = --n, s = e[o], c = --a, h = e[c]; t[s.uuid] = l, e[l] = s, t[h.uuid] = o, e[o] = h, e.pop(); for (let e = 0, t = r; e !== t; ++e) { const t = i[e], r = t[o], n = t[c]; t[l] = r, t[o] = n, t.pop() } } else { const n = --a, o = e[n]; n > 0 && (t[o.uuid] = l), e[l] = o, e.pop(); for (let e = 0, t = r; e !== t; ++e) { const t = i[e]; t[l] = t[n], t.pop() } } } this.nCachedObjects_ = n } subscribe_(e, t) { const i = this._bindingsIndicesByPath; let r = i[e]; const n = this._bindings; if (void 0 !== r) return n[r]; const a = this._paths, o = this._parsedPaths, s = this._objects, l = s.length, c = this.nCachedObjects_, h = new Array(l); r = n.length, i[e] = r, a.push(e), o.push(t), n.push(h); for (let i = c, r = s.length; i !== r; ++i) { const r = s[i]; h[i] = new PropertyBinding(r, e, t) } return h } unsubscribe_(e) { const t = this._bindingsIndicesByPath, i = t[e]; if (void 0 !== i) { const r = this._paths, n = this._parsedPaths, a = this._bindings, o = a.length - 1, s = a[o]; t[e[o]] = i, a[i] = s, a.pop(), n[i] = n[o], n.pop(), r[i] = r[o], r.pop() } } } AnimationObjectGroup.prototype.isAnimationObjectGroup = !0; class AnimationAction { constructor(e, t, i = null, r = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = r; const n = t.tracks, a = n.length, o = new Array(a), s = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding }; for (let e = 0; e !== a; ++e) { const t = n[e].createInterpolant(null); o[e] = t, t.settings = s } this._interpolantSettings = s, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = LoopRepeat, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, i) { if (e.fadeOut(t), this.fadeIn(t), i) { const i = this._clip.duration, r = e._clip.duration, n = r / i, a = i / r; e.warp(1, n, t), this.warp(a, 1, t) } return this } crossFadeTo(e, t, i) { return e.crossFadeFrom(this, t, i) } stopFading() { const e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, i) { const r = this._mixer, n = r.time, a = this.timeScale; let o = this._timeScaleInterpolant; null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o); const s = o.parameterPositions, l = o.sampleValues; return s[0] = n, s[1] = n + i, l[0] = e / a, l[1] = t / a, this } stopWarping() { const e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(e, t, i, r) { if (!this.enabled) return void this._updateWeight(e); const n = this._startTime; if (null !== n) { const r = (e - n) * i; if (r < 0 || 0 === i) return; this._startTime = null, t = i * r } t *= this._updateTimeScale(e); const a = this._updateTime(t), o = this._updateWeight(e); if (o > 0) { const e = this._interpolants, t = this._propertyBindings; switch (this.blendMode) { case AdditiveAnimationBlendMode: for (let i = 0, r = e.length; i !== r; ++i)e[i].evaluate(a), t[i].accumulateAdditive(o); break; case NormalAnimationBlendMode: default: for (let i = 0, n = e.length; i !== n; ++i)e[i].evaluate(a), t[i].accumulate(r, o) } } } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const i = this._weightInterpolant; if (null !== i) { const r = i.evaluate(e)[0]; t *= r, e > i.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1)) } } return this._effectiveWeight = t, t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const i = this._timeScaleInterpolant; if (null !== i) { t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t) } } return this._effectiveTimeScale = t, t } _updateTime(e) { const t = this._clip.duration, i = this.loop; let r = this.time + e, n = this._loopCount; const a = i === LoopPingPong; if (0 === e) return -1 === n ? r : a && 1 == (1 & n) ? t - r : r; if (i === LoopOnce) { -1 === n && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (r >= t) r = t; else { if (!(r < 0)) { this.time = r; break e } r = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (-1 === n && (e >= 0 ? (n = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), r >= t || r < 0) { const i = Math.floor(r / t); r -= t * i, n += Math.abs(i); const o = this.repetitions - n; if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (1 === o) { const t = e < 0; this._setEndings(t, !t, a) } else this._setEndings(!1, !1, a); this._loopCount = n, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: i }) } } else this.time = r; if (a && 1 == (1 & n)) return t - r } return r } _setEndings(e, t, i) { const r = this._interpolantSettings; i ? (r.endingStart = ZeroSlopeEnding, r.endingEnd = ZeroSlopeEnding) : (r.endingStart = e ? this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding : WrapAroundEnding, r.endingEnd = t ? this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding : WrapAroundEnding) } _scheduleFading(e, t, i) { const r = this._mixer, n = r.time; let a = this._weightInterpolant; null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a); const o = a.parameterPositions, s = a.sampleValues; return o[0] = n, s[0] = t, o[1] = n + e, s[1] = i, this } } class AnimationMixer extends EventDispatcher { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, t) { const i = e._localRoot || this._root, r = e._clip.tracks, n = r.length, a = e._propertyBindings, o = e._interpolants, s = i.uuid, l = this._bindingsByRootAndName; let c = l[s]; void 0 === c && (c = {}, l[s] = c); for (let e = 0; e !== n; ++e) { const n = r[e], l = n.name; let h = c[l]; if (void 0 !== h) a[e] = h; else { if (h = a[e], void 0 !== h) { null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, s, l)); continue } const r = t && t._propertyBindings[e].binding.parsedPath; h = new PropertyMixer(PropertyBinding.create(i, l, r), n.ValueTypeName, n.getValueSize()), ++h.referenceCount, this._addInactiveBinding(h, s, l), a[e] = h } o[e].resultBuffer = h.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { if (null === e._cacheIndex) { const t = (e._localRoot || this._root).uuid, i = e._clip.uuid, r = this._actionsByClip[i]; this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, i, t) } const t = e._propertyBindings; for (let e = 0, i = t.length; e !== i; ++e) { const i = t[e]; 0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { const t = e._propertyBindings; for (let e = 0, i = t.length; e !== i; ++e) { const i = t[e]; 0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { const t = e._cacheIndex; return null !== t && t < this._nActiveActions } _addInactiveAction(e, t, i) { const r = this._actions, n = this._actionsByClip; let a = n[t]; if (void 0 === a) a = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, n[t] = a; else { const t = a.knownActions; e._byClipCacheIndex = t.length, t.push(e) } e._cacheIndex = r.length, r.push(e), a.actionByRoot[i] = e } _removeInactiveAction(e) { const t = this._actions, i = t[t.length - 1], r = e._cacheIndex; i._cacheIndex = r, t[r] = i, t.pop(), e._cacheIndex = null; const n = e._clip.uuid, a = this._actionsByClip, o = a[n], s = o.knownActions, l = s[s.length - 1], c = e._byClipCacheIndex; l._byClipCacheIndex = c, s[c] = l, s.pop(), e._byClipCacheIndex = null; delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete a[n], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { const t = e._propertyBindings; for (let e = 0, i = t.length; e !== i; ++e) { const i = t[e]; 0 == --i.referenceCount && this._removeInactiveBinding(i) } } _lendAction(e) { const t = this._actions, i = e._cacheIndex, r = this._nActiveActions++, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n } _takeBackAction(e) { const t = this._actions, i = e._cacheIndex, r = --this._nActiveActions, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n } _addInactiveBinding(e, t, i) { const r = this._bindingsByRootAndName, n = this._bindings; let a = r[t]; void 0 === a && (a = {}, r[t] = a), a[i] = e, e._cacheIndex = n.length, n.push(e) } _removeInactiveBinding(e) { const t = this._bindings, i = e.binding, r = i.rootNode.uuid, n = i.path, a = this._bindingsByRootAndName, o = a[r], s = t[t.length - 1], l = e._cacheIndex; s._cacheIndex = l, t[l] = s, t.pop(), delete o[n], 0 === Object.keys(o).length && delete a[r] } _lendBinding(e) { const t = this._bindings, i = e._cacheIndex, r = this._nActiveBindings++, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n } _takeBackBinding(e) { const t = this._bindings, i = e._cacheIndex, r = --this._nActiveBindings, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let i = e[t]; return void 0 === i && (i = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i.__cacheIndex = t, e[t] = i), i } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, i = e.__cacheIndex, r = --this._nActiveControlInterpolants, n = t[r]; e.__cacheIndex = r, t[r] = e, n.__cacheIndex = i, t[i] = n } clipAction(e, t, i) { const r = t || this._root, n = r.uuid; let a = "string" == typeof e ? AnimationClip.findByName(r, e) : e; const o = null !== a ? a.uuid : e, s = this._actionsByClip[o]; let l = null; if (void 0 === i && (i = null !== a ? a.blendMode : NormalAnimationBlendMode), void 0 !== s) { const e = s.actionByRoot[n]; if (void 0 !== e && e.blendMode === i) return e; l = s.knownActions[0], null === a && (a = l._clip) } if (null === a) return null; const c = new AnimationAction(this, a, t, i); return this._bindAction(c, l), this._addInactiveAction(c, o, n), c } existingAction(e, t) { const i = t || this._root, r = i.uuid, n = "string" == typeof e ? AnimationClip.findByName(i, e) : e, a = n ? n.uuid : e, o = this._actionsByClip[a]; return void 0 !== o && o.actionByRoot[r] || null } stopAllAction() { const e = this._actions; for (let t = this._nActiveActions - 1; t >= 0; --t)e[t].stop(); return this } update(e) { e *= this.timeScale; const t = this._actions, i = this._nActiveActions, r = this.time += e, n = Math.sign(e), a = this._accuIndex ^= 1; for (let o = 0; o !== i; ++o) { t[o]._update(r, e, n, a) } const o = this._bindings, s = this._nActiveBindings; for (let e = 0; e !== s; ++e)o[e].apply(a); return this } setTime(e) { this.time = 0; for (let e = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(e) { const t = this._actions, i = e.uuid, r = this._actionsByClip, n = r[i]; if (void 0 !== n) { const e = n.knownActions; for (let i = 0, r = e.length; i !== r; ++i) { const r = e[i]; this._deactivateAction(r); const n = r._cacheIndex, a = t[t.length - 1]; r._cacheIndex = null, r._byClipCacheIndex = null, a._cacheIndex = n, t[n] = a, t.pop(), this._removeInactiveBindingsForAction(r) } delete r[i] } } uncacheRoot(e) { const t = e.uuid, i = this._actionsByClip; for (const e in i) { const r = i[e].actionByRoot[t]; void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r)) } const r = this._bindingsByRootAndName[t]; if (void 0 !== r) for (const e in r) { const t = r[e]; t.restoreOriginalState(), this._removeInactiveBinding(t) } } uncacheAction(e, t) { const i = this.existingAction(e, t); null !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } } AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1); class Uniform { constructor(e) { "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e } clone() { return new Uniform(void 0 === this.value.clone ? this.value : this.value.clone()) } } function InstancedInterleavedBuffer(e, t, i) { InterleavedBuffer.call(this, e, t), this.meshPerAttribute = i || 1 } function GLBufferAttribute(e, t, i, r, n) { this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = r, this.count = n, this.version = 0 } function Raycaster(e, t, i = 0, r = 1 / 0) { this.ray = new Ray(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new Layers, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function () { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) } function ascSort(e, t) { return e.distance - t.distance } function intersectObject(e, t, i, r) { if (e.layers.test(t.layers) && e.raycast(t, i), !0 === r) { const r = e.children; for (let e = 0, n = r.length; e < n; e++)intersectObject(r[e], t, i, !0) } } InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), { constructor: InstancedInterleavedBuffer, isInstancedInterleavedBuffer: !0, copy: function (e) { return InterleavedBuffer.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this }, clone: function (e) { const t = InterleavedBuffer.prototype.clone.call(this, e); return t.meshPerAttribute = this.meshPerAttribute, t }, toJSON: function (e) { const t = InterleavedBuffer.prototype.toJSON.call(this, e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } }), Object.defineProperty(GLBufferAttribute.prototype, "needsUpdate", { set: function (e) { !0 === e && this.version++ } }), Object.assign(GLBufferAttribute.prototype, { isGLBufferAttribute: !0, setBuffer: function (e) { return this.buffer = e, this }, setType: function (e, t) { return this.type = e, this.elementSize = t, this }, setItemSize: function (e) { return this.itemSize = e, this }, setCount: function (e) { return this.count = e, this } }), Object.assign(Raycaster.prototype, { set: function (e, t) { this.ray.set(e, t) }, setFromCamera: function (e, t) { t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type) }, intersectObject: function (e, t = !1, i = []) { return intersectObject(e, this, i, t), i.sort(ascSort), i }, intersectObjects: function (e, t = !1, i = []) { for (let r = 0, n = e.length; r < n; r++)intersectObject(e[r], this, i, t); return i.sort(ascSort), i } }); class Spherical { constructor(e = 1, t = 0, i = 0) { return this.radius = e, this.phi = t, this.theta = i, this } set(e, t, i) { return this.radius = e, this.phi = t, this.theta = i, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { const e = 1e-6; return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, i) { return this.radius = Math.sqrt(e * e + t * t + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(MathUtils.clamp(t / this.radius, -1, 1))), this } clone() { return (new this.constructor).copy(this) } } class Cylindrical { constructor(e = 1, t = 0, i = 0) { return this.radius = e, this.theta = t, this.y = i, this } set(e, t, i) { return this.radius = e, this.theta = t, this.y = i, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, i) { return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this } clone() { return (new this.constructor).copy(this) } } const _vector$8 = new Vector2; class Box2 { constructor(e = new Vector2(1 / 0, 1 / 0), t = new Vector2(-1 / 0, -1 / 0)) { this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(e) { this.makeEmpty(); for (let t = 0, i = e.length; t < i; t++)this.expandByPoint(e[t]); return this } setFromCenterAndSize(e, t) { const i = _vector$8.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new Vector2), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new Vector2), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new Vector2), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } clampPoint(e, t) { return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new Vector2), t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return _vector$8.copy(e).clamp(this.min, this.max).sub(e).length() } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } Box2.prototype.isBox2 = !0; const _startP = new Vector3, _startEnd = new Vector3; class Line3 { constructor(e = new Vector3, t = new Vector3) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new Vector3), e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new Vector3), e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new Vector3), this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { _startP.subVectors(e, this.start), _startEnd.subVectors(this.end, this.start); const i = _startEnd.dot(_startEnd); let r = _startEnd.dot(_startP) / i; return t && (r = MathUtils.clamp(r, 0, 1)), r } closestPointToPoint(e, t, i) { const r = this.closestPointToPointParameter(e, t); return void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new Vector3), this.delta(i).multiplyScalar(r).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return (new this.constructor).copy(this) } } function ImmediateRenderObject(e) { Object3D.call(this), this.material = e, this.render = function () { }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 } ImmediateRenderObject.prototype = Object.create(Object3D.prototype), ImmediateRenderObject.prototype.constructor = ImmediateRenderObject, ImmediateRenderObject.prototype.isImmediateRenderObject = !0; const _vector$9 = new Vector3; class SpotLightHelper extends Object3D { constructor(e, t) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t; const i = new BufferGeometry, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let e = 0, t = 1, i = 32; e < i; e++, t++) { const n = e / i * Math.PI * 2, a = t / i * Math.PI * 2; r.push(Math.cos(n), Math.sin(n), 1, Math.cos(a), Math.sin(a), 1) } i.setAttribute("position", new Float32BufferAttribute(r, 3)); const n = new LineBasicMaterial({ fog: !1, toneMapped: !1 }); this.cone = new LineSegments(i, n), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateMatrixWorld(); const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle); this.cone.scale.set(t, t, e), _vector$9.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(_vector$9), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } } const _vector$a = new Vector3, _boneMatrix = new Matrix4, _matrixWorldInv = new Matrix4; class SkeletonHelper extends LineSegments { constructor(e) { const t = getBoneList(e), i = new BufferGeometry, r = [], n = [], a = new Color$1(0, 0, 1), o = new Color$1(0, 1, 0); for (let e = 0; e < t.length; e++) { const i = t[e]; i.parent && i.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), n.push(a.r, a.g, a.b), n.push(o.r, o.g, o.b)) } i.setAttribute("position", new Float32BufferAttribute(r, 3)), i.setAttribute("color", new Float32BufferAttribute(n, 3)); super(i, new LineBasicMaterial({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const t = this.bones, i = this.geometry, r = i.getAttribute("position"); _matrixWorldInv.copy(this.root.matrixWorld).invert(); for (let e = 0, i = 0; e < t.length; e++) { const n = t[e]; n.parent && n.parent.isBone && (_boneMatrix.multiplyMatrices(_matrixWorldInv, n.matrixWorld), _vector$a.setFromMatrixPosition(_boneMatrix), r.setXYZ(i, _vector$a.x, _vector$a.y, _vector$a.z), _boneMatrix.multiplyMatrices(_matrixWorldInv, n.parent.matrixWorld), _vector$a.setFromMatrixPosition(_boneMatrix), r.setXYZ(i + 1, _vector$a.x, _vector$a.y, _vector$a.z), i += 2) } i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } } function getBoneList(e) { const t = []; e && e.isBone && t.push(e); for (let i = 0; i < e.children.length; i++)t.push.apply(t, getBoneList(e.children[i])); return t } class PointLightHelper extends Mesh { constructor(e, t, i) { super(new SphereGeometry(t, 4, 2), new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 })), this.light = e, this.light.updateMatrixWorld(), this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } } const _vector$b = new Vector3, _color1 = new Color$1, _color2 = new Color$1; class HemisphereLightHelper extends Object3D { constructor(e, t, i) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i; const r = new OctahedronGeometry(t); r.rotateY(.5 * Math.PI), this.material = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === this.color && (this.material.vertexColors = !0); const n = r.getAttribute("position"), a = new Float32Array(3 * n.count); r.setAttribute("color", new BufferAttribute(a, 3)), this.add(new Mesh(r, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const e = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { const t = e.geometry.getAttribute("color"); _color1.copy(this.light.color), _color2.copy(this.light.groundColor); for (let e = 0, i = t.count; e < i; e++) { const r = e < i / 2 ? _color1 : _color2; t.setXYZ(e, r.r, r.g, r.b) } t.needsUpdate = !0 } e.lookAt(_vector$b.setFromMatrixPosition(this.light.matrixWorld).negate()) } } class GridHelper extends LineSegments { constructor(e = 10, t = 10, i = 4473924, r = 8947848) { i = new Color$1(i), r = new Color$1(r); const n = t / 2, a = e / t, o = e / 2, s = [], l = []; for (let e = 0, c = 0, h = -o; e <= t; e++, h += a) { s.push(-o, 0, h, o, 0, h), s.push(h, 0, -o, h, 0, o); const t = e === n ? i : r; t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3, t.toArray(l, c), c += 3 } const c = new BufferGeometry; c.setAttribute("position", new Float32BufferAttribute(s, 3)), c.setAttribute("color", new Float32BufferAttribute(l, 3)); super(c, new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper" } } class PolarGridHelper extends LineSegments { constructor(e = 10, t = 16, i = 8, r = 64, n = 4473924, a = 8947848) { n = new Color$1(n), a = new Color$1(a); const o = [], s = []; for (let i = 0; i <= t; i++) { const r = i / t * (2 * Math.PI), l = Math.sin(r) * e, c = Math.cos(r) * e; o.push(0, 0, 0), o.push(l, 0, c); const h = 1 & i ? n : a; s.push(h.r, h.g, h.b), s.push(h.r, h.g, h.b) } for (let t = 0; t <= i; t++) { const l = 1 & t ? n : a, c = e - e / i * t; for (let e = 0; e < r; e++) { let t = e / r * (2 * Math.PI), i = Math.sin(t) * c, n = Math.cos(t) * c; o.push(i, 0, n), s.push(l.r, l.g, l.b), t = (e + 1) / r * (2 * Math.PI), i = Math.sin(t) * c, n = Math.cos(t) * c, o.push(i, 0, n), s.push(l.r, l.g, l.b) } } const l = new BufferGeometry; l.setAttribute("position", new Float32BufferAttribute(o, 3)), l.setAttribute("color", new Float32BufferAttribute(s, 3)); super(l, new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 })), this.type = "PolarGridHelper" } } const _v1$6 = new Vector3, _v2$3 = new Vector3, _v3$1$1 = new Vector3; class DirectionalLightHelper$1 extends Object3D { constructor(e, t, i) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === t && (t = 1); let r = new BufferGeometry; r.setAttribute("position", new Float32BufferAttribute([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); const n = new LineBasicMaterial({ fog: !1, toneMapped: !1 }); this.lightPlane = new Line(r, n), this.add(this.lightPlane), r = new BufferGeometry, r.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Line(r, n), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { _v1$6.setFromMatrixPosition(this.light.matrixWorld), _v2$3.setFromMatrixPosition(this.light.target.matrixWorld), _v3$1$1.subVectors(_v2$3, _v1$6), this.lightPlane.lookAt(_v2$3), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(_v2$3), this.targetLine.scale.z = _v3$1$1.length() } } const _vector$c = new Vector3, _camera$1 = new Camera$1$1; class CameraHelper$1 extends LineSegments { constructor(e) { const t = new BufferGeometry, i = new LineBasicMaterial({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], n = [], a = {}, o = new Color$1(16755200), s = new Color$1(16711680), l = new Color$1(43775), c = new Color$1(16777215), h = new Color$1(3355443); function u(e, t, i) { d(e, i), d(t, i) } function d(e, t) { r.push(0, 0, 0), n.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(r.length / 3 - 1) } u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u("f2", "f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2", o), u("n3", "f3", o), u("n4", "f4", o), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), t.setAttribute("position", new Float32BufferAttribute(r, 3)), t.setAttribute("color", new Float32BufferAttribute(n, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update() } update() { const e = this.geometry, t = this.pointMap; _camera$1.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), setPoint$1("c", t, e, _camera$1, 0, 0, -1), setPoint$1("t", t, e, _camera$1, 0, 0, 1), setPoint$1("n1", t, e, _camera$1, -1, -1, -1), setPoint$1("n2", t, e, _camera$1, 1, -1, -1), setPoint$1("n3", t, e, _camera$1, -1, 1, -1), setPoint$1("n4", t, e, _camera$1, 1, 1, -1), setPoint$1("f1", t, e, _camera$1, -1, -1, 1), setPoint$1("f2", t, e, _camera$1, 1, -1, 1), setPoint$1("f3", t, e, _camera$1, -1, 1, 1), setPoint$1("f4", t, e, _camera$1, 1, 1, 1), setPoint$1("u1", t, e, _camera$1, .7, 1.1, -1), setPoint$1("u2", t, e, _camera$1, -.7, 1.1, -1), setPoint$1("u3", t, e, _camera$1, 0, 2, -1), setPoint$1("cf1", t, e, _camera$1, -1, 0, 1), setPoint$1("cf2", t, e, _camera$1, 1, 0, 1), setPoint$1("cf3", t, e, _camera$1, 0, -1, 1), setPoint$1("cf4", t, e, _camera$1, 0, 1, 1), setPoint$1("cn1", t, e, _camera$1, -1, 0, -1), setPoint$1("cn2", t, e, _camera$1, 1, 0, -1), setPoint$1("cn3", t, e, _camera$1, 0, -1, -1), setPoint$1("cn4", t, e, _camera$1, 0, 1, -1), e.getAttribute("position").needsUpdate = !0 } } function setPoint$1(e, t, i, r, n, a, o) { _vector$c.set(n, a, o).unproject(r); const s = t[e]; if (void 0 !== s) { const e = i.getAttribute("position"); for (let t = 0, i = s.length; t < i; t++)e.setXYZ(s[t], _vector$c.x, _vector$c.y, _vector$c.z) } } const _box$3 = new Box3; class BoxHelper extends LineSegments { constructor(e, t = 16776960) { const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(24), n = new BufferGeometry; n.setIndex(new BufferAttribute(i, 1)), n.setAttribute("position", new BufferAttribute(r, 3)), super(n, new LineBasicMaterial({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update(e) { if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && _box$3.setFromObject(this.object), _box$3.isEmpty()) return; const t = _box$3.min, i = _box$3.max, r = this.geometry.attributes.position, n = r.array; n[0] = i.x, n[1] = i.y, n[2] = i.z, n[3] = t.x, n[4] = i.y, n[5] = i.z, n[6] = t.x, n[7] = t.y, n[8] = i.z, n[9] = i.x, n[10] = t.y, n[11] = i.z, n[12] = i.x, n[13] = i.y, n[14] = t.z, n[15] = t.x, n[16] = i.y, n[17] = t.z, n[18] = t.x, n[19] = t.y, n[20] = t.z, n[21] = i.x, n[22] = t.y, n[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere() } setFromObject(e) { return this.object = e, this.update(), this } copy(e) { return LineSegments.prototype.copy.call(this, e), this.object = e.object, this } } class Box3Helper extends LineSegments { constructor(e, t = 16776960) { const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new BufferGeometry; r.setIndex(new BufferAttribute(i, 1)), r.setAttribute("position", new Float32BufferAttribute([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new LineBasicMaterial({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { const t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } } class PlaneHelper extends Line { constructor(e, t = 1, i = 16776960) { const r = i, n = new BufferGeometry; n.setAttribute("position", new Float32BufferAttribute([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), n.computeBoundingSphere(), super(n, new LineBasicMaterial({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t; const a = new BufferGeometry; a.setAttribute("position", new Float32BufferAttribute([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new Mesh(a, new MeshBasicMaterial({ color: r, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { let t = -this.plane.constant; Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? BackSide : FrontSide, this.lookAt(this.plane.normal), super.updateMatrixWorld(e) } } const _axis = new Vector3; let _lineGeometry, _coneGeometry; class ArrowHelper extends Object3D { constructor(e = new Vector3(0, 0, 1), t = new Vector3(0, 0, 0), i = 1, r = 16776960, n = .2 * i, a = .2 * n) { super(), this.type = "ArrowHelper", void 0 === _lineGeometry && (_lineGeometry = new BufferGeometry, _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)), _coneGeometry = new CylinderGeometry(0, .5, 1, 5, 1), _coneGeometry.translate(0, -.5, 0)), this.position.copy(t), this.line = new Line(_lineGeometry, new LineBasicMaterial({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, n, a) } setDirection(e) { if (e.y > .99999) this.quaternion.set(0, 0, 0, 1); else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0); else { _axis.set(e.z, 0, -e.x).normalize(); const t = Math.acos(e.y); this.quaternion.setFromAxisAngle(_axis, t) } } setLength(e, t = .2 * e, i = .2 * t) { this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } } class AxesHelper extends LineSegments { constructor(e = 1) { const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], i = new BufferGeometry; i.setAttribute("position", new Float32BufferAttribute(t, 3)), i.setAttribute("color", new Float32BufferAttribute([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)); super(i, new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 })), this.type = "AxesHelper" } } const _floatView = new Float32Array(1), _int32View = new Int32Array(_floatView.buffer), DataUtils = { toHalfFloat: function (e) { _floatView[0] = e; const t = _int32View[0]; let i = t >> 16 & 32768, r = t >> 12 & 2047; const n = t >> 23 & 255; return n < 103 ? i : n > 142 ? (i |= 31744, i |= (255 == n ? 0 : 1) && 8388607 & t, i) : n < 113 ? (r |= 2048, i |= (r >> 114 - n) + (r >> 113 - n & 1), i) : (i |= n - 112 << 10 | r >> 1, i += 1 & r, i) } }, LOD_MIN = 4, LOD_MAX = 8, SIZE_MAX = Math.pow(2, LOD_MAX), EXTRA_LOD_SIGMA = [.125, .215, .35, .446, .526, .582], TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length, MAX_SAMPLES = 20, ENCODINGS = { [LinearEncoding]: 0, [sRGBEncoding]: 1, [RGBEEncoding]: 2, [RGBM7Encoding]: 3, [RGBM16Encoding]: 4, [RGBDEncoding]: 5, [GammaEncoding]: 6 }, backgroundMaterial = new MeshBasicMaterial({ side: BackSide, depthWrite: !1, depthTest: !1 }), backgroundBox = new Mesh(new BoxGeometry, backgroundMaterial), _flatCamera = new OrthographicCamera, { _lodPlanes: _lodPlanes, _sizeLods: _sizeLods, _sigmas: _sigmas } = _createPlanes(), _clearColor = new Color$1; let _oldTarget = null; const PHI = (1 + Math.sqrt(5)) / 2, INV_PHI = 1 / PHI, _axisDirections = [new Vector3(1, 1, 1), new Vector3(-1, 1, 1), new Vector3(1, 1, -1), new Vector3(-1, 1, -1), new Vector3(0, PHI, INV_PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(-INV_PHI, 0, PHI), new Vector3(PHI, INV_PHI, 0), new Vector3(-PHI, INV_PHI, 0)]; function convertLinearToRGBE(e) { const t = Math.max(e.r, e.g, e.b), i = Math.min(Math.max(Math.ceil(Math.log2(t)), -128), 127); e.multiplyScalar(Math.pow(2, -i)); return (i + 128) / 255 } class PMREMGenerator { constructor(e) { this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = _getBlurShader(MAX_SAMPLES), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial) } fromScene(e, t = 0, i = .1, r = 100) { _oldTarget = this._renderer.getRenderTarget(); const n = this._allocateTargets(); return this._sceneToCubeUV(e, i, r, n), t > 0 && this._blur(n, 0, 0, t), this._applyPMREM(n), this._cleanup(n), n } fromEquirectangular(e, t, i) { return this._fromTexture(e, t, i) } fromCubemap(e, t) { return this._fromTexture(e, t) } compileCubemapShader() { null === this._cubemapShader && (this._cubemapShader = _getCubemapShader(), this._compileMaterial(this._cubemapShader)) } compileEquirectangularShader() { null === this._equirectShader && (this._equirectShader = _getEquirectShader(), this._compileMaterial(this._equirectShader)) } dispose() { this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose(); for (let e = 0; e < _lodPlanes.length; e++)_lodPlanes[e].dispose() } _cleanup(e) { this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(_oldTarget), e.scissorTest = !1, _setViewport(e, 0, 0, e.width, e.height) } _fromTexture(e, t, i) { _oldTarget = this._renderer.getRenderTarget(); const r = this._allocateTargets(e); return this._textureToCubeUV(e, r, t, i), this._applyPMREM(r), this._cleanup(r), r } _allocateTargets(e) { const t = { magFilter: NearestFilter, minFilter: NearestFilter, generateMipmaps: !1, type: UnsignedByteType, format: RGBEFormat, encoding: _isLDR(e) ? e.encoding : RGBEEncoding, depthBuffer: !1 }, i = _createRenderTarget(t); return i.depthBuffer = !e, this._pingPongRenderTarget = _createRenderTarget(t), i } _compileMaterial(e) { const t = new Mesh(_lodPlanes[0], e); this._renderer.compile(t, _flatCamera) } _sceneToCubeUV(e, t, i, r) { const n = new PerspectiveCamera(90, 1, t, i), a = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], s = this._renderer, l = s.autoClear, c = s.outputEncoding, h = s.toneMapping; s.getClearColor(_clearColor), s.toneMapping = NoToneMapping, s.outputEncoding = LinearEncoding, s.autoClear = !1; let u = !1; const d = e.background; if (d) { if (d.isColor) { backgroundMaterial.color.copy(d).convertSRGBToLinear(), e.background = null; const t = convertLinearToRGBE(backgroundMaterial.color); backgroundMaterial.opacity = t, u = !0 } } else { backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear(); const e = convertLinearToRGBE(backgroundMaterial.color); backgroundMaterial.opacity = e, u = !0 } for (let t = 0; t < 6; t++) { const i = t % 3; 0 == i ? (n.up.set(0, a[t], 0), n.lookAt(o[t], 0, 0)) : 1 == i ? (n.up.set(0, 0, a[t]), n.lookAt(0, o[t], 0)) : (n.up.set(0, a[t], 0), n.lookAt(0, 0, o[t])), _setViewport(r, i * SIZE_MAX, t > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX), s.setRenderTarget(r), u && s.render(backgroundBox, n), s.render(e, n) } s.toneMapping = h, s.outputEncoding = c, s.autoClear = l } _textureToCubeUV(e, t, i, r) { const n = this._renderer; e.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = _getCubemapShader()) : null == this._equirectShader && (this._equirectShader = _getEquirectShader()); const a = e.isCubeTexture ? this._cubemapShader : this._equirectShader, o = new Mesh(_lodPlanes[0], a), s = a.uniforms; s.envMap.value = e, "number" == typeof i && (s.cubeMapRotationY.value = i), "number" == typeof r && (s.cubeMapIntensity.value = r), e.isCubeTexture || s.texelSize.value.set(1 / e.image.width, 1 / e.image.height), s.inputEncoding.value = ENCODINGS[e.encoding], s.outputEncoding.value = ENCODINGS[t.texture.encoding], _setViewport(t, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX), n.setRenderTarget(t), n.render(o, _flatCamera) } _applyPMREM(e) { const t = this._renderer, i = t.autoClear; t.autoClear = !1; for (let t = 1; t < TOTAL_LODS; t++) { const i = Math.sqrt(_sigmas[t] * _sigmas[t] - _sigmas[t - 1] * _sigmas[t - 1]), r = _axisDirections[(t - 1) % _axisDirections.length]; this._blur(e, t - 1, t, i, r) } t.autoClear = i } _blur(e, t, i, r, n) { const a = this._pingPongRenderTarget; this._halfBlur(e, a, t, i, r, "latitudinal", n), this._halfBlur(a, e, i, i, r, "longitudinal", n) } _halfBlur(e, t, i, r, n, a, o) { const s = this._renderer, l = this._blurMaterial; "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!"); const c = new Mesh(_lodPlanes[r], l), h = l.uniforms, u = _sizeLods[i] - 1, d = isFinite(n) ? Math.PI / (2 * u) : 2 * Math.PI / (2 * MAX_SAMPLES - 1), p = n / d, f = isFinite(n) ? 1 + Math.floor(3 * p) : MAX_SAMPLES; f > MAX_SAMPLES && console.warn(`sigmaRadians, ${n}, is too large and will clip, as it requested ${f} samples when the maximum is set to ${MAX_SAMPLES}`); const m = []; let g = 0; for (let e = 0; e < MAX_SAMPLES; ++e) { const t = e / p, i = Math.exp(-t * t / 2); m.push(i), 0 == e ? g += i : e < f && (g += 2 * i) } for (let e = 0; e < m.length; e++)m[e] = m[e] / g; h.envMap.value = e.texture, h.samples.value = f, h.weights.value = m, h.latitudinal.value = "latitudinal" === a, o && (h.poleAxis.value = o), h.dTheta.value = d, h.mipInt.value = LOD_MAX - i, h.inputEncoding.value = ENCODINGS[e.texture.encoding], h.outputEncoding.value = ENCODINGS[e.texture.encoding]; const y = _sizeLods[r]; _setViewport(t, 3 * Math.max(0, SIZE_MAX - 2 * y), (0 === r ? 0 : 2 * SIZE_MAX) + 2 * y * (r > LOD_MAX - LOD_MIN ? r - LOD_MAX + LOD_MIN : 0), 3 * y, 2 * y), s.setRenderTarget(t), s.render(c, _flatCamera) } } function _isLDR(e) { return void 0 !== e && e.type === UnsignedByteType && (e.encoding === LinearEncoding || e.encoding === sRGBEncoding || e.encoding === GammaEncoding) } function _createPlanes() { const e = [], t = [], i = []; let r = LOD_MAX; for (let n = 0; n < TOTAL_LODS; n++) { const a = Math.pow(2, r); t.push(a); let o = 1 / a; n > LOD_MAX - LOD_MIN ? o = EXTRA_LOD_SIGMA[n - LOD_MAX + LOD_MIN - 1] : 0 == n && (o = 0), i.push(o); const s = 1 / (a - 1), l = -s / 2, c = 1 + s / 2, h = [l, l, c, l, c, c, l, l, c, c, l, c], u = 6, d = 6, p = 3, f = 2, m = 1, g = new Float32Array(p * d * u), y = new Float32Array(f * d * u), v = new Float32Array(m * d * u); for (let e = 0; e < u; e++) { const t = e % 3 * 2 / 3 - 1, i = e > 2 ? 0 : -1, r = [t, i, 0, t + 2 / 3, i, 0, t + 2 / 3, i + 1, 0, t, i, 0, t + 2 / 3, i + 1, 0, t, i + 1, 0]; g.set(r, p * d * e), y.set(h, f * d * e); const n = [e, e, e, e, e, e]; v.set(n, m * d * e) } const _ = new BufferGeometry; _.setAttribute("position", new BufferAttribute(g, p)), _.setAttribute("uv", new BufferAttribute(y, f)), _.setAttribute("faceIndex", new BufferAttribute(v, m)), e.push(_), r > LOD_MIN && r-- } return { _lodPlanes: e, _sizeLods: t, _sigmas: i } } function _createRenderTarget(e) { const t = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, e); return t.texture.mapping = CubeUVReflectionMapping, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t } function _setViewport(e, t, i, r, n) { e.viewport.set(t, i, r, n), e.scissor.set(t, i, r, n) } function _getBlurShader(e) { const t = new Float32Array(e), i = new Vector3(0, 1, 0); return new RawShaderMaterial({ name: "SphericalGaussianBlur", defines: { n: e }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: t }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: i }, inputEncoding: { value: ENCODINGS[LinearEncoding] }, outputEncoding: { value: ENCODINGS[LinearEncoding] } }, vertexShader: _getCommonVertexShader(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: NoBlending, depthTest: !1, depthWrite: !1 }) } function _getEquirectShader() { const e = new Vector2(1, 1); return new RawShaderMaterial({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: e }, inputEncoding: { value: ENCODINGS[LinearEncoding] }, outputEncoding: { value: ENCODINGS[LinearEncoding] }, cubeMapRotationY: { value: 0 }, cubeMapIntensity: { value: 1 } }, vertexShader: _getCommonVertexShader(), fragmentShader: `\n\n\t\t\tprecision highp float;\n\t\t\tprecision highp int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\t\t\tuniform float cubeMapRotationY;\n\t\t\tuniform float cubeMapIntensity;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n        uv.x += (cubeMapRotationY / 6.283185307379586);\n\n        vec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n        vec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n        gl_FragColor *= cubeMapIntensity;\n\n\t\t\t}\n\t\t\t// void main() {\n\n\t\t\t// \tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t// \tmat4 cubeMapRotateMat = mat4(cos(cubeMapRotationY), 0., -sin(cubeMapRotationY), 0.,\n\t\t\t// \t0., 1., 0., 0.,\n\t\t\t// \tsin(cubeMapRotationY), 0., cos(cubeMapRotationY),  0.,\n\t\t\t// \t0., 0., 0., 1.);\n\t\t\t// \tvec4 reflectVecRotated = vec4(vOutputDirection, 1.);\n\t\t\t// \treflectVecRotated = cubeMapRotateMat * reflectVecRotated;\n\n\t\t\t// \tvec3 outputDirection = normalize( reflectVecRotated.xyz );\n\t\t\t// \tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t// \tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t// \tuv -= f * texelSize;\n\t\t\t// \tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t// \tuv.x += texelSize.x;\n\t\t\t// \tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t// \tuv.y += texelSize.y;\n\t\t\t// \tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t// \tuv.x -= texelSize.x;\n\t\t\t// \tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t// \tvec3 tm = mix( tl, tr, f.x );\n      //   vec3 bm = mix( bl, br, f.x );\n\n\t\t\t// \t//  gl_FragColor.rgb = vec3(1.,0.,0.);\n\t\t\t// \tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t// \tgl_FragColor = linearToOutputTexel( gl_FragColor );\n      //   gl_FragColor *= cubeMapIntensity;\n\n\t\t\t// }\n\t\t`, blending: NoBlending, depthTest: !1, depthWrite: !1 }) } function _getCubemapShader() { return new RawShaderMaterial({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, cubeMapRotationY: { value: 0 }, inputEncoding: { value: ENCODINGS[LinearEncoding] }, outputEncoding: { value: ENCODINGS[LinearEncoding] } }, vertexShader: _getCommonVertexShader(), fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\t\t\tuniform float cubeMapRotationY;\n\n\t\t\t${_getEncodings()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tmat4 cubeMapRotateMat = mat4(cos(cubeMapRotationY), 0., -sin(cubeMapRotationY), 0.,\n\t\t\t\t0., 1., 0., 0.,\n\t\t\t\tsin(cubeMapRotationY), 0., cos(cubeMapRotationY),  0.,\n\t\t\t\t0., 0., 0., 1.);\n\t\t\t\tvec4 reflectVecRotated = vec4(vOutputDirection, 1.);\n\t\t\t\t reflectVecRotated = cubeMapRotateMat * reflectVecRotated;\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - reflectVecRotated.x, reflectVecRotated.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`, blending: NoBlending, depthTest: !1, depthWrite: !1 }) } function _getCommonVertexShader() { return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t" } function _getEncodings() { return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t" } const LineStrip = 0, LinePieces = 1, NoColors = 0, FaceColors = 1, VertexColors = 2; function MeshFaceMaterial(e) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e } function MultiMaterial(e = []) { return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function () { return e.slice() }, e } function PointCloud(e, t) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Points(e, t) } function Particle(e) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Sprite(e) } function ParticleSystem(e, t) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Points(e, t) } function PointCloudMaterial(e) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new PointsMaterial(e) } function ParticleBasicMaterial(e) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new PointsMaterial(e) } function ParticleSystemMaterial(e) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new PointsMaterial(e) } function Vertex(e, t, i) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Vector3(e, t, i) } function DynamicBufferAttribute(e, t) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new BufferAttribute(e, t).setUsage(DynamicDrawUsage) } function Int8Attribute(e, t) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Int8BufferAttribute(e, t) } function Uint8Attribute(e, t) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Uint8BufferAttribute(e, t) } function Uint8ClampedAttribute(e, t) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Uint8ClampedBufferAttribute(e, t) } function Int16Attribute(e, t) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Int16BufferAttribute(e, t) } function Uint16Attribute(e, t) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Uint16BufferAttribute(e, t) } function Int32Attribute(e, t) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Int32BufferAttribute(e, t) } function Uint32Attribute(e, t) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Uint32BufferAttribute(e, t) } function Float32Attribute(e, t) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Float32BufferAttribute(e, t) } function Float64Attribute(e, t) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Float64BufferAttribute(e, t) } function AxisHelper(e) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new AxesHelper(e) } function BoundingBoxHelper(e, t) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new BoxHelper(e, t) } function EdgesHelper(e, t) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new LineSegments(new EdgesGeometry(e.geometry), new LineBasicMaterial({ color: void 0 !== t ? t : 16777215 })) } function WireframeHelper(e, t) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new LineSegments(new WireframeGeometry(e.geometry), new LineBasicMaterial({ color: void 0 !== t ? t : 16777215 })) } function XHRLoader(e) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new FileLoader(e) } function BinaryTextureLoader(e) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new DataTextureLoader(e) } function WebGLRenderTargetCube(e, t, i) { return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new WebGLCubeRenderTarget(e, i) } function CanvasRenderer() { console.error("THREE.CanvasRenderer has been removed") } function JSONLoader() { console.error("THREE.JSONLoader has been removed.") } Curve.create = function (e, t) { return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Curve.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e }, Path$1.prototype.fromPoints = function (e) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e) }, GridHelper.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, SkeletonHelper.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Loader.prototype.extractUrlBase = function (e) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), LoaderUtils.extractUrlBase(e) }, Loader.Handlers = { add: function () { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function () { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, Box2.prototype.center = function (e) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e) }, Box2.prototype.empty = function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, Box2.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, Box2.prototype.size = function (e) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e) }, Box3.prototype.center = function (e) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, Box3.prototype.empty = function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, Box3.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, Box3.prototype.isIntersectionSphere = function (e) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, Box3.prototype.size = function (e) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e) }, Sphere.prototype.empty = function () { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, Frustum.prototype.setFromMatrix = function (e) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e) }, Line3.prototype.center = function (e) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, MathUtils.random16 = function () { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, MathUtils.nearestPowerOfTwo = function (e) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), MathUtils.floorPowerOfTwo(e) }, MathUtils.nextPowerOfTwo = function (e) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), MathUtils.ceilPowerOfTwo(e) }, Matrix3.prototype.flattenToArrayOffset = function (e, t) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, Matrix3.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, Matrix3.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, Matrix3.prototype.applyToBufferAttribute = function (e) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, Matrix3.prototype.applyToVector3Array = function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") }, Matrix3.prototype.getInverse = function (e) { return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert() }, Matrix4.prototype.extractPosition = function (e) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e) }, Matrix4.prototype.flattenToArrayOffset = function (e, t) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, Matrix4.prototype.getPosition = function () { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Vector3).setFromMatrixColumn(this, 3) }, Matrix4.prototype.setRotationFromQuaternion = function (e) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e) }, Matrix4.prototype.multiplyToArray = function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, Matrix4.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, Matrix4.prototype.multiplyVector4 = function (e) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, Matrix4.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, Matrix4.prototype.rotateAxis = function (e) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this) }, Matrix4.prototype.crossVector = function (e) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, Matrix4.prototype.translate = function () { console.error("THREE.Matrix4: .translate() has been removed.") }, Matrix4.prototype.rotateX = function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, Matrix4.prototype.rotateY = function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, Matrix4.prototype.rotateZ = function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, Matrix4.prototype.rotateByAxis = function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, Matrix4.prototype.applyToBufferAttribute = function (e) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, Matrix4.prototype.applyToVector3Array = function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, Matrix4.prototype.makeFrustum = function (e, t, i, r, n, a) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, i, n, a) }, Matrix4.prototype.getInverse = function (e) { return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert() }, Plane.prototype.isIntersectionLine = function (e) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e) }, Quaternion.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this) }, Quaternion.prototype.inverse = function () { return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert() }, Ray.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, Ray.prototype.isIntersectionPlane = function (e) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e) }, Ray.prototype.isIntersectionSphere = function (e) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, Triangle.prototype.area = function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, Triangle.prototype.barycoordFromPoint = function (e, t) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t) }, Triangle.prototype.midpoint = function (e) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e) }, Triangle.prototypenormal = function (e) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e) }, Triangle.prototype.plane = function (e) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e) }, Triangle.barycoordFromPoint = function (e, t, i, r, n) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Triangle.getBarycoord(e, t, i, r, n) }, Triangle.normal = function (e, t, i, r) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Triangle.getNormal(e, t, i, r) }, Shape.prototype.extractAllPoints = function (e) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e) }, Shape.prototype.extrude = function (e) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ExtrudeGeometry(this, e) }, Shape.prototype.makeGeometry = function (e) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ShapeGeometry(this, e) }, Vector2.prototype.fromAttribute = function (e, t, i) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i) }, Vector2.prototype.distanceToManhattan = function (e) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, Vector2.prototype.lengthManhattan = function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Vector3.prototype.setEulerFromRotationMatrix = function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, Vector3.prototype.setEulerFromQuaternion = function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, Vector3.prototype.getPositionFromMatrix = function (e) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e) }, Vector3.prototype.getScaleFromMatrix = function (e) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e) }, Vector3.prototype.getColumnFromMatrix = function (e, t) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e) }, Vector3.prototype.applyProjection = function (e) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e) }, Vector3.prototype.fromAttribute = function (e, t, i) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i) }, Vector3.prototype.distanceToManhattan = function (e) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, Vector3.prototype.lengthManhattan = function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Vector4.prototype.fromAttribute = function (e, t, i) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i) }, Vector4.prototype.lengthManhattan = function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Object3D.prototype.getChildByName = function (e) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e) }, Object3D.prototype.renderDepth = function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, Object3D.prototype.translate = function (e, t) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e) }, Object3D.prototype.getWorldRotation = function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, Object3D.prototype.applyMatrix = function (e) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) }, Object.defineProperties(Object3D.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (e) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Mesh.prototype.setDrawMode = function () { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") }, Object.defineProperties(Mesh.prototype, { drawMode: { get: function () { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), TrianglesDrawMode }, set: function () { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), Object.defineProperties(LOD.prototype, { objects: { get: function () { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(Skeleton.prototype, "useVertexTexture", { get: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), SkinnedMesh.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Object.defineProperty(Curve.prototype, "__arcLengthDivisions", { get: function () { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function (e) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e } }), PerspectiveCamera.prototype.setLens = function (e, t) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e) }, Object.defineProperties(Light.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (e) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e } }, shadowCameraLeft: { set: function (e) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e } }, shadowCameraRight: { set: function (e) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e } }, shadowCameraTop: { set: function (e) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e } }, shadowCameraBottom: { set: function (e) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e } }, shadowCameraNear: { set: function (e) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e } }, shadowCameraFar: { set: function (e) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (e) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (e) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e } }, shadowMapHeight: { set: function (e) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e } } }), Object.defineProperties(BufferAttribute.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function () { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === DynamicDrawUsage }, set: function () { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(DynamicDrawUsage) } } }), BufferAttribute.prototype.setDynamic = function (e) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? DynamicDrawUsage : StaticDrawUsage), this }, BufferAttribute.prototype.copyIndicesArray = function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, BufferAttribute.prototype.setArray = function () { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, BufferGeometry.prototype.addIndex = function (e) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e) }, BufferGeometry.prototype.addAttribute = function (e, t) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new BufferAttribute(arguments[1], arguments[2]))) }, BufferGeometry.prototype.addDrawCall = function (e, t, i) { void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t) }, BufferGeometry.prototype.clearDrawCalls = function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, BufferGeometry.prototype.computeOffsets = function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, BufferGeometry.prototype.removeAttribute = function (e) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e) }, BufferGeometry.prototype.applyMatrix = function (e) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) }, Object.defineProperties(BufferGeometry.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.defineProperties(InstancedBufferGeometry.prototype, { maxInstancedCount: { get: function () { return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount }, set: function (e) { console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = e } } }), Object.defineProperties(Raycaster.prototype, { linePrecision: { get: function () { return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold }, set: function (e) { console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = e } } }), Object.defineProperties(InterleavedBuffer.prototype, { dynamic: { get: function () { return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === DynamicDrawUsage }, set: function (e) { console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(e) } } }), InterleavedBuffer.prototype.setDynamic = function (e) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? DynamicDrawUsage : StaticDrawUsage), this }, InterleavedBuffer.prototype.setArray = function () { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, ExtrudeGeometry.prototype.getArrays = function () { console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.") }, ExtrudeGeometry.prototype.addShapeList = function () { console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.") }, ExtrudeGeometry.prototype.addShape = function () { console.error("THREE.ExtrudeGeometry: .addShape() has been removed.") }, Scene.prototype.dispose = function () { console.error("THREE.Scene: .dispose() has been removed.") }, Object.defineProperties(Uniform.prototype, { dynamic: { set: function () { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(Material$1.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new Color$1 } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e === FlatShading } }, stencilMask: { get: function () { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function (e) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e } } }), Object.defineProperties(MeshPhongMaterial.prototype, { metal: { get: function () { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(MeshPhysicalMaterial.prototype, { transparency: { get: function () { return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission }, set: function (e) { console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = e } } }), Object.defineProperties(ShaderMaterial.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (e) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e } } }), WebGLRenderer.prototype.clearTarget = function (e, t, i, r) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, i, r) }, WebGLRenderer.prototype.animate = function (e) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e) }, WebGLRenderer.prototype.getCurrentRenderTarget = function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, WebGLRenderer.prototype.getMaxAnisotropy = function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, WebGLRenderer.prototype.getPrecision = function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, WebGLRenderer.prototype.resetGLState = function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, WebGLRenderer.prototype.supportsFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, WebGLRenderer.prototype.supportsHalfFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, WebGLRenderer.prototype.supportsStandardDerivatives = function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, WebGLRenderer.prototype.supportsBlendMinMax = function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, WebGLRenderer.prototype.supportsVertexTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, WebGLRenderer.prototype.supportsInstancedArrays = function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, WebGLRenderer.prototype.enableScissorTest = function (e) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e) }, WebGLRenderer.prototype.initMaterial = function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, WebGLRenderer.prototype.addPrePlugin = function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, WebGLRenderer.prototype.addPostPlugin = function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, WebGLRenderer.prototype.updateShadowMap = function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, WebGLRenderer.prototype.setFaceCulling = function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, WebGLRenderer.prototype.allocTextureUnit = function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, WebGLRenderer.prototype.setTexture = function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, WebGLRenderer.prototype.setTexture2D = function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, WebGLRenderer.prototype.setTextureCube = function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, WebGLRenderer.prototype.getActiveMipMapLevel = function () { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() }, Object.defineProperties(WebGLRenderer.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function () { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function () { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function (e) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? sRGBEncoding : LinearEncoding } }, toneMappingWhitePoint: { get: function () { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function () { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(WebGLShadowMap.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(WebGLRenderTarget.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e } } }), Object.defineProperties(Audio.prototype, { load: { value: function (e) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const t = this; return (new AudioLoader).load(e, (function (e) { t.setBuffer(e) })), this } }, startTime: { set: function () { console.warn("THREE.Audio: .startTime is now .play( delay ).") } } }), AudioAnalyser.prototype.getData = function () { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, CubeCamera.prototype.updateCubeMap = function (e, t) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t) }, CubeCamera.prototype.clear = function (e, t, i, r) { return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e, t, i, r) }, ImageUtils.crossOrigin = void 0, ImageUtils.loadTexture = function (e, t, i, r) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); const n = new TextureLoader; n.setCrossOrigin(this.crossOrigin); const a = n.load(e, i, void 0, r); return t && (a.mapping = t), a }, ImageUtils.loadTextureCube = function (e, t, i, r) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); const n = new CubeTextureLoader; n.setCrossOrigin(this.crossOrigin); const a = n.load(e, i, void 0, r); return t && (a.mapping = t), a }, ImageUtils.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, ImageUtils.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }; const SceneUtils = { createMultiMaterialObject: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, detach: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, attach: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") } }; function LensFlare() { console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js") } "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: REVISION } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = REVISION); var THREE = Object.freeze({ __proto__: null, ACESFilmicToneMapping: ACESFilmicToneMapping, AddEquation: AddEquation, AddOperation: AddOperation, AdditiveAnimationBlendMode: AdditiveAnimationBlendMode, AdditiveBlending: AdditiveBlending, AlphaFormat: AlphaFormat, AlwaysDepth: AlwaysDepth, AlwaysStencilFunc: AlwaysStencilFunc, AmbientLight: AmbientLight, AmbientLightProbe: AmbientLightProbe, AnimationClip: AnimationClip, AnimationLoader: AnimationLoader, AnimationMixer: AnimationMixer, AnimationObjectGroup: AnimationObjectGroup, AnimationUtils: AnimationUtils, ArcCurve: ArcCurve, ArrayCamera: ArrayCamera, ArrowHelper: ArrowHelper, Audio: Audio, AudioAnalyser: AudioAnalyser, AudioContext: AudioContext, AudioListener: AudioListener, AudioLoader: AudioLoader, AxesHelper: AxesHelper, AxisHelper: AxisHelper, BackSide: BackSide, BasicDepthPacking: BasicDepthPacking, BasicShadowMap: BasicShadowMap, BinaryTextureLoader: BinaryTextureLoader, Bone: Bone, BooleanKeyframeTrack: BooleanKeyframeTrack, BoundingBoxHelper: BoundingBoxHelper, Box2: Box2, Box3: Box3, Box3Helper: Box3Helper, BoxBufferGeometry: BoxGeometry, BoxGeometry: BoxGeometry, BoxHelper: BoxHelper, BufferAttribute: BufferAttribute, BufferGeometry: BufferGeometry, BufferGeometryLoader: BufferGeometryLoader, ByteType: ByteType, Cache: Cache, Camera: Camera$1$1, CameraHelper: CameraHelper$1, CanvasRenderer: CanvasRenderer, CanvasTexture: CanvasTexture, CatmullRomCurve3: CatmullRomCurve3, CineonToneMapping: CineonToneMapping, CircleBufferGeometry: CircleGeometry, CircleGeometry: CircleGeometry, ClampToEdgeWrapping: ClampToEdgeWrapping, Clock: Clock, Color: Color$1, ColorKeyframeTrack: ColorKeyframeTrack, CompressedTexture: CompressedTexture, CompressedTextureLoader: CompressedTextureLoader, ConeBufferGeometry: ConeGeometry, ConeGeometry: ConeGeometry, CubeCamera: CubeCamera, CubeReflectionMapping: CubeReflectionMapping, CubeRefractionMapping: CubeRefractionMapping, CubeTexture: CubeTexture, CubeTextureLoader: CubeTextureLoader, CubeUVReflectionMapping: CubeUVReflectionMapping, CubeUVRefractionMapping: CubeUVRefractionMapping, CubicBezierCurve: CubicBezierCurve, CubicBezierCurve3: CubicBezierCurve3, CubicInterpolant: CubicInterpolant, CullFaceBack: CullFaceBack, CullFaceFront: CullFaceFront, CullFaceFrontBack: CullFaceFrontBack, CullFaceNone: CullFaceNone, Curve: Curve, CurvePath: CurvePath, CustomBlending: CustomBlending, CustomToneMapping: CustomToneMapping, CylinderBufferGeometry: CylinderGeometry, CylinderGeometry: CylinderGeometry, Cylindrical: Cylindrical, DataTexture: DataTexture, DataTexture2DArray: DataTexture2DArray, DataTexture3D: DataTexture3D, DataTextureLoader: DataTextureLoader, DataUtils: DataUtils, DecrementStencilOp: DecrementStencilOp, DecrementWrapStencilOp: DecrementWrapStencilOp, DefaultLoadingManager: DefaultLoadingManager, DepthFormat: DepthFormat, DepthStencilFormat: DepthStencilFormat, DepthTexture: DepthTexture, DirectionalLight: DirectionalLight, DirectionalLightHelper: DirectionalLightHelper$1, DiscreteInterpolant: DiscreteInterpolant, DodecahedronBufferGeometry: DodecahedronGeometry, DodecahedronGeometry: DodecahedronGeometry, DoubleSide: DoubleSide, DstAlphaFactor: DstAlphaFactor, DstColorFactor: DstColorFactor, DynamicBufferAttribute: DynamicBufferAttribute, DynamicCopyUsage: DynamicCopyUsage, DynamicDrawUsage: DynamicDrawUsage, DynamicReadUsage: DynamicReadUsage, EdgesGeometry: EdgesGeometry, EdgesHelper: EdgesHelper, EllipseCurve: EllipseCurve, EqualDepth: EqualDepth, EqualStencilFunc: EqualStencilFunc, EquirectangularReflectionMapping: EquirectangularReflectionMapping, EquirectangularRefractionMapping: EquirectangularRefractionMapping, Euler: Euler, EventDispatcher: EventDispatcher, ExtrudeBufferGeometry: ExtrudeGeometry, ExtrudeGeometry: ExtrudeGeometry, FaceColors: FaceColors, FileLoader: FileLoader, FlatShading: FlatShading, Float16BufferAttribute: Float16BufferAttribute, Float32Attribute: Float32Attribute, Float32BufferAttribute: Float32BufferAttribute, Float64Attribute: Float64Attribute, Float64BufferAttribute: Float64BufferAttribute, FloatType: FloatType, Fog: Fog, FogExp2: FogExp2, Font: Font, FontLoader: FontLoader, FrontSide: FrontSide, Frustum: Frustum, GLBufferAttribute: GLBufferAttribute, GLSL1: GLSL1, GLSL3: GLSL3, GammaEncoding: GammaEncoding, GreaterDepth: GreaterDepth, GreaterEqualDepth: GreaterEqualDepth, GreaterEqualStencilFunc: GreaterEqualStencilFunc, GreaterStencilFunc: GreaterStencilFunc, GridHelper: GridHelper, Group: Group, HalfFloatType: HalfFloatType, HemisphereLight: HemisphereLight, HemisphereLightHelper: HemisphereLightHelper, HemisphereLightProbe: HemisphereLightProbe, IcosahedronBufferGeometry: IcosahedronGeometry, IcosahedronGeometry: IcosahedronGeometry, ImageBitMapCache: ImageBitMapCache, ImageBitmapLoader: ImageBitmapLoader, ImageLoader: ImageLoader$2, ImageUtils: ImageUtils, ImmediateRenderObject: ImmediateRenderObject, IncrementStencilOp: IncrementStencilOp, IncrementWrapStencilOp: IncrementWrapStencilOp, InstancedBufferAttribute: InstancedBufferAttribute, InstancedBufferGeometry: InstancedBufferGeometry, InstancedInterleavedBuffer: InstancedInterleavedBuffer, InstancedMesh: InstancedMesh, Int16Attribute: Int16Attribute, Int16BufferAttribute: Int16BufferAttribute, Int32Attribute: Int32Attribute, Int32BufferAttribute: Int32BufferAttribute, Int8Attribute: Int8Attribute, Int8BufferAttribute: Int8BufferAttribute, IntType: IntType, InterleavedBuffer: InterleavedBuffer, InterleavedBufferAttribute: InterleavedBufferAttribute, Interpolant: Interpolant, InterpolateDiscrete: InterpolateDiscrete, InterpolateLinear: InterpolateLinear, InterpolateSmooth: InterpolateSmooth, InvertStencilOp: InvertStencilOp, JSONLoader: JSONLoader, KeepStencilOp: KeepStencilOp, KeyframeTrack: KeyframeTrack, LOD: LOD, LatheBufferGeometry: LatheGeometry, LatheGeometry: LatheGeometry, Layers: Layers, LensFlare: LensFlare, LessDepth: LessDepth, LessEqualDepth: LessEqualDepth, LessEqualStencilFunc: LessEqualStencilFunc, LessStencilFunc: LessStencilFunc, Light: Light, LightProbe: LightProbe, Line: Line, Line3: Line3, LineBasicMaterial: LineBasicMaterial, LineCurve: LineCurve, LineCurve3: LineCurve3, LineDashedMaterial: LineDashedMaterial, LineLoop: LineLoop, LinePieces: LinePieces, LineSegments: LineSegments, LineStrip: LineStrip, LinearEncoding: LinearEncoding, LinearFilter: LinearFilter, LinearInterpolant: LinearInterpolant, LinearMipMapLinearFilter: LinearMipMapLinearFilter, LinearMipMapNearestFilter: LinearMipMapNearestFilter, LinearMipmapLinearFilter: LinearMipmapLinearFilter, LinearMipmapNearestFilter: LinearMipmapNearestFilter, LinearToneMapping: LinearToneMapping, Loader: Loader, LoaderUtils: LoaderUtils, LoadingManager: LoadingManager, LogLuvEncoding: LogLuvEncoding, LoopOnce: LoopOnce, LoopPingPong: LoopPingPong, LoopRepeat: LoopRepeat, LuminanceAlphaFormat: LuminanceAlphaFormat, LuminanceFormat: LuminanceFormat, MOUSE: MOUSE, Material: Material$1, MaterialLoader: MaterialLoader, Math: MathUtils, MathUtils: MathUtils, Matrix3: Matrix3, Matrix4: Matrix4, MaxEquation: MaxEquation, Mesh: Mesh, MeshBasicMaterial: MeshBasicMaterial, MeshDepthMaterial: MeshDepthMaterial, MeshDistanceMaterial: MeshDistanceMaterial, MeshFaceMaterial: MeshFaceMaterial, MeshLambertMaterial: MeshLambertMaterial, MeshMatcapMaterial: MeshMatcapMaterial, MeshNormalMaterial: MeshNormalMaterial, MeshPhongMaterial: MeshPhongMaterial, MeshPhysicalMaterial: MeshPhysicalMaterial, MeshStandardMaterial: MeshStandardMaterial, MeshToonMaterial: MeshToonMaterial, MinEquation: MinEquation, MirroredRepeatWrapping: MirroredRepeatWrapping, MixOperation: MixOperation, MultiMaterial: MultiMaterial, MultiplyBlending: MultiplyBlending, MultiplyOperation: MultiplyOperation, NearestFilter: NearestFilter, NearestMipMapLinearFilter: NearestMipMapLinearFilter, NearestMipMapNearestFilter: NearestMipMapNearestFilter, NearestMipmapLinearFilter: NearestMipmapLinearFilter, NearestMipmapNearestFilter: NearestMipmapNearestFilter, NeverDepth: NeverDepth, NeverStencilFunc: NeverStencilFunc, NoBlending: NoBlending, NoColors: NoColors, NoToneMapping: NoToneMapping, NormalAnimationBlendMode: NormalAnimationBlendMode, NormalBlending: NormalBlending, NotEqualDepth: NotEqualDepth, NotEqualStencilFunc: NotEqualStencilFunc, NumberKeyframeTrack: NumberKeyframeTrack, Object3D: Object3D, ObjectLoader: ObjectLoader, ObjectSpaceNormalMap: ObjectSpaceNormalMap, OctahedronBufferGeometry: OctahedronGeometry, OctahedronGeometry: OctahedronGeometry, OneFactor: OneFactor, OneMinusDstAlphaFactor: OneMinusDstAlphaFactor, OneMinusDstColorFactor: OneMinusDstColorFactor, OneMinusSrcAlphaFactor: OneMinusSrcAlphaFactor, OneMinusSrcColorFactor: OneMinusSrcColorFactor, OrthographicCamera: OrthographicCamera, PCFShadowMap: PCFShadowMap, PCFSoftShadowMap: PCFSoftShadowMap, PMREMGenerator: PMREMGenerator, ParametricBufferGeometry: ParametricGeometry, ParametricGeometry: ParametricGeometry, Particle: Particle, ParticleBasicMaterial: ParticleBasicMaterial, ParticleSystem: ParticleSystem, ParticleSystemMaterial: ParticleSystemMaterial, Path: Path$1, PerspectiveCamera: PerspectiveCamera, Plane: Plane, PlaneBufferGeometry: PlaneGeometry, PlaneGeometry: PlaneGeometry, PlaneHelper: PlaneHelper, PointCloud: PointCloud, PointCloudMaterial: PointCloudMaterial, PointLight: PointLight, PointLightHelper: PointLightHelper, Points: Points, PointsMaterial: PointsMaterial, PolarGridHelper: PolarGridHelper, PolyhedronBufferGeometry: PolyhedronGeometry, PolyhedronGeometry: PolyhedronGeometry, PositionalAudio: PositionalAudio, PropertyBinding: PropertyBinding, PropertyMixer: PropertyMixer, QuadraticBezierCurve: QuadraticBezierCurve, QuadraticBezierCurve3: QuadraticBezierCurve3, Quaternion: Quaternion, QuaternionKeyframeTrack: QuaternionKeyframeTrack, QuaternionLinearInterpolant: QuaternionLinearInterpolant, REVISION: REVISION, RGBADepthPacking: RGBADepthPacking, RGBAFormat: RGBAFormat, RGBAIntegerFormat: RGBAIntegerFormat, RGBA_ASTC_10x10_Format: RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format: RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format: RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format: RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format: RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format: RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format: RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format: RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format: RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format: RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format: RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format: RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format: RGBA_ASTC_8x8_Format, RGBA_BPTC_Format: RGBA_BPTC_Format, RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format: RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format: RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format: RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format, RGBDEncoding: RGBDEncoding, RGBEEncoding: RGBEEncoding, RGBEFormat: RGBEFormat, RGBFormat: RGBFormat, RGBIntegerFormat: RGBIntegerFormat, RGBM16Encoding: RGBM16Encoding, RGBM7Encoding: RGBM7Encoding, RGB_ETC1_Format: RGB_ETC1_Format, RGB_ETC2_Format: RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format: RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format, RGFormat: RGFormat, RGIntegerFormat: RGIntegerFormat, RawShaderMaterial: RawShaderMaterial, Ray: Ray, Raycaster: Raycaster, RectAreaLight: RectAreaLight, RedFormat: RedFormat, RedIntegerFormat: RedIntegerFormat, ReinhardToneMapping: ReinhardToneMapping, RepeatWrapping: RepeatWrapping, ReplaceStencilOp: ReplaceStencilOp, ReverseSubtractEquation: ReverseSubtractEquation, RingBufferGeometry: RingGeometry, RingGeometry: RingGeometry, SRGB8_ALPHA8_ASTC_10x10_Format: SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_10x5_Format: SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format: SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format: SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_12x10_Format: SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format: SRGB8_ALPHA8_ASTC_12x12_Format, SRGB8_ALPHA8_ASTC_4x4_Format: SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format: SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format: SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format: SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format: SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format: SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format: SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format: SRGB8_ALPHA8_ASTC_8x8_Format, Scene: Scene, SceneUtils: SceneUtils, ShaderChunk: ShaderChunk, ShaderLib: ShaderLib, ShaderMaterial: ShaderMaterial, ShadowMaterial: ShadowMaterial, Shape: Shape, ShapeBufferGeometry: ShapeGeometry, ShapeGeometry: ShapeGeometry, ShapePath: ShapePath, ShapeUtils: ShapeUtils, ShortType: ShortType, Skeleton: Skeleton, SkeletonHelper: SkeletonHelper, SkinnedMesh: SkinnedMesh, SmoothShading: SmoothShading, Sphere: Sphere, SphereBufferGeometry: SphereGeometry, SphereGeometry: SphereGeometry, Spherical: Spherical, SphericalHarmonics3: SphericalHarmonics3, SplineCurve: SplineCurve, SpotLight: SpotLight, SpotLightHelper: SpotLightHelper, Sprite: Sprite, SpriteMaterial: SpriteMaterial, SrcAlphaFactor: SrcAlphaFactor, SrcAlphaSaturateFactor: SrcAlphaSaturateFactor, SrcColorFactor: SrcColorFactor, StaticCopyUsage: StaticCopyUsage, StaticDrawUsage: StaticDrawUsage, StaticReadUsage: StaticReadUsage, StereoCamera: StereoCamera, StreamCopyUsage: StreamCopyUsage, StreamDrawUsage: StreamDrawUsage, StreamReadUsage: StreamReadUsage, StringKeyframeTrack: StringKeyframeTrack, SubtractEquation: SubtractEquation, SubtractiveBlending: SubtractiveBlending, TOUCH: TOUCH, TangentSpaceNormalMap: TangentSpaceNormalMap, TetrahedronBufferGeometry: TetrahedronGeometry, TetrahedronGeometry: TetrahedronGeometry, TextBufferGeometry: TextGeometry, TextGeometry: TextGeometry, Texture: Texture$1, TextureLoader: TextureLoader, TorusBufferGeometry: TorusGeometry, TorusGeometry: TorusGeometry, TorusKnotBufferGeometry: TorusKnotGeometry, TorusKnotGeometry: TorusKnotGeometry, Triangle: Triangle, TriangleFanDrawMode: TriangleFanDrawMode, TriangleStripDrawMode: TriangleStripDrawMode, TrianglesDrawMode: TrianglesDrawMode, TubeBufferGeometry: TubeGeometry, TubeGeometry: TubeGeometry, UVMapping: UVMapping, Uint16Attribute: Uint16Attribute, Uint16BufferAttribute: Uint16BufferAttribute, Uint32Attribute: Uint32Attribute, Uint32BufferAttribute: Uint32BufferAttribute, Uint8Attribute: Uint8Attribute, Uint8BufferAttribute: Uint8BufferAttribute, Uint8ClampedAttribute: Uint8ClampedAttribute, Uint8ClampedBufferAttribute: Uint8ClampedBufferAttribute, Uniform: Uniform, UniformsLib: UniformsLib, UniformsUtils: UniformsUtils, UnsignedByteType: UnsignedByteType, UnsignedInt248Type: UnsignedInt248Type, UnsignedIntType: UnsignedIntType, UnsignedShort4444Type: UnsignedShort4444Type, UnsignedShort5551Type: UnsignedShort5551Type, UnsignedShort565Type: UnsignedShort565Type, UnsignedShortType: UnsignedShortType, VSMShadowMap: VSMShadowMap, Vector2: Vector2, Vector3: Vector3, Vector4: Vector4, VectorKeyframeTrack: VectorKeyframeTrack, Vertex: Vertex, VertexColors: VertexColors, VideoTexture: VideoTexture, WebGL1Renderer: WebGL1Renderer, WebGLCubeRenderTarget: WebGLCubeRenderTarget, WebGLMultisampleRenderTarget: WebGLMultisampleRenderTarget, WebGLRenderTarget: WebGLRenderTarget, WebGLRenderTargetCube: WebGLRenderTargetCube, WebGLRenderer: WebGLRenderer, WebGLUtils: WebGLUtils, WireframeGeometry: WireframeGeometry, WireframeHelper: WireframeHelper, WrapAroundEnding: WrapAroundEnding, XHRLoader: XHRLoader, ZeroCurvatureEnding: ZeroCurvatureEnding, ZeroFactor: ZeroFactor, ZeroSlopeEnding: ZeroSlopeEnding, ZeroStencilOp: ZeroStencilOp, sRGBEncoding: sRGBEncoding }), DDSLoader = function (e) { CompressedTextureLoader.call(this, e) }; DDSLoader.prototype = Object.assign(Object.create(CompressedTextureLoader.prototype), { constructor: DDSLoader, parse: function (e, t) { var i = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 }; function r(e) { return e.charCodeAt(0) + (e.charCodeAt(1) << 8) + (e.charCodeAt(2) << 16) + (e.charCodeAt(3) << 24) } function n(e, t, i, r) { for (var n = i * r * 4, a = new Uint8Array(e, t, n), o = new Uint8Array(n), s = 0, l = 0, c = 0; c < r; c++)for (var h = 0; h < i; h++) { var u = a[l], d = a[++l], p = a[++l], f = a[++l]; l++, o[s] = p, o[++s] = d, o[++s] = u, o[++s] = f, s++ } return o } var a, o = r("DXT1"), s = r("DXT3"), l = r("DXT5"), c = r("ETC1"), h = new Int32Array(e, 0, 31); if (542327876 !== h[0]) return console.error("THREE.DDSLoader.parse: Invalid magic number in DDS header."), i; if (4 & !h[20]) return console.error("THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code."), i; var u, d = h[21], p = !1; switch (d) { case o: a = 8, i.format = RGB_S3TC_DXT1_Format; break; case s: a = 16, i.format = RGBA_S3TC_DXT3_Format; break; case l: a = 16, i.format = RGBA_S3TC_DXT5_Format; break; case c: a = 8, i.format = RGB_ETC1_Format; break; default: if (!(32 === h[22] && 16711680 & h[23] && 65280 & h[24] && 255 & h[25] && 4278190080 & h[26])) return console.error("THREE.DDSLoader.parse: Unsupported FourCC code ", (u = d, String.fromCharCode(255 & u, u >> 8 & 255, u >> 16 & 255, u >> 24 & 255))), i; p = !0, a = 64, i.format = RGBAFormat }i.mipmapCount = 1, 131072 & h[2] && !1 !== t && (i.mipmapCount = Math.max(1, h[7])); var f = h[28]; if (i.isCubemap = !!(512 & f), i.isCubemap && (!(1024 & f) || !(2048 & f) || !(4096 & f) || !(8192 & f) || !(16384 & f) || !(32768 & f))) return console.error("THREE.DDSLoader.parse: Incomplete cubemap faces"), i; i.width = h[4], i.height = h[3]; for (var m = h[1] + 4, g = i.isCubemap ? 6 : 1, y = 0; y < g; y++)for (var v = i.width, _ = i.height, b = 0; b < i.mipmapCount; b++) { if (p) var x = (w = n(e, m, v, _)).length; else { x = Math.max(4, v) / 4 * Math.max(4, _) / 4 * a; var w = new Uint8Array(e, m, x) } var S = { data: w, width: v, height: _ }; i.mipmaps.push(S), m += x, v = Math.max(v >> 1, 1), _ = Math.max(_ >> 1, 1) } return i } }); var DRACOLoader = function (e) { Loader.call(this, e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } }; DRACOLoader.prototype = Object.assign(Object.create(Loader.prototype), { constructor: DRACOLoader, setDecoderPath: function (e) { return this.decoderPath = e, this }, setDecoderConfig: function (e) { return this.decoderConfig = e, this }, setWorkerLimit: function (e) { return this.workerLimit = e, this }, setVerbosity: function () { console.warn("THREE.DRACOLoader: The .setVerbosity() method has been removed.") }, setDrawMode: function () { console.warn("THREE.DRACOLoader: The .setDrawMode() method has been removed.") }, setSkipDequantization: function () { console.warn("THREE.DRACOLoader: The .setSkipDequantization() method has been removed.") }, load: function (e, t, i, r) { var n = new FileLoader(this.manager); n.setPath(this.path), n.setResponseType("arraybuffer"), n.setRequestHeader(this.requestHeader), n.setWithCredentials(this.withCredentials), n.load(e, (e => { var i = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: !1 }; this.decodeGeometry(e, i).then(t).catch(r) }), i, r) }, decodeDracoFile: function (e, t, i, r) { var n = { attributeIDs: i || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!i }; this.decodeGeometry(e, n).then(t) }, decodeGeometry: function (e, t) { for (var i in t.attributeTypes) { var r = t.attributeTypes[i]; void 0 !== r.BYTES_PER_ELEMENT && (t.attributeTypes[i] = r.name) } var n, a = JSON.stringify(t); if (DRACOLoader.taskCache.has(e)) { var o = DRACOLoader.taskCache.get(e); if (o.key === a) return o.promise; if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } var s = this.workerNextTaskID++, l = e.byteLength, c = this._getWorker(s, l).then((i => (n = i, new Promise(((i, r) => { n._callbacks[s] = { resolve: i, reject: r }, n.postMessage({ type: "decode", id: s, taskConfig: t, buffer: e }, [e]) }))))).then((e => this._createGeometry(e.geometry))); return c.catch((() => !0)).then((() => { n && s && this._releaseTask(n, s) })), DRACOLoader.taskCache.set(e, { key: a, promise: c }), c }, _createGeometry: function (e) { var t = new BufferGeometry; e.index && t.setIndex(new BufferAttribute(e.index.array, 1)); for (var i = 0; i < e.attributes.length; i++) { var r = e.attributes[i], n = r.name, a = r.array, o = r.itemSize; t.setAttribute(n, new BufferAttribute(a, o)) } return t }, _loadLibrary: function (e, t) { var i = new FileLoader(this.manager); return i.setPath(this.decoderPath), i.setResponseType(t), i.setWithCredentials(this.withCredentials), new Promise(((t, r) => { i.load(e, t, void 0, r) })) }, preload: function () { return this._initDecoder(), this }, _initDecoder: function () { if (this.decoderPending) return this.decoderPending; var e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type, t = []; return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => { var i = t[0]; e || (this.decoderConfig.wasmBinary = t[1]); var r = DRACOLoader.DRACOWorker.toString(), n = ["/* draco decoder */", i, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n"); this.workerSourceURL = URL.createObjectURL(new Blob([n])) })), this.decoderPending }, _getWorker: function (e, t) { return this._initDecoder().then((() => { var i; this.workerPool.length < this.workerLimit ? ((i = new Worker(this.workerSourceURL))._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({ type: "init", decoderConfig: this.decoderConfig }), i.onmessage = function (e) { var t = e.data; switch (t.type) { case "decode": i._callbacks[t.id].resolve(t); break; case "error": i._callbacks[t.id].reject(t); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + t.type + '"') } }, this.workerPool.push(i)) : this.workerPool.sort((function (e, t) { return e._taskLoad > t._taskLoad ? -1 : 1 })); return (i = this.workerPool[this.workerPool.length - 1])._taskCosts[e] = t, i._taskLoad += t, i })) }, _releaseTask: function (e, t) { e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t] }, debug: function () { console.log("Task load: ", this.workerPool.map((e => e._taskLoad))) }, dispose: function () { for (var e = 0; e < this.workerPool.length; ++e)this.workerPool[e].terminate(); return this.workerPool.length = 0, this } }), DRACOLoader.DRACOWorker = function () { var e, t; function i(e, t, i, r, n, a) { var o = a.num_components(), s = i.num_points() * o, l = s * n.BYTES_PER_ELEMENT, c = function (e, t) { switch (t) { case Float32Array: return e.DT_FLOAT32; case Int8Array: return e.DT_INT8; case Int16Array: return e.DT_INT16; case Int32Array: return e.DT_INT32; case Uint8Array: return e.DT_UINT8; case Uint16Array: return e.DT_UINT16; case Uint32Array: return e.DT_UINT32 } }(e, n), h = e._malloc(l); t.GetAttributeDataArrayForAllPoints(i, a, c, l, h); var u = new n(e.HEAPF32.buffer, h, s).slice(); return e._free(h), { name: r, array: u, itemSize: o } } onmessage = function (r) { var n = r.data; switch (n.type) { case "init": e = n.decoderConfig, t = new Promise((function (t) { e.onModuleLoaded = function (e) { t({ draco: e }) }, DracoDecoderModule(e) })); break; case "decode": var a = n.buffer, o = n.taskConfig; t.then((e => { var t = e.draco, r = new t.Decoder, s = new t.DecoderBuffer; s.Init(new Int8Array(a), a.byteLength); try { var l = function (e, t, r, n) { var a, o, s = n.attributeIDs, l = n.attributeTypes, c = t.GetEncodedGeometryType(r); if (c === e.TRIANGULAR_MESH) a = new e.Mesh, o = t.DecodeBufferToMesh(r, a); else { if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type."); a = new e.PointCloud, o = t.DecodeBufferToPointCloud(r, a) } if (!o.ok() || 0 === a.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + o.error_msg()); var h = { index: null, attributes: [] }; for (var u in s) { var d, p, f = self[l[u]]; if (n.useUniqueIDs) p = s[u], d = t.GetAttributeByUniqueId(a, p); else { if (-1 === (p = t.GetAttributeId(a, e[s[u]]))) continue; d = t.GetAttribute(a, p) } h.attributes.push(i(e, t, a, u, f, d)) } c === e.TRIANGULAR_MESH && (h.index = function (e, t, i) { var r = 3 * i.num_faces(), n = 4 * r, a = e._malloc(n); t.GetTrianglesUInt32Array(i, n, a); var o = new Uint32Array(e.HEAPF32.buffer, a, r).slice(); return e._free(a), { array: o, itemSize: 1 } }(e, t, a)); return e.destroy(a), h }(t, r, s, o), c = l.attributes.map((e => e.array.buffer)); l.index && c.push(l.index.array.buffer), self.postMessage({ type: "decode", id: n.id, geometry: l }, c) } catch (e) { console.error(e), self.postMessage({ type: "error", id: n.id, error: e.message }) } finally { t.destroy(s), t.destroy(r) } })) } } }, DRACOLoader.taskCache = new WeakMap, DRACOLoader.setDecoderPath = function () { console.warn("THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.") }, DRACOLoader.setDecoderConfig = function () { console.warn("THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.") }, DRACOLoader.releaseDecoderModule = function () { console.warn("THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.") }, DRACOLoader.getDecoderModule = function () { console.warn("THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.") }; var GLTFExporter$1 = function () { function e() { this.pluginCallbacks = [], this.register((function (e) { return new C(e) })), this.register((function (e) { return new L(e) })), this.register((function (e) { return new R(e) })) } e.prototype = { constructor: e, register: function (e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this }, unregister: function (e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this }, parse: function (e, t, i) { for (var r = new E, n = [], a = 0, o = this.pluginCallbacks.length; a < o; a++)n.push(this.pluginCallbacks[a](r)); r.setPlugins(n), r.write(e, t, i) } }; var t = 0, i = 1, r = 2, n = 3, a = 4, o = 5121, s = 5123, l = 5126, c = 5125, h = 34962, u = 34963, d = 9728, p = 9729, f = 9984, m = 9985, g = 9986, y = 9987, v = 33071, _ = 33648, b = 10497, x = {}; x[NearestFilter] = d, x[NearestMipmapNearestFilter] = f, x[NearestMipmapLinearFilter] = g, x[LinearFilter] = p, x[LinearMipmapNearestFilter] = m, x[LinearMipmapLinearFilter] = y, x[ClampToEdgeWrapping] = v, x[RepeatWrapping] = b, x[MirroredRepeatWrapping] = _; var w = { scale: "scale", position: "translation", quaternion: "rotation", morphTargetInfluences: "weights" }; function S(e, t) { return e.length === t.length && e.every((function (e, i) { return e === t[i] })) } function M(e) { return 4 * Math.ceil(e / 4) } function T(e, t) { t = t || 0; var i = M(e.byteLength); if (i !== e.byteLength) { var r = new Uint8Array(i); if (r.set(new Uint8Array(e)), 0 !== t) for (var n = e.byteLength; n < i; n++)r[n] = t; return r.buffer } return e } var A = null; function E() { this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map, this.skins = [], this.extensionsUsed = {}, this.uids = new Map, this.uid = 0, this.json = { asset: { version: "2.0", generator: "THREE.GLTFExporter" } }, this.cache = { meshes: new Map, attributes: new Map, attributesNormalized: new Map, materials: new Map, textures: new Map, images: new Map } } function C(e) { this.writer = e, this.name = "KHR_lights_punctual" } function L(e) { this.writer = e, this.name = "KHR_materials_unlit" } function R(e) { this.writer = e, this.name = "KHR_materials_pbrSpecularGlossiness" } return E.prototype = { constructor: E, setPlugins: function (e) { this.plugins = e }, write: function (e, t, i) { this.options = Object.assign({}, { binary: !1, trs: !1, onlyVisible: !0, truncateDrawRange: !0, embedImages: !0, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: !1 }, i), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e); var r = this; Promise.all(this.pending).then((function () { var e, i = r.buffers, n = r.json, a = r.options, o = r.extensionsUsed, s = new Blob(i, { type: "application/octet-stream" }), l = Object.keys(o); (l.length > 0 && (n.extensionsUsed = l), n.buffers && n.buffers.length > 0 && (n.buffers[0].byteLength = s.size), !0 === a.binary) ? ((e = new window.FileReader).readAsArrayBuffer(s), e.onloadend = function () { var i = T(e.result), r = new DataView(new ArrayBuffer(8)); r.setUint32(0, i.byteLength, !0), r.setUint32(4, 5130562, !0); var a = T(function (e) { if (void 0 !== window.TextEncoder) return (new TextEncoder).encode(e).buffer; for (var t = new Uint8Array(new ArrayBuffer(e.length)), i = 0, r = e.length; i < r; i++) { var n = e.charCodeAt(i); t[i] = n > 255 ? 32 : n } return t.buffer }(JSON.stringify(n)), 32), o = new DataView(new ArrayBuffer(8)); o.setUint32(0, a.byteLength, !0), o.setUint32(4, 1313821514, !0); var s = new ArrayBuffer(12), l = new DataView(s); l.setUint32(0, 1179937895, !0), l.setUint32(4, 2, !0); var c = 12 + o.byteLength + a.byteLength + r.byteLength + i.byteLength; l.setUint32(8, c, !0); var h = new Blob([s, o, a, r, i], { type: "application/octet-stream" }), u = new window.FileReader; u.readAsArrayBuffer(h), u.onloadend = function () { t(u.result) } }) : n.buffers && n.buffers.length > 0 ? ((e = new window.FileReader).readAsDataURL(s), e.onloadend = function () { var i = e.result; n.buffers[0].uri = i, t(n) }) : t(n) })) }, serializeUserData: function (e, t) { if (0 !== Object.keys(e.userData).length) { var i = this.options, r = this.extensionsUsed; try { var n = JSON.parse(JSON.stringify(e.userData)); if (i.includeCustomExtensions && n.gltfExtensions) { for (var a in void 0 === t.extensions && (t.extensions = {}), n.gltfExtensions) t.extensions[a] = n.gltfExtensions[a], r[a] = !0; delete n.gltfExtensions } Object.keys(n).length > 0 && (t.extras = n) } catch (t) { console.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + t.message) } } }, getUID: function (e) { return this.uids.has(e) || this.uids.set(e, this.uid++), this.uids.get(e) }, isNormalizedNormalAttribute: function (e) { if (this.cache.attributesNormalized.has(e)) return !1; for (var t = new Vector3, i = 0, r = e.count; i < r; i++)if (Math.abs(t.fromBufferAttribute(e, i).length() - 1) > 5e-4) return !1; return !0 }, createNormalizedNormalAttribute: function (e) { var t = this.cache; if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e); for (var i = e.clone(), r = new Vector3, n = 0, a = i.count; n < a; n++)r.fromBufferAttribute(i, n), 0 === r.x && 0 === r.y && 0 === r.z ? r.setX(1) : r.normalize(), i.setXYZ(n, r.x, r.y, r.z); return t.attributesNormalized.set(e, i), i }, applyTextureTransform: function (e, t) { var i = !1, r = {}; 0 === t.offset.x && 0 === t.offset.y || (r.offset = t.offset.toArray(), i = !0), 0 !== t.rotation && (r.rotation = t.rotation, i = !0), 1 === t.repeat.x && 1 === t.repeat.y || (r.scale = t.repeat.toArray(), i = !0), i && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = r, this.extensionsUsed.KHR_texture_transform = !0) }, processBuffer: function (e) { var t = this.json, i = this.buffers; return t.buffers || (t.buffers = [{ byteLength: 0 }]), i.push(e), 0 }, processBufferView: function (e, t, i, r, n) { var a, u = this.json; u.bufferViews || (u.bufferViews = []), a = t === o ? 1 : t === s ? 2 : 4; for (var d = M(r * e.itemSize * a), p = new DataView(new ArrayBuffer(d)), f = 0, m = i; m < i + r; m++)for (var g = 0; g < e.itemSize; g++) { var y; e.itemSize > 4 ? y = e.array[m * e.itemSize + g] : 0 === g ? y = e.getX(m) : 1 === g ? y = e.getY(m) : 2 === g ? y = e.getZ(m) : 3 === g && (y = e.getW(m)), t === l ? p.setFloat32(f, y, !0) : t === c ? p.setUint32(f, y, !0) : t === s ? p.setUint16(f, y, !0) : t === o && p.setUint8(f, y), f += a } var v = { buffer: this.processBuffer(p.buffer), byteOffset: this.byteOffset, byteLength: d }; return void 0 !== n && (v.target = n), n === h && (v.byteStride = e.itemSize * a), this.byteOffset += d, u.bufferViews.push(v), { id: u.bufferViews.length - 1, byteLength: 0 } }, processBufferViewImage: function (e) { var t = this, i = t.json; return i.bufferViews || (i.bufferViews = []), new Promise((function (r) { var n = new window.FileReader; n.readAsArrayBuffer(e), n.onloadend = function () { var e = T(n.result), a = { buffer: t.processBuffer(e), byteOffset: t.byteOffset, byteLength: e.byteLength }; t.byteOffset += e.byteLength, r(i.bufferViews.push(a) - 1) } })) }, processAccessor: function (e, t, i, r) { var n, a = this.options, d = this.json; if (e.array.constructor === Float32Array) n = l; else if (e.array.constructor === Uint32Array) n = c; else if (e.array.constructor === Uint16Array) n = s; else { if (e.array.constructor !== Uint8Array) throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type."); n = o } if (void 0 === i && (i = 0), void 0 === r && (r = e.count), a.truncateDrawRange && void 0 !== t && null === t.index) { var p = i + r, f = t.drawRange.count === 1 / 0 ? e.count : t.drawRange.start + t.drawRange.count; i = Math.max(i, t.drawRange.start), (r = Math.min(p, f) - i) < 0 && (r = 0) } if (0 === r) return null; var m, g = function (e, t, i) { for (var r = { min: new Array(e.itemSize).fill(Number.POSITIVE_INFINITY), max: new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY) }, n = t; n < t + i; n++)for (var a = 0; a < e.itemSize; a++) { var o; e.itemSize > 4 ? o = e.array[n * e.itemSize + a] : 0 === a ? o = e.getX(n) : 1 === a ? o = e.getY(n) : 2 === a ? o = e.getZ(n) : 3 === a && (o = e.getW(n)), r.min[a] = Math.min(r.min[a], o), r.max[a] = Math.max(r.max[a], o) } return r }(e, i, r); void 0 !== t && (m = e === t.index ? u : h); var y = this.processBufferView(e, n, i, r, m), v = { bufferView: y.id, byteOffset: y.byteOffset, componentType: n, count: r, max: g.max, min: g.min, type: { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 16: "MAT4" }[e.itemSize] }; return !0 === e.normalized && (v.normalized = !0), d.accessors || (d.accessors = []), d.accessors.push(v) - 1 }, processImage: function (e, t, i) { var r = this, n = r.cache, a = r.json, o = r.options, s = r.pending; n.images.has(e) || n.images.set(e, {}); var l = n.images.get(e), c = t === RGBAFormat ? "image/png" : "image/jpeg", h = c + ":flipY/" + i.toString(); if (void 0 !== l[h]) return l[h]; a.images || (a.images = []); var u = { mimeType: c }; if (o.embedImages) { var d = A = A || document.createElement("canvas"); d.width = Math.min(e.width, o.maxTextureSize), d.height = Math.min(e.height, o.maxTextureSize); var p = d.getContext("2d"); if (!0 === i && (p.translate(0, d.height), p.scale(1, -1)), "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) p.drawImage(e, 0, 0, d.width, d.height); else { t !== RGBAFormat && t !== RGBFormat && console.error("GLTFExporter: Only RGB and RGBA formats are supported."), (e.width > o.maxTextureSize || e.height > o.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e); var f = e.data; if (t === RGBFormat) { f = new Uint8ClampedArray(e.height * e.width * 4); for (var m = 0, g = 0; m < f.length; m += 4, g += 3)f[m + 0] = e.data[g + 0], f[m + 1] = e.data[g + 1], f[m + 2] = e.data[g + 2], f[m + 3] = 255 } p.putImageData(new ImageData(f, e.width, e.height), 0, 0) } !0 === o.binary ? s.push(new Promise((function (e) { d.toBlob((function (t) { r.processBufferViewImage(t).then((function (t) { u.bufferView = t, e() })) }), c) }))) : u.uri = d.toDataURL(c) } else u.uri = e.src; var y = a.images.push(u) - 1; return l[h] = y, y }, processSampler: function (e) { var t = this.json; t.samplers || (t.samplers = []); var i = { magFilter: x[e.magFilter], minFilter: x[e.minFilter], wrapS: x[e.wrapS], wrapT: x[e.wrapT] }; return t.samplers.push(i) - 1 }, processTexture: function (e) { var t = this.cache, i = this.json; if (t.textures.has(e)) return t.textures.get(e); i.textures || (i.textures = []); var r = { sampler: this.processSampler(e), source: this.processImage(e.image, e.format, e.flipY) }; e.name && (r.name = e.name), this._invokeAll((function (t) { t.writeTexture && t.writeTexture(e, r) })); var n = i.textures.push(r) - 1; return t.textures.set(e, n), n }, processMaterial: function (e) { var t = this.cache, i = this.json; if (t.materials.has(e)) return t.materials.get(e); if (e.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null; i.materials || (i.materials = []); var r = { pbrMetallicRoughness: {} }; !0 !== e.isMeshStandardMaterial && !0 !== e.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results."); var n = e.color.toArray().concat([e.opacity]); if (S(n, [1, 1, 1, 1]) || (r.pbrMetallicRoughness.baseColorFactor = n), e.isMeshStandardMaterial ? (r.pbrMetallicRoughness.metallicFactor = e.metalness, r.pbrMetallicRoughness.roughnessFactor = e.roughness) : (r.pbrMetallicRoughness.metallicFactor = .5, r.pbrMetallicRoughness.roughnessFactor = .5), e.metalnessMap || e.roughnessMap) if (e.metalnessMap === e.roughnessMap) { var a = { index: this.processTexture(e.metalnessMap) }; this.applyTextureTransform(a, e.metalnessMap), r.pbrMetallicRoughness.metallicRoughnessTexture = a } else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture."); if (e.map) { var o = { index: this.processTexture(e.map) }; this.applyTextureTransform(o, e.map), r.pbrMetallicRoughness.baseColorTexture = o } if (e.emissive) { var s = e.emissive.clone().multiplyScalar(e.emissiveIntensity).toArray(); if (S(s, [0, 0, 0]) || (r.emissiveFactor = s), e.emissiveMap) { var l = { index: this.processTexture(e.emissiveMap) }; this.applyTextureTransform(l, e.emissiveMap), r.emissiveTexture = l } } if (e.normalMap) { var c = { index: this.processTexture(e.normalMap) }; e.normalScale && -1 !== e.normalScale.x && (e.normalScale.x !== e.normalScale.y && console.warn("THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."), c.scale = e.normalScale.x), this.applyTextureTransform(c, e.normalMap), r.normalTexture = c } if (e.aoMap) { var h = { index: this.processTexture(e.aoMap), texCoord: 1 }; 1 !== e.aoMapIntensity && (h.strength = e.aoMapIntensity), this.applyTextureTransform(h, e.aoMap), r.occlusionTexture = h } e.transparent ? r.alphaMode = "BLEND" : e.alphaTest > 0 && (r.alphaMode = "MASK", r.alphaCutoff = e.alphaTest), e.side === DoubleSide && (r.doubleSided = !0), "" !== e.name && (r.name = e.name), this.serializeUserData(e, r), this._invokeAll((function (t) { t.writeMaterial && t.writeMaterial(e, r) })); var u = i.materials.push(r) - 1; return t.materials.set(e, u), u }, processMesh: function (e) { var o = this.cache, s = this.json, l = [e.geometry.uuid]; if (Array.isArray(e.material)) for (var c = 0, h = e.material.length; c < h; c++)l.push(e.material[c].uuid); else l.push(e.material.uuid); var u = l.join(":"); if (o.meshes.has(u)) return o.meshes.get(u); var d, p = e.geometry; if (d = e.isLineSegments ? i : e.isLineLoop ? r : e.isLine ? n : e.isPoints ? t : e.material.wireframe ? i : a, !0 !== p.isBufferGeometry) throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry."); var f = {}, m = {}, g = [], y = [], v = { uv: "TEXCOORD_0", uv2: "TEXCOORD_1", color: "COLOR_0", skinWeight: "WEIGHTS_0", skinIndex: "JOINTS_0" }, _ = p.getAttribute("normal"); void 0 === _ || this.isNormalizedNormalAttribute(_) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), p.setAttribute("normal", this.createNormalizedNormalAttribute(_))); var b = null; for (var x in p.attributes) if ("morph" !== x.substr(0, 5)) { var w = p.attributes[x]; x = v[x] || x.toUpperCase(); if (/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(x) || (x = "_" + x), o.attributes.has(this.getUID(w))) m[x] = o.attributes.get(this.getUID(w)); else { b = null; var S = w.array; "JOINTS_0" !== x || S instanceof Uint16Array || S instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), b = new BufferAttribute(new Uint16Array(S), w.itemSize, w.normalized)); var M = this.processAccessor(b || w, p); null !== M && (m[x] = M, o.attributes.set(this.getUID(w), M)) } } if (void 0 !== _ && p.setAttribute("normal", _), 0 === Object.keys(m).length) return null; if (void 0 !== e.morphTargetInfluences && e.morphTargetInfluences.length > 0) { var T = [], A = [], E = {}; if (void 0 !== e.morphTargetDictionary) for (var C in e.morphTargetDictionary) E[e.morphTargetDictionary[C]] = C; for (c = 0; c < e.morphTargetInfluences.length; ++c) { var L = {}, R = !1; for (var x in p.morphAttributes) if ("position" === x || "normal" === x) { w = p.morphAttributes[x][c]; var D = x.toUpperCase(), P = p.attributes[x]; if (o.attributes.has(this.getUID(w))) L[D] = o.attributes.get(this.getUID(w)); else { var O = w.clone(); if (!p.morphTargetsRelative) for (var I = 0, k = w.count; I < k; I++)O.setXYZ(I, w.getX(I) - P.getX(I), w.getY(I) - P.getY(I), w.getZ(I) - P.getZ(I)); L[D] = this.processAccessor(O, p), o.attributes.set(this.getUID(P), L[D]) } } else R || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), R = !0); y.push(L), T.push(e.morphTargetInfluences[c]), void 0 !== e.morphTargetDictionary && A.push(E[c]) } f.weights = T, A.length > 0 && (f.extras = {}, f.extras.targetNames = A) } var B = Array.isArray(e.material); if (B && 0 === p.groups.length) return null; for (var N = B ? e.material : [e.material], F = B ? p.groups : [{ materialIndex: 0, start: void 0, count: void 0 }], U = (c = 0, F.length); c < U; c++) { var z = { mode: d, attributes: m }; if (this.serializeUserData(p, z), y.length > 0 && (z.targets = y), null !== p.index) { var G = this.getUID(p.index); void 0 === F[c].start && void 0 === F[c].count || (G += ":" + F[c].start + ":" + F[c].count), o.attributes.has(G) ? z.indices = o.attributes.get(G) : (z.indices = this.processAccessor(p.index, p, F[c].start, F[c].count), o.attributes.set(G, z.indices)), null === z.indices && delete z.indices } var H = this.processMaterial(N[F[c].materialIndex]); null !== H && (z.material = H), g.push(z) } f.primitives = g, s.meshes || (s.meshes = []), this._invokeAll((function (t) { t.writeMesh && t.writeMesh(e, f) })); var V = s.meshes.push(f) - 1; return o.meshes.set(u, V), V }, processCamera: function (e) { var t = this.json; t.cameras || (t.cameras = []); var i = e.isOrthographicCamera, r = { type: i ? "orthographic" : "perspective" }; return i ? r.orthographic = { xmag: 2 * e.right, ymag: 2 * e.top, zfar: e.far <= 0 ? .001 : e.far, znear: e.near < 0 ? 0 : e.near } : r.perspective = { aspectRatio: e.aspect, yfov: MathUtils.degToRad(e.fov), zfar: e.far <= 0 ? .001 : e.far, znear: e.near < 0 ? 0 : e.near }, "" !== e.name && (r.name = e.type), t.cameras.push(r) - 1 }, processAnimation: function (t, i) { var r = this.json, n = this.nodeMap; r.animations || (r.animations = []); for (var a = (t = e.Utils.mergeMorphTargetTracks(t.clone(), i)).tracks, o = [], s = [], l = 0; l < a.length; ++l) { var c = a[l], h = PropertyBinding.parseTrackName(c.name), u = PropertyBinding.findNode(i, h.nodeName), d = w[h.propertyName]; if ("bones" === h.objectName && (u = !0 === u.isSkinnedMesh ? u.skeleton.getBoneByName(h.objectIndex) : void 0), !u || !d) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name), null; var p, f = c.values.length / c.times.length; d === w.morphTargetInfluences && (f /= u.morphTargetInfluences.length), !0 === c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (p = "CUBICSPLINE", f /= 3) : p = c.getInterpolation() === InterpolateDiscrete ? "STEP" : "LINEAR", s.push({ input: this.processAccessor(new BufferAttribute(c.times, 1)), output: this.processAccessor(new BufferAttribute(c.values, f)), interpolation: p }), o.push({ sampler: s.length - 1, target: { node: n.get(u), path: d } }) } return r.animations.push({ name: t.name || "clip_" + r.animations.length, samplers: s, channels: o }), r.animations.length - 1 }, processSkin: function (e) { var t = this.json, i = this.nodeMap, r = t.nodes[i.get(e)], n = e.skeleton; if (void 0 === n) return null; var a = e.skeleton.bones[0]; if (void 0 === a) return null; for (var o = [], s = new Float32Array(16 * n.bones.length), l = new Matrix4, c = 0; c < n.bones.length; ++c)o.push(i.get(n.bones[c])), l.copy(n.boneInverses[c]), l.multiply(e.bindMatrix).toArray(s, 16 * c); return void 0 === t.skins && (t.skins = []), t.skins.push({ inverseBindMatrices: this.processAccessor(new BufferAttribute(s, 16)), joints: o, skeleton: i.get(a) }), r.skin = t.skins.length - 1 }, processNode: function (e) { var t = this.json, i = this.options, r = this.nodeMap; t.nodes || (t.nodes = []); var n = {}; if (i.trs) { var a = e.quaternion.toArray(), o = e.position.toArray(), s = e.scale.toArray(); S(a, [0, 0, 0, 1]) || (n.rotation = a), S(o, [0, 0, 0]) || (n.translation = o), S(s, [1, 1, 1]) || (n.scale = s) } else e.matrixAutoUpdate && e.updateMatrix(), !1 === S(e.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (n.matrix = e.matrix.elements); if ("" !== e.name && (n.name = String(e.name)), this.serializeUserData(e, n), e.isMesh || e.isLine || e.isPoints) { var l = this.processMesh(e); null !== l && (n.mesh = l) } else e.isCamera && (n.camera = this.processCamera(e)); if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) { for (var c = [], h = 0, u = e.children.length; h < u; h++) { var d = e.children[h]; if (d.visible || !1 === i.onlyVisible) null !== (p = this.processNode(d)) && c.push(p) } c.length > 0 && (n.children = c) } this._invokeAll((function (t) { t.writeNode && t.writeNode(e, n) })); var p = t.nodes.push(n) - 1; return r.set(e, p), p }, processScene: function (e) { var t = this.json, i = this.options; t.scenes || (t.scenes = [], t.scene = 0); var r = {}; "" !== e.name && (r.name = e.name), t.scenes.push(r); for (var n = [], a = 0, o = e.children.length; a < o; a++) { var s = e.children[a]; if (s.visible || !1 === i.onlyVisible) { var l = this.processNode(s); null !== l && n.push(l) } } n.length > 0 && (r.nodes = n), this.serializeUserData(e, r) }, processObjects: function (e) { var t = new Scene; t.name = "AuxScene"; for (var i = 0; i < e.length; i++)t.children.push(e[i]); this.processScene(t) }, processInput: function (e) { var t = this.options; e = e instanceof Array ? e : [e], this._invokeAll((function (t) { t.beforeParse && t.beforeParse(e) })); for (var i = [], r = 0; r < e.length; r++)e[r] instanceof Scene ? this.processScene(e[r]) : i.push(e[r]); i.length > 0 && this.processObjects(i); for (r = 0; r < this.skins.length; ++r)this.processSkin(this.skins[r]); for (r = 0; r < t.animations.length; ++r)this.processAnimation(t.animations[r], e[0]); this._invokeAll((function (t) { t.afterParse && t.afterParse(e) })) }, _invokeAll: function (e) { for (var t = 0, i = this.plugins.length; t < i; t++)e(this.plugins[t]) } }, C.prototype = { constructor: C, writeNode: function (e, t) { if (e.isLight) if (e.isDirectionalLight || e.isPointLight || e.isSpotLight) { var i = this.writer, r = i.json, n = i.extensionsUsed, a = {}; e.name && (a.name = e.name), a.color = e.color.toArray(), a.intensity = e.intensity, e.isDirectionalLight ? a.type = "directional" : e.isPointLight ? (a.type = "point", e.distance > 0 && (a.range = e.distance)) : e.isSpotLight && (a.type = "spot", e.distance > 0 && (a.range = e.distance), a.spot = {}, a.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, a.spot.outerConeAngle = e.angle), void 0 !== e.decay && 2 !== e.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !e.target || e.target.parent === e && 0 === e.target.position.x && 0 === e.target.position.y && -1 === e.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), n[this.name] || (r.extensions = r.extensions || {}, r.extensions[this.name] = { lights: [] }, n[this.name] = !0); var o = r.extensions[this.name].lights; o.push(a), t.extensions = t.extensions || {}, t.extensions[this.name] = { light: o.length - 1 } } else console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e) } }, L.prototype = { constructor: L, writeMaterial: function (e, t) { if (e.isMeshBasicMaterial) { var i = this.writer.extensionsUsed; t.extensions = t.extensions || {}, t.extensions[this.name] = {}, i[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = .9 } } }, R.prototype = { constructor: R, writeMaterial: function (e, t) { if (e.isGLTFSpecularGlossinessMaterial) { var i = this.writer, r = i.extensionsUsed, n = {}; t.pbrMetallicRoughness.baseColorFactor && (n.diffuseFactor = t.pbrMetallicRoughness.baseColorFactor); var a = [1, 1, 1]; if (e.specular.toArray(a, 0), n.specularFactor = a, n.glossinessFactor = e.glossiness, t.pbrMetallicRoughness.baseColorTexture && (n.diffuseTexture = t.pbrMetallicRoughness.baseColorTexture), e.specularMap) { var o = { index: i.processTexture(e.specularMap) }; i.applyTextureTransform(o, e.specularMap), n.specularGlossinessTexture = o } t.extensions = t.extensions || {}, t.extensions[this.name] = n, r[this.name] = !0 } } }, e.Utils = { insertKeyframe: function (e, t) { var i, r = .001, n = e.getValueSize(), a = new e.TimeBufferType(e.times.length + 1), o = new e.ValueBufferType(e.values.length + n), s = e.createInterpolant(new e.ValueBufferType(n)); if (0 === e.times.length) { a[0] = t; for (var l = 0; l < n; l++)o[l] = 0; i = 0 } else if (t < e.times[0]) { if (Math.abs(e.times[0] - t) < r) return 0; a[0] = t, a.set(e.times, 1), o.set(s.evaluate(t), 0), o.set(e.values, n), i = 0 } else if (t > e.times[e.times.length - 1]) { if (Math.abs(e.times[e.times.length - 1] - t) < r) return e.times.length - 1; a[a.length - 1] = t, a.set(e.times, 0), o.set(e.values, 0), o.set(s.evaluate(t), e.values.length), i = a.length - 1 } else for (l = 0; l < e.times.length; l++) { if (Math.abs(e.times[l] - t) < r) return l; if (e.times[l] < t && e.times[l + 1] > t) { a.set(e.times.slice(0, l + 1), 0), a[l + 1] = t, a.set(e.times.slice(l + 1), l + 2), o.set(e.values.slice(0, (l + 1) * n), 0), o.set(s.evaluate(t), (l + 1) * n), o.set(e.values.slice((l + 1) * n), (l + 2) * n), i = l + 1; break } } return e.times = a, e.values = o, i }, mergeMorphTargetTracks: function (e, t) { for (var i = [], r = {}, n = e.tracks, a = 0; a < n.length; ++a) { var o = n[a], s = PropertyBinding.parseTrackName(o.name), l = PropertyBinding.findNode(t, s.nodeName); if ("morphTargetInfluences" === s.propertyName && void 0 !== s.propertyIndex) { if (o.createInterpolant !== o.InterpolantFactoryMethodDiscrete && o.createInterpolant !== o.InterpolantFactoryMethodLinear) { if (o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation."); console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), (o = o.clone()).setInterpolation(InterpolateLinear) } var c, h = l.morphTargetInfluences.length, u = l.morphTargetDictionary[s.propertyIndex]; if (void 0 === u) throw new Error("THREE.GLTFExporter: Morph target name not found: " + s.propertyIndex); if (void 0 !== r[l.uuid]) { var d = o.createInterpolant(new o.ValueBufferType(1)); c = r[l.uuid]; for (m = 0; m < c.times.length; m++)c.values[m * h + u] = d.evaluate(c.times[m]); for (m = 0; m < o.times.length; m++) { var p = this.insertKeyframe(c, o.times[m]); c.values[p * h + u] = o.values[m] } } else { for (var f = new ((c = o.clone()).ValueBufferType)(h * c.times.length), m = 0; m < c.times.length; m++)f[m * h + u] = c.values[m]; c.name = (s.nodeName || "") + ".morphTargetInfluences", c.values = f, r[l.uuid] = c, i.push(c) } } else i.push(o) } return e.tracks = i, e } }, e }(), LineSegmentsGeometry = function () { InstancedBufferGeometry.call(this), this.type = "LineSegmentsGeometry"; this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new Float32BufferAttribute([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new Float32BufferAttribute([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2)) }, vector, box; LineSegmentsGeometry.prototype = Object.assign(Object.create(InstancedBufferGeometry.prototype), { constructor: LineSegmentsGeometry, isLineSegmentsGeometry: !0, applyMatrix4: function (e) { var t = this.attributes.instanceStart, i = this.attributes.instanceEnd; return void 0 !== t && (t.applyMatrix4(e), i.applyMatrix4(e), t.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, setPositions: function (e) { var t; e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e)); var i = new InstancedInterleavedBuffer(t, 6, 1); return this.setAttribute("instanceStart", new InterleavedBufferAttribute(i, 3, 0)), this.setAttribute("instanceEnd", new InterleavedBufferAttribute(i, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this }, setColors: function (e) { var t; e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e)); var i = new InstancedInterleavedBuffer(t, 6, 1); return this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(i, 3, 0)), this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(i, 3, 3)), this }, fromWireframeGeometry: function (e) { return this.setPositions(e.attributes.position.array), this }, fromEdgesGeometry: function (e) { return this.setPositions(e.attributes.position.array), this }, fromMesh: function (e) { return this.fromWireframeGeometry(new WireframeGeometry(e.geometry)), this }, fromLineSegments: function (e) { var t = e.geometry; if (!t.isGeometry) return t.isBufferGeometry && this.setPositions(t.attributes.position.array), this; console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.") }, computeBoundingBox: (box = new Box3, function () { null === this.boundingBox && (this.boundingBox = new Box3); var e = this.attributes.instanceStart, t = this.attributes.instanceEnd; void 0 !== e && void 0 !== t && (this.boundingBox.setFromBufferAttribute(e), box.setFromBufferAttribute(t), this.boundingBox.union(box)) }), computeBoundingSphere: (vector = new Vector3, function () { null === this.boundingSphere && (this.boundingSphere = new Sphere), null === this.boundingBox && this.computeBoundingBox(); var e = this.attributes.instanceStart, t = this.attributes.instanceEnd; if (void 0 !== e && void 0 !== t) { var i = this.boundingSphere.center; this.boundingBox.getCenter(i); for (var r = 0, n = 0, a = e.count; n < a; n++)vector.fromBufferAttribute(e, n), r = Math.max(r, i.distanceToSquared(vector)), vector.fromBufferAttribute(t, n), r = Math.max(r, i.distanceToSquared(vector)); this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this) } }), toJSON: function () { }, applyMatrix: function (e) { return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e) } }), UniformsLib.line = { linewidth: { value: 1 }, resolution: { value: new Vector2(1, 1) }, dashScale: { value: 1 }, dashSize: { value: 1 }, dashOffset: { value: 0 }, gapSize: { value: 1 }, opacity: { value: 1 } }, ShaderLib.line = { uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, UniformsLib.line]), vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t", fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t" }; var LineMaterial = function (e) { ShaderMaterial.call(this, { type: "LineMaterial", uniforms: UniformsUtils.clone(ShaderLib.line.uniforms), vertexShader: ShaderLib.line.vertexShader, fragmentShader: ShaderLib.line.fragmentShader, clipping: !0 }), this.dashed = !1, Object.defineProperties(this, { color: { enumerable: !0, get: function () { return this.uniforms.diffuse.value }, set: function (e) { this.uniforms.diffuse.value = e } }, linewidth: { enumerable: !0, get: function () { return this.uniforms.linewidth.value }, set: function (e) { this.uniforms.linewidth.value = e } }, dashScale: { enumerable: !0, get: function () { return this.uniforms.dashScale.value }, set: function (e) { this.uniforms.dashScale.value = e } }, dashSize: { enumerable: !0, get: function () { return this.uniforms.dashSize.value }, set: function (e) { this.uniforms.dashSize.value = e } }, dashOffset: { enumerable: !0, get: function () { return this.uniforms.dashOffset.value }, set: function (e) { this.uniforms.dashOffset.value = e } }, gapSize: { enumerable: !0, get: function () { return this.uniforms.gapSize.value }, set: function (e) { this.uniforms.gapSize.value = e } }, opacity: { enumerable: !0, get: function () { return this.uniforms.opacity.value }, set: function (e) { this.uniforms.opacity.value = e } }, resolution: { enumerable: !0, get: function () { return this.uniforms.resolution.value }, set: function (e) { this.uniforms.resolution.value.copy(e) } } }), this.setValues(e) }; LineMaterial.prototype = Object.create(ShaderMaterial.prototype), LineMaterial.prototype.constructor = LineMaterial, LineMaterial.prototype.isLineMaterial = !0; var LineSegments2 = function (e, t) { void 0 === e && (e = new LineSegmentsGeometry), void 0 === t && (t = new LineMaterial({ color: 16777215 * Math.random() })), Mesh.call(this, e, t), this.type = "LineSegments2" }; LineSegments2.prototype = Object.assign(Object.create(Mesh.prototype), { constructor: LineSegments2, isLineSegments2: !0, computeLineDistances: function () { var e = new Vector3, t = new Vector3; return function () { for (var i = this.geometry, r = i.attributes.instanceStart, n = i.attributes.instanceEnd, a = new Float32Array(2 * r.data.count), o = 0, s = 0, l = r.data.count; o < l; o++, s += 2)e.fromBufferAttribute(r, o), t.fromBufferAttribute(n, o), a[s] = 0 === s ? 0 : a[s - 1], a[s + 1] = a[s] + e.distanceTo(t); var c = new InstancedInterleavedBuffer(a, 2, 1); return i.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(c, 1, 0)), i.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(c, 1, 1)), this } }(), raycast: function () { var e = new Vector4, t = new Vector4, i = new Vector4, r = new Vector3, n = new Matrix4, a = new Line3, o = new Vector3; return function (s, l) { null === s.camera && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.'); var c = void 0 !== s.params.Line2 && s.params.Line2.threshold || 0, h = s.ray, u = s.camera, d = u.projectionMatrix, p = this.geometry, f = this.material, m = f.resolution, g = f.linewidth + c, y = p.attributes.instanceStart, v = p.attributes.instanceEnd, _ = -u.near; h.at(1, i), i.w = 1, i.applyMatrix4(u.matrixWorldInverse), i.applyMatrix4(d), i.multiplyScalar(1 / i.w), i.x *= m.x / 2, i.y *= m.y / 2, i.z = 0, r.copy(i); var b = this.matrixWorld; n.multiplyMatrices(u.matrixWorldInverse, b); for (var x = 0, w = y.count; x < w; x++) { if (e.fromBufferAttribute(y, x), t.fromBufferAttribute(v, x), e.w = 1, t.w = 1, e.applyMatrix4(n), t.applyMatrix4(n), !(e.z > _ && t.z > _)) { if (e.z > _) { const i = e.z - t.z, r = (e.z - _) / i; e.lerp(t, r) } else if (t.z > _) { const i = t.z - e.z, r = (t.z - _) / i; t.lerp(e, r) } e.applyMatrix4(d), t.applyMatrix4(d), e.multiplyScalar(1 / e.w), t.multiplyScalar(1 / t.w), e.x *= m.x / 2, e.y *= m.y / 2, t.x *= m.x / 2, t.y *= m.y / 2, a.start.copy(e), a.start.z = 0, a.end.copy(t), a.end.z = 0; var S = a.closestPointToPointParameter(r, !0); a.at(S, o); var M = MathUtils.lerp(e.z, t.z, S), T = M >= -1 && M <= 1, A = r.distanceTo(o) < .5 * g; if (T && A) { a.start.fromBufferAttribute(y, x), a.end.fromBufferAttribute(v, x), a.start.applyMatrix4(b), a.end.applyMatrix4(b); var E = new Vector3, C = new Vector3; h.distanceSqToSegment(a.start, a.end, C, E), l.push({ point: C, pointOnLine: E, distance: h.origin.distanceTo(C), object: this, face: null, faceIndex: x, uv: null, uv2: null }) } } } } }() }); var LineGeometry = function () { LineSegmentsGeometry.call(this), this.type = "LineGeometry" }; LineGeometry.prototype = Object.assign(Object.create(LineSegmentsGeometry.prototype), { constructor: LineGeometry, isLineGeometry: !0, setPositions: function (e) { for (var t = e.length - 3, i = new Float32Array(2 * t), r = 0; r < t; r += 3)i[2 * r] = e[r], i[2 * r + 1] = e[r + 1], i[2 * r + 2] = e[r + 2], i[2 * r + 3] = e[r + 3], i[2 * r + 4] = e[r + 4], i[2 * r + 5] = e[r + 5]; return LineSegmentsGeometry.prototype.setPositions.call(this, i), this }, setColors: function (e) { for (var t = e.length - 3, i = new Float32Array(2 * t), r = 0; r < t; r += 3)i[2 * r] = e[r], i[2 * r + 1] = e[r + 1], i[2 * r + 2] = e[r + 2], i[2 * r + 3] = e[r + 3], i[2 * r + 4] = e[r + 4], i[2 * r + 5] = e[r + 5]; return LineSegmentsGeometry.prototype.setColors.call(this, i), this }, fromLine: function (e) { var t = e.geometry; if (!t.isGeometry) return t.isBufferGeometry && this.setPositions(t.attributes.position.array), this; console.error("THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.") }, copy: function () { return this } }); var Line2 = function (e, t) { void 0 === e && (e = new LineGeometry), void 0 === t && (t = new LineMaterial({ color: 16777215 * Math.random() })), LineSegments2.call(this, e, t), this.type = "Line2" }; Line2.prototype = Object.assign(Object.create(LineSegments2.prototype), { constructor: Line2, isLine2: !0 }); var TGALoader = function (e) { Loader.call(this, e) }; TGALoader.prototype = Object.assign(Object.create(Loader.prototype), { constructor: TGALoader, load: function (e, t, i, r) { var n = this, a = new Texture$1, o = new FileLoader(this.manager); return o.setResponseType("arraybuffer"), o.setPath(this.path), o.setWithCredentials(this.withCredentials), o.load(e, (function (e) { a.image = n.parse(e), a.needsUpdate = !0, void 0 !== t && t(a) }), i, r), a }, parse: function (e) { var t = 0, i = 1, r = 2, n = 3, a = 9, o = 10, s = 11, l = 48, c = 4, h = 0, u = 1, d = 2, p = 3; e.length < 19 && console.error("THREE.TGALoader: Not enough data to contain header."); var f = new Uint8Array(e), m = 0, g = { id_length: f[m++], colormap_type: f[m++], image_type: f[m++], colormap_index: f[m++] | f[m++] << 8, colormap_length: f[m++] | f[m++] << 8, colormap_size: f[m++], origin: [f[m++] | f[m++] << 8, f[m++] | f[m++] << 8], width: f[m++] | f[m++] << 8, height: f[m++] | f[m++] << 8, pixel_size: f[m++], flags: f[m++] }; !function (e) { switch (e.image_type) { case i: case a: (e.colormap_length > 256 || 24 !== e.colormap_size || 1 !== e.colormap_type) && console.error("THREE.TGALoader: Invalid type colormap data for indexed type."); break; case r: case n: case o: case s: e.colormap_type && console.error("THREE.TGALoader: Invalid type colormap data for colormap type."); break; case t: console.error("THREE.TGALoader: No data."); default: console.error('THREE.TGALoader: Invalid type "%s".', e.image_type) }(e.width <= 0 || e.height <= 0) && console.error("THREE.TGALoader: Invalid image size."), 8 !== e.pixel_size && 16 !== e.pixel_size && 24 !== e.pixel_size && 32 !== e.pixel_size && console.error('THREE.TGALoader: Invalid pixel size "%s".', e.pixel_size) }(g), g.id_length + m > e.length && console.error("THREE.TGALoader: No data."), m += g.id_length; var y = !1, v = !1, _ = !1; switch (g.image_type) { case a: y = !0, v = !0; break; case i: v = !0; break; case o: y = !0; break; case r: break; case s: y = !0, _ = !0; break; case n: _ = !0 }var b = "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(g.width, g.height) : document.createElement("canvas"); b.width = g.width, b.height = g.height; var x = b.getContext("2d"), w = x.createImageData(g.width, g.height), S = function (e, t, i, r, n) { var a, o, s, l; if (o = i.pixel_size >> 3, s = i.width * i.height * o, t && (l = n.subarray(r, r += i.colormap_length * (i.colormap_size >> 3))), e) { var c, h, u; a = new Uint8Array(s); for (var d = 0, p = new Uint8Array(o); d < s;)if (h = 1 + (127 & (c = n[r++])), 128 & c) { for (u = 0; u < o; ++u)p[u] = n[r++]; for (u = 0; u < h; ++u)a.set(p, d + u * o); d += o * h } else { for (h *= o, u = 0; u < h; ++u)a[d + u] = n[r++]; d += h } } else a = n.subarray(r, r += t ? i.width * i.height : s); return { pixel_data: a, palettes: l } }(y, v, g, m, f); return function (e, t, i, r, n) { var a, o, s, f, m, y; switch ((g.flags & l) >> c) { default: case d: a = 0, s = 1, m = t, o = 0, f = 1, y = i; break; case h: a = 0, s = 1, m = t, o = i - 1, f = -1, y = -1; break; case p: a = t - 1, s = -1, m = -1, o = 0, f = 1, y = i; break; case u: a = t - 1, s = -1, m = -1, o = i - 1, f = -1, y = -1 }if (_) switch (g.pixel_size) { case 8: !function (e, t, i, r, n, a, o, s) { var l, c, h, u = 0, d = g.width; for (h = t; h !== r; h += i)for (c = n; c !== o; c += a, u++)l = s[u], e[4 * (c + d * h) + 0] = l, e[4 * (c + d * h) + 1] = l, e[4 * (c + d * h) + 2] = l, e[4 * (c + d * h) + 3] = 255 }(e, o, f, y, a, s, m, r); break; case 16: !function (e, t, i, r, n, a, o, s) { var l, c, h = 0, u = g.width; for (c = t; c !== r; c += i)for (l = n; l !== o; l += a, h += 2)e[4 * (l + u * c) + 0] = s[h + 0], e[4 * (l + u * c) + 1] = s[h + 0], e[4 * (l + u * c) + 2] = s[h + 0], e[4 * (l + u * c) + 3] = s[h + 1] }(e, o, f, y, a, s, m, r); break; default: console.error("THREE.TGALoader: Format not supported.") } else switch (g.pixel_size) { case 8: !function (e, t, i, r, n, a, o, s, l) { var c, h, u, d = l, p = 0, f = g.width; for (u = t; u !== r; u += i)for (h = n; h !== o; h += a, p++)c = s[p], e[4 * (h + f * u) + 3] = 255, e[4 * (h + f * u) + 2] = d[3 * c + 0], e[4 * (h + f * u) + 1] = d[3 * c + 1], e[4 * (h + f * u) + 0] = d[3 * c + 2] }(e, o, f, y, a, s, m, r, n); break; case 16: !function (e, t, i, r, n, a, o, s) { var l, c, h, u = 0, d = g.width; for (h = t; h !== r; h += i)for (c = n; c !== o; c += a, u += 2)l = s[u + 0] + (s[u + 1] << 8), e[4 * (c + d * h) + 0] = (31744 & l) >> 7, e[4 * (c + d * h) + 1] = (992 & l) >> 2, e[4 * (c + d * h) + 2] = (31 & l) >> 3, e[4 * (c + d * h) + 3] = 32768 & l ? 0 : 255 }(e, o, f, y, a, s, m, r); break; case 24: !function (e, t, i, r, n, a, o, s) { var l, c, h = 0, u = g.width; for (c = t; c !== r; c += i)for (l = n; l !== o; l += a, h += 3)e[4 * (l + u * c) + 3] = 255, e[4 * (l + u * c) + 2] = s[h + 0], e[4 * (l + u * c) + 1] = s[h + 1], e[4 * (l + u * c) + 0] = s[h + 2] }(e, o, f, y, a, s, m, r); break; case 32: !function (e, t, i, r, n, a, o, s) { var l, c, h = 0, u = g.width; for (c = t; c !== r; c += i)for (l = n; l !== o; l += a, h += 4)e[4 * (l + u * c) + 2] = s[h + 0], e[4 * (l + u * c) + 1] = s[h + 1], e[4 * (l + u * c) + 0] = s[h + 2], e[4 * (l + u * c) + 3] = s[h + 3] }(e, o, f, y, a, s, m, r); break; default: console.error("THREE.TGALoader: Format not supported.") } }(w.data, g.width, g.height, S.pixel_data, S.palettes), x.putImageData(w, 0, 0), b } }); var Stats = function () { var e = 0, t = document.createElement("div"); function i(e) { return t.appendChild(e.dom), e } function r(i) { for (var r = 0; r < t.children.length; r++)t.children[r].style.display = r === i ? "block" : "none"; e = i } t.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", t.addEventListener("click", (function (i) { i.preventDefault(), r(++e % t.children.length) }), !1); var n = (performance || Date).now(), a = n, o = 0, s = i(new Stats.Panel("FPS", "#0ff", "#002")), l = i(new Stats.Panel("MS", "#0f0", "#020")); if (self.performance && self.performance.memory) var c = i(new Stats.Panel("MB", "#f08", "#201")); return r(0), { REVISION: 16, dom: t, addPanel: i, showPanel: r, begin: function () { n = (performance || Date).now() }, end: function () { o++; var e = (performance || Date).now(); if (l.update(e - n, 200), e >= a + 1e3 && (s.update(1e3 * o / (e - a), 100), a = e, o = 0, c)) { var t = performance.memory; c.update(t.usedJSHeapSize / 1048576, t.jsHeapSizeLimit / 1048576) } return e }, update: function () { n = this.end() }, domElement: t, setMode: r } }; Stats.Panel = function (e, t, i) { var r = 1 / 0, n = 0, a = Math.round, o = a(window.devicePixelRatio || 1), s = 80 * o, l = 48 * o, c = 3 * o, h = 2 * o, u = 3 * o, d = 15 * o, p = 74 * o, f = 30 * o, m = document.createElement("canvas"); m.width = s, m.height = l, m.style.cssText = "width:80px;height:48px"; var g = m.getContext("2d"); return g.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif", g.textBaseline = "top", g.fillStyle = i, g.fillRect(0, 0, s, l), g.fillStyle = t, g.fillText(e, c, h), g.fillRect(u, d, p, f), g.fillStyle = i, g.globalAlpha = .9, g.fillRect(u, d, p, f), { dom: m, update: function (l, y) { r = Math.min(r, l), n = Math.max(n, l), g.fillStyle = i, g.globalAlpha = 1, g.fillRect(0, 0, s, d), g.fillStyle = t, g.fillText(a(l) + " " + e + " (" + a(r) + "-" + a(n) + ")", c, h), g.drawImage(m, u + o, d, p - o, f, u, d, p - o, f), g.fillRect(u + p - o, d, o, f), g.fillStyle = i, g.globalAlpha = .9, g.fillRect(u + p - o, d, o, a((1 - l / y) * f)) } } }; var Stats$1 = Stats, ColorChannel = { RED: 0, GREEN: 1, BLUE: 2, ALPHA: 3 }, shader_default2 = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}", shader_default3 = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;\n#if PASS == 1\nuniform vec4 kernel64[32];\n#else\nuniform vec4 kernel16[8];\n#endif\nvarying vec2 vUv;void main(){\n#ifdef FOREGROUND\nvec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;\n#else\nfloat CoC=texture2D(cocBuffer,vUv).g*scale;\n#endif\nif(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\n#ifdef FOREGROUND\nvec2 step=texelSize*max(CoC,CoCNearFar.g*scale);\n#else\nvec2 step=texelSize*CoC;\n#endif\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}", BokehMaterial = class extends ShaderMaterial { constructor(e = !1, t = !1) { super({ type: "BokehMaterial", defines: { PASS: e ? "2" : "1" }, uniforms: { kernel64: new Uniform(null), kernel16: new Uniform(null), inputBuffer: new Uniform(null), cocBuffer: new Uniform(null), texelSize: new Uniform(new Vector2), scale: new Uniform(1) }, fragmentShader: shader_default3, vertexShader: shader_default2, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1, t && (this.defines.FOREGROUND = "1"), this.generateKernel() } generateKernel() { const e = new Float32Array(128), t = new Float32Array(32); let i = 0, r = 0; for (let n = 0; n < 80; ++n) { const a = 2.39996323 * n, o = Math.sqrt(n) / Math.sqrt(80), s = o * Math.cos(a), l = o * Math.sin(a); n % 5 == 0 ? (t[r++] = s, t[r++] = l) : (e[i++] = s, e[i++] = l) } const n = [], a = []; for (let t = 0; t < 128;)n.push(new Vector4(e[t++], e[t++], e[t++], e[t++])); for (let e = 0; e < 32;)a.push(new Vector4(t[e++], t[e++], t[e++], t[e++])); this.uniforms.kernel64.value = n, this.uniforms.kernel16.value = a } setTexelSize(e, t) { this.uniforms.texelSize.value.set(e, t) } }, shader_default4 = "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float focusDistance;uniform float focalLength;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focalLength,abs(signedDistance));gl_FragColor.rg=vec2(step(signedDistance,0.0)*magnitude,step(0.0,signedDistance)*magnitude);}", CircleOfConfusionMaterial = class extends ShaderMaterial { constructor(e) { super({ type: "CircleOfConfusionMaterial", defines: { DEPTH_PACKING: "0" }, uniforms: { depthBuffer: new Uniform(null), focusDistance: new Uniform(0), focalLength: new Uniform(0), cameraNear: new Uniform(.3), cameraFar: new Uniform(1e3) }, fragmentShader: shader_default4, vertexShader: shader_default2, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1, this.adoptCameraSettings(e) } get depthPacking() { return Number(this.defines.DEPTH_PACKING) } set depthPacking(e) { this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0 } adoptCameraSettings(e = null) { null !== e && (this.uniforms.cameraNear.value = e.near, this.uniforms.cameraFar.value = e.far, e instanceof PerspectiveCamera ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0) } }, shader_default5 = "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=linearToRelativeLuminance(texture2D(inputBuffer,vUv).rgb);float lLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv0).rgb);float lTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=linearToRelativeLuminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=linearToRelativeLuminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}", shader_default6 = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}", shader_default7 = "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <dithering_fragment>\n}", shader_default8 = "uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}", ConvolutionMaterial = class extends ShaderMaterial { constructor(e = new Vector2) { super({ type: "ConvolutionMaterial", uniforms: { inputBuffer: new Uniform(null), texelSize: new Uniform(new Vector2), halfTexelSize: new Uniform(new Vector2), kernel: new Uniform(0), scale: new Uniform(1) }, fragmentShader: shader_default7, vertexShader: shader_default8, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1, this.setTexelSize(e.x, e.y), this.kernelSize = KernelSize$1.LARGE } getKernel() { return kernelPresets$1[this.kernelSize] } setTexelSize(e, t) { this.uniforms.texelSize.value.set(e, t), this.uniforms.halfTexelSize.value.set(e, t).multiplyScalar(.5) } }, kernelPresets$1 = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])], KernelSize$1 = { VERY_SMALL: 0, SMALL: 1, MEDIUM: 2, LARGE: 3, VERY_LARGE: 4, HUGE: 5 }, shader_default9 = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <encodings_fragment>\n}", CopyMaterial = class extends ShaderMaterial { constructor() { super({ type: "CopyMaterial", uniforms: { inputBuffer: new Uniform(null), opacity: new Uniform(1) }, fragmentShader: shader_default9, vertexShader: shader_default2, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1 } }, shader_default10 = "#include <packing>\n#include <clipping_planes_pars_fragment>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float cameraNear;uniform float cameraFar;varying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <clipping_planes_fragment>\nvec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);float fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#else\nfloat viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#endif\nfloat depthTest=(-vViewZ>-viewZ)? 1.0 : 0.0;gl_FragColor.rg=vec2(0.0,depthTest);}", shader_default11 = "#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\nvViewZ=mvPosition.z;vProjTexCoord=gl_Position;\n#include <clipping_planes_vertex>\n}", DepthComparisonMaterial = class extends ShaderMaterial { constructor(e = null, t) { super({ type: "DepthComparisonMaterial", uniforms: { depthBuffer: new Uniform(e), cameraNear: new Uniform(.3), cameraFar: new Uniform(1e3) }, fragmentShader: shader_default10, vertexShader: shader_default11, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1, this.adoptCameraSettings(t) } adoptCameraSettings(e = null) { null !== e && (this.uniforms.cameraNear.value = e.near, this.uniforms.cameraFar.value = e.far, e instanceof PerspectiveCamera ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA) } }, shader_default14 = "#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\n#ifdef DOWNSAMPLE_NORMALS\nuniform lowp sampler2D normalBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])/4.0;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);\n#ifdef DOWNSAMPLE_NORMALS\nvec2 uvs[4];uvs[0]=vUv0;uvs[1]=vUv1;uvs[2]=vUv2;uvs[3]=vUv3;vec3 n=texture2D(normalBuffer,uvs[index]).rgb;\n#else\nvec3 n=vec3(0.0);\n#endif\ngl_FragColor=vec4(n,d[index]);}", shader_default15 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}", DepthDownsamplingMaterial = class extends ShaderMaterial { constructor() { super({ type: "DepthDownsamplingMaterial", defines: { DEPTH_PACKING: "0" }, uniforms: { depthBuffer: new Uniform(null), normalBuffer: new Uniform(null), texelSize: new Uniform(new Vector2) }, fragmentShader: shader_default14, vertexShader: shader_default15, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1 } get depthPacking() { return Number(this.defines.DEPTH_PACKING) } set depthPacking(e) { this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0 } setTexelSize(e, t) { this.uniforms.texelSize.value.set(e, t) } }, EdgeDetectionMaterial = class extends ShaderMaterial { constructor(e = new Vector2, t = EdgeDetectionMode.COLOR) { super({ type: "EdgeDetectionMaterial", defines: { LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0", EDGE_THRESHOLD: "0.1", DEPTH_THRESHOLD: "0.01", PREDICATION_MODE: "0", PREDICATION_THRESHOLD: "0.01", PREDICATION_SCALE: "2.0", PREDICATION_STRENGTH: "1.0", DEPTH_PACKING: "0" }, uniforms: { inputBuffer: new Uniform(null), depthBuffer: new Uniform(null), predicationBuffer: new Uniform(null), texelSize: new Uniform(e) }, fragmentShader: shader_default5, vertexShader: shader_default6, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1, this.setEdgeDetectionMode(t) } get depthPacking() { return Number(this.defines.DEPTH_PACKING) } set depthPacking(e) { this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0 } setEdgeDetectionMode(e) { this.defines.EDGE_DETECTION_MODE = e.toFixed(0), this.needsUpdate = !0 } setLocalContrastAdaptationFactor(e) { this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6"), this.needsUpdate = !0 } setEdgeDetectionThreshold(e) { this.defines.EDGE_THRESHOLD = e.toFixed("6"), this.defines.DEPTH_THRESHOLD = (.1 * e).toFixed("6"), this.needsUpdate = !0 } setPredicationMode(e) { this.defines.PREDICATION_MODE = e.toFixed(0), this.needsUpdate = !0 } setPredicationBuffer(e) { this.uniforms.predicationBuffer.value = e } setPredicationThreshold(e) { this.defines.PREDICATION_THRESHOLD = e.toFixed("6"), this.needsUpdate = !0 } setPredicationScale(e) { this.defines.PREDICATION_SCALE = e.toFixed("6"), this.needsUpdate = !0 } setPredicationStrength(e) { this.defines.PREDICATION_STRENGTH = e.toFixed("6"), this.needsUpdate = !0 } }, EdgeDetectionMode = { DEPTH: 0, LUMA: 1, COLOR: 2 }, PredicationMode = { DISABLED: 0, DEPTH: 1, CUSTOM: 2 }, shader_default17 = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <encodings_fragment>\n#endif\n#include <dithering_fragment>\n}", shader_default18 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}", EffectMaterial = class extends ShaderMaterial { constructor(e = null, t = null, i = null, r, n = !1) { super({ type: "EffectMaterial", defines: { DEPTH_PACKING: "0", ENCODE_OUTPUT: "1" }, uniforms: { inputBuffer: new Uniform(null), depthBuffer: new Uniform(null), resolution: new Uniform(new Vector2), texelSize: new Uniform(new Vector2), cameraNear: new Uniform(.3), cameraFar: new Uniform(1e3), aspect: new Uniform(1), time: new Uniform(0) }, blending: NoBlending, depthWrite: !1, depthTest: !1, dithering: n }), this.toneMapped = !1, null !== e && this.setShaderParts(e), null !== t && this.setDefines(t), null !== i && this.setUniforms(i), this.adoptCameraSettings(r) } get depthPacking() { return Number(this.defines.DEPTH_PACKING) } set depthPacking(e) { this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0 } setShaderParts(e) { return this.fragmentShader = shader_default17.replace(Section.FRAGMENT_HEAD, e.get(Section.FRAGMENT_HEAD)).replace(Section.FRAGMENT_MAIN_UV, e.get(Section.FRAGMENT_MAIN_UV)).replace(Section.FRAGMENT_MAIN_IMAGE, e.get(Section.FRAGMENT_MAIN_IMAGE)), this.vertexShader = shader_default18.replace(Section.VERTEX_HEAD, e.get(Section.VERTEX_HEAD)).replace(Section.VERTEX_MAIN_SUPPORT, e.get(Section.VERTEX_MAIN_SUPPORT)), this.needsUpdate = !0, this } setDefines(e) { for (const t of e.entries()) this.defines[t[0]] = t[1]; return this.needsUpdate = !0, this } setUniforms(e) { for (const t of e.entries()) this.uniforms[t[0]] = t[1]; return this } adoptCameraSettings(e = null) { null !== e && (this.uniforms.cameraNear.value = e.near, this.uniforms.cameraFar.value = e.far, e instanceof PerspectiveCamera ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0) } setSize(e, t) { const i = Math.max(e, 1), r = Math.max(t, 1); this.uniforms.resolution.value.set(i, r), this.uniforms.texelSize.value.set(1 / i, 1 / r), this.uniforms.aspect.value = i / r } }, Section = { FRAGMENT_HEAD: "FRAGMENT_HEAD", FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV", FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE", VERTEX_HEAD: "VERTEX_HEAD", VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT" }, shader_default20 = "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=linearToRelativeLuminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l);\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*l,l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}", LuminanceMaterial = class extends ShaderMaterial { constructor(e = !1, t = null) { const i = null !== t; super({ type: "LuminanceMaterial", uniforms: { inputBuffer: new Uniform(null), threshold: new Uniform(0), smoothing: new Uniform(1), range: new Uniform(i ? t : new Vector2) }, fragmentShader: shader_default20, vertexShader: shader_default2, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1, this.colorOutput = e, this.useThreshold = !0, this.useRange = i } get threshold() { return this.uniforms.threshold.value } set threshold(e) { this.uniforms.threshold.value = e } get smoothing() { return this.uniforms.smoothing.value } set smoothing(e) { this.uniforms.smoothing.value = e } get useThreshold() { return void 0 !== this.defines.THRESHOLD } set useThreshold(e) { e ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.needsUpdate = !0 } get colorOutput() { return void 0 !== this.defines.COLOR } set colorOutput(e) { e ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0 } setColorOutputEnabled(e) { this.colorOutput = e } get useRange() { return void 0 !== this.defines.RANGE } set useRange(e) { e ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.needsUpdate = !0 } get luminanceRange() { return this.useRange } set luminanceRange(e) { this.useRange = e } setLuminanceRangeEnabled(e) { this.useRange = e } }, shader_default21 = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef MASK_PRECISION_HIGH\nuniform mediump sampler2D maskTexture;\n#else\nuniform lowp sampler2D maskTexture;\n#endif\n#if MASK_FUNCTION != 0\nuniform float strength;\n#endif\nvarying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nmask=step(mask,0.0);\n#else\nmask=1.0-step(mask,0.0);\n#endif\n#else\nmask=clamp(mask*strength,0.0,1.0);\n#ifdef INVERTED\nmask=1.0-mask;\n#endif\n#endif\n#if MASK_FUNCTION == 2\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\n#else\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#endif\n}", MaskMaterial = class extends ShaderMaterial { constructor(e = null) { super({ type: "MaskMaterial", uniforms: { maskTexture: new Uniform(e), inputBuffer: new Uniform(null), strength: new Uniform(1) }, fragmentShader: shader_default21, vertexShader: shader_default2, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1, this.colorChannel = ColorChannel.RED, this.maskFunction = MaskFunction.DISCARD } set maskTexture(e) { this.uniforms.maskTexture.value = e, delete this.defines.MASK_PRECISION_HIGH, e.type !== UnsignedByteType && (this.defines.MASK_PRECISION_HIGH = "1"), this.needsUpdate = !0 } set colorChannel(e) { this.defines.COLOR_CHANNEL = e.toFixed(0), this.needsUpdate = !0 } set maskFunction(e) { this.defines.MASK_FUNCTION = e.toFixed(0), this.needsUpdate = !0 } get inverted() { return void 0 !== this.defines.INVERTED } set inverted(e) { this.inverted && !e ? delete this.defines.INVERTED : e && (this.defines.INVERTED = "1"), this.needsUpdate = !0 } get strength() { return this.uniforms.strength.value } set strength(e) { this.uniforms.strength.value = e } }, MaskFunction = { DISCARD: 0, MULTIPLY: 1, MULTIPLY_RGB_SET_ALPHA: 2 }, shader_default22 = "uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)? vec2(d,0.0): vec2(0.0,d);}", shader_default23 = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}", OutlineMaterial = class extends ShaderMaterial { constructor(e = new Vector2) { super({ type: "OutlineMaterial", uniforms: { inputBuffer: new Uniform(null), texelSize: new Uniform(new Vector2) }, fragmentShader: shader_default22, vertexShader: shader_default23, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1, this.setTexelSize(e.x, e.y), this.uniforms.maskTexture = this.uniforms.inputBuffer } setTexelSize(e, t) { this.uniforms.texelSize.value.set(e, t) } }, shader_default24 = "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}", shader_default25 = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}", SMAAWeightsMaterial = class extends ShaderMaterial { constructor(e = new Vector2, t = new Vector2) { super({ type: "SMAAWeightsMaterial", defines: { MAX_SEARCH_STEPS_INT: "16", MAX_SEARCH_STEPS_FLOAT: "16.0", MAX_SEARCH_STEPS_DIAG_INT: "8", MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0", CORNER_ROUNDING: "25", CORNER_ROUNDING_NORM: "0.25", AREATEX_MAX_DISTANCE: "16.0", AREATEX_MAX_DISTANCE_DIAG: "20.0", AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))", AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)", SEARCHTEX_SIZE: "vec2(66.0, 33.0)", SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)" }, uniforms: { inputBuffer: new Uniform(null), areaTexture: new Uniform(null), searchTexture: new Uniform(null), texelSize: new Uniform(e), resolution: new Uniform(t) }, fragmentShader: shader_default24, vertexShader: shader_default25, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1 } setOrthogonalSearchSteps(e) { const t = Math.min(Math.max(e, 0), 112); this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1"), this.needsUpdate = !0 } setDiagonalSearchSteps(e) { const t = Math.min(Math.max(e, 0), 20); this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1"), this.needsUpdate = !0 } setCornerRounding(e) { const t = Math.min(Math.max(e, 0), 100); this.defines.CORNER_ROUNDING = t.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4"), this.needsUpdate = !0 } get diagonalDetection() { return void 0 === this.defines.DISABLE_DIAG_DETECTION } set diagonalDetection(e) { e ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = !0 } get cornerRounding() { return void 0 === this.defines.DISABLE_CORNER_DETECTION } set cornerRounding(e) { e ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = !0 } }, shader_default26 = "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\n#ifndef NORMAL_DEPTH\nuniform lowp sampler2D normalBuffer;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(normalDepthBuffer,uv));\n#else\nreturn texture2D(normalDepthBuffer,uv).r;\n#endif\n}\n#endif\nuniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float minRadiusScale;uniform float intensity;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){\n#ifdef DISTANCE_SCALING\nfloat radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;\n#else\nfloat radius=RADIUS;\n#endif\nfloat noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float invSamples=1.0/SAMPLES_FLOAT;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*invSamples;float angle=alpha*rings+baseAngle;vec2 coord=alpha*radius*vec2(cos(angle),sin(angle))*texelSize+uv;if(coord.s<0.0||coord.s>1.0||coord.t<0.0||coord.t>1.0){continue;}\n#ifdef NORMAL_DEPTH\nfloat sampleDepth=texture2D(normalDepthBuffer,coord).a;\n#else\nfloat sampleDepth=readDepth(coord);\n#endif\nfloat viewZ=getViewZ(sampleDepth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearSampleDepth=sampleDepth;\n#endif\nfloat proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coord,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){\n#ifdef NORMAL_DEPTH\nvec4 normalDepth=texture2D(normalDepthBuffer,vUv);\n#else\nvec4 normalDepth=vec4(texture2D(normalBuffer,vUv).rgb,readDepth(vUv));\n#endif\nfloat ao=1.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao-=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,1.0,d);ao=clamp(pow(ao,abs(intensity)),0.0,1.0);}gl_FragColor.r=ao;}", shader_default27 = "uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}", SSAOMaterial = class extends ShaderMaterial { constructor(e) { super({ type: "SSAOMaterial", defines: { SAMPLES_INT: "0", SAMPLES_FLOAT: "0.0", SPIRAL_TURNS: "0.0", RADIUS: "1.0", RADIUS_SQ: "1.0", DISTANCE_SCALING: "1", DEPTH_PACKING: "0" }, uniforms: { normalBuffer: new Uniform(null), normalDepthBuffer: new Uniform(null), noiseTexture: new Uniform(null), inverseProjectionMatrix: new Uniform(new Matrix4), projectionMatrix: new Uniform(new Matrix4), texelSize: new Uniform(new Vector2), cameraNear: new Uniform(0), cameraFar: new Uniform(0), distanceCutoff: new Uniform(new Vector2), proximityCutoff: new Uniform(new Vector2), noiseScale: new Uniform(new Vector2), minRadiusScale: new Uniform(.33), intensity: new Uniform(1), fade: new Uniform(.01), bias: new Uniform(0) }, fragmentShader: shader_default26, vertexShader: shader_default27, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1, this.adoptCameraSettings(e) } get depthPacking() { return Number(this.defines.DEPTH_PACKING) } set depthPacking(e) { this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0 } setTexelSize(e, t) { this.uniforms.texelSize.value.set(e, t) } adoptCameraSettings(e = null) { if (null !== e) { const t = this.uniforms; t.cameraNear.value = e.near, t.cameraFar.value = e.far, e instanceof PerspectiveCamera ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0 } } }, dummyCamera = new Camera$1$1, geometry = null;
/**
   * postprocessing v6.23.2 build Thu Oct 28 2021
   * https://github.com/vanruesc/postprocessing
   * Copyright 2021 Raoul van Rüschen
   * @license Zlib
   */function getFullscreenTriangle() { if (null === geometry) { const e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), t = new Float32Array([0, 0, 2, 0, 0, 2]); void 0 !== (geometry = new BufferGeometry).setAttribute ? (geometry.setAttribute("position", new BufferAttribute(e, 3)), geometry.setAttribute("uv", new BufferAttribute(t, 2))) : (geometry.addAttribute("position", new BufferAttribute(e, 3)), geometry.addAttribute("uv", new BufferAttribute(t, 2))) } return geometry } var Pass = class { constructor(e = "Pass", t = new Scene, i = dummyCamera) { this.name = e, this.scene = t, this.camera = i, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0 } get renderToScreen() { return !this.rtt } set renderToScreen(e) { if (this.rtt === e) { const t = this.getFullscreenMaterial(); null !== t && (t.needsUpdate = !0), this.rtt = !e } } isEnabled() { return this.enabled } setEnabled(e) { this.enabled = e } getFullscreenMaterial() { return null !== this.screen ? this.screen.material : null } setFullscreenMaterial(e) { let t = this.screen; null !== t ? t.material = e : (t = new Mesh(getFullscreenTriangle(), e), t.frustumCulled = !1, null === this.scene && (this.scene = new Scene), this.scene.add(t), this.screen = t) } getDepthTexture() { return null } setDepthTexture(e, t = 0) { } render(e, t, i, r, n) { throw new Error("Render method not implemented!") } setSize(e, t) { } initialize(e, t, i) { } dispose() { const e = this.getFullscreenMaterial(); null !== e && e.dispose(); for (const e of Object.keys(this)) { const t = this[e]; if (null !== t && "function" == typeof t.dispose) { if (t instanceof Scene) continue; this[e].dispose() } } } }, AUTO_SIZE = -1, Resizer = class { constructor(e, t = AUTO_SIZE, i = AUTO_SIZE, r = 1) { this.resizable = e, this.base = new Vector2(1, 1), this.target = new Vector2(t, i), this.s = r } get scale() { return this.s } set scale(e) { this.s = e, this.target.x = AUTO_SIZE, this.target.y = AUTO_SIZE, this.resizable.setSize(this.base.x, this.base.y) } get width() { const e = this.base, t = this.target; let i; return i = t.x !== AUTO_SIZE ? t.x : t.y !== AUTO_SIZE ? Math.round(t.y * (e.x / e.y)) : Math.round(e.x * this.s), i } set width(e) { this.target.x = e, this.resizable.setSize(this.base.x, this.base.y) } get height() { const e = this.base, t = this.target; let i; return i = t.y !== AUTO_SIZE ? t.y : t.x !== AUTO_SIZE ? Math.round(t.x / (e.x / e.y)) : Math.round(e.y * this.s), i } set height(e) { this.target.y = e, this.resizable.setSize(this.base.x, this.base.y) } static get AUTO_SIZE() { return AUTO_SIZE } }, BlurPass = class extends Pass { constructor({ resolutionScale: e = .5, width: t = Resizer.AUTO_SIZE, height: i = Resizer.AUTO_SIZE, kernelSize: r = KernelSize$1.LARGE } = {}) { super("BlurPass"), this.renderTargetA = new WebGLRenderTarget(1, 1, { minFilter: LinearFilter, magFilter: LinearFilter, stencilBuffer: !1, depthBuffer: !1 }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B", this.resolution = new Resizer(this, t, i, e), this.convolutionMaterial = new ConvolutionMaterial, this.ditheredConvolutionMaterial = new ConvolutionMaterial, this.ditheredConvolutionMaterial.dithering = !0, this.dithering = !1, this.kernelSize = r } get width() { return this.resolution.width } set width(e) { this.resolution.width = e } get height() { return this.resolution.height } set height(e) { this.resolution.height = e } get scale() { return this.convolutionMaterial.uniforms.scale.value } set scale(e) { this.convolutionMaterial.uniforms.scale.value = e, this.ditheredConvolutionMaterial.uniforms.scale.value = e } get kernelSize() { return this.convolutionMaterial.kernelSize } set kernelSize(e) { this.convolutionMaterial.kernelSize = e, this.ditheredConvolutionMaterial.kernelSize = e } getResolutionScale() { return this.resolution.scale } setResolutionScale(e) { this.resolution.scale = e } render(e, t, i, r, n) { const a = this.scene, o = this.camera, s = this.renderTargetA, l = this.renderTargetB; let c = this.convolutionMaterial, h = c.uniforms; const u = c.getKernel(); let d, p, f, m = t; for (this.setFullscreenMaterial(c), p = 0, f = u.length - 1; p < f; ++p)d = 0 == (1 & p) ? s : l, h.kernel.value = u[p], h.inputBuffer.value = m.texture, e.setRenderTarget(d), e.render(a, o), m = d; this.dithering && (c = this.ditheredConvolutionMaterial, h = c.uniforms, this.setFullscreenMaterial(c)), h.kernel.value = u[p], h.inputBuffer.value = m.texture, e.setRenderTarget(this.renderToScreen ? null : i), e.render(a, o) } setSize(e, t) { const i = this.resolution; i.base.set(e, t); const r = i.width, n = i.height; this.renderTargetA.setSize(r, n), this.renderTargetB.setSize(r, n), this.convolutionMaterial.setTexelSize(1 / r, 1 / n), this.ditheredConvolutionMaterial.setTexelSize(1 / r, 1 / n) } initialize(e, t, i) { if (t || i !== UnsignedByteType || (this.renderTargetA.texture.format = RGBFormat, this.renderTargetB.texture.format = RGBFormat), void 0 !== i && (this.renderTargetA.texture.type = i, this.renderTargetB.texture.type = i, i !== UnsignedByteType)) { const e = this.convolutionMaterial, t = this.ditheredConvolutionMaterial; e.defines.FRAMEBUFFER_PRECISION_HIGH = "1", t.defines.FRAMEBUFFER_PRECISION_HIGH = "1" } } static get AUTO_SIZE() { return Resizer.AUTO_SIZE } }, ClearMaskPass = class extends Pass { constructor() { super("ClearMaskPass", null, null), this.needsSwap = !1 } render(e, t, i, r, n) { const a = e.state.buffers.stencil; a.setLocked(!1), a.setTest(!1) } }, color = new Color$1, ClearPass = class extends Pass { constructor(e = !0, t = !0, i = !1) { super("ClearPass", null, null), this.needsSwap = !1, this.color = e, this.depth = t, this.stencil = i, this.overrideClearColor = null, this.overrideClearAlpha = -1 } render(e, t, i, r, n) { const a = this.overrideClearColor, o = this.overrideClearAlpha, s = e.getClearAlpha(), l = null !== a, c = o >= 0; l ? (color.copy(e.getClearColor(color)), e.setClearColor(a, c ? o : s)) : c && e.setClearAlpha(o), e.setRenderTarget(this.renderToScreen ? null : t), e.clear(this.color, this.depth, this.stencil), l ? e.setClearColor(color, s) : c && e.setClearAlpha(s) } }, workaroundEnabled = !1, OverrideMaterialManager = class { constructor(e = null) { this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(e), this.meshCount = 0, this.replaceMaterial = e => { if (e.isMesh) { let t; if (e.material.flatShading) switch (e.material.side) { case DoubleSide: t = this.materialsFlatShadedDoubleSide; break; case BackSide: t = this.materialsFlatShadedBackSide; break; default: t = this.materialsFlatShaded } else switch (e.material.side) { case DoubleSide: t = this.materialsDoubleSide; break; case BackSide: t = this.materialsBackSide; break; default: t = this.materials }this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount } } } setMaterial(e) { if (this.disposeMaterials(), this.material = e, null !== e) { const t = this.materials = [e.clone(), e.clone(), e.clone()]; for (const i of t) i.uniforms = Object.assign({}, e.uniforms), i.side = FrontSide; t[2].skinning = !0, this.materialsBackSide = t.map((t => { const i = t.clone(); return i.uniforms = Object.assign({}, e.uniforms), i.side = BackSide, i })), this.materialsDoubleSide = t.map((t => { const i = t.clone(); return i.uniforms = Object.assign({}, e.uniforms), i.side = DoubleSide, i })), this.materialsFlatShaded = t.map((t => { const i = t.clone(); return i.uniforms = Object.assign({}, e.uniforms), i.flatShading = !0, i })), this.materialsFlatShadedBackSide = t.map((t => { const i = t.clone(); return i.uniforms = Object.assign({}, e.uniforms), i.flatShading = !0, i.side = BackSide, i })), this.materialsFlatShadedDoubleSide = t.map((t => { const i = t.clone(); return i.uniforms = Object.assign({}, e.uniforms), i.flatShading = !0, i.side = DoubleSide, i })) } } render(e, t, i) { const r = e.shadowMap.enabled; if (e.shadowMap.enabled = !1, workaroundEnabled) { const r = this.originalMaterials; this.meshCount = 0, t.traverse(this.replaceMaterial), e.render(t, i); for (const e of r) e[0].material = e[1]; this.meshCount !== r.size && r.clear() } else { const r = t.overrideMaterial; t.overrideMaterial = this.material, e.render(t, i), t.overrideMaterial = r } e.shadowMap.enabled = r } disposeMaterials() { if (null !== this.material) { const e = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide); for (const t of e) t.dispose() } } dispose() { this.originalMaterials.clear(), this.disposeMaterials() } static get workaroundEnabled() { return workaroundEnabled } static set workaroundEnabled(e) { workaroundEnabled = e } }, RenderPass = class extends Pass { constructor(e, t, i = null) { super("RenderPass", e, t), this.needsSwap = !1, this.clearPass = new ClearPass, this.overrideMaterialManager = null === i ? null : new OverrideMaterialManager(i), this.backgroundDisabled = !1, this.shadowMapDisabled = !1, this.selection = null } get renderToScreen() { return super.renderToScreen } set renderToScreen(e) { super.renderToScreen = e, this.clearPass.renderToScreen = e } get overrideMaterial() { const e = this.overrideMaterialManager; return null !== e ? e.material : null } set overrideMaterial(e) { const t = this.overrideMaterialManager; null !== e ? null !== t ? t.setMaterial(e) : this.overrideMaterialManager = new OverrideMaterialManager(e) : null !== t && (t.dispose(), this.overrideMaterialManager = null) } get clear() { return this.clearPass.enabled } set clear(e) { this.clearPass.enabled = e } getSelection() { return this.selection } setSelection(e) { this.selection = e } isBackgroundDisabled() { return this.backgroundDisabled } setBackgroundDisabled(e) { this.backgroundDisabled = e } isShadowMapDisabled() { return this.shadowMapDisabled } setShadowMapDisabled(e) { this.shadowMapDisabled = e } getClearPass() { return this.clearPass } render(e, t, i, r, n) { const a = this.scene, o = this.camera, s = this.selection, l = o.layers.mask, c = a.background, h = e.shadowMap.autoUpdate, u = this.renderToScreen ? null : t; null !== s && o.layers.set(s.getLayer()), this.shadowMapDisabled && (e.shadowMap.autoUpdate = !1), (this.backgroundDisabled || null !== this.clearPass.overrideClearColor) && (a.background = null), this.clear && this.clearPass.render(e, t), e.setRenderTarget(u), null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(e, a, o) : e.render(a, o), o.layers.mask = l, a.background = c, e.shadowMap.autoUpdate = h } }, DepthPass = class extends Pass { constructor(e, t, { resolutionScale: i = 1, width: r = Resizer.AUTO_SIZE, height: n = Resizer.AUTO_SIZE, renderTarget: a } = {}) { super("DepthPass"), this.needsSwap = !1, this.renderPass = new RenderPass(e, t, new MeshDepthMaterial({ depthPacking: RGBADepthPacking })); const o = this.renderPass; o.setBackgroundDisabled(!0), o.setShadowMapDisabled(!0); const s = o.getClearPass(); s.overrideClearColor = new Color$1(16777215), s.overrideClearAlpha = 1, this.renderTarget = a, void 0 === this.renderTarget && (this.renderTarget = new WebGLRenderTarget(1, 1, { minFilter: NearestFilter, magFilter: NearestFilter, stencilBuffer: !1 }), this.renderTarget.texture.name = "DepthPass.Target"), this.resolution = new Resizer(this, r, n, i) } get texture() { return this.renderTarget.texture } getResolutionScale() { return this.resolutionScale } setResolutionScale(e) { this.resolutionScale = e, this.setSize(this.resolution.base.x, this.resolution.base.y) } render(e, t, i, r, n) { const a = this.renderToScreen ? null : this.renderTarget; this.renderPass.render(e, a) } setSize(e, t) { const i = this.resolution; i.base.set(e, t), this.renderTarget.setSize(i.width, i.height) } }, DepthDownsamplingPass = class extends Pass { constructor({ normalBuffer: e = null, resolutionScale: t = .5, width: i = Resizer.AUTO_SIZE, height: r = Resizer.AUTO_SIZE } = {}) { if (super("DepthDownsamplingPass"), this.setFullscreenMaterial(new DepthDownsamplingMaterial), this.needsDepthTexture = !0, this.needsSwap = !1, null !== e) { const t = this.getFullscreenMaterial(); t.uniforms.normalBuffer.value = e, t.defines.DOWNSAMPLE_NORMALS = "1" } this.renderTarget = new WebGLRenderTarget(1, 1, { minFilter: NearestFilter, magFilter: NearestFilter, stencilBuffer: !1, depthBuffer: !1, type: FloatType }), this.renderTarget.texture.name = "DepthDownsamplingPass.Target", this.renderTarget.texture.generateMipmaps = !1, this.resolution = new Resizer(this, i, r), this.resolution.scale = t } get texture() { return this.renderTarget.texture } setDepthTexture(e, t = BasicDepthPacking) { const i = this.getFullscreenMaterial(); i.uniforms.depthBuffer.value = e, i.depthPacking = t } render(e, t, i, r, n) { e.setRenderTarget(this.renderToScreen ? null : this.renderTarget), e.render(this.scene, this.camera) } setSize(e, t) { const i = this.resolution; i.base.set(e, t), this.getFullscreenMaterial().setTexelSize(1 / e, 1 / t), this.renderTarget.setSize(i.width, i.height) } initialize(e, t, i) { e.capabilities.isWebGL2 || console.error("The DepthDownsamplingPass requires WebGL 2") } }, BlendFunction = { SKIP: 0, ADD: 1, ALPHA: 2, AVERAGE: 3, COLOR_BURN: 4, COLOR_DODGE: 5, DARKEN: 6, DIFFERENCE: 7, EXCLUSION: 8, LIGHTEN: 9, MULTIPLY: 10, DIVIDE: 11, NEGATION: 12, NORMAL: 13, OVERLAY: 14, REFLECT: 15, SCREEN: 16, SOFT_LIGHT: 17, SUBTRACT: 18 }, shader_default28 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}", shader_default29 = "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}", shader_default30 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}", shader_default31 = "float blend(const in float x,const in float y){return(y==0.0)? y : max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", shader_default32 = "float blend(const in float x,const in float y){return(y==1.0)? y : min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", shader_default33 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}", shader_default34 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}", shader_default35 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}", shader_default36 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}", shader_default37 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}", shader_default38 = "float blend(const in float x,const in float y){return(y>0.0)? min(x/y,1.0): 1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", shader_default39 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}", shader_default40 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}", shader_default41 = "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", shader_default42 = "float blend(const in float x,const in float y){return(y==1.0)? y : min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", shader_default43 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}", shader_default44 = "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", shader_default45 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}", blendFunctions = new Map([[BlendFunction.SKIP, null], [BlendFunction.ADD, shader_default28], [BlendFunction.ALPHA, shader_default29], [BlendFunction.AVERAGE, shader_default30], [BlendFunction.COLOR_BURN, shader_default31], [BlendFunction.COLOR_DODGE, shader_default32], [BlendFunction.DARKEN, shader_default33], [BlendFunction.DIFFERENCE, shader_default34], [BlendFunction.EXCLUSION, shader_default35], [BlendFunction.LIGHTEN, shader_default36], [BlendFunction.MULTIPLY, shader_default37], [BlendFunction.DIVIDE, shader_default38], [BlendFunction.NEGATION, shader_default39], [BlendFunction.NORMAL, shader_default40], [BlendFunction.OVERLAY, shader_default41], [BlendFunction.REFLECT, shader_default42], [BlendFunction.SCREEN, shader_default43], [BlendFunction.SOFT_LIGHT, shader_default44], [BlendFunction.SUBTRACT, shader_default45]]), BlendMode = class extends EventDispatcher { constructor(e, t = 1) { super(), this.blendFunction = e, this.opacity = new Uniform(t) } getBlendFunction() { return this.blendFunction } setBlendFunction(e) { this.blendFunction = e, this.dispatchEvent({ type: "change" }) } getShaderCode() { return blendFunctions.get(this.blendFunction) } }, Effect$1 = class extends EventDispatcher { constructor(e, t, { attributes: i = EffectAttribute.NONE, blendFunction: r = BlendFunction.SCREEN, defines: n = new Map, uniforms: a = new Map, extensions: o = null, vertexShader: s = null } = {}) { super(), this.name = e, this.attributes = i, this.fragmentShader = t, this.vertexShader = s, this.defines = n, this.uniforms = a, this.extensions = o, this.blendMode = new BlendMode(r), this.blendMode.addEventListener("change", (e => this.setChanged())) } setChanged() { this.dispatchEvent({ type: "change" }) } getAttributes() { return this.attributes } setAttributes(e) { this.attributes = e, this.setChanged() } getFragmentShader() { return this.fragmentShader } setFragmentShader(e) { this.fragmentShader = e, this.setChanged() } getVertexShader() { return this.vertexShader } setVertexShader(e) { this.vertexShader = e, this.setChanged() } setDepthTexture(e, t = 0) { } update(e, t, i) { } setSize(e, t) { } initialize(e, t, i) { } dispose() { for (const e of Object.keys(this)) { const t = this[e]; if (null !== t && "function" == typeof t.dispose) { if (t instanceof Scene) continue; this[e].dispose() } } } }, EffectAttribute = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 }; function findSubstrings(e, t) { const i = []; let r; for (; null !== (r = e.exec(t));)i.push(r[1]); return i } function prefixSubstrings(e, t, i) { let r, n; for (const a of t) { r = "$1" + e + a.charAt(0).toUpperCase() + a.slice(1), n = new RegExp("([^\\.])(\\b" + a + "\\b)", "g"); for (const e of i.entries()) null !== e[1] && i.set(e[0], e[1].replace(n, r)) } } function integrateEffect(e, t, i, r, n, a, o) { const s = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g, l = /(?:varying\s+\w+\s+(\w*))/g, c = t.blendMode, h = new Map([["fragment", t.getFragmentShader()], ["vertex", t.getVertexShader()]]), u = void 0 !== h.get("fragment") && /mainImage/.test(h.get("fragment")), d = void 0 !== h.get("fragment") && /mainUv/.test(h.get("fragment")); let p = [], f = [], m = !1, g = !1; if (void 0 === h.get("fragment")) console.error("Missing fragment shader", t); else if (d && 0 != (o & EffectAttribute.CONVOLUTION)) console.error("Effects that transform UV coordinates are incompatible with convolution effects", t); else if (u || d) { if (d && (i.set(Section.FRAGMENT_MAIN_UV, i.get(Section.FRAGMENT_MAIN_UV) + "\t" + e + "MainUv(UV);\n"), m = !0), null !== h.get("vertex") && /mainSupport/.test(h.get("vertex"))) { let t = "\t" + e + "MainSupport("; /mainSupport *\([\w\s]*?uv\s*?\)/.test(h.get("vertex")) && (t += "vUv"), t += ");\n", i.set(Section.VERTEX_MAIN_SUPPORT, i.get(Section.VERTEX_MAIN_SUPPORT) + t), p = p.concat(findSubstrings(l, h.get("vertex"))), f = f.concat(p).concat(findSubstrings(s, h.get("vertex"))) } if (f = f.concat(findSubstrings(s, h.get("fragment"))), f = f.concat(Array.from(t.defines.keys()).map((e => e.replace(/\([\w\s,]*\)/g, "")))), f = f.concat(Array.from(t.uniforms.keys())), t.uniforms.forEach(((t, i) => a.set(e + i.charAt(0).toUpperCase() + i.slice(1), t))), t.defines.forEach(((t, i) => n.set(e + i.charAt(0).toUpperCase() + i.slice(1), t))), prefixSubstrings(e, f, n), prefixSubstrings(e, f, h), r.set(c.blendFunction, c), u) { const t = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/; let r = e + "MainImage(color0, UV, "; 0 != (o & EffectAttribute.DEPTH) && t.test(h.get("fragment")) && (r += "depth, ", g = !0), r += "color1);\n\t"; const n = e + "BlendOpacity"; a.set(n, c.opacity), r += "color0 = blend" + c.getBlendFunction() + "(color0, color1, " + n + ");\n\n\t", i.set(Section.FRAGMENT_MAIN_IMAGE, i.get(Section.FRAGMENT_MAIN_IMAGE) + r), i.set(Section.FRAGMENT_HEAD, i.get(Section.FRAGMENT_HEAD) + "uniform float " + n + ";\n\n") } i.set(Section.FRAGMENT_HEAD, i.get(Section.FRAGMENT_HEAD) + h.get("fragment") + "\n"), null !== h.get("vertex") && i.set(Section.VERTEX_HEAD, i.get(Section.VERTEX_HEAD) + h.get("vertex") + "\n") } else console.error("The fragment shader contains neither a mainImage nor a mainUv function", t); return { varyings: p, transformedUv: m, readDepth: g } } var EffectPass = class extends Pass { constructor(e, ...t) { super("EffectPass"), this.setFullscreenMaterial(new EffectMaterial(null, null, null, e)), this.effects = t.sort(((e, t) => t.attributes - e.attributes)), this.skipRendering = !1, this.uniforms = 0, this.varyings = 0, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY } get encodeOutput() { return void 0 !== this.getFullscreenMaterial().defines.ENCODE_OUTPUT } set encodeOutput(e) { if (this.encodeOutput !== e) { const t = this.getFullscreenMaterial(); t.needsUpdate = !0, e ? t.defines.ENCODE_OUTPUT = "1" : delete t.defines.ENCODE_OUTPUT } } get dithering() { return this.getFullscreenMaterial().dithering } set dithering(e) { const t = this.getFullscreenMaterial(); t.dithering !== e && (t.dithering = e, t.needsUpdate = !0) } verifyResources(e) { const t = e.capabilities; let i = Math.min(t.maxFragmentUniforms, t.maxVertexUniforms); this.uniforms > i && console.warn("The current rendering context doesn't support more than " + i + " uniforms, but " + this.uniforms + " were defined"), i = t.maxVaryings, this.varyings > i && console.warn("The current rendering context doesn't support more than " + i + " varyings, but " + this.varyings + " were defined") } updateMaterial() { const e = /\bblend\b/g, t = new Map([[Section.FRAGMENT_HEAD, ""], [Section.FRAGMENT_MAIN_UV, ""], [Section.FRAGMENT_MAIN_IMAGE, ""], [Section.VERTEX_HEAD, ""], [Section.VERTEX_MAIN_SUPPORT, ""]]), i = new Map, r = new Map, n = new Map, a = new Set; let o, s = 0, l = 0, c = 0, h = !1, u = !1; for (const e of this.effects) if (e.blendMode.getBlendFunction() === BlendFunction.SKIP) c |= e.getAttributes() & EffectAttribute.DEPTH; else if (0 != (c & EffectAttribute.CONVOLUTION) && 0 != (e.getAttributes() & EffectAttribute.CONVOLUTION)) console.error("Convolution effects cannot be merged", e); else if (c |= e.getAttributes(), o = integrateEffect("e" + s++, e, t, i, r, n, c), l += o.varyings.length, h = h || o.transformedUv, u = u || o.readDepth, null !== e.extensions) for (const t of e.extensions) a.add(t); for (const r of i.values()) t.set(Section.FRAGMENT_HEAD, t.get(Section.FRAGMENT_HEAD) + r.getShaderCode().replace(e, "blend" + r.getBlendFunction()) + "\n"); 0 != (c & EffectAttribute.DEPTH) ? (u && t.set(Section.FRAGMENT_MAIN_IMAGE, "float depth = readDepth(UV);\n\n\t" + t.get(Section.FRAGMENT_MAIN_IMAGE)), this.needsDepthTexture = null === this.getDepthTexture()) : this.needsDepthTexture = !1, h ? (t.set(Section.FRAGMENT_MAIN_UV, "vec2 transformedUv = vUv;\n" + t.get(Section.FRAGMENT_MAIN_UV)), r.set("UV", "transformedUv")) : r.set("UV", "vUv"), t.forEach(((e, t, i) => i.set(t, e.trim().replace(/^#/, "\n#")))), this.uniforms = n.size, this.varyings = l, this.skipRendering = 0 === s, this.needsSwap = !this.skipRendering; const d = this.getFullscreenMaterial(); if (d.setShaderParts(t), d.setDefines(r), d.setUniforms(n), d.extensions = {}, a.size > 0) for (const e of a) d.extensions[e] = !0; this.needsUpdate = !1 } recompile(e) { this.updateMaterial(), void 0 !== e && this.verifyResources(e) } getDepthTexture() { return this.getFullscreenMaterial().uniforms.depthBuffer.value } setDepthTexture(e, t = BasicDepthPacking) { const i = this.getFullscreenMaterial(); i.uniforms.depthBuffer.value = e, i.depthPacking = t, i.needsUpdate = !0; for (const i of this.effects) i.setDepthTexture(e, t) } render(e, t, i, r, n) { const a = this.getFullscreenMaterial(), o = a.uniforms.time.value + r; this.needsUpdate && this.recompile(e); for (const i of this.effects) i.update(e, t, r); this.skipRendering && !this.renderToScreen || (a.uniforms.inputBuffer.value = t.texture, a.uniforms.time.value = o <= this.maxTime ? o : this.minTime, e.setRenderTarget(this.renderToScreen ? null : i), e.render(this.scene, this.camera)) } setSize(e, t) { this.getFullscreenMaterial().setSize(e, t); for (const i of this.effects) i.setSize(e, t) } initialize(e, t, i) { for (const r of this.effects) r.initialize(e, t, i), r.addEventListener("change", (e => this.handleEvent(e))); if (this.updateMaterial(), this.verifyResources(e), void 0 !== i && i !== UnsignedByteType) { this.getFullscreenMaterial().defines.FRAMEBUFFER_PRECISION_HIGH = "1" } } dispose() { super.dispose(); for (const e of this.effects) e.dispose() } handleEvent(e) { switch (e.type) { case "change": this.needsUpdate = !0 } } }, LuminancePass = class extends Pass { constructor({ width: e = Resizer.AUTO_SIZE, height: t = Resizer.AUTO_SIZE, renderTarget: i, luminanceRange: r, colorOutput: n } = {}) { super("LuminancePass"), this.setFullscreenMaterial(new LuminanceMaterial(n, r)), this.needsSwap = !1, this.renderTarget = i, void 0 === this.renderTarget && (this.renderTarget = new WebGLRenderTarget(1, 1, { minFilter: LinearFilter, magFilter: LinearFilter, format: n ? RGBAFormat : LuminanceFormat, stencilBuffer: !1, depthBuffer: !1 }), this.renderTarget.texture.name = "LuminancePass.Target", this.renderTarget.texture.generateMipmaps = !1), this.resolution = new Resizer(this, e, t) } get texture() { return this.renderTarget.texture } render(e, t, i, r, n) { this.getFullscreenMaterial().uniforms.inputBuffer.value = t.texture, e.setRenderTarget(this.renderToScreen ? null : this.renderTarget), e.render(this.scene, this.camera) } setSize(e, t) { const i = this.resolution; i.base.set(e, t), this.renderTarget.setSize(i.width, i.height) } initialize(e, t, i) { if (void 0 !== i && i !== UnsignedByteType) { this.getFullscreenMaterial().defines.FRAMEBUFFER_PRECISION_HIGH = "1" } } }, MaskPass = class extends Pass { constructor(e, t) { super("MaskPass", e, t), this.needsSwap = !1, this.clearPass = new ClearPass(!1, !1, !0), this.inverse = !1 } get clear() { return this.clearPass.enabled } set clear(e) { this.clearPass.enabled = e } render(e, t, i, r, n) { const a = e.getContext(), o = e.state.buffers, s = this.scene, l = this.camera, c = this.clearPass, h = this.inverse ? 0 : 1, u = 1 - h; o.color.setMask(!1), o.depth.setMask(!1), o.color.setLocked(!0), o.depth.setLocked(!0), o.stencil.setTest(!0), o.stencil.setOp(a.REPLACE, a.REPLACE, a.REPLACE), o.stencil.setFunc(a.ALWAYS, h, 4294967295), o.stencil.setClear(u), o.stencil.setLocked(!0), this.clear && (this.renderToScreen ? c.render(e, null) : (c.render(e, t), c.render(e, i))), this.renderToScreen ? (e.setRenderTarget(null), e.render(s, l)) : (e.setRenderTarget(t), e.render(s, l), e.setRenderTarget(i), e.render(s, l)), o.color.setLocked(!1), o.depth.setLocked(!1), o.stencil.setLocked(!1), o.stencil.setFunc(a.EQUAL, 1, 4294967295), o.stencil.setOp(a.KEEP, a.KEEP, a.KEEP), o.stencil.setLocked(!0) } }, NormalPass = class extends Pass { constructor(e, t, { resolutionScale: i = 1, width: r = Resizer.AUTO_SIZE, height: n = Resizer.AUTO_SIZE, renderTarget: a } = {}) { super("NormalPass"), this.needsSwap = !1, this.renderPass = new RenderPass(e, t, new MeshNormalMaterial); const o = this.renderPass; o.setBackgroundDisabled(!0), o.setShadowMapDisabled(!0); const s = o.getClearPass(); s.overrideClearColor = new Color$1(7829503), s.overrideClearAlpha = 1, this.renderTarget = a, void 0 === this.renderTarget && (this.renderTarget = new WebGLRenderTarget(1, 1, { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBFormat, stencilBuffer: !1 }), this.renderTarget.texture.name = "NormalPass.Target"), this.resolution = new Resizer(this, r, n, i) } get texture() { return this.renderTarget.texture } getResolutionScale() { return this.resolutionScale } setResolutionScale(e) { this.resolutionScale = e, this.setSize(this.resolution.base.x, this.resolution.base.y) } render(e, t, i, r, n) { const a = this.renderToScreen ? null : this.renderTarget; this.renderPass.render(e, a, a) } setSize(e, t) { const i = this.resolution; i.base.set(e, t), this.renderTarget.setSize(i.width, i.height) } }, ShaderPass = class extends Pass { constructor(e, t = "inputBuffer") { super("ShaderPass"), this.setFullscreenMaterial(e), this.uniform = null, this.setInput(t) } setInput(e) { const t = this.getFullscreenMaterial(); if (this.uniform = null, null !== t) { const i = t.uniforms; void 0 !== i && void 0 !== i[e] && (this.uniform = i[e]) } } render(e, t, i, r, n) { null !== this.uniform && null !== t && (this.uniform.value = t.texture), e.setRenderTarget(this.renderToScreen ? null : i), e.render(this.scene, this.camera) } initialize(e, t, i) { if (void 0 !== i && i !== UnsignedByteType) { this.getFullscreenMaterial().defines.FRAMEBUFFER_PRECISION_HIGH = "1" } } }, MILLISECONDS_TO_SECONDS = .001, SECONDS_TO_MILLISECONDS = 1e3, Timer = class { constructor() { this.previousTime = 0, this.currentTime = 0, this.delta = 0, this.fixedDelta = 1e3 / 60, this.elapsed = 0, this.timescale = 1, this.fixedDeltaEnabled = !1 } setFixedDeltaEnabled(e) { return this.fixedDeltaEnabled = e, this } setAutoResetEnabled(e) { return "undefined" != typeof document && void 0 !== document.hidden && (e ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this)), this } getDelta() { return this.delta * MILLISECONDS_TO_SECONDS } getFixedDelta() { return this.fixedDelta * MILLISECONDS_TO_SECONDS } setFixedDelta(e) { return this.fixedDelta = e * SECONDS_TO_MILLISECONDS, this } getElapsed() { return this.elapsed * MILLISECONDS_TO_SECONDS } getTimescale() { return this.timescale } setTimescale(e) { return this.timescale = e, this } update(e) { return this.fixedDeltaEnabled ? this.delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = void 0 !== e ? e : performance.now(), this.delta = this.currentTime - this.previousTime), this.delta *= this.timescale, this.elapsed += this.deltaTime, this } reset() { return this.delta = 0, this.elapsed = 0, this.currentTime = performance.now(), this } handleEvent(e) { document.hidden || (this.currentTime = performance.now()) } dispose() { "undefined" != typeof document && document.removeEventListener("visibilitychange", this) } }, EffectComposer = class { constructor(e = null, { depthBuffer: t = !0, stencilBuffer: i = !1, alpha: r = !1, multisampling: n = 0, frameBufferType: a } = {}) { this.renderer = e, this.inputBuffer = null, this.outputBuffer = null, null !== this.renderer && (this.renderer.autoClear = !1, this.inputBuffer = this.createBuffer(t, i, a, n), this.outputBuffer = this.inputBuffer.clone()), this.copyPass = new ShaderPass(new CopyMaterial), this.alpha = r, this.depthTexture = null, this.passes = [], this.timer = new Timer, this.autoRenderToScreen = !0 } get multisampling() { return this.inputBuffer instanceof WebGLMultisampleRenderTarget ? this.inputBuffer.samples : 0 } set multisampling(e) { const t = this.inputBuffer, i = this.multisampling; i > 0 && e > 0 ? (this.inputBuffer.samples = e, this.outputBuffer.samples = e) : i !== e && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(t.depthBuffer, t.stencilBuffer, t.texture.type, e), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone()) } getTimer() { return this.timer } getRenderer() { return this.renderer } replaceRenderer(e, t = !0) { const i = this.renderer; if (null !== i && i !== e) { const r = i.getSize(new Vector2), n = e.getSize(new Vector2), a = i.domElement.parentNode; this.renderer = e, this.renderer.autoClear = !1, r.equals(n) || this.setSize(), t && null !== a && (a.removeChild(i.domElement), a.appendChild(e.domElement)) } return i } createDepthTexture() { const e = this.depthTexture = new DepthTexture; return this.inputBuffer.depthTexture = e, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (e.format = DepthStencilFormat, e.type = UnsignedInt248Type) : e.type = UnsignedIntType, e } deleteDepthTexture() { if (null !== this.depthTexture) { this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose(); for (const e of this.passes) e.setDepthTexture(null) } } createBuffer(e, t, i, r) { const n = this.renderer, a = n.getContext(), o = n.getDrawingBufferSize(new Vector2), s = { format: this.alpha || a.getContextAttributes().alpha || i !== UnsignedByteType ? RGBAFormat : RGBFormat, minFilter: LinearFilter, magFilter: LinearFilter, stencilBuffer: t, depthBuffer: e, type: i }, l = r > 0 ? new WebGLMultisampleRenderTarget(o.width, o.height, s) : new WebGLRenderTarget(o.width, o.height, s); return r > 0 && (l.samples = r), l.texture.name = "EffectComposer.Buffer", l.texture.generateMipmaps = !1, l } addPass(e, t) { const i = this.passes, r = this.renderer, n = r.getDrawingBufferSize(new Vector2), a = r.getContext().getContextAttributes().alpha, o = this.inputBuffer.texture.type; if (e.setSize(n.width, n.height), e.initialize(r, a, o), this.autoRenderToScreen && (i.length > 0 && (i[i.length - 1].renderToScreen = !1), e.renderToScreen && (this.autoRenderToScreen = !1)), void 0 !== t ? i.splice(t, 0, e) : i.push(e), this.autoRenderToScreen && (i[i.length - 1].renderToScreen = !0), e.needsDepthTexture || null !== this.depthTexture) if (null === this.depthTexture) { const t = this.createDepthTexture(); for (e of i) e.setDepthTexture(t) } else e.setDepthTexture(this.depthTexture) } removePass(e) { const t = this.passes, i = t.indexOf(e); if (-1 !== i && t.splice(i, 1).length > 0) { if (null !== this.depthTexture) { const i = (e, t) => e || t.needsDepthTexture; t.reduce(i, !1) || (e.getDepthTexture() === this.depthTexture && e.setDepthTexture(null), this.deleteDepthTexture()) } this.autoRenderToScreen && i === t.length && (e.renderToScreen = !1, t.length > 0 && (t[t.length - 1].renderToScreen = !0)) } } removeAllPasses() { const e = this.passes; this.deleteDepthTexture(), e.length > 0 && (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = !1), this.passes = []) } render(e) { const t = this.renderer, i = this.copyPass; let r, n, a, o = this.inputBuffer, s = this.outputBuffer, l = !1; void 0 === e && (e = this.timer.update().getDelta()); for (const c of this.passes) c.isEnabled() && (c.render(t, o, s, e, l), c.needsSwap && (l && (i.renderToScreen = c.renderToScreen, r = t.getContext(), n = t.state.buffers.stencil, n.setFunc(r.NOTEQUAL, 1, 4294967295), i.render(t, o, s, e, l), n.setFunc(r.EQUAL, 1, 4294967295)), a = o, o = s, s = a), c instanceof MaskPass ? l = !0 : c instanceof ClearMaskPass && (l = !1)) } setSize(e, t, i) { const r = this.renderer; if (void 0 === e || void 0 === t) { const i = r.getSize(new Vector2); e = i.width, t = i.height } else r.setSize(e, t, i); const n = r.getDrawingBufferSize(new Vector2), a = this.inputBuffer, o = this.outputBuffer; a.setSize(n.width, n.height), o.setSize(n.width, n.height); for (const e of this.passes) e.setSize(n.width, n.height) } reset() { this.dispose(), this.autoRenderToScreen = !0 } dispose() { for (const e of this.passes) e.dispose(); this.passes = [], null !== this.inputBuffer && this.inputBuffer.dispose(), null !== this.outputBuffer && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose() } }, Selection = class extends Set { constructor(e, t = 10) { super(), this.currentLayer = t, this.exclusive = !1, void 0 !== e && this.set(e) } get layer() { return this.currentLayer } set layer(e) { this.setLayer(e) } getLayer() { return this.currentLayer } setLayer(e) { const t = this.currentLayer; for (const i of this) i.layers.disable(t), i.layers.enable(e); this.currentLayer = e } clear() { const e = this.layer; for (const t of this) t.layers.disable(e); return super.clear() } set(e) { this.clear(); for (const t of e) this.add(t); return this } indexOf(e) { return this.has(e) ? 0 : -1 } add(e) { return this.exclusive ? e.layers.set(this.layer) : e.layers.enable(this.layer), super.add(e) } delete(e) { return this.has(e) && e.layers.disable(this.layer), super.delete(e) } setVisible(e) { for (const t of this) e ? t.layers.enable(0) : t.layers.disable(0); return this } }, shader_default46 = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=clamp(texture2D(map,uv)*intensity,0.0,1.0);}", BloomEffect = class extends Effect$1 { constructor({ blendFunction: e = BlendFunction.SCREEN, luminanceThreshold: t = .9, luminanceSmoothing: i = .025, resolutionScale: r = .5, intensity: n = 1, width: a = Resizer.AUTO_SIZE, height: o = Resizer.AUTO_SIZE, kernelSize: s = KernelSize$1.LARGE } = {}) { super("BloomEffect", shader_default46, { blendFunction: e, uniforms: new Map([["map", new Uniform(null)], ["intensity", new Uniform(n)]]) }), this.renderTarget = new WebGLRenderTarget(1, 1, { minFilter: LinearFilter, magFilter: LinearFilter, stencilBuffer: !1, depthBuffer: !1 }), this.renderTarget.texture.name = "Bloom.Target", this.renderTarget.texture.generateMipmaps = !1, this.uniforms.get("map").value = this.renderTarget.texture, this.blurPass = new BlurPass({ resolutionScale: r, width: a, height: o, kernelSize: s }), this.blurPass.resolution.resizable = this, this.luminancePass = new LuminancePass({ renderTarget: this.renderTarget, colorOutput: !0 }), this.luminancePass.resolution = this.resolution, this.luminanceMaterial.threshold = t, this.luminanceMaterial.smoothing = i } get texture() { return this.renderTarget.texture } get luminanceMaterial() { return this.luminancePass.getFullscreenMaterial() } get resolution() { return this.blurPass.resolution } get width() { return this.resolution.width } set width(e) { this.resolution.width = e } get height() { return this.resolution.height } set height(e) { this.resolution.height = e } get dithering() { return this.blurPass.dithering } set dithering(e) { this.blurPass.dithering = e } get kernelSize() { return this.blurPass.kernelSize } set kernelSize(e) { this.blurPass.kernelSize = e } get distinction() { return console.warn(this.name, "The distinction field has been removed, use .threshold and .smoothing instead."), 1 } set distinction(e) { console.warn(this.name, "The distinction field has been removed, use .threshold and .smoothing instead.") } get intensity() { return this.uniforms.get("intensity").value } set intensity(e) { this.uniforms.get("intensity").value = e } getResolutionScale() { return this.resolution.scale } setResolutionScale(e) { this.resolution.scale = e } update(e, t, i) { const r = this.renderTarget; this.luminancePass.isEnabled() ? (this.luminancePass.render(e, t, r), this.blurPass.render(e, r, r)) : this.blurPass.render(e, t, r) } setSize(e, t) { this.blurPass.setSize(e, t), this.renderTarget.setSize(this.resolution.width, this.resolution.height) } initialize(e, t, i) { this.blurPass.initialize(e, t, i), t || i !== UnsignedByteType || (this.renderTarget.texture.format = RGBFormat), void 0 !== i && (this.renderTarget.texture.type = i) } }, shader_default48 = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(min(color+vec3(0.5),1.0),inputColor.a);}", BrightnessContrastEffect = class extends Effect$1 { constructor({ blendFunction: e = BlendFunction.NORMAL, brightness: t = 0, contrast: i = 0 } = {}) { super("BrightnessContrastEffect", shader_default48, { blendFunction: e, uniforms: new Map([["brightness", new Uniform(t)], ["contrast", new Uniform(i)]]) }) } }, shader_default53 = "void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){\n#ifdef INVERTED\nvec3 color=vec3(1.0-depth);\n#else\nvec3 color=vec3(depth);\n#endif\noutputColor=vec4(color,inputColor.a);}", DepthEffect = class extends Effect$1 { constructor({ blendFunction: e = BlendFunction.NORMAL, inverted: t = !1 } = {}) { super("DepthEffect", shader_default53, { blendFunction: e, attributes: EffectAttribute.DEPTH }), this.inverted = t } get inverted() { return this.defines.has("INVERTED") } set inverted(e) { this.inverted !== e && (e ? this.defines.set("INVERTED", "1") : this.defines.delete("INVERTED"), this.setChanged()) } }, shader_default54 = "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\n#else\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\n#endif\nuniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float CoCNear=texture2D(nearCoCBuffer,uv).r;CoCNear=min(CoCNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,CoCNear);outputColor=result;}", DepthOfFieldEffect = class extends Effect$1 { constructor(e, { blendFunction: t = BlendFunction.NORMAL, focusDistance: i = 0, focalLength: r = .1, bokehScale: n = 1, width: a = Resizer.AUTO_SIZE, height: o = Resizer.AUTO_SIZE } = {}) { super("DepthOfFieldEffect", shader_default54, { blendFunction: t, attributes: EffectAttribute.DEPTH, uniforms: new Map([["nearColorBuffer", new Uniform(null)], ["farColorBuffer", new Uniform(null)], ["nearCoCBuffer", new Uniform(null)], ["scale", new Uniform(1)]]) }), this.camera = e, this.renderTarget = new WebGLRenderTarget(1, 1, { minFilter: LinearFilter, magFilter: LinearFilter, stencilBuffer: !1, depthBuffer: !1 }), this.renderTarget.texture.name = "DoF.Intermediate", this.renderTarget.texture.generateMipmaps = !1, this.renderTargetMasked = this.renderTarget.clone(), this.renderTargetMasked.texture.name = "DoF.Masked.Far", this.renderTargetNear = this.renderTarget.clone(), this.renderTargetNear.texture.name = "DoF.Bokeh.Near", this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture, this.renderTargetFar = this.renderTarget.clone(), this.renderTargetFar.texture.name = "DoF.Bokeh.Far", this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture, this.renderTargetCoC = this.renderTarget.clone(), this.renderTargetCoC.texture.format = RGBFormat, this.renderTargetCoC.texture.name = "DoF.CoC", this.renderTargetCoCBlurred = this.renderTargetCoC.clone(), this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred", this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture, this.cocPass = new ShaderPass(new CircleOfConfusionMaterial(e)); const s = this.circleOfConfusionMaterial; s.uniforms.focusDistance.value = i, s.uniforms.focalLength.value = r, this.blurPass = new BlurPass({ width: a, height: o, kernelSize: KernelSize$1.MEDIUM }), this.blurPass.resolution.resizable = this, this.maskPass = new ShaderPass(new MaskMaterial(this.renderTargetCoC.texture)); const l = this.maskPass.getFullscreenMaterial(); l.maskFunction = MaskFunction.MULTIPLY, l.colorChannel = ColorChannel.GREEN, this.bokehNearBasePass = new ShaderPass(new BokehMaterial(!1, !0)), this.bokehNearFillPass = new ShaderPass(new BokehMaterial(!0, !0)), this.bokehFarBasePass = new ShaderPass(new BokehMaterial(!1, !1)), this.bokehFarFillPass = new ShaderPass(new BokehMaterial(!0, !1)), this.bokehScale = n, this.target = null } get circleOfConfusionMaterial() { return this.cocPass.getFullscreenMaterial() } get resolution() { return this.blurPass.resolution } get bokehScale() { return this.uniforms.get("scale").value } set bokehScale(e) { [this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass].map((e => e.getFullscreenMaterial().uniforms.scale)).forEach((t => { t.value = e })), this.maskPass.getFullscreenMaterial().uniforms.strength.value = e, this.uniforms.get("scale").value = e } calculateFocusDistance(e) { const t = this.camera, i = t.far - t.near, r = t.position.distanceTo(e); return Math.min(Math.max(r / i, 0), 1) } setDepthTexture(e, t = BasicDepthPacking) { const i = this.circleOfConfusionMaterial; i.uniforms.depthBuffer.value = e, i.depthPacking = t } update(e, t, i) { const r = this.renderTarget, n = this.renderTargetCoC, a = this.renderTargetCoCBlurred, o = this.renderTargetMasked, s = this.bokehFarBasePass, l = this.bokehFarFillPass, c = s.getFullscreenMaterial().uniforms, h = l.getFullscreenMaterial().uniforms, u = this.bokehNearBasePass, d = this.bokehNearFillPass, p = u.getFullscreenMaterial().uniforms, f = d.getFullscreenMaterial().uniforms; if (null !== this.target) { const e = this.calculateFocusDistance(this.target); this.circleOfConfusionMaterial.uniforms.focusDistance.value = e } this.cocPass.render(e, null, n), this.blurPass.render(e, n, a), this.maskPass.render(e, t, o), c.cocBuffer.value = n.texture, h.cocBuffer.value = n.texture, s.render(e, o, r), l.render(e, r, this.renderTargetFar), p.cocBuffer.value = a.texture, f.cocBuffer.value = a.texture, u.render(e, t, r), d.render(e, r, this.renderTargetNear) } setSize(e, t) { const i = this.resolution; let r = [this.cocPass, this.blurPass, this.maskPass, this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass]; r.push(this.renderTargetCoC, this.renderTargetMasked), r.forEach((i => i.setSize(e, t))); const n = i.width, a = i.height; r = [this.renderTarget, this.renderTargetNear, this.renderTargetFar, this.renderTargetCoCBlurred], r.forEach((e => e.setSize(n, a)));[this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass].forEach((e => e.getFullscreenMaterial().setTexelSize(1 / n, 1 / a))) } initialize(e, t, i) { [this.cocPass, this.maskPass, this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass].forEach((r => r.initialize(e, t, i))), this.blurPass.initialize(e, t, UnsignedByteType), t || i !== UnsignedByteType || (this.renderTargetNear.texture.type = RGBFormat), void 0 !== i && (this.renderTarget.texture.type = i, this.renderTargetNear.texture.type = i, this.renderTargetFar.texture.type = i, this.renderTargetMasked.texture.type = i) } }; function getNoise(e, t, i) { const r = new Map([[LuminanceFormat, 1], [RedFormat, 1], [RGFormat, 2], [RGBFormat, 3], [RGBAFormat, 4]]); let n; if (r.has(t) || console.error("Invalid noise texture format"), i === UnsignedByteType) { n = new Uint8Array(e * r.get(t)); for (let e = 0, t = n.length; e < t; ++e)n[e] = 255 * Math.random() } else { n = new Float32Array(e * r.get(t)); for (let e = 0, t = n.length; e < t; ++e)n[e] = Math.random() } return n } var NoiseTexture = class extends DataTexture { constructor(e, t, i = LuminanceFormat, r = UnsignedByteType) { super(getNoise(e * t, i, r), e, t, i, r) } }; new Matrix4; var shader_default60 = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}", HueSaturationEffect = class extends Effect$1 { constructor({ blendFunction: e = BlendFunction.NORMAL, hue: t = 0, saturation: i = 0 } = {}) { super("HueSaturationEffect", shader_default60, { blendFunction: e, uniforms: new Map([["hue", new Uniform(new Vector3)], ["saturation", new Uniform(i)]]) }), this.setHue(t) } setHue(e) { const t = Math.sin(e), i = Math.cos(e); this.uniforms.get("hue").value.set(2 * i, -Math.sqrt(3) * t - i, Math.sqrt(3) * t - i).addScalar(1).divideScalar(3) } }; function createCanvas(e, t, i) { const r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), n = r.getContext("2d"); if (r.width = e, r.height = t, i instanceof Image) n.drawImage(i, 0, 0); else { const r = n.createImageData(e, t); r.data.set(i), n.putImageData(r, 0, 0) } return r } var RawImageData = class { constructor(e = 0, t = 0, i = null) { this.width = e, this.height = t, this.data = i } toCanvas() { return "undefined" == typeof document ? null : createCanvas(this.width, this.height, this.data) } static from(e) { const { width: t, height: i } = e; let r; if (e instanceof Image) { const n = createCanvas(t, i, e); if (null !== n) { r = n.getContext("2d").getImageData(0, 0, t, i).data } } else r = e.data; return new RawImageData(t, i, r) } }, LUTOperation = { SCALE_UP: "lut.scaleup" }, worker_default = '(()=>{var q=Math.pow;var _={SCALE_UP:"lut.scaleup"};var k=[new Float32Array(3),new Float32Array(3)],t=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],U=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function L(a,n,r,m){let h=r[0]-n[0],e=r[1]-n[1],s=r[2]-n[2],l=a[0]-n[0],w=a[1]-n[1],c=a[2]-n[2],y=e*c-s*w,A=s*l-h*c,g=h*w-e*l,p=Math.sqrt(y*y+A*A+g*g),V=p*.5,F=y/p,f=A/p,i=g/p,u=-(a[0]*F+a[1]*f+a[2]*i),M=m[0]*F+m[1]*f+m[2]*i;return Math.abs(M+u)*V/3}function X(a,n,r,m,h,e){let s=(r+m*n+h*n*n)*3;e[0]=a[s+0],e[1]=a[s+1],e[2]=a[s+2]}function j(a,n,r,m,h,e){let s=r*(n-1),l=m*(n-1),w=h*(n-1),c=Math.floor(s),y=Math.floor(l),A=Math.floor(w),g=Math.ceil(s),p=Math.ceil(l),V=Math.ceil(w),F=s-c,f=l-y,i=w-A;if(c===s&&y===l&&A===w)X(a,n,s,l,w,e);else{let u;F>=f&&f>=i?u=U[0]:F>=i&&i>=f?u=U[1]:i>=F&&F>=f?u=U[2]:f>=F&&F>=i?u=U[3]:f>=i&&i>=F?u=U[4]:i>=f&&f>=F&&(u=U[5]);let[M,x,P,T]=u,d=k[0];d[0]=F,d[1]=f,d[2]=i;let o=k[1],Y=g-c,Z=p-y,b=V-A;o[0]=Y*M[0]+c,o[1]=Z*M[1]+y,o[2]=b*M[2]+A,X(a,n,o[0],o[1],o[2],t[0]),o[0]=Y*x[0]+c,o[1]=Z*x[1]+y,o[2]=b*x[2]+A,X(a,n,o[0],o[1],o[2],t[1]),o[0]=Y*P[0]+c,o[1]=Z*P[1]+y,o[2]=b*P[2]+A,X(a,n,o[0],o[1],o[2],t[2]),o[0]=Y*T[0]+c,o[1]=Z*T[1]+y,o[2]=b*T[2]+A,X(a,n,o[0],o[1],o[2],t[3]);let v=L(x,P,T,d)*6,S=L(M,P,T,d)*6,C=L(M,x,T,d)*6,E=L(M,x,P,d)*6;t[0][0]*=v,t[0][1]*=v,t[0][2]*=v,t[1][0]*=S,t[1][1]*=S,t[1][2]*=S,t[2][0]*=C,t[2][1]*=C,t[2][2]*=C,t[3][0]*=E,t[3][1]*=E,t[3][2]*=E,e[0]=t[0][0]+t[1][0]+t[2][0]+t[3][0],e[1]=t[0][1]+t[1][1]+t[2][1]+t[3][1],e[2]=t[0][2]+t[1][2]+t[2][2]+t[3][2]}}var O=class{static expand(n,r){let m=Math.cbrt(n.length/3),h=new Float32Array(3),e=new n.constructor(q(r,3)*3),s=1/(r-1);for(let l=0;l<r;++l)for(let w=0;w<r;++w)for(let c=0;c<r;++c){let y=c*s,A=w*s,g=l*s,p=Math.round(c+w*r+l*r*r)*3;j(n,m,y,A,g,h),e[p+0]=h[0],e[p+1]=h[1],e[p+2]=h[2]}return e}};self.addEventListener("message",a=>{let n=a.data,r=n.data;switch(n.operation){case _.SCALE_UP:r=O.expand(r,n.size);break}postMessage(r,[r.buffer]),close()});})();\n', c = new Color$1, LookupTexture3D = class extends DataTexture3D { constructor(e, t) { super(e, t, t, t), this.type = FloatType, this.format = RGBFormat, this.encoding = LinearEncoding, this.minFilter = LinearFilter, this.magFilter = LinearFilter, this.wrapS = ClampToEdgeWrapping, this.wrapT = ClampToEdgeWrapping, this.wrapR = ClampToEdgeWrapping, this.unpackAlignment = 1, this.domainMin = new Vector3(0, 0, 0), this.domainMax = new Vector3(1, 1, 1) } get isLookupTexture3D() { return !0 } scaleUp(e, t = !0) { const i = this.image; let r; if (e <= i.width) r = Promise.reject(new Error("The target size must be greater than the current size")); else { const n = URL.createObjectURL(new Blob([worker_default], { type: "text/javascript" })), a = new Worker(n); r = new Promise(((r, o) => { a.addEventListener("error", (e => o(e.error))), a.addEventListener("message", (t => { const i = new LookupTexture3D(t.data, e); i.encoding = this.encoding, i.type = this.type, i.name = this.name, URL.revokeObjectURL(n), r(i) })); const s = t ? [i.data.buffer] : []; a.postMessage({ operation: LUTOperation.SCALE_UP, data: i.data, size: e }, s) })) } return r } applyLUT(e) { const t = this.image, i = e.image, r = Math.min(t.width, t.height, t.depth); if (r !== Math.min(i.width, i.height, i.depth)) console.error("Size mismatch"); else if (e.type !== FloatType || this.type !== FloatType) console.error("Both LUTs must be FloatType textures"); else if (e.format !== RGBFormat || this.format !== RGBFormat) console.error("Both LUTs must be RGB textures"); else { const e = t.data, n = i.data, a = r, o = a - 1; for (let t = 0, i = a ** 3; t < i; ++t) { const i = 3 * t, r = e[i + 0] * o, s = e[i + 1] * o, l = e[i + 2] * o, c = 3 * Math.round(r + s * a + l * a * a); e[i + 0] = n[c + 0], e[i + 1] = n[c + 1], e[i + 2] = n[c + 2] } this.needsUpdate = !0 } return this } convertToUint8() { if (this.type === FloatType) { const e = this.image.data, t = new Uint8Array(e.length); for (let i = 0, r = e.length; i < r; ++i)t[i] = 255 * e[i]; this.image.data = t, this.type = UnsignedByteType, this.needsUpdate = !0 } return this } convertToFloat() { if (this.type === UnsignedByteType) { const e = this.image.data, t = new Float32Array(e.length); for (let i = 0, r = e.length; i < r; ++i)t[i] = e[i] / 255; this.image.data = t, this.type = FloatType, this.needsUpdate = !0 } return this } convertLinearToSRGB() { const e = this.image.data; if (this.type === FloatType) { const t = this.format === RGBAFormat ? 4 : 3; for (let i = 0, r = e.length; i < r; i += t)c.fromArray(e, i).convertLinearToSRGB().toArray(e, i); this.encoding = sRGBEncoding, this.needsUpdate = !0 } else console.error("Color space conversion requires FloatType data"); return this } convertSRGBToLinear() { const e = this.image.data; if (this.type === FloatType) { const t = this.format === RGBAFormat ? 4 : 3; for (let i = 0, r = e.length; i < r; i += t)c.fromArray(e, i).convertSRGBToLinear().toArray(e, i); this.encoding = LinearEncoding, this.needsUpdate = !0 } else console.error("Color space conversion requires FloatType data"); return this } convertToRGBA() { if (this.format === RGBFormat) { const e = this.image.width, t = this.image.data, i = new t.constructor(e ** 3 * 4), r = this.type === FloatType ? 1 : 255; for (let e = 0, n = 0, a = t.length; e < a; e += 3, n += 4)i[n + 0] = t[e + 0], i[n + 1] = t[e + 1], i[n + 2] = t[e + 2], i[n + 3] = r; this.image.data = i, this.format = RGBAFormat, this.needsUpdate = !0 } return this } toDataTexture() { const e = this.image.width, t = this.image.height * this.image.depth, i = new DataTexture(this.image.data, e, t); return i.name = this.name, i.type = this.type, i.format = this.format, i.encoding = this.encoding, i.minFilter = LinearFilter, i.magFilter = LinearFilter, i.wrapS = this.wrapS, i.wrapT = this.wrapT, i.generateMipmaps = !1, i } static from(e) { const t = e.image, { width: i, height: r } = t, n = Math.min(i, r); let a; if (t instanceof Image) { a = RawImageData.from(t).data; const e = new Uint8Array(n ** 3 * 3); if (i > r) for (let t = 0; t < n; ++t)for (let i = 0; i < n; ++i)for (let r = 0; r < n; ++r) { const o = 4 * (r + t * n + i * n * n), s = 3 * (r + i * n + t * n * n); e[s + 0] = a[o + 0], e[s + 1] = a[o + 1], e[s + 2] = a[o + 2] } else for (let t = 0, i = n ** 3; t < i; ++t) { const i = 4 * t, r = 3 * t; e[r + 0] = a[i + 0], e[r + 1] = a[i + 1], e[r + 2] = a[i + 2] } a = e } else a = t.data.slice(); const o = new LookupTexture3D(a, n); return o.type = e.type, o.encoding = e.encoding, o.name = e.name, o } static createNeutral(e) { const t = new Float32Array(e ** 3 * 3), i = 1 / (e - 1); for (let r = 0; r < e; ++r)for (let n = 0; n < e; ++n)for (let a = 0; a < e; ++a) { const o = 3 * (r + n * e + a * e * e); t[o + 0] = r * i, t[o + 1] = n * i, t[o + 2] = a * i } const r = new LookupTexture3D(t, e); return r.name = "neutral", r } }, shader_default61 = "uniform vec3 scale;uniform vec3 offset;\n#ifdef CUSTOM_INPUT_DOMAIN\nuniform vec3 domainMin;uniform vec3 domainMax;\n#endif\n#ifdef LUT_3D\n#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler3D lut;\n#else\nuniform mediump sampler3D lut;\n#endif\n#else\nuniform lowp sampler3D lut;\n#endif\nvec4 applyLUT(const in vec3 rgb){\n#ifdef TETRAHEDRAL_INTERPOLATION\nvec3 p=floor(rgb);vec3 f=rgb-p;vec3 v1=(p+0.5)*LUT_TEXEL_WIDTH;vec3 v4=(p+1.5)*LUT_TEXEL_WIDTH;vec3 v2,v3;vec3 frac;if(f.r>=f.g){if(f.g>f.b){frac=f.rgb;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else if(f.r>=f.b){frac=f.rbg;v2=vec3(v4.x,v1.y,v1.z);v3=vec3(v4.x,v1.y,v4.z);}else{frac=f.brg;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v4.x,v1.y,v4.z);}}else{if(f.b>f.g){frac=f.bgr;v2=vec3(v1.x,v1.y,v4.z);v3=vec3(v1.x,v4.y,v4.z);}else if(f.r>=f.b){frac=f.grb;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v4.x,v4.y,v1.z);}else{frac=f.gbr;v2=vec3(v1.x,v4.y,v1.z);v3=vec3(v1.x,v4.y,v4.z);}}vec4 n1=texture(lut,v1);vec4 n2=texture(lut,v2);vec4 n3=texture(lut,v3);vec4 n4=texture(lut,v4);vec4 weights=vec4(1.0-frac.x,frac.x-frac.y,frac.y-frac.z,frac.z);vec4 result=weights*mat4(vec4(n1.r,n2.r,n3.r,n4.r),vec4(n1.g,n2.g,n3.g,n4.g),vec4(n1.b,n2.b,n3.b,n4.b),vec4(1.0));return vec4(result.rgb,1.0);\n#else\nreturn texture(lut,rgb);\n#endif\n}\n#else\n#ifdef LUT_PRECISION_HIGH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D lut;\n#else\nuniform mediump sampler2D lut;\n#endif\n#else\nuniform lowp sampler2D lut;\n#endif\nvec4 applyLUT(const in vec3 rgb){float slice=rgb.b*LUT_SIZE;float slice0=floor(slice);float interp=slice-slice0;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);\n#ifdef LUT_STRIP_HORIZONTAL\nfloat xOffset=clamp(rgb.r*LUT_TEXEL_HEIGHT,LUT_TEXEL_WIDTH*0.5,LUT_TEXEL_HEIGHT-LUT_TEXEL_WIDTH*0.5);vec2 uv0=vec2(slice0*LUT_TEXEL_HEIGHT+xOffset,rgb.g);vec2 uv1=vec2(slice1*LUT_TEXEL_HEIGHT+xOffset,rgb.g);\n#else\nfloat yOffset=clamp(rgb.g*LUT_TEXEL_WIDTH,LUT_TEXEL_HEIGHT*0.5,LUT_TEXEL_WIDTH-LUT_TEXEL_HEIGHT*0.5);vec2 uv0=vec2(rgb.r,slice0*LUT_TEXEL_WIDTH+yOffset);vec2 uv1=vec2(rgb.r,slice1*LUT_TEXEL_WIDTH+yOffset);\n#endif\nvec4 sample0=texture2D(lut,uv0);vec4 sample1=texture2D(lut,uv1);return mix(sample0,sample1,abs(centeredInterp));}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 c=linearToInputTexel(inputColor).rgb;\n#ifdef CUSTOM_INPUT_DOMAIN\nif(c.r>=domainMin.r&&c.g>=domainMin.g&&c.b>=domainMin.b&&c.r<=domainMax.r&&c.g<=domainMax.g&&c.b<=domainMax.b){c=texelToLinear(applyLUT(scale*c+offset)).rgb;}else{c=inputColor.rgb;}\n#else\n#if !defined(LUT_3D) || defined(TETRAHEDRAL_INTERPOLATION)\nc=clamp(c,0.0,1.0);\n#endif\nc=texelToLinear(applyLUT(scale*c+offset)).rgb;\n#endif\noutputColor=vec4(c,inputColor.a);}", LUTEffect = class extends Effect$1 { constructor(e, { blendFunction: t = BlendFunction.NORMAL, tetrahedralInterpolation: i = !1 } = {}) { super("LUTEffect", shader_default61, { blendFunction: t, uniforms: new Map([["lut", new Uniform(null)], ["scale", new Uniform(new Vector3)], ["offset", new Uniform(new Vector3)], ["domainMin", new Uniform(null)], ["domainMax", new Uniform(null)]]) }), this.tetrahedralInterpolation = i, this.inputEncoding = sRGBEncoding, this.outputEncoding = this.inputEncoding, this.setInputEncoding(sRGBEncoding), this.setLUT(e) } getOutputEncoding() { return this.outputEncoding } getInputEncoding() { return this.inputEncoding } setInputEncoding(e) { const t = this.defines, i = this.getLUT(); switch (e) { case sRGBEncoding: t.set("linearToInputTexel(texel)", "LinearTosRGB(texel)"); break; case LinearEncoding: t.set("linearToInputTexel(texel)", "texel"); break; default: console.error("Unsupported input encoding:", e) }if (null !== i) switch (this.outputEncoding = i.encoding === LinearEncoding ? e : i.encoding, this.outputEncoding) { case sRGBEncoding: t.set("texelToLinear(texel)", "sRGBToLinear(texel)"); break; case LinearEncoding: t.set("texelToLinear(texel)", "texel"); break; default: console.error("Unsupported LUT encoding:", i.encoding) }this.inputEncoding !== e && (this.inputEncoding = e, this.setChanged()) } getLUT() { return this.uniforms.get("lut").value } setLUT(e) { const t = this.defines, i = this.uniforms; if (this.getLUT() !== e) { const r = e.image; if (t.clear(), t.set("LUT_SIZE", Math.min(r.width, r.height).toFixed(16)), t.set("LUT_TEXEL_WIDTH", (1 / r.width).toFixed(16)), t.set("LUT_TEXEL_HEIGHT", (1 / r.height).toFixed(16)), i.get("lut").value = e, i.get("domainMin").value = null, i.get("domainMax").value = null, e.type !== FloatType && e.type !== HalfFloatType || t.set("LUT_PRECISION_HIGH", "1"), r.width > r.height ? t.set("LUT_STRIP_HORIZONTAL", "1") : e instanceof DataTexture3D && t.set("LUT_3D", "1"), e instanceof LookupTexture3D) { const r = e.domainMin, n = e.domainMax; 0 === r.x && 0 === r.y && 0 === r.z && 1 === n.x && 1 === n.y && 1 === n.z || (t.set("CUSTOM_INPUT_DOMAIN", "1"), i.get("domainMin").value = r.clone(), i.get("domainMax").value = n.clone()) } this.configureTetrahedralInterpolation(), this.updateScaleOffset(), this.setInputEncoding(this.inputEncoding), this.setChanged() } } updateScaleOffset() { const e = this.getLUT(), t = Math.min(e.image.width, e.image.height), i = this.uniforms.get("scale").value, r = this.uniforms.get("offset").value; if (this.defines.has("TETRAHEDRAL_INTERPOLATION")) if (this.defines.has("CUSTOM_INPUT_DOMAIN")) { const n = e.domainMax.clone().sub(e.domainMin); i.setScalar(t - 1).divide(n), r.copy(e.domainMin).negate().multiply(i) } else i.setScalar(t - 1), r.setScalar(0); else if (this.defines.has("CUSTOM_INPUT_DOMAIN")) { const n = e.domainMax.clone().sub(e.domainMin).multiplyScalar(t); i.setScalar(t - 1).divide(n), r.copy(e.domainMin).negate().multiply(i).addScalar(1 / (2 * t)) } else i.setScalar((t - 1) / t), r.setScalar(1 / (2 * t)) } configureTetrahedralInterpolation() { const e = this.getLUT(); e.minFilter = LinearFilter, e.magFilter = LinearFilter, this.defines.delete("TETRAHEDRAL_INTERPOLATION"), this.tetrahedralInterpolation && null !== e && (e instanceof DataTexture3D ? (this.defines.set("TETRAHEDRAL_INTERPOLATION", "1"), e.minFilter = NearestFilter, e.magFilter = NearestFilter) : console.warn("Tetrahedral interpolation requires a 3D texture")), e.needsUpdate = !0 } setTetrahedralInterpolationEnabled(e) { this.tetrahedralInterpolation = e, this.configureTetrahedralInterpolation(), this.updateScaleOffset(), this.setChanged() } }, shader_default62 = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));\n#ifdef PREMULTIPLY\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}", NoiseEffect = class extends Effect$1 { constructor({ blendFunction: e = BlendFunction.SCREEN, premultiply: t = !1 } = {}) { super("NoiseEffect", shader_default62, { blendFunction: e }), this.premultiply = t } get premultiply() { return this.defines.has("PREMULTIPLY") } set premultiply(e) { this.premultiply !== e && (e ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"), this.setChanged()) } }; function getTextureDecoding(e, t) { let i = "texel"; if (null !== e) { if (!(Number.parseInt(REVISION) >= 133 && t && e.format === RGBAFormat && e.type === UnsignedByteType && e.encoding === sRGBEncoding)) switch (e.encoding) { case sRGBEncoding: i = "sRGBToLinear(texel)"; break; case LinearEncoding: i = "texel"; break; default: throw new Error(`Unsupported encoding: ${e.encoding}`) } } return i } var shader_default63 = "uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;\n#ifdef USE_PATTERN\nuniform lowp sampler2D patternTexture;varying vec2 vUvPattern;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;\n#ifndef X_RAY\nedge.y=0.0;\n#endif\nedge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;\n#ifdef USE_PATTERN\nvec4 patternColor=texelToLinear(texture2D(patternTexture,vUvPattern));\n#ifdef X_RAY\nfloat hiddenFactor=0.5;\n#else\nfloat hiddenFactor=0.0;\n#endif\nvisibilityFactor=(1.0-mask.y>0.0)? 1.0 : hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;\n#endif\nfloat alpha=max(max(edge.x,edge.y),visibilityFactor);\n#ifdef ALPHA\noutputColor=vec4(color,alpha);\n#else\noutputColor=vec4(color,max(alpha,inputColor.a));\n#endif\n}", shader_default64 = "uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}", OutlineEffect = class extends Effect$1 { constructor(e, t, { blendFunction: i = BlendFunction.SCREEN, patternTexture: r = null, edgeStrength: n = 1, pulseSpeed: a = 0, visibleEdgeColor: o = 16777215, hiddenEdgeColor: s = 2230538, resolutionScale: l = .5, width: c = Resizer.AUTO_SIZE, height: h = Resizer.AUTO_SIZE, kernelSize: u = KernelSize$1.VERY_SMALL, blur: d = !1, xRay: p = !0 } = {}) { super("OutlineEffect", shader_default63, { uniforms: new Map([["maskTexture", new Uniform(null)], ["edgeTexture", new Uniform(null)], ["edgeStrength", new Uniform(n)], ["visibleEdgeColor", new Uniform(new Color$1(o))], ["hiddenEdgeColor", new Uniform(new Color$1(s))], ["pulse", new Uniform(1)], ["patternScale", new Uniform(1)], ["patternTexture", new Uniform(null)]]) }), this.blendMode.addEventListener("change", (e => { this.blendMode.getBlendFunction() === BlendFunction.ALPHA ? this.defines.set("ALPHA", "1") : this.defines.delete("ALPHA"), this.setChanged() })), this.blendMode.setBlendFunction(i), this.setPatternTexture(r), this.xRay = p, this.scene = e, this.camera = t, this.renderTargetMask = new WebGLRenderTarget(1, 1, { minFilter: LinearFilter, magFilter: LinearFilter, stencilBuffer: !1, format: RGBFormat }), this.renderTargetMask.texture.name = "Outline.Mask", this.uniforms.get("maskTexture").value = this.renderTargetMask.texture, this.renderTargetOutline = this.renderTargetMask.clone(), this.renderTargetOutline.texture.name = "Outline.Edges", this.renderTargetOutline.depthBuffer = !1, this.renderTargetBlurredOutline = this.renderTargetOutline.clone(), this.renderTargetBlurredOutline.texture.name = "Outline.BlurredEdges", this.clearPass = new ClearPass, this.clearPass.overrideClearColor = new Color$1(0), this.clearPass.overrideClearAlpha = 1, this.depthPass = new DepthPass(e, t), this.maskPass = new RenderPass(e, t, new DepthComparisonMaterial(this.depthPass.texture, t)); const f = this.maskPass.getClearPass(); f.overrideClearColor = new Color$1(16777215), f.overrideClearAlpha = 1, this.blurPass = new BlurPass({ resolutionScale: l, width: c, height: h, kernelSize: u }), this.blurPass.resolution.resizable = this, this.blur = d, this.outlinePass = new ShaderPass(new OutlineMaterial); this.outlinePass.getFullscreenMaterial().uniforms.inputBuffer.value = this.renderTargetMask.texture, this.time = 0, this.selection = new Selection, this.selection.setLayer(10), this.pulseSpeed = a, this.isWebGL2 = !1 } get resolution() { return this.blurPass.resolution } get width() { return this.resolution.width } set width(e) { this.resolution.width = e } get height() { return this.resolution.height } set height(e) { this.resolution.height = e } get selectionLayer() { return this.selection.layer } set selectionLayer(e) { this.selection.layer = e } get dithering() { return this.blurPass.dithering } set dithering(e) { this.blurPass.dithering = e } get kernelSize() { return this.blurPass.kernelSize } set kernelSize(e) { this.blurPass.kernelSize = e } get blur() { return this.blurPass.isEnabled() } set blur(e) { this.blurPass.setEnabled(e), this.uniforms.get("edgeTexture").value = e ? this.renderTargetBlurredOutline.texture : this.renderTargetOutline.texture } get xRay() { return this.defines.has("X_RAY") } set xRay(e) { this.xRay !== e && (e ? this.defines.set("X_RAY", "1") : this.defines.delete("X_RAY"), this.setChanged()) } setPatternTexture(e) { null !== e ? (e.wrapS = e.wrapT = RepeatWrapping, this.defines.set("USE_PATTERN", "1"), this.uniforms.get("patternTexture").value = e, this.setVertexShader(shader_default64)) : (this.defines.delete("USE_PATTERN"), this.uniforms.get("patternTexture").value = null, this.setVertexShader(null)); const t = getTextureDecoding(e, this.isWebGL2); this.defines.set("texelToLinear(texel)", t), this.setChanged() } getResolutionScale() { return this.resolution.scale } setResolutionScale(e) { this.resolution.scale = e } setSelection(e) { return this.selection.set(e), this } clearSelection() { return this.selection.clear(), this } selectObject(e) { return this.selection.add(e), this } deselectObject(e) { return this.selection.delete(e), this } update(e, t, i) { const r = this.scene, n = this.camera, a = this.selection, o = this.uniforms.get("pulse"), s = r.background, l = n.layers.mask; a.size > 0 ? (r.background = null, o.value = 1, this.pulseSpeed > 0 && (o.value = .375 * Math.cos(this.time * this.pulseSpeed * 10) + .625), this.time += i, a.setVisible(!1), this.depthPass.render(e), a.setVisible(!0), n.layers.set(a.getLayer()), this.maskPass.render(e, this.renderTargetMask), n.layers.mask = l, r.background = s, this.outlinePass.render(e, null, this.renderTargetOutline), this.blur && this.blurPass.render(e, this.renderTargetOutline, this.renderTargetBlurredOutline)) : this.time > 0 && (this.clearPass.render(e, this.renderTargetMask), this.time = 0) } setSize(e, t) { this.blurPass.setSize(e, t), this.renderTargetMask.setSize(e, t); const i = this.resolution.width, r = this.resolution.height; this.depthPass.setSize(i, r), this.renderTargetOutline.setSize(i, r), this.renderTargetBlurredOutline.setSize(i, r), this.outlinePass.getFullscreenMaterial().setTexelSize(1 / i, 1 / r) } initialize(e, t, i) { this.isWebGL2 = e.capabilities.isWebGL2; const r = getTextureDecoding(this.uniforms.get("patternTexture").value, this.isWebGL2); this.defines.set("texelToLinear(texel)", r), this.blurPass.initialize(e, t, UnsignedByteType), void 0 !== i && (this.depthPass.initialize(e, t, i), this.maskPass.initialize(e, t, i), this.outlinePass.initialize(e, t, i)) } }, searchImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC", areaImageDataURL_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC", shader_default71 = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", shader_default72 = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}", SMAAEffect = class extends Effect$1 { constructor(e, t, i = SMAAPreset.HIGH, r = EdgeDetectionMode.COLOR) { super("SMAAEffect", shader_default71, { vertexShader: shader_default72, blendFunction: BlendFunction.NORMAL, attributes: EffectAttribute.CONVOLUTION | EffectAttribute.DEPTH, uniforms: new Map([["weightMap", new Uniform(null)]]) }), this.renderTargetEdges = new WebGLRenderTarget(1, 1, { minFilter: LinearFilter, stencilBuffer: !1, depthBuffer: !1, format: RGBFormat }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.renderTargetWeights.texture.format = RGBAFormat, this.uniforms.get("weightMap").value = this.renderTargetWeights.texture, this.clearPass = new ClearPass(!0, !1, !1), this.clearPass.overrideClearColor = new Color$1(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new ShaderPass(new EdgeDetectionMaterial(new Vector2, r)), this.weightsPass = new ShaderPass(new SMAAWeightsMaterial); const n = new Texture$1(e); n.name = "SMAA.Search", n.magFilter = NearestFilter, n.minFilter = NearestFilter, n.format = RGBAFormat, n.generateMipmaps = !1, n.needsUpdate = !0, n.flipY = !0; const a = new Texture$1(t); a.name = "SMAA.Area", a.magFilter = LinearFilter, a.minFilter = LinearFilter, a.format = RGBAFormat, a.generateMipmaps = !1, a.needsUpdate = !0, a.flipY = !1; const o = this.weightsPass.getFullscreenMaterial(); o.uniforms.searchTexture.value = n, o.uniforms.areaTexture.value = a, this.applyPreset(i) } get edgeDetectionMaterial() { return this.edgeDetectionPass.getFullscreenMaterial() } get colorEdgesMaterial() { return this.edgeDetectionMaterial } get weightsMaterial() { return this.weightsPass.getFullscreenMaterial() } setEdgeDetectionThreshold(e) { this.edgeDetectionPass.getFullscreenMaterial().setEdgeDetectionThreshold(e) } setOrthogonalSearchSteps(e) { this.weightsPass.getFullscreenMaterial().setOrthogonalSearchSteps(e) } applyPreset(e) { const t = this.edgeDetectionMaterial, i = this.weightsMaterial; switch (e) { case SMAAPreset.LOW: t.setEdgeDetectionThreshold(.15), i.setOrthogonalSearchSteps(4), i.diagonalDetection = !1, i.cornerRounding = !1; break; case SMAAPreset.MEDIUM: t.setEdgeDetectionThreshold(.1), i.setOrthogonalSearchSteps(8), i.diagonalDetection = !1, i.cornerRounding = !1; break; case SMAAPreset.HIGH: t.setEdgeDetectionThreshold(.1), i.setOrthogonalSearchSteps(16), i.setDiagonalSearchSteps(8), i.setCornerRounding(25), i.diagonalDetection = !0, i.cornerRounding = !0; break; case SMAAPreset.ULTRA: t.setEdgeDetectionThreshold(.05), i.setOrthogonalSearchSteps(32), i.setDiagonalSearchSteps(16), i.setCornerRounding(25), i.diagonalDetection = !0, i.cornerRounding = !0 } } setDepthTexture(e, t = BasicDepthPacking) { const i = this.edgeDetectionMaterial; i.uniforms.depthBuffer.value = e, i.depthPacking = t } update(e, t, i) { this.clearPass.render(e, this.renderTargetEdges), this.edgeDetectionPass.render(e, t, this.renderTargetEdges), this.weightsPass.render(e, this.renderTargetEdges, this.renderTargetWeights) } setSize(e, t) { const i = this.weightsPass.getFullscreenMaterial(), r = this.edgeDetectionPass.getFullscreenMaterial(); this.renderTargetEdges.setSize(e, t), this.renderTargetWeights.setSize(e, t), i.uniforms.resolution.value.set(e, t), i.uniforms.texelSize.value.set(1 / e, 1 / t), r.uniforms.texelSize.value.copy(i.uniforms.texelSize.value) } dispose() { const e = this.weightsPass.getFullscreenMaterial().uniforms; e.searchTexture.value.dispose(), e.areaTexture.value.dispose(), super.dispose() } static get searchImageDataURL() { return searchImageDataURL_default } static get areaImageDataURL() { return areaImageDataURL_default } }, SMAAPreset = { LOW: 0, MEDIUM: 1, HIGH: 2, ULTRA: 3 }, shader_default73 = "uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;\n#ifdef DEPTH_AWARE_UPSAMPLING\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\n#endif\n#ifdef COLORIZE\nuniform vec3 color;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;\n#if defined(DEPTH_AWARE_UPSAMPLING) && __VERSION__ == 300\nvec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);\n#else\nfloat ao=aoLinear;\n#endif\nfloat l=linearToRelativeLuminance(inputColor.rgb);ao=mix(ao,1.0,l*luminanceInfluence);\n#ifdef COLORIZE\noutputColor=vec4(1.0-(1.0-ao)*(1.0-color),inputColor.a);\n#else\noutputColor=vec4(vec3(ao),inputColor.a);\n#endif\n}", NOISE_TEXTURE_SIZE = 64, SSAOEffect = class extends Effect$1 { constructor(e, t, { blendFunction: i = BlendFunction.MULTIPLY, distanceScaling: r = !0, depthAwareUpsampling: n = !0, normalDepthBuffer: a = null, samples: o = 9, rings: s = 7, distanceThreshold: l = .97, distanceFalloff: c = .03, rangeThreshold: h = 5e-4, rangeFalloff: u = .001, minRadiusScale: d = .33, luminanceInfluence: p = .7, radius: f = .1825, intensity: m = 1, bias: g = .025, fade: y = .01, color: v = null, resolutionScale: _ = 1, width: b = Resizer.AUTO_SIZE, height: x = Resizer.AUTO_SIZE } = {}) { super("SSAOEffect", shader_default73, { blendFunction: i, attributes: EffectAttribute.DEPTH, defines: new Map([["THRESHOLD", "0.997"]]), uniforms: new Map([["aoBuffer", new Uniform(null)], ["normalDepthBuffer", new Uniform(null)], ["luminanceInfluence", new Uniform(p)], ["color", new Uniform(null)], ["scale", new Uniform(0)]]) }), this.renderTargetAO = new WebGLRenderTarget(1, 1, { minFilter: LinearFilter, magFilter: LinearFilter, stencilBuffer: !1, depthBuffer: !1, format: RGBFormat }), this.renderTargetAO.texture.name = "AO.Target", this.renderTargetAO.texture.generateMipmaps = !1, this.uniforms.get("aoBuffer").value = this.renderTargetAO.texture, this.resolution = new Resizer(this, b, x, _), this.r = 1, this.camera = e, this.ssaoPass = new ShaderPass((() => { const i = new NoiseTexture(NOISE_TEXTURE_SIZE, NOISE_TEXTURE_SIZE); i.wrapS = i.wrapT = RepeatWrapping; const r = new SSAOMaterial(e); return r.uniforms.noiseTexture.value = i, r.uniforms.intensity.value = m, r.uniforms.minRadiusScale.value = d, r.uniforms.fade.value = y, r.uniforms.bias.value = g, null !== a ? (r.uniforms.normalDepthBuffer.value = a, r.defines.NORMAL_DEPTH = "1", n && (this.depthAwareUpsampling = n, this.uniforms.get("normalDepthBuffer").value = a)) : r.uniforms.normalBuffer.value = t, r })()), this.distanceScaling = r, this.samples = o, this.rings = s, this.color = v, this.radius = f > 1 ? f / 100 : f, this.setDistanceCutoff(l, c), this.setProximityCutoff(h, u) } get ssaoMaterial() { return this.ssaoPass.getFullscreenMaterial() } get samples() { return Number(this.ssaoMaterial.defines.SAMPLES_INT) } set samples(e) { const t = this.ssaoMaterial; t.defines.SAMPLES_INT = e.toFixed(0), t.defines.SAMPLES_FLOAT = e.toFixed(1), t.needsUpdate = !0 } get rings() { return Number(this.ssaoMaterial.defines.SPIRAL_TURNS) } set rings(e) { const t = this.ssaoMaterial; t.defines.SPIRAL_TURNS = e.toFixed(1), t.needsUpdate = !0 } get radius() { return this.r } set radius(e) { this.r = Math.min(Math.max(e, 1e-6), 1); const t = this.r * this.resolution.height, i = this.ssaoMaterial; i.defines.RADIUS = t.toFixed(11), i.defines.RADIUS_SQ = (t * t).toFixed(11), i.needsUpdate = !0 } get depthAwareUpsampling() { return this.defines.has("DEPTH_AWARE_UPSAMPLING") } set depthAwareUpsampling(e) { this.depthAwareUpsampling !== e && (e ? this.defines.set("DEPTH_AWARE_UPSAMPLING", "1") : this.defines.delete("DEPTH_AWARE_UPSAMPLING"), this.setChanged()) } get distanceScaling() { return void 0 !== this.ssaoMaterial.defines.DISTANCE_SCALING } set distanceScaling(e) { if (this.distanceScaling !== e) { const t = this.ssaoMaterial; e ? t.defines.DISTANCE_SCALING = "1" : delete t.defines.DISTANCE_SCALING, t.needsUpdate = !0 } } get color() { return this.uniforms.get("color").value } set color(e) { const t = this.uniforms, i = this.defines; null !== e ? i.has("COLORIZE") ? t.get("color").value.set(e) : (i.set("COLORIZE", "1"), t.get("color").value = new Color$1(e), this.setChanged()) : i.has("COLORIZE") && (i.delete("COLORIZE"), t.get("color").value = null, this.setChanged()) } setDistanceCutoff(e, t) { this.ssaoMaterial.uniforms.distanceCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + t, 0), 1)) } setProximityCutoff(e, t) { this.ssaoMaterial.uniforms.proximityCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + t, 0), 1)) } setDepthTexture(e, t = BasicDepthPacking) { const i = this.ssaoMaterial; void 0 === i.defines.NORMAL_DEPTH && (i.uniforms.normalDepthBuffer.value = e, i.depthPacking = t) } update(e, t, i) { this.ssaoPass.render(e, null, this.renderTargetAO) } setSize(e, t) { const i = this.resolution; i.base.set(e, t); const r = i.width, n = i.height; this.renderTargetAO.setSize(r, n), this.ssaoMaterial.setTexelSize(1 / r, 1 / n); const a = this.camera, o = this.ssaoMaterial.uniforms; o.noiseScale.value.set(r, n).divideScalar(NOISE_TEXTURE_SIZE), o.projectionMatrix.value.copy(a.projectionMatrix), o.inverseProjectionMatrix.value.copy(a.projectionMatrix).invert(), this.radius = this.r } }, shader_default74 = "#ifdef TEXTURE_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\n#if defined(ASPECT_CORRECTION) || defined(UV_TRANSFORM)\nvarying vec2 vUv2;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#if defined(ASPECT_CORRECTION) || defined(UV_TRANSFORM)\nvec4 texel=texelToLinear(texture2D(map,vUv2));\n#else\nvec4 texel=texelToLinear(texture2D(map,uv));\n#endif\noutputColor=TEXEL;}", shader_default75 = "#ifdef ASPECT_CORRECTION\nuniform float scale;\n#else\nuniform mat3 uvTransform;\n#endif\nvarying vec2 vUv2;void mainSupport(const in vec2 uv){\n#ifdef ASPECT_CORRECTION\nvUv2=uv*vec2(aspect,1.0)*scale;\n#else\nvUv2=(uvTransform*vec3(uv,1.0)).xy;\n#endif\n}", TextureEffect = class extends Effect$1 { constructor({ blendFunction: e = BlendFunction.NORMAL, texture: t = null, aspectCorrection: i = !1 } = {}) { super("TextureEffect", shader_default74, { blendFunction: e, defines: new Map([["TEXEL", "texel"]]), uniforms: new Map([["map", new Uniform(null)], ["scale", new Uniform(1)], ["uvTransform", new Uniform(null)]]) }), this.texture = t, this.aspectCorrection = i, this.isWebGL2 = !1 } get texture() { return this.uniforms.get("map").value } set texture(e) { const t = this.texture, i = this.defines; if (t !== e) { this.uniforms.get("map").value = e, i.delete("TEXTURE_PRECISION_HIGH"); const r = getTextureDecoding(e, this.isWebGL2); i.set("texelToLinear(texel)", r), null !== e && (e.type !== UnsignedByteType && i.set("TEXTURE_PRECISION_HIGH", "1"), null !== t && t.type === e.type && t.encoding === e.encoding || this.setChanged()) } } get aspectCorrection() { return this.defines.has("ASPECT_CORRECTION") } set aspectCorrection(e) { this.aspectCorrection !== e && (e ? (this.uvTransform && (this.uvTransform = !1), this.defines.set("ASPECT_CORRECTION", "1"), this.setVertexShader(shader_default75)) : (this.defines.delete("ASPECT_CORRECTION"), this.setVertexShader(null)), this.setChanged()) } get uvTransform() { return this.defines.has("UV_TRANSFORM") } set uvTransform(e) { this.uvTransform !== e && (e ? (this.aspectCorrection && (this.aspectCorrection = !1), this.defines.set("UV_TRANSFORM", "1"), this.uniforms.get("uvTransform").value = new Matrix3, this.setVertexShader(shader_default75)) : (this.defines.delete("UV_TRANSFORM"), this.uniforms.get("uvTransform").value = null, this.setVertexShader(null)), this.setChanged()) } setTextureSwizzleRGBA(e, t = e, i = e, r = e) { const n = "rgba"; let a = ""; e === ColorChannel.RED && t === ColorChannel.GREEN && i === ColorChannel.BLUE && r === ColorChannel.ALPHA || (a = [".", n[e], n[t], n[i], n[r]].join("")), this.defines.set("TEXEL", "texel" + a), this.setChanged() } update(e, t, i) { const r = this.uniforms.get("map").value; this.uvTransform && r.matrixAutoUpdate && (r.updateMatrix(), this.uniforms.get("uvTransform").value.copy(r.matrix)) } initialize(e, t, i) { this.isWebGL2 = e.capabilities.isWebGL2; const r = getTextureDecoding(this.texture, this.isWebGL2); this.defines.set("texelToLinear(texel)", r) } }, LUTCubeLoader = class extends Loader { load(e, t = (() => { }), i = (() => { }), r = null) { const n = this.manager, a = new LoadingManager, o = new FileLoader(a); return o.setPath(this.path), o.setResponseType("text"), new Promise(((s, l) => { a.onError = e => { n.itemError(e), null !== r ? (r(`Failed to load ${e}`), s()) : l(`Failed to load ${e}`) }, n.itemStart(e), o.load(e, (i => { try { const r = this.parse(i); n.itemEnd(e), t(r), s(r) } catch (t) { console.error(t), a.onError(e) } }), i) })) } parse(e) { const t = /^([\d.]+) +([\d.]+) +([\d.]+) *$/gm; let i = /TITLE +"([^"]*)"/.exec(e); const r = null !== i ? i[1] : null; if (i = /LUT_3D_SIZE +(\d+)/.exec(e), null === i) throw new Error("Missing LUT_3D_SIZE information"); const n = Number(i[1]), a = new Float32Array(n ** 3 * 3), o = new Vector3(0, 0, 0), s = new Vector3(1, 1, 1); if (i = /DOMAIN_MIN +([\d.]+) +([\d.]+) +([\d.]+)/.exec(e), null !== i && o.set(Number(i[1]), Number(i[2]), Number(i[3])), i = /DOMAIN_MAX +([\d.]+) +([\d.]+) +([\d.]+)/.exec(e), null !== i && s.set(Number(i[1]), Number(i[2]), Number(i[3])), o.x > s.x || o.y > s.y || o.z > s.z) throw o.set(0, 0, 0), s.set(1, 1, 1), new Error("Invalid input domain"); let l = 0; for (; null !== (i = t.exec(e));)a[l++] = Number(i[1]), a[l++] = Number(i[2]), a[l++] = Number(i[3]); const c = new LookupTexture3D(a, n, n, n); return c.encoding = sRGBEncoding, c.domainMin.copy(o), c.domainMax.copy(s), null !== r && (c.name = r), c } }, SMAAImageLoader = class extends Loader { load(e = (() => { }), t = null) { 4 === arguments.length ? (e = arguments[1], t = arguments[3]) : 3 !== arguments.length && "function" == typeof arguments[0] || (e = arguments[1], t = null); const i = this.manager, r = new LoadingManager; return new Promise(((n, a) => { const o = new Image, s = new Image; r.onError = e => { i.itemError(e), null !== t ? (t(`Failed to load ${e}`), n()) : a(`Failed to load ${e}`) }, r.onLoad = () => { const t = [o, s]; e(t), n(t) }, o.addEventListener("error", (e => { r.itemError("smaa-search") })), s.addEventListener("error", (e => { r.itemError("smaa-area") })), o.addEventListener("load", (() => { i.itemEnd("smaa-search"), r.itemEnd("smaa-search") })), s.addEventListener("load", (() => { i.itemEnd("smaa-area"), r.itemEnd("smaa-area") })), i.itemStart("smaa-search"), i.itemStart("smaa-area"), r.itemStart("smaa-search"), r.itemStart("smaa-area"), o.src = searchImageDataURL_default, s.src = areaImageDataURL_default })) } }; function assertPath(e) { if ("string" != typeof e) throw new TypeError("Path must be a string. Received " + JSON.stringify(e)) } function normalizeStringPosix(e, t) { for (var i, r = "", n = 0, a = -1, o = 0, s = 0; s <= e.length; ++s) { if (s < e.length) i = e.charCodeAt(s); else { if (47 === i) break; i = 47 } if (47 === i) { if (a === s - 1 || 1 === o); else if (a !== s - 1 && 2 === o) { if (r.length < 2 || 2 !== n || 46 !== r.charCodeAt(r.length - 1) || 46 !== r.charCodeAt(r.length - 2)) if (r.length > 2) { var l = r.lastIndexOf("/"); if (l !== r.length - 1) { -1 === l ? (r = "", n = 0) : n = (r = r.slice(0, l)).length - 1 - r.lastIndexOf("/"), a = s, o = 0; continue } } else if (2 === r.length || 1 === r.length) { r = "", n = 0, a = s, o = 0; continue } t && (r.length > 0 ? r += "/.." : r = "..", n = 2) } else r.length > 0 ? r += "/" + e.slice(a + 1, s) : r = e.slice(a + 1, s), n = s - a - 1; a = s, o = 0 } else 46 === i && -1 !== o ? ++o : o = -1 } return r } function _format(e, t) { var i = t.dir || t.root, r = t.base || (t.name || "") + (t.ext || ""); return i ? i === t.root ? i + r : i + e + r : r } var posix = { resolve: function () { for (var e, t = "", i = !1, r = arguments.length - 1; r >= -1 && !i; r--) { var n; r >= 0 ? n = arguments[r] : (void 0 === e && (e = process.cwd()), n = e), assertPath(n), 0 !== n.length && (t = n + "/" + t, i = 47 === n.charCodeAt(0)) } return t = normalizeStringPosix(t, !i), i ? t.length > 0 ? "/" + t : "/" : t.length > 0 ? t : "." }, normalize: function (e) { if (assertPath(e), 0 === e.length) return "."; var t = 47 === e.charCodeAt(0), i = 47 === e.charCodeAt(e.length - 1); return 0 !== (e = normalizeStringPosix(e, !t)).length || t || (e = "."), e.length > 0 && i && (e += "/"), t ? "/" + e : e }, isAbsolute: function (e) { return assertPath(e), e.length > 0 && 47 === e.charCodeAt(0) }, join: function () { if (0 === arguments.length) return "."; for (var e, t = 0; t < arguments.length; ++t) { var i = arguments[t]; assertPath(i), i.length > 0 && (void 0 === e ? e = i : e += "/" + i) } return void 0 === e ? "." : posix.normalize(e) }, relative: function (e, t) { if (assertPath(e), assertPath(t), e === t) return ""; if ((e = posix.resolve(e)) === (t = posix.resolve(t))) return ""; for (var i = 1; i < e.length && 47 === e.charCodeAt(i); ++i); for (var r = e.length, n = r - i, a = 1; a < t.length && 47 === t.charCodeAt(a); ++a); for (var o = t.length - a, s = n < o ? n : o, l = -1, c = 0; c <= s; ++c) { if (c === s) { if (o > s) { if (47 === t.charCodeAt(a + c)) return t.slice(a + c + 1); if (0 === c) return t.slice(a + c) } else n > s && (47 === e.charCodeAt(i + c) ? l = c : 0 === c && (l = 0)); break } var h = e.charCodeAt(i + c); if (h !== t.charCodeAt(a + c)) break; 47 === h && (l = c) } var u = ""; for (c = i + l + 1; c <= r; ++c)c !== r && 47 !== e.charCodeAt(c) || (0 === u.length ? u += ".." : u += "/.."); return u.length > 0 ? u + t.slice(a + l) : (a += l, 47 === t.charCodeAt(a) && ++a, t.slice(a)) }, _makeLong: function (e) { return e }, dirname: function (e) { if (assertPath(e), 0 === e.length) return "."; for (var t = e.charCodeAt(0), i = 47 === t, r = -1, n = !0, a = e.length - 1; a >= 1; --a)if (47 === (t = e.charCodeAt(a))) { if (!n) { r = a; break } } else n = !1; return -1 === r ? i ? "/" : "." : i && 1 === r ? "//" : e.slice(0, r) }, basename: function (e, t) { if (void 0 !== t && "string" != typeof t) throw new TypeError('"ext" argument must be a string'); assertPath(e); var i, r = 0, n = -1, a = !0; if (void 0 !== t && t.length > 0 && t.length <= e.length) { if (t.length === e.length && t === e) return ""; var o = t.length - 1, s = -1; for (i = e.length - 1; i >= 0; --i) { var l = e.charCodeAt(i); if (47 === l) { if (!a) { r = i + 1; break } } else -1 === s && (a = !1, s = i + 1), o >= 0 && (l === t.charCodeAt(o) ? -1 == --o && (n = i) : (o = -1, n = s)) } return r === n ? n = s : -1 === n && (n = e.length), e.slice(r, n) } for (i = e.length - 1; i >= 0; --i)if (47 === e.charCodeAt(i)) { if (!a) { r = i + 1; break } } else -1 === n && (a = !1, n = i + 1); return -1 === n ? "" : e.slice(r, n) }, extname: function (e) { assertPath(e); for (var t = -1, i = 0, r = -1, n = !0, a = 0, o = e.length - 1; o >= 0; --o) { var s = e.charCodeAt(o); if (47 !== s) -1 === r && (n = !1, r = o + 1), 46 === s ? -1 === t ? t = o : 1 !== a && (a = 1) : -1 !== t && (a = -1); else if (!n) { i = o + 1; break } } return -1 === t || -1 === r || 0 === a || 1 === a && t === r - 1 && t === i + 1 ? "" : e.slice(t, r) }, format: function (e) { if (null === e || "object" != typeof e) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e); return _format("/", e) }, parse: function (e) { assertPath(e); var t = { root: "", dir: "", base: "", ext: "", name: "" }; if (0 === e.length) return t; var i, r = e.charCodeAt(0), n = 47 === r; n ? (t.root = "/", i = 1) : i = 0; for (var a = -1, o = 0, s = -1, l = !0, c = e.length - 1, h = 0; c >= i; --c)if (47 !== (r = e.charCodeAt(c))) -1 === s && (l = !1, s = c + 1), 46 === r ? -1 === a ? a = c : 1 !== h && (h = 1) : -1 !== a && (h = -1); else if (!l) { o = c + 1; break } return -1 === a || -1 === s || 0 === h || 1 === h && a === s - 1 && a === o + 1 ? -1 !== s && (t.base = t.name = 0 === o && n ? e.slice(1, s) : e.slice(o, s)) : (0 === o && n ? (t.name = e.slice(1, a), t.base = e.slice(1, s)) : (t.name = e.slice(o, a), t.base = e.slice(o, s)), t.ext = e.slice(a, s)), o > 0 ? t.dir = e.slice(0, o - 1) : n && (t.dir = "/"), t }, sep: "/", delimiter: ":", win32: null, posix: null }; posix.posix = posix; var pathBrowserify = posix; function urlJoin(...e) { const t = /^[a-zA-Z]+:\/\//; let i = -1; for (let r = 0, n = e.length; r < n; r++)t.test(e[r]) && (i = r); if (-1 === i) return pathBrowserify.join(...e).replace(/\\/g, "/"); { const r = i <= 0 ? e : e.slice(i), n = r[0].match(t)[0]; return r[0] = r[0].substring(n.length), (n + pathBrowserify.join(...r)).replace(/\\/g, "/") } } function getUrlExtension(e) { let t; try { t = new URL(e, "http://fakehost.com/") } catch (e) { return null } const i = t.pathname.split("/").pop(), r = i.lastIndexOf("."); if (-1 === r || r === i.length - 1) return null; return i.substring(r + 1) } function enqueueMicrotask(e) { Promise.resolve().then(e) } class LRUCache { constructor() { this.maxSize = 800, this.minSize = 600, this.unloadPercent = .05, this.itemSet = new Map, this.itemList = [], this.usedSet = new Set, this.callbacks = new Map, this.unloadPriorityCallback = null; const e = this.itemSet; this.defaultPriorityCallback = t => e.get(t) } isFull() { return this.itemSet.size >= this.maxSize } add(e, t) { const i = this.itemSet; if (i.has(e)) return !1; if (this.isFull()) return !1; const r = this.usedSet, n = this.itemList, a = this.callbacks; return n.push(e), r.add(e), i.set(e, Date.now()), a.set(e, t), !0 } remove(e) { const t = this.usedSet, i = this.itemSet, r = this.itemList, n = this.callbacks; if (i.has(e)) { n.get(e)(e); const a = r.indexOf(e); return r.splice(a, 1), t.delete(e), i.delete(e), n.delete(e), !0 } return !1 } markUsed(e) { const t = this.itemSet, i = this.usedSet; t.has(e) && !i.has(e) && (t.set(e, Date.now()), i.add(e)) } markAllUnused() { this.usedSet.clear() } unloadUnusedContent() { const e = this.unloadPercent, t = this.minSize, i = this.itemList, r = this.itemSet, n = this.usedSet, a = this.callbacks, o = i.length - n.size, s = i.length - t, l = this.unloadPriorityCallback || this.defaultPriorityCallback; if (s > 0 && o > 0) { i.sort(((e, t) => { const i = n.has(e), r = n.has(t); return i && r ? 0 : i || r ? i ? 1 : -1 : l(t) - l(e) })); const c = Math.min(s, o), h = Math.max(t * e, c * e); let u = Math.min(h, o); u = Math.ceil(u); const d = i.splice(0, u); for (let e = 0, t = d.length; e < t; e++) { const t = d[e]; a.get(t)(t), r.delete(t), a.delete(t) } } } scheduleUnload(e = !0) { this.scheduled || (this.scheduled = !0, enqueueMicrotask((() => { this.scheduled = !1, this.unloadUnusedContent(), e && this.markAllUnused() }))) } } class PriorityQueue { constructor() { this.maxJobs = 6, this.items = [], this.callbacks = new Map, this.currJobs = 0, this.scheduled = !1, this.autoUpdate = !0, this.priorityCallback = () => { throw new Error("PriorityQueue: PriorityCallback function not defined.") }, this.schedulingCallback = e => { requestAnimationFrame(e) }, this._runjobs = () => { this.tryRunJobs(), this.scheduled = !1 } } sort() { const e = this.priorityCallback; this.items.sort(e) } add(e, t) { return new Promise(((i, r) => { const n = this.items, a = this.callbacks; n.push(e), a.set(e, ((...e) => t(...e).then(i).catch(r))), this.autoUpdate && this.scheduleJobRun() })) } remove(e) { const t = this.items, i = this.callbacks, r = t.indexOf(e); -1 !== r && (t.splice(r, 1), i.delete(e)) } tryRunJobs() { this.sort(); const e = this.items, t = this.callbacks, i = this.maxJobs; let r = this.currJobs; for (; i > r && e.length > 0;) { r++; const i = e.pop(), n = t.get(i); t.delete(i), n(i).then((() => { this.currJobs--, this.autoUpdate && this.scheduleJobRun() })).catch((() => { this.currJobs--, this.autoUpdate && this.scheduleJobRun() })) } this.currJobs = r } scheduleJobRun() { this.scheduled || (this.schedulingCallback(this._runjobs), this.scheduled = !0) } } const UNLOADED = 0, LOADING = 1, PARSING = 2, LOADED = 3, FAILED = 4; function isDownloadFinished(e) { return e === LOADED || e === FAILED } function isUsedThisFrame(e, t) { return e.__lastFrameVisited === t && e.__used } function resetFrameState(e, t) { e.__lastFrameVisited !== t && (e.__lastFrameVisited = t, e.__used = !1, e.__inFrustum = !1, e.__isLeaf = !1, e.__visible = !1, e.__active = !1, e.__error = 1 / 0, e.__distanceFromCamera = 1 / 0, e.__childrenWereVisible = !1, e.__allChildrenLoaded = !1) } function recursivelyMarkUsed(e, t, i) { if (resetFrameState(e, t), e.__used = !0, i.markUsed(e), e.__contentEmpty) { const r = e.children; for (let e = 0, n = r.length; e < n; e++)recursivelyMarkUsed(r[e], t, i) } } function recursivelyLoadTiles(e, t, i) { if (e.__contentEmpty && (!e.__externalTileSet || isDownloadFinished(e.__loadingState))) { const r = e.children; for (let e = 0, n = r.length; e < n; e++) { const n = r[e]; n.__depthFromRenderedParent = t, recursivelyLoadTiles(n, t, i) } } else i.requestTileContents(e) } function traverseSet(e, t = null, i = null, r = null, n = 0) { if (t && t(e, r, n)) return void (i && i(e, r, n)); const a = e.children; for (let r = 0, o = a.length; r < o; r++)traverseSet(a[r], t, i, e, n + 1); i && i(e, r, n) } function determineFrustumSet(e, t) { const i = t.stats, r = t.frameCount, n = t.errorTarget, a = t.maxDepth, o = t.loadSiblings, s = t.lruCache, l = t.stopAtEmptyTiles; resetFrameState(e, r); if (!1 === t.tileInView(e)) return !1; if (e.__used = !0, s.markUsed(e), e.__inFrustum = !0, i.inFrustum++, (l || !e.__contentEmpty) && !e.__externalTileSet) { t.calculateError(e); if (e.__error <= n) return !0; if (t.maxDepth > 0 && e.__depth + 1 >= a) return !0 } let c = !1; const h = e.children; for (let e = 0, i = h.length; e < i; e++) { const i = determineFrustumSet(h[e], t); c = c || i } if (c && o) for (let e = 0, t = h.length; e < t; e++) { recursivelyMarkUsed(h[e], r, s) } return !0 } function markUsedSetLeaves(e, t) { const i = t.stats, r = t.frameCount; if (!isUsedThisFrame(e, r)) return; i.used++; const n = e.children; let a = !1; for (let e = 0, t = n.length; e < t; e++) { const t = n[e]; a = a || isUsedThisFrame(t, r) } if (a) { let i = !1, a = !0; for (let e = 0, o = n.length; e < o; e++) { const o = n[e]; if (markUsedSetLeaves(o, t), i = i || o.__wasSetVisible || o.__childrenWereVisible, isUsedThisFrame(o, r)) { const e = o.__allChildrenLoaded || !o.__contentEmpty && isDownloadFinished(o.__loadingState) || o.__externalTileSet && o.__loadingState === FAILED; a = a && e } } e.__childrenWereVisible = i, e.__allChildrenLoaded = a } else e.__isLeaf = !0 } function skipTraversal(e, t) { const i = t.stats, r = t.frameCount; if (!isUsedThisFrame(e, r)) return; const n = e.parent, a = n ? n.__depthFromRenderedParent : -1; e.__depthFromRenderedParent = a; const o = t.lruCache; if (e.__isLeaf) return e.__depthFromRenderedParent++, void (e.__loadingState === LOADED ? (e.__inFrustum && (e.__visible = !0, i.visible++), e.__active = !0, i.active++) : o.isFull() || e.__contentEmpty && !e.__externalTileSet || t.requestTileContents(e)); const s = (t.errorTarget + 1) * t.errorThreshold, l = e.__error <= s, c = l || "ADD" === e.refine, h = !e.__contentEmpty, u = h || e.__externalTileSet, d = isDownloadFinished(e.__loadingState) && u, p = e.__childrenWereVisible, f = e.children; let m = e.__allChildrenLoaded; if (c && h && e.__depthFromRenderedParent++, c && !d && !o.isFull() && u && t.requestTileContents(e), (l && !m && !p && d || "ADD" === e.refine && d) && (e.__inFrustum && (e.__visible = !0, i.visible++), e.__active = !0, i.active++), "ADD" !== e.refine && l && !m && d) for (let i = 0, n = f.length; i < n; i++) { const n = f[i]; isUsedThisFrame(n, r) && !o.isFull() && (n.__depthFromRenderedParent = e.__depthFromRenderedParent + 1, recursivelyLoadTiles(n, n.__depthFromRenderedParent, t)) } else for (let e = 0, i = f.length; e < i; e++) { const i = f[e]; isUsedThisFrame(i, r) && skipTraversal(i, t) } } function toggleTiles(e, t) { const i = isUsedThisFrame(e, t.frameCount); if (i || e.__usedLastFrame) { let r = !1, n = !1; i && (r = e.__active, n = t.displayActiveTiles && e.__active || e.__visible), e.__contentEmpty || e.__loadingState !== LOADED || (e.__wasSetActive !== r && t.setTileActive(e, r), e.__wasSetVisible !== n && t.setTileVisible(e, n)), e.__wasSetActive = r, e.__wasSetVisible = n, e.__usedLastFrame = i; const a = e.children; for (let e = 0, i = a.length; e < i; e++) { toggleTiles(a[e], t) } } } const priorityCallback = (e, t) => e.__depth !== t.__depth ? e.__depth > t.__depth ? -1 : 1 : e.__inFrustum !== t.__inFrustum ? e.__inFrustum ? 1 : -1 : e.__used !== t.__used ? e.__used ? 1 : -1 : e.__error !== t.__error ? e.__error > t.__error ? 1 : -1 : e.__distanceFromCamera !== t.__distanceFromCamera ? e.__distanceFromCamera > t.__distanceFromCamera ? -1 : 1 : 0, lruPriorityCallback = e => 1 / (e.__depthFromRenderedParent + 1); class TilesRendererBase { get rootTileSet() { const e = this.tileSets[this.rootURL]; return !e || e instanceof Promise ? null : e } get root() { const e = this.rootTileSet; return e ? e.root : null } constructor(e) { this.tileSets = {}, this.rootURL = e, this.fetchOptions = {}, this.preprocessURL = null; const t = new LRUCache; t.unloadPriorityCallback = lruPriorityCallback; const i = new PriorityQueue; i.maxJobs = 4, i.priorityCallback = priorityCallback; const r = new PriorityQueue; r.maxJobs = 1, r.priorityCallback = priorityCallback, this.lruCache = t, this.downloadQueue = i, this.parseQueue = r, this.stats = { parsing: 0, downloading: 0, failed: 0, inFrustum: 0, used: 0, active: 0, visible: 0 }, this.frameCount = 0, this.errorTarget = 6, this.errorThreshold = 1 / 0, this.loadSiblings = !0, this.displayActiveTiles = !1, this.maxDepth = 1 / 0, this.stopAtEmptyTiles = !0 } traverse(e, t) { const i = this.tileSets[this.rootURL]; i && i.root && traverseSet(i.root, e, t) } update() { const e = this.stats, t = this.lruCache, i = this.tileSets, r = i[this.rootURL]; if (!(this.rootURL in i)) return void this.loadRootTileSet(this.rootURL); if (!r || !r.root) return; const n = r.root; e.inFrustum = 0, e.used = 0, e.active = 0, e.visible = 0, this.frameCount++, determineFrustumSet(n, this), markUsedSetLeaves(n, this), skipTraversal(n, this), toggleTiles(n, this), t.scheduleUnload() } parseTile(e, t, i) { return null } disposeTile(e) { } preprocessNode(e, t, i) { e.content && (!("uri" in e.content) && "url" in e.content && (e.content.uri = e.content.url, delete e.content.url), e.content.uri && (e.content.uri = urlJoin(i, e.content.uri)), e.content.boundingVolume && !("box" in e.content.boundingVolume || "sphere" in e.content.boundingVolume || "region" in e.content.boundingVolume) && delete e.content.boundingVolume), e.parent = t, e.children = e.children || []; if (e.content && e.content.uri) { const t = getUrlExtension(e.content.uri), i = Boolean(t && "json" === t.toLowerCase()); e.__externalTileSet = i, e.__contentEmpty = i } else e.__externalTileSet = !1, e.__contentEmpty = !0; e.__distanceFromCamera = 1 / 0, e.__error = 1 / 0, e.__inFrustum = !1, e.__isLeaf = !1, e.__usedLastFrame = !1, e.__used = !1, e.__wasSetVisible = !1, e.__visible = !1, e.__childrenWereVisible = !1, e.__allChildrenLoaded = !1, e.__wasSetActive = !1, e.__active = !1, e.__loadingState = UNLOADED, e.__loadIndex = 0, e.__loadAbort = null, e.__depthFromRenderedParent = -1, null === t ? (e.__depth = 0, e.refine = e.refine || "REPLACE") : (e.__depth = t.__depth + 1, e.refine = e.refine || t.refine) } setTileActive(e, t) { } setTileVisible(e, t) { } calculateError(e) { return 0 } tileInView(e) { return !0 } fetchTileSet(e, t, i = null) { return fetch(e, t).then((t => { if (t.ok) return t.json(); throw new Error(`TilesRenderer: Failed to load tileset "${e}" with status ${t.status} : ${t.statusText}`) })).then((t => { const r = t.asset.version; console.assert("1.0" === r || "0.0" === r, 'asset.version is expected to be a string of "1.0" or "0.0"'); const n = pathBrowserify.dirname(e); return traverseSet(t.root, ((e, t) => this.preprocessNode(e, t, n)), null, i, i ? i.__depth : 0), t })) } loadRootTileSet(e) { const t = this.tileSets; if (e in t) return t[e] instanceof Error ? Promise.reject(t[e]) : Promise.resolve(t[e]); { const i = this.fetchTileSet(e, this.fetchOptions).then((i => { t[e] = i })); return i.catch((i => { console.error(i), t[e] = i })), t[e] = i, i } } requestTileContents(e) { if (e.__loadingState !== UNLOADED) return; const t = this.stats, i = this.lruCache, r = this.downloadQueue, n = this.parseQueue, a = e.__externalTileSet; i.add(e, (e => { e.__loadingState === LOADING ? (e.__loadAbort.abort(), e.__loadAbort = null) : a ? e.children.length = 0 : this.disposeTile(e), e.__loadingState === LOADING ? t.downloading-- : e.__loadingState === PARSING && t.parsing--, e.__loadingState = UNLOADED, e.__loadIndex++, n.remove(e), r.remove(e) })), e.__loadIndex++; const o = e.__loadIndex, s = new AbortController, l = s.signal; t.downloading++, e.__loadAbort = s, e.__loadingState = LOADING; const c = a => { e.__loadIndex === o && ("AbortError" !== a.name ? (n.remove(e), r.remove(e), e.__loadingState === PARSING ? t.parsing-- : e.__loadingState === LOADING && t.downloading--, t.failed++, console.error(`TilesRenderer : Failed to load tile at url "${e.content.uri}".`), console.error(a), e.__loadingState = FAILED) : i.remove(e)) }; a ? r.add(e, (e => { if (e.__loadIndex !== o) return Promise.resolve(); const t = this.preprocessURL ? this.preprocessURL(e.content.uri) : e.content.uri; return this.fetchTileSet(t, Object.assign({ signal: l }, this.fetchOptions), e) })).then((i => { e.__loadIndex === o && (t.downloading--, e.__loadAbort = null, e.__loadingState = LOADED, e.children.push(i.root)) })).catch(c) : r.add(e, (e => { if (e.__loadIndex !== o) return Promise.resolve(); const t = this.preprocessURL ? this.preprocessURL(e.content.uri) : e.content.uri; return fetch(t, Object.assign({ signal: l }, this.fetchOptions)) })).then((t => { if (e.__loadIndex === o) { if (t.ok) return t.arrayBuffer(); throw new Error(`Failed to load model with error code ${t.status}`) } })).then((i => { if (e.__loadIndex === o) return t.downloading--, t.parsing++, e.__loadAbort = null, e.__loadingState = PARSING, n.add(e, (e => { if (e.__loadIndex !== o) return Promise.resolve(); const t = getUrlExtension(e.content.uri); return this.parseTile(i, e, t) })) })).then((() => { e.__loadIndex === o && (t.parsing--, e.__loadingState = LOADED, e.__wasSetVisible && this.setTileVisible(e, !0), e.__wasSetActive && this.setTileActive(e, !0)) })).catch(c) } dispose() { const e = this.lruCache; this.traverse((t => { e.remove(t) })) } } function arrayToString(e) { return (new TextDecoder).decode(e) } class FeatureTable { constructor(e, t, i, r) { this.buffer = e, this.binOffset = t + i, this.binLength = r; let n = null; if (0 !== i) { const r = new Uint8Array(e, t, i); n = JSON.parse(arrayToString(r)) } else n = {}; this.header = n } getKeys() { return Object.keys(this.header) } getData(e, t, i = null, r = null) { const n = this.header; if (!(e in n)) return null; const a = n[e]; if (a instanceof Object) { if (Array.isArray(a)) return a; { const { buffer: n, binOffset: o, binLength: s } = this, l = a.byteOffset || 0, c = a.type || r, h = a.componentType || i; if ("type" in a && r && a.type !== r) throw new Error("FeatureTable: Specified type does not match expected type."); let u, d; switch (c) { case "SCALAR": u = 1; break; case "VEC2": u = 2; break; case "VEC3": u = 3; break; case "VEC4": u = 4; break; default: throw new Error(`FeatureTable : Feature type not provided for "${e}".`) }const p = o + l, f = t * u; switch (h) { case "BYTE": d = new Int8Array(n, p, f); break; case "UNSIGNED_BYTE": d = new Uint8Array(n, p, f); break; case "SHORT": d = new Int16Array(n, p, f); break; case "UNSIGNED_SHORT": d = new Uint16Array(n, p, f); break; case "INT": d = new Int32Array(n, p, f); break; case "UNSIGNED_INT": d = new Uint32Array(n, p, f); break; case "FLOAT": d = new Float32Array(n, p, f); break; case "DOUBLE": d = new Float64Array(n, p, f); break; default: throw new Error(`FeatureTable : Feature component type not provided for "${e}".`) }if (p + f * d.BYTES_PER_ELEMENT > o + s) throw new Error("FeatureTable: Feature data read outside binary body length."); return d } } return a } } class BatchTable extends FeatureTable { constructor(e, t, i, r, n) { super(e, i, r, n), this.batchSize = t } getData(e, t = null, i = null) { return super.getData(e, this.batchSize, i, t) } } class B3DMLoaderBase { constructor() { this.fetchOptions = {}, this.workingPath = "" } load(e) { return fetch(e, this.fetchOptions).then((t => { if (!t.ok) throw new Error(`Failed to load file "${e}" with status ${t.status} : ${t.statusText}`); return t.arrayBuffer() })).then((t => { if ("" === this.workingPath) { const t = e.split(/\\\//g); t.pop(), this.workingPath = t.join("/") } return this.parse(t) })) } parse(e) { const t = new DataView(e), i = String.fromCharCode(t.getUint8(0)) + String.fromCharCode(t.getUint8(1)) + String.fromCharCode(t.getUint8(2)) + String.fromCharCode(t.getUint8(3)); console.assert("b3dm" === i); const r = t.getUint32(4, !0); console.assert(1 === r); const n = t.getUint32(8, !0); console.assert(n === e.byteLength); const a = t.getUint32(12, !0), o = t.getUint32(16, !0), s = t.getUint32(20, !0), l = t.getUint32(24, !0), c = e.slice(28, 28 + a + o), h = new FeatureTable(c, 0, a, o), u = 28 + a + o, d = e.slice(u, u + s + l), p = new BatchTable(d, h.getData("BATCH_LENGTH"), 0, s, l), f = u + s + l; return { version: r, featureTable: h, batchTable: p, glbBytes: new Uint8Array(e, f, n - f) } } } var GLTFLoader = function () { function e(e) { Loader.call(this, e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function (e) { return new a(e) })), this.register((function (e) { return new s(e) })), this.register((function (e) { return new l(e) })), this.register((function (e) { return new o(e) })), this.register((function (e) { return new r(e) })), this.register((function (e) { return new c(e) })) } function t() { var e = {}; return { get: function (t) { return e[t] }, add: function (t, i) { e[t] = i }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } e.prototype = Object.assign(Object.create(Loader.prototype), { constructor: e, load: function (e, t, i, r) { var n, a = this; n = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : LoaderUtils.extractUrlBase(e), this.manager.itemStart(e); var o = function (t) { r ? r(t) : console.error(t), a.manager.itemError(e), a.manager.itemEnd(e) }, s = new FileLoader(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function (i) { try { a.parse(i, n, (function (i) { t(i), a.manager.itemEnd(e) }), o) } catch (e) { o(e) } }), i, o) }, setDRACOLoader: function (e) { return this.dracoLoader = e, this }, setDDSLoader: function () { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') }, setKTX2Loader: function (e) { return this.ktx2Loader = e, this }, setMeshoptDecoder: function (e) { return this.meshoptDecoder = e, this }, register: function (e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this }, unregister: function (e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this }, parse: function (e, t, r, a) { var o, s = {}, l = {}; if ("string" == typeof e) o = e; else if (LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === h) { try { s[i.KHR_BINARY_GLTF] = new p(e) } catch (e) { return void (a && a(e)) } o = s[i.KHR_BINARY_GLTF].content } else o = LoaderUtils.decodeText(new Uint8Array(e)); var c = JSON.parse(o); if (void 0 === c.asset || c.asset.version[0] < 2) a && a(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); else { var u = new H(c, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); u.fileLoader.setRequestHeader(this.requestHeader); for (var d = 0; d < this.pluginCallbacks.length; d++) { var g = this.pluginCallbacks[d](u); l[g.name] = g, s[g.name] = !0 } if (c.extensionsUsed) for (d = 0; d < c.extensionsUsed.length; ++d) { var _ = c.extensionsUsed[d], b = c.extensionsRequired || []; switch (_) { case i.KHR_MATERIALS_UNLIT: s[_] = new n; break; case i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: s[_] = new y; break; case i.KHR_DRACO_MESH_COMPRESSION: s[_] = new f(c, this.dracoLoader); break; case i.KHR_TEXTURE_TRANSFORM: s[_] = new m; break; case i.KHR_MESH_QUANTIZATION: s[_] = new v; break; default: b.indexOf(_) >= 0 && void 0 === l[_] && console.warn('THREE.GLTFLoader: Unknown extension "' + _ + '".') } } u.setExtensions(s), u.setPlugins(l), u.parse(r, a) } } }); var i = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" }; function r(e) { this.parser = e, this.name = i.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } function n() { this.name = i.KHR_MATERIALS_UNLIT } function a(e) { this.parser = e, this.name = i.KHR_MATERIALS_CLEARCOAT } function o(e) { this.parser = e, this.name = i.KHR_MATERIALS_TRANSMISSION } function s(e) { this.parser = e, this.name = i.KHR_TEXTURE_BASISU } function l(e) { this.parser = e, this.name = i.EXT_TEXTURE_WEBP, this.isSupported = null } function c(e) { this.name = i.EXT_MESHOPT_COMPRESSION, this.parser = e } r.prototype._markDefs = function () { for (var e = this.parser, t = this.parser.json.nodes || [], i = 0, r = t.length; i < r; i++) { var n = t[i]; n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && e._addNodeRef(this.cache, n.extensions[this.name].light) } }, r.prototype._loadLight = function (e) { var t = this.parser, i = "light:" + e, r = t.cache.get(i); if (r) return r; var n, a = t.json, o = ((a.extensions && a.extensions[this.name] || {}).lights || [])[e], s = new Color$1(16777215); void 0 !== o.color && s.fromArray(o.color); var l = void 0 !== o.range ? o.range : 0; switch (o.type) { case "directional": (n = new DirectionalLight(s)).target.position.set(0, 0, -1), n.add(n.target); break; case "point": (n = new PointLight(s)).distance = l; break; case "spot": (n = new SpotLight(s)).distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, n.angle = o.spot.outerConeAngle, n.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, n.target.position.set(0, 0, -1), n.add(n.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type) }return n.position.set(0, 0, 0), n.decay = 2, void 0 !== o.intensity && (n.intensity = o.intensity), n.name = t.createUniqueName(o.name || "light_" + e), r = Promise.resolve(n), t.cache.add(i, r), r }, r.prototype.createNodeAttachment = function (e) { var t = this, i = this.parser, r = i.json.nodes[e], n = (r.extensions && r.extensions[this.name] || {}).light; return void 0 === n ? null : this._loadLight(n).then((function (e) { return i._getNodeRef(t.cache, n, e) })) }, n.prototype.getMaterialType = function () { return MeshBasicMaterial }, n.prototype.extendParams = function (e, t, i) { var r = []; e.color = new Color$1(1, 1, 1), e.opacity = 1; var n = t.pbrMetallicRoughness; if (n) { if (Array.isArray(n.baseColorFactor)) { var a = n.baseColorFactor; e.color.fromArray(a), e.opacity = a[3] } void 0 !== n.baseColorTexture && r.push(i.assignTexture(e, "map", n.baseColorTexture)) } return Promise.all(r) }, a.prototype.getMaterialType = function (e) { var t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null }, a.prototype.extendMaterialParams = function (e, t) { var i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); var n = [], a = r.extensions[this.name]; if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && n.push(i.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && n.push(i.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (n.push(i.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) { var o = a.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new Vector2(o, -o) } return Promise.all(n) }, o.prototype.getMaterialType = function (e) { var t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null }, o.prototype.extendMaterialParams = function (e, t) { var i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); var n = [], a = r.extensions[this.name]; return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor), void 0 !== a.transmissionTexture && n.push(i.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(n) }, s.prototype.loadTexture = function (e) { var t = this.parser, i = t.json, r = i.textures[e]; if (!r.extensions || !r.extensions[this.name]) return null; var n = r.extensions[this.name], a = i.images[n.source], o = t.options.ktx2Loader; if (!o) { if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, a, o) }, l.prototype.loadTexture = function (e) { var t = this.name, i = this.parser, r = i.json, n = r.textures[e]; if (!n.extensions || !n.extensions[t]) return null; var a = n.extensions[t], o = r.images[a.source], s = i.textureLoader; if (o.uri) { var l = i.options.manager.getHandler(o.uri); null !== l && (s = l) } return this.detectSupport().then((function (n) { if (n) return i.loadTextureImage(e, o, s); if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return i.loadTexture(e) })) }, l.prototype.detectSupport = function () { return this.isSupported || (this.isSupported = new Promise((function (e) { var t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported }, c.prototype.loadBufferView = function (e) { var t = this.parser.json, i = t.bufferViews[e]; if (i.extensions && i.extensions[this.name]) { var r = i.extensions[this.name], n = this.parser.getDependency("buffer", r.buffer), a = this.parser.options.meshoptDecoder; if (!a || !a.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return Promise.all([n, a.ready]).then((function (e) { var t = r.byteOffset || 0, i = r.byteLength || 0, n = r.count, o = r.byteStride, s = new ArrayBuffer(n * o), l = new Uint8Array(e[0], t, i); return a.decodeGltfBuffer(new Uint8Array(s), n, o, l, r.mode, r.filter), s })) } return null }; var h = "glTF", u = 1313821514, d = 5130562; function p(e) { this.name = i.KHR_BINARY_GLTF, this.content = null, this.body = null; var t = new DataView(e, 0, 12); if (this.header = { magic: LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== h) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); for (var r = this.header.length - 12, n = new DataView(e, 12), a = 0; a < r;) { var o = n.getUint32(a, !0); a += 4; var s = n.getUint32(a, !0); if (a += 4, s === u) { var l = new Uint8Array(e, 12 + a, o); this.content = LoaderUtils.decodeText(l) } else if (s === d) { var c = 12 + a; this.body = e.slice(c, c + o) } a += o } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } function f(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = i.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } function m() { this.name = i.KHR_TEXTURE_TRANSFORM } function g(e) { MeshStandardMaterial.call(this), this.isGLTFSpecularGlossinessMaterial = !0; var t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), i = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), n = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), a = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), o = { specular: { value: (new Color$1).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = o, this.onBeforeCompile = function (e) { for (var s in o) e.uniforms[s] = o[s]; e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", n).replace("#include <lights_physical_fragment>", a) }, Object.defineProperties(this, { specular: { get: function () { return o.specular.value }, set: function (e) { o.specular.value = e } }, specularMap: { get: function () { return o.specularMap.value }, set: function (e) { o.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function () { return o.glossiness.value }, set: function (e) { o.glossiness.value = e } }, glossinessMap: { get: function () { return o.glossinessMap.value }, set: function (e) { o.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e) } function y() { return { name: i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"], getMaterialType: function () { return g }, extendParams: function (e, t, i) { var r = t.extensions[this.name]; e.color = new Color$1(1, 1, 1), e.opacity = 1; var n = []; if (Array.isArray(r.diffuseFactor)) { var a = r.diffuseFactor; e.color.fromArray(a), e.opacity = a[3] } if (void 0 !== r.diffuseTexture && n.push(i.assignTexture(e, "map", r.diffuseTexture)), e.emissive = new Color$1(0, 0, 0), e.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, e.specular = new Color$1(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) { var o = r.specularGlossinessTexture; n.push(i.assignTexture(e, "glossinessMap", o)), n.push(i.assignTexture(e, "specularMap", o)) } return Promise.all(n) }, createMaterial: function (e) { var t = new g(e); return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = TangentSpaceNormalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } } function v() { this.name = i.KHR_MESH_QUANTIZATION } function _(e, t, i, r) { Interpolant.call(this, e, t, i, r) } f.prototype.decodePrimitive = function (e, t) { var i = this.json, r = this.dracoLoader, n = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, s = {}, l = {}; for (var c in a) { var h = D[c] || c.toLowerCase(); o[h] = a[c] } for (c in e.attributes) { h = D[c] || c.toLowerCase(); if (void 0 !== a[c]) { var u = i.accessors[e.attributes[c]], d = E[u.componentType]; l[h] = d, s[h] = !0 === u.normalized } } return t.getDependency("bufferView", n).then((function (e) { return new Promise((function (t) { r.decodeDracoFile(e, (function (e) { for (var i in e.attributes) { var r = e.attributes[i], n = s[i]; void 0 !== n && (r.normalized = n) } t(e) }), o, l) })) })) }, m.prototype.extendTexture = function (e, t) { return e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), e.needsUpdate = !0, e }, g.prototype = Object.create(MeshStandardMaterial.prototype), g.prototype.constructor = g, g.prototype.copy = function (e) { return MeshStandardMaterial.prototype.copy.call(this, e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this }, _.prototype = Object.create(Interpolant.prototype), _.prototype.constructor = _, _.prototype.copySampleValue_ = function (e) { for (var t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, n = e * r * 3 + r, a = 0; a !== r; a++)t[a] = i[n + a]; return t }, _.prototype.beforeStart_ = _.prototype.copySampleValue_, _.prototype.afterEnd_ = _.prototype.copySampleValue_, _.prototype.interpolate_ = function (e, t, i, r) { for (var n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = 2 * o, l = 3 * o, c = r - t, h = (i - t) / c, u = h * h, d = u * h, p = e * l, f = p - l, m = -2 * d + 3 * u, g = d - u, y = 1 - m, v = g - u + h, _ = 0; _ !== o; _++) { var b = a[f + _ + o], x = a[f + _ + s] * c, w = a[p + _ + o], S = a[p + _] * c; n[_] = y * b + v * x + m * w + g * S } return n }; var b = 0, x = 1, w = 2, S = 3, M = 4, T = 5, A = 6, E = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, C = { 9728: NearestFilter, 9729: LinearFilter, 9984: NearestMipmapNearestFilter, 9985: LinearMipmapNearestFilter, 9986: NearestMipmapLinearFilter, 9987: LinearMipmapLinearFilter }, L = { 33071: ClampToEdgeWrapping, 33648: MirroredRepeatWrapping, 10497: RepeatWrapping }, R = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, D = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, P = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, O = { CUBICSPLINE: void 0, LINEAR: InterpolateLinear, STEP: InterpolateDiscrete }, I = "OPAQUE", k = "MASK", B = "BLEND"; function N(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } function F(e, t, i) { for (var r in i.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = i.extensions[r]) } function U(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) } function z(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (var i = 0, r = t.weights.length; i < r; i++)e.morphTargetInfluences[i] = t.weights[i]; if (t.extras && Array.isArray(t.extras.targetNames)) { var n = t.extras.targetNames; if (e.morphTargetInfluences.length === n.length) { e.morphTargetDictionary = {}; for (i = 0, r = n.length; i < r; i++)e.morphTargetDictionary[n[i]] = i } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function G(e) { for (var t = "", i = Object.keys(e).sort(), r = 0, n = i.length; r < n; r++)t += i[r] + ":" + e[i[r]] + ";"; return t } function H(e, i) { this.json = e || {}, this.extensions = {}, this.plugins = {}, this.options = i || {}, this.cache = new t, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new ImageBitmapLoader(this.options.manager) : this.textureLoader = new TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } function V(e, t, i) { var r = t.attributes, n = []; function a(t, r) { return i.getDependency("accessor", t).then((function (t) { e.setAttribute(r, t) })) } for (var o in r) { var s = D[o] || o.toLowerCase(); s in e.attributes || n.push(a(r[o], s)) } if (void 0 !== t.indices && !e.index) { var l = i.getDependency("accessor", t.indices).then((function (t) { e.setIndex(t) })); n.push(l) } return U(e, t), function (e, t, i) { var r = t.attributes, n = new Box3; if (void 0 !== r.POSITION) { var a = (d = i.json.accessors[r.POSITION]).min, o = d.max; if (void 0 !== a && void 0 !== o) { n.set(new Vector3(a[0], a[1], a[2]), new Vector3(o[0], o[1], o[2])); var s = t.targets; if (void 0 !== s) { for (var l = new Vector3, c = new Vector3, h = 0, u = s.length; h < u; h++) { var d, p = s[h]; if (void 0 !== p.POSITION) a = (d = i.json.accessors[p.POSITION]).min, o = d.max, void 0 !== a && void 0 !== o ? (c.setX(Math.max(Math.abs(a[0]), Math.abs(o[0]))), c.setY(Math.max(Math.abs(a[1]), Math.abs(o[1]))), c.setZ(Math.max(Math.abs(a[2]), Math.abs(o[2]))), l.max(c)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } n.expandByVector(l) } e.boundingBox = n; var f = new Sphere; n.getCenter(f.center), f.radius = n.min.distanceTo(n.max) / 2, e.boundingSphere = f } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.") } }(e, t, i), Promise.all(n).then((function () { return void 0 !== t.targets ? function (e, t, i) { for (var r = !1, n = !1, a = 0, o = t.length; a < o && (void 0 !== (c = t[a]).POSITION && (r = !0), void 0 !== c.NORMAL && (n = !0), !r || !n); a++); if (!r && !n) return Promise.resolve(e); var s = [], l = []; for (a = 0, o = t.length; a < o; a++) { var c = t[a]; if (r) { var h = void 0 !== c.POSITION ? i.getDependency("accessor", c.POSITION) : e.attributes.position; s.push(h) } n && (h = void 0 !== c.NORMAL ? i.getDependency("accessor", c.NORMAL) : e.attributes.normal, l.push(h)) } return Promise.all([Promise.all(s), Promise.all(l)]).then((function (t) { var i = t[0], a = t[1]; return r && (e.morphAttributes.position = i), n && (e.morphAttributes.normal = a), e.morphTargetsRelative = !0, e })) }(e, t.targets, i) : e })) } function j(e, t) { var i = e.getIndex(); if (null === i) { var r = [], n = e.getAttribute("position"); if (void 0 === n) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (var a = 0; a < n.count; a++)r.push(a); e.setIndex(r), i = e.getIndex() } var o = i.count - 2, s = []; if (t === TriangleFanDrawMode) for (a = 1; a <= o; a++)s.push(i.getX(0)), s.push(i.getX(a)), s.push(i.getX(a + 1)); else for (a = 0; a < o; a++)a % 2 == 0 ? (s.push(i.getX(a)), s.push(i.getX(a + 1)), s.push(i.getX(a + 2))) : (s.push(i.getX(a + 2)), s.push(i.getX(a + 1)), s.push(i.getX(a))); s.length / 3 !== o && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); var l = e.clone(); return l.setIndex(s), l } return H.prototype.setExtensions = function (e) { this.extensions = e }, H.prototype.setPlugins = function (e) { this.plugins = e }, H.prototype.parse = function (e, t) { var i = this, r = this.json, n = this.extensions; this.cache.removeAll(), this._invokeAll((function (e) { return e._markDefs && e._markDefs() })), Promise.all(this._invokeAll((function (e) { return e.beforeRoot && e.beforeRoot() }))).then((function () { return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")]) })).then((function (t) { var a = { scene: t[0][r.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: r.asset, parser: i, userData: {} }; F(n, a, r), U(a, r), Promise.all(i._invokeAll((function (e) { return e.afterRoot && e.afterRoot(a) }))).then((function () { e(a) })) })).catch(t) }, H.prototype._markDefs = function () { for (var e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || [], r = 0, n = t.length; r < n; r++)for (var a = t[r].joints, o = 0, s = a.length; o < s; o++)e[a[o]].isBone = !0; for (var l = 0, c = e.length; l < c; l++) { var h = e[l]; void 0 !== h.mesh && (this._addNodeRef(this.meshCache, h.mesh), void 0 !== h.skin && (i[h.mesh].isSkinnedMesh = !0)), void 0 !== h.camera && this._addNodeRef(this.cameraCache, h.camera) } }, H.prototype._addNodeRef = function (e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) }, H.prototype._getNodeRef = function (e, t, i) { if (e.refs[t] <= 1) return i; var r = i.clone(); return r.name += "_instance_" + e.uses[t]++, r }, H.prototype._invokeOne = function (e) { var t = Object.values(this.plugins); t.push(this); for (var i = 0; i < t.length; i++) { var r = e(t[i]); if (r) return r } }, H.prototype._invokeAll = function (e) { var t = Object.values(this.plugins); t.unshift(this); for (var i = [], r = 0; r < t.length; r++) { var n = e(t[r]); n && i.push(n) } return i }, H.prototype.getDependency = function (e, t) { var i = e + ":" + t, r = this.cache.get(i); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this.loadNode(t); break; case "mesh": r = this._invokeOne((function (e) { return e.loadMesh && e.loadMesh(t) })); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this._invokeOne((function (e) { return e.loadBufferView && e.loadBufferView(t) })); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this._invokeOne((function (e) { return e.loadMaterial && e.loadMaterial(t) })); break; case "texture": r = this._invokeOne((function (e) { return e.loadTexture && e.loadTexture(t) })); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this.loadAnimation(t); break; case "camera": r = this.loadCamera(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(i, r) } return r }, H.prototype.getDependencies = function (e) { var t = this.cache.get(e); if (!t) { var i = this, r = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(r.map((function (t, r) { return i.getDependency(e, r) }))), this.cache.add(e, t) } return t }, H.prototype.loadBuffer = function (e) { var t = this.json.buffers[e], r = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[i.KHR_BINARY_GLTF].body); var n = this.options; return new Promise((function (e, i) { r.load(N(t.uri, n.path), e, void 0, (function () { i(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) })) })) }, H.prototype.loadBufferView = function (e) { var t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then((function (e) { var i = t.byteLength || 0, r = t.byteOffset || 0; return e.slice(r, r + i) })) }, H.prototype.loadAccessor = function (e) { var t = this, i = this.json, r = this.json.accessors[e]; if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null); var n = []; return void 0 !== r.bufferView ? n.push(this.getDependency("bufferView", r.bufferView)) : n.push(null), void 0 !== r.sparse && (n.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), n.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(n).then((function (e) { var n, a = e[0], o = R[r.type], s = E[r.componentType], l = s.BYTES_PER_ELEMENT, c = l * o, h = r.byteOffset || 0, u = void 0 !== r.bufferView ? i.bufferViews[r.bufferView].byteStride : void 0, d = !0 === r.normalized; if (u && u !== c) { var p = Math.floor(h / u), f = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + p + ":" + r.count, m = t.cache.get(f); m || (m = new InterleavedBuffer(new s(a, p * u, r.count * u / l), u / l), t.cache.add(f, m)), n = new InterleavedBufferAttribute(m, o, h % u / l, d) } else n = new BufferAttribute(null === a ? new s(r.count * o) : new s(a, h, r.count * o), o, d); if (void 0 !== r.sparse) { var g = R.SCALAR, y = E[r.sparse.indices.componentType], v = r.sparse.indices.byteOffset || 0, _ = r.sparse.values.byteOffset || 0, b = new y(e[1], v, r.sparse.count * g), x = new s(e[2], _, r.sparse.count * o); null !== a && (n = new BufferAttribute(n.array.slice(), n.itemSize, n.normalized)); for (var w = 0, S = b.length; w < S; w++) { var M = b[w]; if (n.setX(M, x[w * o]), o >= 2 && n.setY(M, x[w * o + 1]), o >= 3 && n.setZ(M, x[w * o + 2]), o >= 4 && n.setW(M, x[w * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return n })) }, H.prototype.loadTexture = function (e) { var t = this.json, i = this.options, r = t.textures[e], n = t.images[r.source], a = this.textureLoader; if (n.uri) { var o = i.manager.getHandler(n.uri); null !== o && (a = o) } return this.loadTextureImage(e, n, a) }, H.prototype.loadTextureImage = function (e, t, i) { var r = this, n = this.json, a = this.options, o = n.textures[e], s = self.URL || self.webkitURL, l = t.uri, c = !1, h = !0; if ("image/jpeg" === t.mimeType && (h = !1), void 0 !== t.bufferView) l = r.getDependency("bufferView", t.bufferView).then((function (e) { if ("image/png" === t.mimeType) { var i = new DataView(e, 25, 1).getUint8(0, !1); h = 6 === i || 4 === i || 3 === i } c = !0; var r = new Blob([e], { type: t.mimeType }); return l = s.createObjectURL(r) })); else if (void 0 === t.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"); return Promise.resolve(l).then((function (e) { return new Promise((function (t, r) { var n = t; !0 === i.isImageBitmapLoader && (n = function (e) { t(new CanvasTexture(e)) }), i.load(N(e, a.path), n, void 0, r) })) })).then((function (t) { !0 === c && s.revokeObjectURL(l), t.flipY = !1, o.name && (t.name = o.name), h || (t.format = RGBFormat); var i = (n.samplers || {})[o.sampler] || {}; return t.magFilter = C[i.magFilter] || LinearFilter, t.minFilter = C[i.minFilter] || LinearMipmapLinearFilter, t.wrapS = L[i.wrapS] || RepeatWrapping, t.wrapT = L[i.wrapT] || RepeatWrapping, r.associations.set(t, { type: "textures", index: e }), t })) }, H.prototype.assignTexture = function (e, t, r) { var n = this; return this.getDependency("texture", r.index).then((function (a) { if (void 0 === r.texCoord || 0 == r.texCoord || "aoMap" === t && 1 == r.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + r.texCoord + " for texture " + t + " not yet supported."), n.extensions[i.KHR_TEXTURE_TRANSFORM]) { var o = void 0 !== r.extensions ? r.extensions[i.KHR_TEXTURE_TRANSFORM] : void 0; if (o) { var s = n.associations.get(a); a = n.extensions[i.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), n.associations.set(a, s) } } e[t] = a })) }, H.prototype.assignFinalMaterial = function (e) { var t = e.geometry, i = e.material, r = void 0 !== t.attributes.tangent, n = void 0 !== t.attributes.color, a = void 0 === t.attributes.normal, o = !0 === e.isSkinnedMesh, s = Object.keys(t.morphAttributes).length > 0, l = s && void 0 !== t.morphAttributes.normal; if (e.isPoints) { var c = "PointsMaterial:" + i.uuid, h = this.cache.get(c); h || (h = new PointsMaterial, Material$1.prototype.copy.call(h, i), h.color.copy(i.color), h.map = i.map, h.sizeAttenuation = !1, this.cache.add(c, h)), i = h } else if (e.isLine) { c = "LineBasicMaterial:" + i.uuid; var u = this.cache.get(c); u || (u = new LineBasicMaterial, Material$1.prototype.copy.call(u, i), u.color.copy(i.color), this.cache.add(c, u)), i = u } if (r || n || a || o || s) { c = "ClonedMaterial:" + i.uuid + ":"; i.isGLTFSpecularGlossinessMaterial && (c += "specular-glossiness:"), o && (c += "skinning:"), r && (c += "vertex-tangents:"), n && (c += "vertex-colors:"), a && (c += "flat-shading:"), s && (c += "morph-targets:"), l && (c += "morph-normals:"); var d = this.cache.get(c); d || (d = i.clone(), o && (d.skinning = !0), n && (d.vertexColors = !0), a && (d.flatShading = !0), s && (d.morphTargets = !0), l && (d.morphNormals = !0), r && (d.vertexTangents = !0, d.normalScale && (d.normalScale.y *= -1), d.clearcoatNormalScale && (d.clearcoatNormalScale.y *= -1)), this.cache.add(c, d), this.associations.set(d, this.associations.get(i))), i = d } i.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = i }, H.prototype.getMaterialType = function () { return MeshStandardMaterial }, H.prototype.loadMaterial = function (e) { var t, r = this, n = this.json, a = this.extensions, o = n.materials[e], s = {}, l = o.extensions || {}, c = []; if (l[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { var h = a[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; t = h.getMaterialType(), c.push(h.extendParams(s, o, r)) } else if (l[i.KHR_MATERIALS_UNLIT]) { var u = a[i.KHR_MATERIALS_UNLIT]; t = u.getMaterialType(), c.push(u.extendParams(s, o, r)) } else { var d = o.pbrMetallicRoughness || {}; if (s.color = new Color$1(1, 1, 1), s.opacity = 1, Array.isArray(d.baseColorFactor)) { var p = d.baseColorFactor; s.color.fromArray(p), s.opacity = p[3] } void 0 !== d.baseColorTexture && c.push(r.assignTexture(s, "map", d.baseColorTexture)), s.metalness = void 0 !== d.metallicFactor ? d.metallicFactor : 1, s.roughness = void 0 !== d.roughnessFactor ? d.roughnessFactor : 1, void 0 !== d.metallicRoughnessTexture && (c.push(r.assignTexture(s, "metalnessMap", d.metallicRoughnessTexture)), c.push(r.assignTexture(s, "roughnessMap", d.metallicRoughnessTexture))), t = this._invokeOne((function (t) { return t.getMaterialType && t.getMaterialType(e) })), c.push(Promise.all(this._invokeAll((function (t) { return t.extendMaterialParams && t.extendMaterialParams(e, s) })))) } !0 === o.doubleSided && (s.side = DoubleSide); var f = o.alphaMode || I; return f === B ? (s.transparent = !0, s.depthWrite = !1) : (s.transparent = !1, f === k && (s.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : .5)), void 0 !== o.normalTexture && t !== MeshBasicMaterial && (c.push(r.assignTexture(s, "normalMap", o.normalTexture)), s.normalScale = new Vector2(1, -1), void 0 !== o.normalTexture.scale && s.normalScale.set(o.normalTexture.scale, -o.normalTexture.scale)), void 0 !== o.occlusionTexture && t !== MeshBasicMaterial && (c.push(r.assignTexture(s, "aoMap", o.occlusionTexture)), void 0 !== o.occlusionTexture.strength && (s.aoMapIntensity = o.occlusionTexture.strength)), void 0 !== o.emissiveFactor && t !== MeshBasicMaterial && (s.emissive = (new Color$1).fromArray(o.emissiveFactor)), void 0 !== o.emissiveTexture && t !== MeshBasicMaterial && c.push(r.assignTexture(s, "emissiveMap", o.emissiveTexture)), Promise.all(c).then((function () { var n; return n = t === g ? a[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s) : new t(s), o.name && (n.name = o.name), n.map && (n.map.encoding = sRGBEncoding), n.emissiveMap && (n.emissiveMap.encoding = sRGBEncoding), U(n, o), r.associations.set(n, { type: "materials", index: e }), o.extensions && F(a, n, o), n })) }, H.prototype.createUniqueName = function (e) { for (var t = PropertyBinding.sanitizeNodeName(e || ""), i = t, r = 1; this.nodeNamesUsed[i]; ++r)i = t + "_" + r; return this.nodeNamesUsed[i] = !0, i }, H.prototype.loadGeometries = function (e) { var t = this, r = this.extensions, n = this.primitiveCache; function a(e) { return r[i.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (i) { return V(i, e, t) })) } for (var o, s, l = [], c = 0, h = e.length; c < h; c++) { var u, d = e[c], p = (s = void 0, (s = (o = d).extensions && o.extensions[i.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + s.bufferView + ":" + s.indices + ":" + G(s.attributes) : o.indices + ":" + G(o.attributes) + ":" + o.mode), f = n[p]; if (f) l.push(f.promise); else u = d.extensions && d.extensions[i.KHR_DRACO_MESH_COMPRESSION] ? a(d) : V(new BufferGeometry, d, t), n[p] = { primitive: d, promise: u }, l.push(u) } return Promise.all(l) }, H.prototype.loadMesh = function (e) { for (var t, i = this, r = this.json, n = this.extensions, a = r.meshes[e], o = a.primitives, s = [], l = 0, c = o.length; l < c; l++) { var h = void 0 === o[l].material ? (void 0 === (t = this.cache).DefaultMaterial && (t.DefaultMaterial = new MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: FrontSide })), t.DefaultMaterial) : this.getDependency("material", o[l].material); s.push(h) } return s.push(i.loadGeometries(o)), Promise.all(s).then((function (t) { for (var r = t.slice(0, t.length - 1), s = t[t.length - 1], l = [], c = 0, h = s.length; c < h; c++) { var u, d = s[c], p = o[c], f = r[c]; if (p.mode === M || p.mode === T || p.mode === A || void 0 === p.mode) !0 !== (u = !0 === a.isSkinnedMesh ? new SkinnedMesh(d, f) : new Mesh(d, f)).isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), p.mode === T ? u.geometry = j(u.geometry, TriangleStripDrawMode) : p.mode === A && (u.geometry = j(u.geometry, TriangleFanDrawMode)); else if (p.mode === x) u = new LineSegments(d, f); else if (p.mode === S) u = new Line(d, f); else if (p.mode === w) u = new LineLoop(d, f); else { if (p.mode !== b) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p.mode); u = new Points(d, f) } Object.keys(u.geometry.morphAttributes).length > 0 && z(u, a), u.name = i.createUniqueName(a.name || "mesh_" + e), U(u, a), p.extensions && F(n, u, p), i.assignFinalMaterial(u), l.push(u) } if (1 === l.length) return l[0]; var m = new Group; for (c = 0, h = l.length; c < h; c++)m.add(l[c]); return m })) }, H.prototype.loadCamera = function (e) { var t, i = this.json.cameras[e], r = i[i.type]; if (r) return "perspective" === i.type ? t = new PerspectiveCamera(MathUtils.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === i.type && (t = new OrthographicCamera(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), i.name && (t.name = this.createUniqueName(i.name)), U(t, i), Promise.resolve(t); console.warn("THREE.GLTFLoader: Missing camera parameters.") }, H.prototype.loadSkin = function (e) { var t = this.json.skins[e], i = { joints: t.joints }; return void 0 === t.inverseBindMatrices ? Promise.resolve(i) : this.getDependency("accessor", t.inverseBindMatrices).then((function (e) { return i.inverseBindMatrices = e, i })) }, H.prototype.loadAnimation = function (e) { for (var t = this.json.animations[e], i = [], r = [], n = [], a = [], o = [], s = 0, l = t.channels.length; s < l; s++) { var c = t.channels[s], h = t.samplers[c.sampler], u = c.target, d = void 0 !== u.node ? u.node : u.id, p = void 0 !== t.parameters ? t.parameters[h.input] : h.input, f = void 0 !== t.parameters ? t.parameters[h.output] : h.output; i.push(this.getDependency("node", d)), r.push(this.getDependency("accessor", p)), n.push(this.getDependency("accessor", f)), a.push(h), o.push(u) } return Promise.all([Promise.all(i), Promise.all(r), Promise.all(n), Promise.all(a), Promise.all(o)]).then((function (i) { for (var r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], l = [], c = 0, h = r.length; c < h; c++) { var u = r[c], d = n[c], p = a[c], f = o[c], m = s[c]; if (void 0 !== u) { var g; switch (u.updateMatrix(), u.matrixAutoUpdate = !0, P[m.path]) { case P.weights: g = NumberKeyframeTrack; break; case P.rotation: g = QuaternionKeyframeTrack; break; case P.position: case P.scale: default: g = VectorKeyframeTrack }var y = u.name ? u.name : u.uuid, v = void 0 !== f.interpolation ? O[f.interpolation] : InterpolateLinear, b = []; P[m.path] === P.weights ? u.traverse((function (e) { !0 === e.isMesh && e.morphTargetInfluences && b.push(e.name ? e.name : e.uuid) })) : b.push(y); var x = p.array; if (p.normalized) { var w; if (x.constructor === Int8Array) w = 1 / 127; else if (x.constructor === Uint8Array) w = 1 / 255; else if (x.constructor == Int16Array) w = 1 / 32767; else { if (x.constructor !== Uint16Array) throw new Error("THREE.GLTFLoader: Unsupported output accessor component type."); w = 1 / 65535 } for (var S = new Float32Array(x.length), M = 0, T = x.length; M < T; M++)S[M] = x[M] * w; x = S } for (M = 0, T = b.length; M < T; M++) { var A = new g(b[M] + "." + P[m.path], d.array, x, v); "CUBICSPLINE" === f.interpolation && (A.createInterpolant = function (e) { return new _(this.times, this.values, this.getValueSize() / 3, e) }, A.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(A) } } } var E = t.name ? t.name : "animation_" + e; return new AnimationClip(E, void 0, l) })) }, H.prototype.loadNode = function (e) { var t, i = this.json, r = this.extensions, n = this, a = i.nodes[e], o = a.name ? n.createUniqueName(a.name) : ""; return (t = [], void 0 !== a.mesh && t.push(n.getDependency("mesh", a.mesh).then((function (e) { var t = n._getNodeRef(n.meshCache, a.mesh, e); return void 0 !== a.weights && t.traverse((function (e) { if (e.isMesh) for (var t = 0, i = a.weights.length; t < i; t++)e.morphTargetInfluences[t] = a.weights[t] })), t }))), void 0 !== a.camera && t.push(n.getDependency("camera", a.camera).then((function (e) { return n._getNodeRef(n.cameraCache, a.camera, e) }))), n._invokeAll((function (t) { return t.createNodeAttachment && t.createNodeAttachment(e) })).forEach((function (e) { t.push(e) })), Promise.all(t)).then((function (t) { var i; if ((i = !0 === a.isBone ? new Bone : t.length > 1 ? new Group : 1 === t.length ? t[0] : new Object3D) !== t[0]) for (var s = 0, l = t.length; s < l; s++)i.add(t[s]); if (a.name && (i.userData.name = a.name, i.name = o), U(i, a), a.extensions && F(r, i, a), void 0 !== a.matrix) { var c = new Matrix4; c.fromArray(a.matrix), i.applyMatrix4(c) } else void 0 !== a.translation && i.position.fromArray(a.translation), void 0 !== a.rotation && i.quaternion.fromArray(a.rotation), void 0 !== a.scale && i.scale.fromArray(a.scale); return n.associations.set(i, { type: "nodes", index: e }), i })) }, H.prototype.loadScene = function () { function e(t, i, r, n) { var a = r.nodes[t]; return n.getDependency("node", t).then((function (e) { return void 0 === a.skin ? e : n.getDependency("skin", a.skin).then((function (e) { for (var i = [], r = 0, a = (t = e).joints.length; r < a; r++)i.push(n.getDependency("node", t.joints[r])); return Promise.all(i) })).then((function (i) { return e.traverse((function (e) { if (e.isMesh) { for (var r = [], n = [], a = 0, o = i.length; a < o; a++) { var s = i[a]; if (s) { r.push(s); var l = new Matrix4; void 0 !== t.inverseBindMatrices && l.fromArray(t.inverseBindMatrices.array, 16 * a), n.push(l) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[a]) } e.bind(new Skeleton(r, n), e.matrixWorld) } })), e })); var t })).then((function (t) { i.add(t); var o = []; if (a.children) for (var s = a.children, l = 0, c = s.length; l < c; l++) { var h = s[l]; o.push(e(h, t, r, n)) } return Promise.all(o) })) } return function (t) { var i = this.json, r = this.extensions, n = this.json.scenes[t], a = new Group; n.name && (a.name = this.createUniqueName(n.name)), U(a, n), n.extensions && F(r, a, n); for (var o = n.nodes || [], s = [], l = 0, c = o.length; l < c; l++)s.push(e(o[l], a, i, this)); return Promise.all(s).then((function () { return a })) } }(), e }(); class B3DMLoader extends B3DMLoaderBase { constructor(e = DefaultLoadingManager) { super(), this.manager = e } parse(e) { const t = super.parse(e), i = t.glbBytes.slice().buffer; return new Promise(((e, r) => { const n = this.manager, a = this.fetchOptions, o = n.getHandler("path.gltf") || new GLTFLoader(n); "include" === a.credentials && "cors" === a.mode && o.setCrossOrigin("use-credentials"), "credentials" in a && o.setWithCredentials("include" === a.credentials), a.headers && o.setRequestHeader(a.headers); let s = this.workingPath; /[\\/]$/.test(s) || (s += "/"), o.parse(i, s, (i => { const { batchTable: r, featureTable: n } = t, { scene: a } = i, o = n.getData("RTC_CENTER"); o && (a.position.x += o[0], a.position.y += o[1], a.position.z += o[2]), i.batchTable = r, i.featureTable = n, a.batchTable = r, a.featureTable = n, e(i) }), r) })) } } class PNTSLoaderBase { constructor() { this.fetchOptions = {} } load(e) { return fetch(e, this.fetchOptions).then((t => { if (!t.ok) throw new Error(`Failed to load file "${e}" with status ${t.status} : ${t.statusText}`); return t.arrayBuffer() })).then((e => this.parse(e))) } parse(e) { const t = new DataView(e), i = String.fromCharCode(t.getUint8(0)) + String.fromCharCode(t.getUint8(1)) + String.fromCharCode(t.getUint8(2)) + String.fromCharCode(t.getUint8(3)); console.assert("pnts" === i); const r = t.getUint32(4, !0); console.assert(1 === r); const n = t.getUint32(8, !0); console.assert(n === e.byteLength); const a = t.getUint32(12, !0), o = t.getUint32(16, !0), s = t.getUint32(20, !0), l = t.getUint32(24, !0), c = e.slice(28, 28 + a + o), h = new FeatureTable(c, 0, a, o), u = 28 + a + o, d = e.slice(u, u + s + l), p = new BatchTable(d, h.getData("BATCH_LENGTH") || h.getData("POINTS_LENGTH"), 0, s, l); return { version: r, featureTable: h, batchTable: p } } } class PNTSLoader extends PNTSLoaderBase { constructor(e = DefaultLoadingManager) { super(), this.manager = e } parse(e) { const t = super.parse(e), { featureTable: i } = t, r = i.getData("POINTS_LENGTH"), n = i.getData("POSITION", r, "FLOAT", "VEC3"), a = i.getData("RGB", r, "UNSIGNED_BYTE", "VEC3");["RTC_CENTER", "QUANTIZED_VOLUME_OFFSET", "QUANTIZED_VOLUME_SCALE", "CONSTANT_RGBA", "BATCH_LENGTH", "POSITION_QUANTIZED", "RGBA", "RGB565", "NORMAL", "NORMAL_OCT16P"].forEach((e => { e in i.header && console.warn(`PNTSLoader: Unsupported FeatureTable feature "${e}" detected.`) })); const o = new BufferGeometry; o.setAttribute("position", new BufferAttribute(n, 3, !1)); const s = new PointsMaterial; s.size = 2, s.sizeAttenuation = !1, null !== a && (o.setAttribute("color", new BufferAttribute(a, 3, !0)), s.vertexColors = !0); const l = new Points(o, s); t.scene = l, t.scene.featureTable = i; const c = i.getData("RTC_CENTER"); return c && (t.scene.position.x += c[0], t.scene.position.y += c[1], t.scene.position.z += c[2]), t } } class I3DMLoaderBase { constructor() { this.fetchOptions = {}, this.workingPath = "" } resolveExternalURL(e) { return /^[^\\/]/.test(e) ? this.workingPath + "/" + e : e } load(e) { return fetch(e, this.fetchOptions).then((t => { if (!t.ok) throw new Error(`Failed to load file "${e}" with status ${t.status} : ${t.statusText}`); return t.arrayBuffer() })).then((t => { if ("" === this.workingPath) { const t = e.split(/\\\//g); t.pop(), this.workingPath = t.join("/") } return this.parse(t) })) } parse(e) { const t = new DataView(e), i = String.fromCharCode(t.getUint8(0)) + String.fromCharCode(t.getUint8(1)) + String.fromCharCode(t.getUint8(2)) + String.fromCharCode(t.getUint8(3)); console.assert("i3dm" === i); const r = t.getUint32(4, !0); console.assert(1 === r); const n = t.getUint32(8, !0); console.assert(n === e.byteLength); const a = t.getUint32(12, !0), o = t.getUint32(16, !0), s = t.getUint32(20, !0), l = t.getUint32(24, !0), c = t.getUint32(28, !0), h = e.slice(32, 32 + a + o), u = new FeatureTable(h, 0, a, o), d = 32 + a + o, p = e.slice(d, d + s + l), f = new BatchTable(p, u.getData("INSTANCES_LENGTH"), 0, s, l), m = d + s + l, g = new Uint8Array(e, m, n - m); let y = null, v = null; if (c) y = g, v = Promise.resolve(); else { const e = this.resolveExternalURL(arrayToString(g)); v = fetch(e, this.fetchOptions).then((t => { if (!t.ok) throw new Error(`I3DMLoaderBase : Failed to load file "${e}" with status ${t.status} : ${t.statusText}`); return t.arrayBuffer() })).then((e => { y = new Uint8Array(e) })) } return v.then((() => ({ version: r, featureTable: u, batchTable: f, glbBytes: y }))) } } const tempFwd = new Vector3, tempUp = new Vector3, tempRight = new Vector3, tempPos = new Vector3, tempQuat = new Quaternion, tempSca = new Vector3, tempMat$2 = new Matrix4; class I3DMLoader extends I3DMLoaderBase { constructor(e = DefaultLoadingManager) { super(), this.manager = e } resolveExternalURL(e) { return this.manager.resolveURL(super.resolveExternalURL(e)) } parse(e) { return super.parse(e).then((e => { const { featureTable: t, batchTable: i } = e, r = e.glbBytes.slice().buffer; return new Promise(((e, n) => { const a = this.fetchOptions, o = this.manager, s = o.getHandler("path.gltf") || new GLTFLoader(o); "include" === a.credentials && "cors" === a.mode && s.setCrossOrigin("use-credentials"), "credentials" in a && s.setWithCredentials("include" === a.credentials), a.headers && s.setRequestHeader(a.headers); let l = this.workingPath; /[\\/]$/.test(l) || (l += "/"), s.parse(r, l, (r => { const n = t.getData("INSTANCES_LENGTH"), a = t.getData("POSITION", n, "FLOAT", "VEC3"), o = t.getData("NORMAL_UP", n, "FLOAT", "VEC3"), s = t.getData("NORMAL_RIGHT", n, "FLOAT", "VEC3"), l = t.getData("SCALE_NON_UNIFORM", n, "FLOAT", "VEC3"), c = t.getData("SCALE", n, "FLOAT", "SCALAR");["RTC_CENTER", "QUANTIZED_VOLUME_OFFSET", "QUANTIZED_VOLUME_SCALE", "EAST_NORTH_UP", "POSITION_QUANTIZED", "NORMAL_UP_OCT32P", "NORMAL_RIGHT_OCT32P"].forEach((e => { e in t.header && console.warn(`I3DMLoader: Unsupported FeatureTable feature "${e}" detected.`) })); const h = new Map, u = []; r.scene.traverse((e => { if (e.isMesh) { const { geometry: t, material: i } = e, r = new InstancedMesh(t, i, n); r.position.copy(e.position), r.rotation.copy(e.rotation), r.scale.copy(e.scale), u.push(r), h.set(e, r) } })); const d = new Vector3; for (let e = 0; e < n; e++)d.x += a[3 * e + 0] / n, d.y += a[3 * e + 1] / n, d.z += a[3 * e + 2] / n; h.forEach(((e, t) => { const i = t.parent; i && (i.remove(t), i.add(e), e.updateMatrixWorld(), e.position.copy(d).applyMatrix4(e.matrixWorld)) })); for (let e = 0; e < n; e++) { tempPos.set(a[3 * e + 0] - d.x, a[3 * e + 1] - d.y, a[3 * e + 2] - d.z), o ? (tempUp.set(o[3 * e + 0], o[3 * e + 1], o[3 * e + 2]), tempRight.set(s[3 * e + 0], s[3 * e + 1], s[3 * e + 2]), tempFwd.crossVectors(tempRight, tempUp).normalize(), tempMat$2.makeBasis(tempRight, tempUp, tempFwd), tempQuat.setFromRotationMatrix(tempMat$2)) : tempQuat.set(0, 0, 0, 1), c ? tempSca.setScalar(c[e]) : l ? tempSca.set(l[3 * e + 0], l[3 * e + 1], l[3 * e + 2]) : tempSca.set(1, 1, 1), tempMat$2.compose(tempPos, tempQuat, tempSca); for (let t = 0, i = u.length; t < i; t++) { u[t].setMatrixAt(e, tempMat$2) } } r.batchTable = i, r.featureTable = t, r.scene.batchTable = i, r.scene.featureTable = t, e(r) }), n) })) })) } } class CMPTLoaderBase { constructor() { this.fetchOptions = {}, this.workingPath = "" } load(e) { return fetch(e, this.fetchOptions).then((t => { if (!t.ok) throw new Error(`Failed to load file "${e}" with status ${t.status} : ${t.statusText}`); return t.arrayBuffer() })).then((t => { if ("" === this.workingPath) { const t = e.split(/\\\//g); t.pop(), this.workingPath = t.join("/") } return this.parse(t) })) } parse(e) { const t = new DataView(e), i = String.fromCharCode(t.getUint8(0)) + String.fromCharCode(t.getUint8(1)) + String.fromCharCode(t.getUint8(2)) + String.fromCharCode(t.getUint8(3)); console.assert("cmpt" === i, 'CMPTLoader: The magic bytes equal "cmpt".'); const r = t.getUint32(4, !0); console.assert(1 === r, 'CMPTLoader: The version listed in the header is "1".'); const n = t.getUint32(8, !0); console.assert(n === e.byteLength, "CMPTLoader: The contents buffer length listed in the header matches the file."); const a = t.getUint32(12, !0), o = []; let s = 16; for (let t = 0; t < a; t++) { const t = new DataView(e, s, 12), i = String.fromCharCode(t.getUint8(0)) + String.fromCharCode(t.getUint8(1)) + String.fromCharCode(t.getUint8(2)) + String.fromCharCode(t.getUint8(3)), r = t.getUint32(4, !0), n = t.getUint32(8, !0), a = new Uint8Array(e, s, n); o.push({ type: i, buffer: a, version: r }), s += n } return { version: r, tiles: o } } } class CMPTLoader extends CMPTLoaderBase { constructor(e = DefaultLoadingManager) { super(), this.manager = e } parse(e) { const t = super.parse(e), i = this.manager, r = []; for (const e in t.tiles) { const { type: n, buffer: a } = t.tiles[e]; switch (n) { case "b3dm": { const e = a.slice(), t = new B3DMLoader(i); t.workingPath = this.workingPath, t.fetchOptions = this.fetchOptions; const n = t.parse(e.buffer); r.push(n); break } case "pnts": { const e = a.slice(), t = new PNTSLoader(i).parse(e.buffer), n = Promise.resolve(t); r.push(n); break } case "i3dm": { const e = a.slice(), t = new I3DMLoader(i); t.workingPath = this.workingPath, t.fetchOptions = this.fetchOptions; const n = t.parse(e.buffer); r.push(n); break } } } return Promise.all(r).then((e => { const t = new Group; return e.forEach((e => { t.add(e.scene) })), { tiles: e, scene: t } })) } } const tempMat$1 = new Matrix4; class TilesGroup extends Group { constructor(e) { super(), this.name = "TilesRenderer.TilesGroup", this.tilesRenderer = e } raycast(e, t) { this.tilesRenderer.optimizeRaycast && this.tilesRenderer.raycast(e, t) } updateMatrixWorld(e) { if (this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldNeedsUpdate || e) { null === this.parent ? tempMat$1.copy(this.matrix) : tempMat$1.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1; const e = tempMat$1.elements, t = this.matrixWorld.elements; let i = !1; for (let r = 0; r < 16; r++) { const n = e[r], a = t[r]; if (Math.abs(n - a) > Number.EPSILON) { i = !0; break } } if (i) { this.matrixWorld.copy(tempMat$1); const e = this.children; for (let t = 0, i = e.length; t < i; t++)e[t].updateMatrixWorld() } } } } const _sphere = new Sphere, _mat = new Matrix4, _vec = new Vector3, _vec2 = new Vector3, _ray = new Ray, _hitArray = []; function distanceSort(e, t) { return e.distance - t.distance } function intersectTileScene(e, t, i) { e.traverse((e => { Object.getPrototypeOf(e).raycast.call(e, t, i) })) } function raycastTraverseFirstHit(e, t, i, r) { if (i.has(e)) { if (intersectTileScene(e.cached.scene, r, _hitArray), _hitArray.length > 0) { _hitArray.length > 1 && _hitArray.sort(distanceSort); const e = _hitArray[0]; return _hitArray.length = 0, e } return null } const n = [], a = e.children; for (let e = 0, i = a.length; e < i; e++) { const i = a[e], o = i.cached, s = t.matrixWorld; _mat.copy(s); const l = o.sphere; if (l && (_sphere.copy(l), _sphere.applyMatrix4(_mat), !r.ray.intersectsSphere(_sphere))) continue; const c = o.box, h = o.boxTransform; if (c) { if (_mat.multiply(h).invert(), _ray.copy(r.ray), _ray.applyMatrix4(_mat), !_ray.intersectBox(c, _vec)) continue; { let e; _vec2.setFromMatrixScale(_mat), e = _vec2.x, Math.abs(Math.max(_vec2.x - _vec2.y, _vec2.x - _vec2.z)) > 1e-6 && console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when raycasting."); let t = { distance: 1 / 0, tile: null }; n.push(t), t.distance = _vec.distanceToSquared(_ray.origin) * e * e, t.tile = i } } } n.sort(distanceSort); let o = 1 / 0, s = null; for (let e = 0, a = n.length; e < a; e++) { const a = n[e]; if (a.distance > o) break; { const e = a.tile, n = e.cached.scene; let l = null; if (i.has(e) ? (intersectTileScene(n, r, _hitArray), _hitArray.length > 0 && (_hitArray.length > 1 && _hitArray.sort(distanceSort), l = _hitArray[0])) : l = raycastTraverseFirstHit(e, t, i, r), l) { const e = l.distance * l.distance; e < o && (o = e, s = l), _hitArray.length = 0 } } } return s } function raycastTraverse(e, t, i, r, n) { const a = e.cached, o = t.matrixWorld; _mat.copy(o); const s = a.sphere; if (s && (_sphere.copy(s), _sphere.applyMatrix4(_mat), !r.ray.intersectsSphere(_sphere))) return; const l = a.box, c = a.boxTransform; if (l && (_mat.multiply(c).invert(), _ray.copy(r.ray).applyMatrix4(_mat), !_ray.intersectsBox(l))) return; const h = a.scene; if (i.has(e)) return void intersectTileScene(h, r, n); const u = e.children; for (let e = 0, a = u.length; e < a; e++)raycastTraverse(u[e], t, i, r, n) } let _context = { loaders: {}, eventHandlerStore: {}, pgl: {} }; const C = 20037508.34, C1$1 = C; class CoordinateConvertHelper { constructor() { let e = { x: 0, y: 0, z: 0 }, t = { scaleX: 1, scaleY: 1, scaleZ: 1 }, i = { x: 0, y: 0, z: 0 }, r = "surface"; this.setDatumShiftModel = n => { e.x = n.lon, e.y = n.lat, e.z = n.alt, t.scaleX = n.scaleX, t.scaleY = n.scaleY, t.scaleZ = n.scaleZ, r = n.type || r, "ecef" === r.toLowerCase() && n.offset && (e.x = n.offset.x, e.y = n.offset.y, e.z = n.offset.z), "ecef" === r.toLowerCase() && n.rotation && (i.x = n.rotation.x, i.y = n.rotation.y, i.z = n.rotation.z) }, this.convertTransform = (n, a) => { var o = new Matrix4; switch (o.makeScale(t.scaleX, t.scaleY, t.scaleZ), null == a && (null == r && (r = ""), a = r), a.toLowerCase()) { case "surface": var s = this.CartesianFrom(n), l = this.GetWorldToLocal({ x: e.x, y: e.y, z: e.z }); s = this.preMult(s, l); let r = new Vector3(s.x, s.z, -s.y); return r.applyMatrix4(o), r; case "ecef": s = this.CartesianFrom(n); s = this.preMult(s, o); const a = new Vector3(s.x, s.z, -s.y), d = new Matrix4; return d.makeRotationFromEuler(new Euler(MathUtils.degToRad(i.x), MathUtils.degToRad(i.y), MathUtils.degToRad(i.z))), a.applyMatrix4(d), a.x += e.x, a.y += e.y, a.z += e.z, a; case "planarglobal": return this.preMult(n, o); case "planarlocal": return (l = new Matrix4).makeTranslation(-e.x, -e.y, -e.z), n = this.preMult(n, l), n = this.preMult(n, o), new Vector3(n.x, n.z, -n.y); case "mercator": var c = n.x * C / 180, h = Math.log(Math.tan((90 + n.y) * Math.PI / 360)) / (Math.PI / 180); h = h * C1$1 / 180; var u = n.z + e.z; return c += e.x, h -= e.y, new Vector3(c * t.scaleX, u * t.scaleY, -h * t.scaleZ); default: return { x: n.x || 0, y: n.y || 0, z: n.z || 0 } } }, this.getCartesianFrom = e => this.CartesianFrom(e), this.XYZToLLA = (n, a) => { var o = new Matrix4; o.makeScale(t.scaleX, t.scaleY, t.scaleZ); var s = new Matrix4; switch (s.copy(o).invert(), null == a && (a = r), a) { case "surface": var l = this.GetWorldToLocal({ x: e.x, y: e.y, z: e.z }), c = new Matrix4; c.copy(l).invert(); let r = new Vector3(n.x, -n.z, n.y); return r.applyMatrix4(s), h = this.preMult(r, c), this.fromCartesian(h); case "ecef": const a = new Vector3(n.x, -n.z, n.y); a.x -= e.x, a.y -= e.y, a.z -= e.z; const o = new Matrix4; o.makeRotationFromEuler(new Euler(MathUtils.degToRad(i.x), MathUtils.degToRad(i.y), MathUtils.degToRad(i.z))), o.invert(), a.applyMatrix4(o); var h = this.preMult(a, s); return this.fromCartesian(h); case "planarglobal": return h = this.preMult(n, s); case "planarlocal": return (l = new Matrix4).makeTranslation(e.x, e.y, e.z), l.multiply(s), this.preMult({ x: n.x, y: -n.z, z: n.y }, l); case "mercator": n.x = n.x / t.scaleX - e.x, n.z = 0 - n.z / t.scaleZ, n.z = n.z + e.y; var u = n.x / C * 180, d = n.z / C1$1 * 180; d = 180 / Math.PI * (2 * Math.atan(Math.exp(d * Math.PI / 180)) - .5 * Math.PI); var p = n.y / t.scaleY - e.z; return new Vector3(u, d, p); default: return { x: n.x, y: n.y, z: n.z } } }, this.CartesianFrom = e => { var t = e.x * Math.PI / 180, i = e.y * Math.PI / 180, r = Math.sqrt(Math.pow(CoordinateConvertHelper.EARTH_RADIUS_EQUATOR, 2) - Math.pow(CoordinateConvertHelper.EARTH_RADIUS_POLAR, 2)) / CoordinateConvertHelper.EARTH_RADIUS_EQUATOR, n = Math.sqrt(1 - Math.pow(r, 2) * Math.pow(Math.sin(i), 2)), a = CoordinateConvertHelper.EARTH_RADIUS_EQUATOR / n, o = e.z, s = (a + o) * Math.cos(i) * Math.cos(t), l = (a + o) * Math.cos(i) * Math.sin(t), c = (a * (1 - Math.pow(r, 2)) + o) * Math.sin(i); return new Vector3(s, l, c) }, this.fromCartesian = e => { var t = e.x, i = e.y, r = e.z, n = CoordinateConvertHelper.EARTH_RADIUS_EQUATOR, a = CoordinateConvertHelper.EARTH_RADIUS_POLAR, o = (n - a) / n, s = 2 * o - o * o, l = Math.sqrt(t * t + i * i), c = Math.atan2(r * n, l * a), h = (n * n - a * a) / (a * a), u = Math.sin(c), d = Math.cos(c), p = Math.atan((r + h * a * u * u * u) / (l - s * n * d * d * d)), f = Math.atan2(i, t), m = Math.sin(p), g = n / Math.sqrt(1 - s * m * m), y = l / Math.cos(p) - g, v = 180 / Math.PI; return new Vector3(f * v, p * v, y) }, this.GetWorldToLocal = e => { var t = this.CartesianFrom(e), i = e.x * Math.PI / 180, r = e.y * Math.PI / 180, n = Math.cos(i) * Math.cos(r), a = Math.sin(i) * Math.cos(r), o = Math.sin(r), s = new Vector3(n, a, o), l = new Vector3(-Math.sin(i), Math.cos(i), 0), c = new Vector3(s.x, s.y, s.z).cross(l), h = new Matrix4; h.set(l.x, l.y, l.z, 1, c.x, c.y, c.z, 1, s.x, s.y, s.z, 1, 0, 0, 0, 1); var u = new Matrix4; return u.setPosition(-t.x, -t.y, -t.z), h.multiply(u) }, this.preMult = (e, t) => { var i = t.elements; return new Vector3(i[0] * e.x + i[4] * e.y + i[8] * e.z + 1 * i[12], i[1] * e.x + i[5] * e.y + i[9] * e.z + 1 * i[13], i[2] * e.x + i[6] * e.y + i[10] * e.z + 1 * i[14]) } } } function globals(e) { e("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), e("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), e("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), e.WGS84 = e["EPSG:4326"], e["EPSG:3785"] = e["EPSG:3857"], e.GOOGLE = e["EPSG:3857"], e["EPSG:900913"] = e["EPSG:3857"], e["EPSG:102113"] = e["EPSG:3857"] } CoordinateConvertHelper.EARTH_RADIUS_EQUATOR = 6378137, CoordinateConvertHelper.EARTH_RADIUS_POLAR = 6356752.31414; var PJD_3PARAM = 1, PJD_7PARAM = 2, PJD_GRIDSHIFT = 3, PJD_WGS84 = 4, PJD_NODATUM = 5, SRS_WGS84_SEMIMAJOR = 6378137, SRS_WGS84_SEMIMINOR = 6356752.314, SRS_WGS84_ESQUARED = .0066943799901413165, SEC_TO_RAD = 484813681109536e-20, HALF_PI = Math.PI / 2, SIXTH = .16666666666666666, RA4 = .04722222222222222, RA6 = .022156084656084655, EPSLN = 1e-10, D2R$1 = .017453292519943295, R2D = 57.29577951308232, FORTPI = Math.PI / 4, TWO_PI = 2 * Math.PI, SPI = 3.14159265359, exports$2 = { greenwich: 0, lisbon: -9.131906111111, paris: 2.337229166667, bogota: -74.080916666667, madrid: -3.687938888889, rome: 12.452333333333, bern: 7.439583333333, jakarta: 106.807719444444, ferro: -17.666666666667, brussels: 4.367975, stockholm: 18.058277777778, athens: 23.7163375, oslo: 10.722916666667 }, units = { ft: { to_meter: .3048 }, "us-ft": { to_meter: 1200 / 3937 } }, ignoredChar = /[\s_\-\/\(\)]/g; function match(e, t) { if (e[t]) return e[t]; for (var i, r = Object.keys(e), n = t.toLowerCase().replace(ignoredChar, ""), a = -1; ++a < r.length;)if ((i = r[a]).toLowerCase().replace(ignoredChar, "") === n) return e[i] } function projStr(e) { var t, i, r, n = {}, a = e.split("+").map((function (e) { return e.trim() })).filter((function (e) { return e })).reduce((function (e, t) { var i = t.split("="); return i.push(!0), e[i[0].toLowerCase()] = i[1], e }), {}), o = { proj: "projName", datum: "datumCode", rf: function (e) { n.rf = parseFloat(e) }, lat_0: function (e) { n.lat0 = e * D2R$1 }, lat_1: function (e) { n.lat1 = e * D2R$1 }, lat_2: function (e) { n.lat2 = e * D2R$1 }, lat_ts: function (e) { n.lat_ts = e * D2R$1 }, lon_0: function (e) { n.long0 = e * D2R$1 }, lon_1: function (e) { n.long1 = e * D2R$1 }, lon_2: function (e) { n.long2 = e * D2R$1 }, alpha: function (e) { n.alpha = parseFloat(e) * D2R$1 }, gamma: function (e) { n.rectified_grid_angle = parseFloat(e) }, lonc: function (e) { n.longc = e * D2R$1 }, x_0: function (e) { n.x0 = parseFloat(e) }, y_0: function (e) { n.y0 = parseFloat(e) }, k_0: function (e) { n.k0 = parseFloat(e) }, k: function (e) { n.k0 = parseFloat(e) }, a: function (e) { n.a = parseFloat(e) }, b: function (e) { n.b = parseFloat(e) }, r_a: function () { n.R_A = !0 }, zone: function (e) { n.zone = parseInt(e, 10) }, south: function () { n.utmSouth = !0 }, towgs84: function (e) { n.datum_params = e.split(",").map((function (e) { return parseFloat(e) })) }, to_meter: function (e) { n.to_meter = parseFloat(e) }, units: function (e) { n.units = e; var t = match(units, e); t && (n.to_meter = t.to_meter) }, from_greenwich: function (e) { n.from_greenwich = e * D2R$1 }, pm: function (e) { var t = match(exports$2, e); n.from_greenwich = (t || parseFloat(e)) * D2R$1 }, nadgrids: function (e) { "@null" === e ? n.datumCode = "none" : n.nadgrids = e }, axis: function (e) { var t = "ewnsud"; 3 === e.length && -1 !== t.indexOf(e.substr(0, 1)) && -1 !== t.indexOf(e.substr(1, 1)) && -1 !== t.indexOf(e.substr(2, 1)) && (n.axis = e) }, approx: function () { n.approx = !0 } }; for (t in a) i = a[t], t in o ? "function" == typeof (r = o[t]) ? r(i) : n[r] = i : n[t] = i; return "string" == typeof n.datumCode && "WGS84" !== n.datumCode && (n.datumCode = n.datumCode.toLowerCase()), n } var NEUTRAL = 1, KEYWORD = 2, NUMBER = 3, QUOTED = 4, AFTERQUOTE = 5, ENDED = -1, whitespace = /\s/, latin = /[A-Za-z]/, keyword = /[A-Za-z84]/, endThings = /[,\]]/, digets = /[\d\.E\-\+]/; function Parser(e) { if ("string" != typeof e) throw new Error("not a string"); this.text = e.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = NEUTRAL } function parseString(e) { return new Parser(e).output() } function mapit(e, t, i) { Array.isArray(t) && (i.unshift(t), t = null); var r = t ? {} : e, n = i.reduce((function (e, t) { return sExpr(t, e), e }), r); t && (e[t] = n) } function sExpr(e, t) { if (Array.isArray(e)) { var i = e.shift(); if ("PARAMETER" === i && (i = e.shift()), 1 === e.length) return Array.isArray(e[0]) ? (t[i] = {}, void sExpr(e[0], t[i])) : void (t[i] = e[0]); if (e.length) if ("TOWGS84" !== i) { if ("AXIS" === i) return i in t || (t[i] = []), void t[i].push(e); var r; switch (Array.isArray(i) || (t[i] = {}), i) { case "UNIT": case "PRIMEM": case "VERT_DATUM": return t[i] = { name: e[0].toLowerCase(), convert: e[1] }, void (3 === e.length && sExpr(e[2], t[i])); case "SPHEROID": case "ELLIPSOID": return t[i] = { name: e[0], a: e[1], rf: e[2] }, void (4 === e.length && sExpr(e[3], t[i])); case "PROJECTEDCRS": case "PROJCRS": case "GEOGCS": case "GEOCCS": case "PROJCS": case "LOCAL_CS": case "GEODCRS": case "GEODETICCRS": case "GEODETICDATUM": case "EDATUM": case "ENGINEERINGDATUM": case "VERT_CS": case "VERTCRS": case "VERTICALCRS": case "COMPD_CS": case "COMPOUNDCRS": case "ENGINEERINGCRS": case "ENGCRS": case "FITTED_CS": case "LOCAL_DATUM": case "DATUM": return e[0] = ["name", e[0]], void mapit(t, i, e); default: for (r = -1; ++r < e.length;)if (!Array.isArray(e[r])) return sExpr(e, t[i]); return mapit(t, i, e) } } else t[i] = e; else t[i] = !0 } else t[e] = !0 } Parser.prototype.readCharicter = function () { var e = this.text[this.place++]; if (this.state !== QUOTED) for (; whitespace.test(e);) { if (this.place >= this.text.length) return; e = this.text[this.place++] } switch (this.state) { case NEUTRAL: return this.neutral(e); case KEYWORD: return this.keyword(e); case QUOTED: return this.quoted(e); case AFTERQUOTE: return this.afterquote(e); case NUMBER: return this.number(e); case ENDED: return } }, Parser.prototype.afterquote = function (e) { if ('"' === e) return this.word += '"', void (this.state = QUOTED); if (endThings.test(e)) return this.word = this.word.trim(), void this.afterItem(e); throw new Error("havn't handled \"" + e + '" in afterquote yet, index ' + this.place) }, Parser.prototype.afterItem = function (e) { return "," === e ? (null !== this.word && this.currentObject.push(this.word), this.word = null, void (this.state = NEUTRAL)) : "]" === e ? (this.level--, null !== this.word && (this.currentObject.push(this.word), this.word = null), this.state = NEUTRAL, this.currentObject = this.stack.pop(), void (this.currentObject || (this.state = ENDED))) : void 0 }, Parser.prototype.number = function (e) { if (!digets.test(e)) { if (endThings.test(e)) return this.word = parseFloat(this.word), void this.afterItem(e); throw new Error("havn't handled \"" + e + '" in number yet, index ' + this.place) } this.word += e }, Parser.prototype.quoted = function (e) { '"' !== e ? this.word += e : this.state = AFTERQUOTE }, Parser.prototype.keyword = function (e) { if (keyword.test(e)) this.word += e; else { if ("[" === e) { var t = []; return t.push(this.word), this.level++, null === this.root ? this.root = t : this.currentObject.push(t), this.stack.push(this.currentObject), this.currentObject = t, void (this.state = NEUTRAL) } if (!endThings.test(e)) throw new Error("havn't handled \"" + e + '" in keyword yet, index ' + this.place); this.afterItem(e) } }, Parser.prototype.neutral = function (e) { if (latin.test(e)) return this.word = e, void (this.state = KEYWORD); if ('"' === e) return this.word = "", void (this.state = QUOTED); if (digets.test(e)) return this.word = e, void (this.state = NUMBER); if (!endThings.test(e)) throw new Error("havn't handled \"" + e + '" in neutral yet, index ' + this.place); this.afterItem(e) }, Parser.prototype.output = function () { for (; this.place < this.text.length;)this.readCharicter(); if (this.state === ENDED) return this.root; throw new Error('unable to parse string "' + this.text + '". State is ' + this.state) }; var D2R = .017453292519943295; function rename(e, t) { var i = t[0], r = t[1]; !(i in e) && r in e && (e[i] = e[r], 3 === t.length && (e[i] = t[2](e[i]))) } function d2r$1(e) { return e * D2R } function cleanWKT(e) { if ("GEOGCS" === e.type ? e.projName = "longlat" : "LOCAL_CS" === e.type ? (e.projName = "identity", e.local = !0) : "object" == typeof e.PROJECTION ? e.projName = Object.keys(e.PROJECTION)[0] : e.projName = e.PROJECTION, e.AXIS) { for (var t = "", i = 0, r = e.AXIS.length; i < r; ++i) { var n = [e.AXIS[i][0].toLowerCase(), e.AXIS[i][1].toLowerCase()]; -1 !== n[0].indexOf("north") || ("y" === n[0] || "lat" === n[0]) && "north" === n[1] ? t += "n" : -1 !== n[0].indexOf("south") || ("y" === n[0] || "lat" === n[0]) && "south" === n[1] ? t += "s" : -1 !== n[0].indexOf("east") || ("x" === n[0] || "lon" === n[0]) && "east" === n[1] ? t += "e" : -1 === n[0].indexOf("west") && ("x" !== n[0] && "lon" !== n[0] || "west" !== n[1]) || (t += "w") } 2 === t.length && (t += "u"), 3 === t.length && (e.axis = t) } e.UNIT && (e.units = e.UNIT.name.toLowerCase(), "metre" === e.units && (e.units = "meter"), e.UNIT.convert && ("GEOGCS" === e.type ? e.DATUM && e.DATUM.SPHEROID && (e.to_meter = e.UNIT.convert * e.DATUM.SPHEROID.a) : e.to_meter = e.UNIT.convert)); var a = e.GEOGCS; function o(t) { return t * (e.to_meter || 1) } "GEOGCS" === e.type && (a = e), a && (a.DATUM ? e.datumCode = a.DATUM.name.toLowerCase() : e.datumCode = a.name.toLowerCase(), "d_" === e.datumCode.slice(0, 2) && (e.datumCode = e.datumCode.slice(2)), "new_zealand_geodetic_datum_1949" !== e.datumCode && "new_zealand_1949" !== e.datumCode || (e.datumCode = "nzgd49"), "wgs_1984" !== e.datumCode && "world_geodetic_system_1984" !== e.datumCode || ("Mercator_Auxiliary_Sphere" === e.PROJECTION && (e.sphere = !0), e.datumCode = "wgs84"), "_ferro" === e.datumCode.slice(-6) && (e.datumCode = e.datumCode.slice(0, -6)), "_jakarta" === e.datumCode.slice(-8) && (e.datumCode = e.datumCode.slice(0, -8)), ~e.datumCode.indexOf("belge") && (e.datumCode = "rnb72"), a.DATUM && a.DATUM.SPHEROID && (e.ellps = a.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), "international" === e.ellps.toLowerCase().slice(0, 13) && (e.ellps = "intl"), e.a = a.DATUM.SPHEROID.a, e.rf = parseFloat(a.DATUM.SPHEROID.rf, 10)), a.DATUM && a.DATUM.TOWGS84 && (e.datum_params = a.DATUM.TOWGS84), ~e.datumCode.indexOf("osgb_1936") && (e.datumCode = "osgb36"), ~e.datumCode.indexOf("osni_1952") && (e.datumCode = "osni52"), (~e.datumCode.indexOf("tm65") || ~e.datumCode.indexOf("geodetic_datum_of_1965")) && (e.datumCode = "ire65"), "ch1903+" === e.datumCode && (e.datumCode = "ch1903"), ~e.datumCode.indexOf("israel") && (e.datumCode = "isr93")), e.b && !isFinite(e.b) && (e.b = e.a);[["standard_parallel_1", "Standard_Parallel_1"], ["standard_parallel_1", "Latitude of 1st standard parallel"], ["standard_parallel_2", "Standard_Parallel_2"], ["standard_parallel_2", "Latitude of 2nd standard parallel"], ["false_easting", "False_Easting"], ["false_easting", "False easting"], ["false-easting", "Easting at false origin"], ["false_northing", "False_Northing"], ["false_northing", "False northing"], ["false_northing", "Northing at false origin"], ["central_meridian", "Central_Meridian"], ["central_meridian", "Longitude of natural origin"], ["central_meridian", "Longitude of false origin"], ["latitude_of_origin", "Latitude_Of_Origin"], ["latitude_of_origin", "Central_Parallel"], ["latitude_of_origin", "Latitude of natural origin"], ["latitude_of_origin", "Latitude of false origin"], ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"], ["latitude_of_center", "Latitude_Of_Center"], ["latitude_of_center", "Latitude_of_center"], ["lat0", "latitude_of_center", d2r$1], ["longitude_of_center", "Longitude_Of_Center"], ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", d2r$1], ["x0", "false_easting", o], ["y0", "false_northing", o], ["long0", "central_meridian", d2r$1], ["lat0", "latitude_of_origin", d2r$1], ["lat0", "standard_parallel_1", d2r$1], ["lat1", "standard_parallel_1", d2r$1], ["lat2", "standard_parallel_2", d2r$1], ["azimuth", "Azimuth"], ["alpha", "azimuth", d2r$1], ["srsCode", "name"]].forEach((function (t) { return rename(e, t) })), e.long0 || !e.longc || "Albers_Conic_Equal_Area" !== e.projName && "Lambert_Azimuthal_Equal_Area" !== e.projName || (e.long0 = e.longc), e.lat_ts || !e.lat1 || "Stereographic_South_Pole" !== e.projName && "Polar Stereographic (variant B)" !== e.projName || (e.lat0 = d2r$1(e.lat1 > 0 ? 90 : -90), e.lat_ts = e.lat1) } function wkt(e) { var t = parseString(e), i = t.shift(), r = t.shift(); t.unshift(["name", r]), t.unshift(["type", i]); var n = {}; return sExpr(t, n), cleanWKT(n), n } function defs(e) { var t = this; if (2 === arguments.length) { var i = arguments[1]; "string" == typeof i ? "+" === i.charAt(0) ? defs[e] = projStr(arguments[1]) : defs[e] = wkt(arguments[1]) : defs[e] = i } else if (1 === arguments.length) { if (Array.isArray(e)) return e.map((function (e) { Array.isArray(e) ? defs.apply(t, e) : defs(e) })); if ("string" == typeof e) { if (e in defs) return defs[e] } else "EPSG" in e ? defs["EPSG:" + e.EPSG] = e : "ESRI" in e ? defs["ESRI:" + e.ESRI] = e : "IAU2000" in e ? defs["IAU2000:" + e.IAU2000] = e : console.log(e); return } } function testObj(e) { return "string" == typeof e } function testDef(e) { return e in defs } globals(defs); var codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"]; function testWKT(e) { return codeWords.some((function (t) { return e.indexOf(t) > -1 })) } var codes = ["3857", "900913", "3785", "102113"]; function checkMercator(e) { var t = match(e, "authority"); if (t) { var i = match(t, "epsg"); return i && codes.indexOf(i) > -1 } } function checkProjStr(e) { var t = match(e, "extension"); if (t) return match(t, "proj4") } function testProj(e) { return "+" === e[0] } function parse(e) { if (!testObj(e)) return e; if (testDef(e)) return defs[e]; if (testWKT(e)) { var t = wkt(e); if (checkMercator(t)) return defs["EPSG:3857"]; var i = checkProjStr(t); return i ? projStr(i) : t } return testProj(e) ? projStr(e) : void 0 } function extend(e, t) { var i, r; if (e = e || {}, !t) return e; for (r in t) void 0 !== (i = t[r]) && (e[r] = i); return e } function msfnz(e, t, i) { var r = e * t; return i / Math.sqrt(1 - r * r) } function sign(e) { return e < 0 ? -1 : 1 } function adjust_lon(e) { return Math.abs(e) <= SPI ? e : e - sign(e) * TWO_PI } function tsfnz(e, t, i) { var r = e * i, n = .5 * e; return r = Math.pow((1 - r) / (1 + r), n), Math.tan(.5 * (HALF_PI - t)) / r } function phi2z(e, t) { for (var i, r, n = .5 * e, a = HALF_PI - 2 * Math.atan(t), o = 0; o <= 15; o++)if (i = e * Math.sin(a), a += r = HALF_PI - 2 * Math.atan(t * Math.pow((1 - i) / (1 + i), n)) - a, Math.abs(r) <= 1e-10) return a; return -9999 } function init$u() { var e = this.b / this.a; this.es = 1 - e * e, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1) } function forward$t(e) { var t, i, r = e.x, n = e.y; if (n * R2D > 90 && n * R2D < -90 && r * R2D > 180 && r * R2D < -180) return null; if (Math.abs(Math.abs(n) - HALF_PI) <= EPSLN) return null; if (this.sphere) t = this.x0 + this.a * this.k0 * adjust_lon(r - this.long0), i = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + .5 * n)); else { var a = Math.sin(n), o = tsfnz(this.e, n, a); t = this.x0 + this.a * this.k0 * adjust_lon(r - this.long0), i = this.y0 - this.a * this.k0 * Math.log(o) } return e.x = t, e.y = i, e } function inverse$t(e) { var t, i, r = e.x - this.x0, n = e.y - this.y0; if (this.sphere) i = HALF_PI - 2 * Math.atan(Math.exp(-n / (this.a * this.k0))); else { var a = Math.exp(-n / (this.a * this.k0)); if (-9999 === (i = phi2z(this.e, a))) return null } return t = adjust_lon(this.long0 + r / (this.a * this.k0)), e.x = t, e.y = i, e } var names$v = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"], merc = { init: init$u, forward: forward$t, inverse: inverse$t, names: names$v }; function init$t() { } function identity(e) { return e } var names$u = ["longlat", "identity"], longlat = { init: init$t, forward: identity, inverse: identity, names: names$u }, projs = [merc, longlat], names$t = {}, projStore = []; function add(e, t) { var i = projStore.length; return e.names ? (projStore[i] = e, e.names.forEach((function (e) { names$t[e.toLowerCase()] = i })), this) : (console.log(t), !0) } function get$1(e) { if (!e) return !1; var t = e.toLowerCase(); return void 0 !== names$t[t] && projStore[names$t[t]] ? projStore[names$t[t]] : void 0 } function start() { projs.forEach(add) } var projections = { start: start, add: add, get: get$1 }, exports$1 = { MERIT: { a: 6378137, rf: 298.257, ellipseName: "MERIT 1983" }, SGS85: { a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85" }, GRS80: { a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)" }, IAU76: { a: 6378140, rf: 298.257, ellipseName: "IAU 1976" }, airy: { a: 6377563.396, b: 6356256.91, ellipseName: "Airy 1830" }, APL4: { a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965" }, NWL9D: { a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965" }, mod_airy: { a: 6377340.189, b: 6356034.446, ellipseName: "Modified Airy" }, andrae: { a: 6377104.43, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)" }, aust_SA: { a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969" }, GRS67: { a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)" }, bessel: { a: 6377397.155, rf: 299.1528128, ellipseName: "Bessel 1841" }, bess_nam: { a: 6377483.865, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)" }, clrk66: { a: 6378206.4, b: 6356583.8, ellipseName: "Clarke 1866" }, clrk80: { a: 6378249.145, rf: 293.4663, ellipseName: "Clarke 1880 mod." }, clrk58: { a: 6378293.645208759, rf: 294.2606763692654, ellipseName: "Clarke 1858" }, CPM: { a: 6375738.7, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799" }, delmbr: { a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)" }, engelis: { a: 6378136.05, rf: 298.2566, ellipseName: "Engelis 1985" }, evrst30: { a: 6377276.345, rf: 300.8017, ellipseName: "Everest 1830" }, evrst48: { a: 6377304.063, rf: 300.8017, ellipseName: "Everest 1948" }, evrst56: { a: 6377301.243, rf: 300.8017, ellipseName: "Everest 1956" }, evrst69: { a: 6377295.664, rf: 300.8017, ellipseName: "Everest 1969" }, evrstSS: { a: 6377298.556, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)" }, fschr60: { a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960" }, fschr60m: { a: 6378155, rf: 298.3, ellipseName: "Fischer 1960" }, fschr68: { a: 6378150, rf: 298.3, ellipseName: "Fischer 1968" }, helmert: { a: 6378200, rf: 298.3, ellipseName: "Helmert 1906" }, hough: { a: 6378270, rf: 297, ellipseName: "Hough" }, intl: { a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)" }, kaula: { a: 6378163, rf: 298.24, ellipseName: "Kaula 1961" }, lerch: { a: 6378139, rf: 298.257, ellipseName: "Lerch 1979" }, mprts: { a: 6397300, rf: 191, ellipseName: "Maupertius 1738" }, new_intl: { a: 6378157.5, b: 6356772.2, ellipseName: "New International 1967" }, plessis: { a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)" }, krass: { a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942" }, SEasia: { a: 6378155, b: 6356773.3205, ellipseName: "Southeast Asia" }, walbeck: { a: 6376896, b: 6355834.8467, ellipseName: "Walbeck" }, WGS60: { a: 6378165, rf: 298.3, ellipseName: "WGS 60" }, WGS66: { a: 6378145, rf: 298.25, ellipseName: "WGS 66" }, WGS7: { a: 6378135, rf: 298.26, ellipseName: "WGS 72" } }, WGS84 = exports$1.WGS84 = { a: 6378137, rf: 298.257223563, ellipseName: "WGS 84" }; function eccentricity(e, t, i, r) { var n = e * e, a = t * t, o = (n - a) / n, s = 0; return r ? (n = (e *= 1 - o * (SIXTH + o * (RA4 + o * RA6))) * e, o = 0) : s = Math.sqrt(o), { es: o, e: s, ep2: (n - a) / a } } function sphere(e, t, i, r, n) { if (!e) { var a = match(exports$1, r); a || (a = WGS84), e = a.a, t = a.b, i = a.rf } return i && !t && (t = (1 - 1 / i) * e), (0 === i || Math.abs(e - t) < EPSLN) && (n = !0, t = e), { a: e, b: t, rf: i, sphere: n } } exports$1.sphere = { a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)" }; var exports$3 = {}; function datum$1(e, t, i, r, n, a, o) { var s = {}; return s.datum_type = void 0 === e || "none" === e ? PJD_NODATUM : PJD_WGS84, t && (s.datum_params = t.map(parseFloat), 0 === s.datum_params[0] && 0 === s.datum_params[1] && 0 === s.datum_params[2] || (s.datum_type = PJD_3PARAM), s.datum_params.length > 3 && (0 === s.datum_params[3] && 0 === s.datum_params[4] && 0 === s.datum_params[5] && 0 === s.datum_params[6] || (s.datum_type = PJD_7PARAM, s.datum_params[3] *= SEC_TO_RAD, s.datum_params[4] *= SEC_TO_RAD, s.datum_params[5] *= SEC_TO_RAD, s.datum_params[6] = s.datum_params[6] / 1e6 + 1))), o && (s.datum_type = PJD_GRIDSHIFT, s.grids = o), s.a = i, s.b = r, s.es = n, s.ep2 = a, s } exports$3.wgs84 = { towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84" }, exports$3.ch1903 = { towgs84: "674.374,15.056,405.346", ellipse: "bessel", datumName: "swiss" }, exports$3.ggrs87 = { towgs84: "-199.87,74.79,246.62", ellipse: "GRS80", datumName: "Greek_Geodetic_Reference_System_1987" }, exports$3.nad83 = { towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983" }, exports$3.nad27 = { nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat", ellipse: "clrk66", datumName: "North_American_Datum_1927" }, exports$3.potsdam = { towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7", ellipse: "bessel", datumName: "Potsdam Rauenberg 1950 DHDN" }, exports$3.carthage = { towgs84: "-263.0,6.0,431.0", ellipse: "clark80", datumName: "Carthage 1934 Tunisia" }, exports$3.hermannskogel = { towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232", ellipse: "bessel", datumName: "Hermannskogel" }, exports$3.osni52 = { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "airy", datumName: "Irish National" }, exports$3.ire65 = { towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15", ellipse: "mod_airy", datumName: "Ireland 1965" }, exports$3.rassadiran = { towgs84: "-133.63,-157.5,-158.62", ellipse: "intl", datumName: "Rassadiran" }, exports$3.nzgd49 = { towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993", ellipse: "intl", datumName: "New Zealand Geodetic Datum 1949" }, exports$3.osgb36 = { towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894", ellipse: "airy", datumName: "Airy 1830" }, exports$3.s_jtsk = { towgs84: "589,76,480", ellipse: "bessel", datumName: "S-JTSK (Ferro)" }, exports$3.beduaram = { towgs84: "-106,-87,188", ellipse: "clrk80", datumName: "Beduaram" }, exports$3.gunung_segara = { towgs84: "-403,684,41", ellipse: "bessel", datumName: "Gunung Segara Jakarta" }, exports$3.rnb72 = { towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1", ellipse: "intl", datumName: "Reseau National Belge 1972" }; var loadedNadgrids = {}; function nadgrid(e, t) { var i = new DataView(t), r = detectLittleEndian(i), n = readHeader(i, r); n.nSubgrids > 1 && console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored"); var a = { header: n, subgrids: readSubgrids(i, n, r) }; return loadedNadgrids[e] = a, a } function getNadgrids(e) { return void 0 === e ? null : e.split(",").map(parseNadgridString) } function parseNadgridString(e) { if (0 === e.length) return null; var t = "@" === e[0]; return t && (e = e.slice(1)), "null" === e ? { name: "null", mandatory: !t, grid: null, isNull: !0 } : { name: e, mandatory: !t, grid: loadedNadgrids[e] || null, isNull: !1 } } function secondsToRadians(e) { return e / 3600 * Math.PI / 180 } function detectLittleEndian(e) { var t = e.getInt32(8, !1); return 11 !== t && (11 !== (t = e.getInt32(8, !0)) && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0) } function readHeader(e, t) { return { nFields: e.getInt32(8, t), nSubgridFields: e.getInt32(24, t), nSubgrids: e.getInt32(40, t), shiftType: decodeString(e, 56, 64).trim(), fromSemiMajorAxis: e.getFloat64(120, t), fromSemiMinorAxis: e.getFloat64(136, t), toSemiMajorAxis: e.getFloat64(152, t), toSemiMinorAxis: e.getFloat64(168, t) } } function decodeString(e, t, i) { return String.fromCharCode.apply(null, new Uint8Array(e.buffer.slice(t, i))) } function readSubgrids(e, t, i) { for (var r = [], n = 0; n < t.nSubgrids; n++) { var a = readGridHeader(e, 176, i), o = readGridNodes(e, 176, a, i), s = Math.round(1 + (a.upperLongitude - a.lowerLongitude) / a.longitudeInterval), l = Math.round(1 + (a.upperLatitude - a.lowerLatitude) / a.latitudeInterval); r.push({ ll: [secondsToRadians(a.lowerLongitude), secondsToRadians(a.lowerLatitude)], del: [secondsToRadians(a.longitudeInterval), secondsToRadians(a.latitudeInterval)], lim: [s, l], count: a.gridNodeCount, cvs: mapNodes(o) }) } return r } function mapNodes(e) { return e.map((function (e) { return [secondsToRadians(e.longitudeShift), secondsToRadians(e.latitudeShift)] })) } function readGridHeader(e, t, i) { return { name: decodeString(e, t + 8, t + 16).trim(), parent: decodeString(e, t + 24, t + 24 + 8).trim(), lowerLatitude: e.getFloat64(t + 72, i), upperLatitude: e.getFloat64(t + 88, i), lowerLongitude: e.getFloat64(t + 104, i), upperLongitude: e.getFloat64(t + 120, i), latitudeInterval: e.getFloat64(t + 136, i), longitudeInterval: e.getFloat64(t + 152, i), gridNodeCount: e.getInt32(t + 168, i) } } function readGridNodes(e, t, i, r) { for (var n = t + 176, a = [], o = 0; o < i.gridNodeCount; o++) { var s = { latitudeShift: e.getFloat32(n + 16 * o, r), longitudeShift: e.getFloat32(n + 16 * o + 4, r), latitudeAccuracy: e.getFloat32(n + 16 * o + 8, r), longitudeAccuracy: e.getFloat32(n + 16 * o + 12, r) }; a.push(s) } return a } function Projection(e, t) { if (!(this instanceof Projection)) return new Projection(e); t = t || function (e) { if (e) throw e }; var i = parse(e); if ("object" == typeof i) { var r = Projection.projections.get(i.projName); if (r) { if (i.datumCode && "none" !== i.datumCode) { var n = match(exports$3, i.datumCode); n && (i.datum_params = i.datum_params || (n.towgs84 ? n.towgs84.split(",") : null), i.ellps = n.ellipse, i.datumName = n.datumName ? n.datumName : i.datumCode) } i.k0 = i.k0 || 1, i.axis = i.axis || "enu", i.ellps = i.ellps || "wgs84", i.lat1 = i.lat1 || i.lat0; var a = sphere(i.a, i.b, i.rf, i.ellps, i.sphere), o = eccentricity(a.a, a.b, a.rf, i.R_A), s = getNadgrids(i.nadgrids), l = i.datum || datum$1(i.datumCode, i.datum_params, a.a, a.b, o.es, o.ep2, s); extend(this, i), extend(this, r), this.a = a.a, this.b = a.b, this.rf = a.rf, this.sphere = a.sphere, this.es = o.es, this.e = o.e, this.ep2 = o.ep2, this.datum = l, this.init(), t(null, this) } else t(e) } else t(e) } function compareDatums(e, t) { return e.datum_type === t.datum_type && (!(e.a !== t.a || Math.abs(e.es - t.es) > 5e-11) && (e.datum_type === PJD_3PARAM ? e.datum_params[0] === t.datum_params[0] && e.datum_params[1] === t.datum_params[1] && e.datum_params[2] === t.datum_params[2] : e.datum_type !== PJD_7PARAM || e.datum_params[0] === t.datum_params[0] && e.datum_params[1] === t.datum_params[1] && e.datum_params[2] === t.datum_params[2] && e.datum_params[3] === t.datum_params[3] && e.datum_params[4] === t.datum_params[4] && e.datum_params[5] === t.datum_params[5] && e.datum_params[6] === t.datum_params[6])) } function geodeticToGeocentric(e, t, i) { var r, n, a, o, s = e.x, l = e.y, c = e.z ? e.z : 0; if (l < -HALF_PI && l > -1.001 * HALF_PI) l = -HALF_PI; else if (l > HALF_PI && l < 1.001 * HALF_PI) l = HALF_PI; else { if (l < -HALF_PI) return { x: -1 / 0, y: -1 / 0, z: e.z }; if (l > HALF_PI) return { x: 1 / 0, y: 1 / 0, z: e.z } } return s > Math.PI && (s -= 2 * Math.PI), n = Math.sin(l), o = Math.cos(l), a = n * n, { x: ((r = i / Math.sqrt(1 - t * a)) + c) * o * Math.cos(s), y: (r + c) * o * Math.sin(s), z: (r * (1 - t) + c) * n } } function geocentricToGeodetic(e, t, i, r) { var n, a, o, s, l, c, h, u, d, p, f, m, g, y, v, _ = 1e-12, b = e.x, x = e.y, w = e.z ? e.z : 0; if (n = Math.sqrt(b * b + x * x), a = Math.sqrt(b * b + x * x + w * w), n / i < _) { if (y = 0, a / i < _) return HALF_PI, v = -r, { x: e.x, y: e.y, z: e.z } } else y = Math.atan2(x, b); o = w / a, u = (s = n / a) * (1 - t) * (l = 1 / Math.sqrt(1 - t * (2 - t) * s * s)), d = o * l, g = 0; do { g++, c = t * (h = i / Math.sqrt(1 - t * d * d)) / (h + (v = n * u + w * d - h * (1 - t * d * d))), m = (f = o * (l = 1 / Math.sqrt(1 - c * (2 - c) * s * s))) * u - (p = s * (1 - c) * l) * d, u = p, d = f } while (m * m > 1e-24 && g < 30); return { x: y, y: Math.atan(f / Math.abs(p)), z: v } } function geocentricToWgs84(e, t, i) { if (t === PJD_3PARAM) return { x: e.x + i[0], y: e.y + i[1], z: e.z + i[2] }; if (t === PJD_7PARAM) { var r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], l = i[5], c = i[6]; return { x: c * (e.x - l * e.y + s * e.z) + r, y: c * (l * e.x + e.y - o * e.z) + n, z: c * (-s * e.x + o * e.y + e.z) + a } } } function geocentricFromWgs84(e, t, i) { if (t === PJD_3PARAM) return { x: e.x - i[0], y: e.y - i[1], z: e.z - i[2] }; if (t === PJD_7PARAM) { var r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], l = i[5], c = i[6], h = (e.x - r) / c, u = (e.y - n) / c, d = (e.z - a) / c; return { x: h + l * u - s * d, y: -l * h + u + o * d, z: s * h - o * u + d } } } function checkParams(e) { return e === PJD_3PARAM || e === PJD_7PARAM } function datum_transform(e, t, i) { if (compareDatums(e, t)) return i; if (e.datum_type === PJD_NODATUM || t.datum_type === PJD_NODATUM) return i; var r = e.a, n = e.es; if (e.datum_type === PJD_GRIDSHIFT) { if (0 !== applyGridShift(e, !1, i)) return; r = SRS_WGS84_SEMIMAJOR, n = SRS_WGS84_ESQUARED } var a = t.a, o = t.b, s = t.es; if (t.datum_type === PJD_GRIDSHIFT && (a = SRS_WGS84_SEMIMAJOR, o = SRS_WGS84_SEMIMINOR, s = SRS_WGS84_ESQUARED), n === s && r === a && !checkParams(e.datum_type) && !checkParams(t.datum_type)) return i; if ((i = geodeticToGeocentric(i, n, r), checkParams(e.datum_type) && (i = geocentricToWgs84(i, e.datum_type, e.datum_params)), checkParams(t.datum_type) && (i = geocentricFromWgs84(i, t.datum_type, t.datum_params)), i = geocentricToGeodetic(i, s, a, o), t.datum_type === PJD_GRIDSHIFT) && 0 !== applyGridShift(t, !0, i)) return; return i } function applyGridShift(e, t, i) { if (null === e.grids || 0 === e.grids.length) return console.log("Grid shift grids not found"), -1; for (var r = { x: -i.x, y: i.y }, n = { x: Number.NaN, y: Number.NaN }, a = [], o = 0; o < e.grids.length; o++) { var s = e.grids[o]; if (a.push(s.name), s.isNull) { n = r; break } if (null !== s.grid) { var l = s.grid.subgrids[0], c = (Math.abs(l.del[1]) + Math.abs(l.del[0])) / 1e4, h = l.ll[0] - c, u = l.ll[1] - c, d = l.ll[0] + (l.lim[0] - 1) * l.del[0] + c, p = l.ll[1] + (l.lim[1] - 1) * l.del[1] + c; if (!(u > r.y || h > r.x || p < r.y || d < r.x || (n = applySubgridShift(r, t, l), isNaN(n.x)))) break } else if (s.mandatory) return console.log("Unable to find mandatory grid '" + s.name + "'"), -1 } return isNaN(n.x) ? (console.log("Failed to find a grid shift table for location '" + -r.x * R2D + " " + r.y * R2D + " tried: '" + a + "'"), -1) : (i.x = -n.x, i.y = n.y, 0) } function applySubgridShift(e, t, i) { var r = { x: Number.NaN, y: Number.NaN }; if (isNaN(e.x)) return r; var n = { x: e.x, y: e.y }; n.x -= i.ll[0], n.y -= i.ll[1], n.x = adjust_lon(n.x - Math.PI) + Math.PI; var a = nadInterpolate(n, i); if (t) { if (isNaN(a.x)) return r; a.x = n.x - a.x, a.y = n.y - a.y; var o, s, l = 9; do { if (s = nadInterpolate(a, i), isNaN(s.x)) { console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation."); break } o = { x: n.x - (s.x + a.x), y: n.y - (s.y + a.y) }, a.x += o.x, a.y += o.y } while (l-- && Math.abs(o.x) > 1e-12 && Math.abs(o.y) > 1e-12); if (l < 0) return console.log("Inverse grid shift iterator failed to converge."), r; r.x = adjust_lon(a.x + i.ll[0]), r.y = a.y + i.ll[1] } else isNaN(a.x) || (r.x = e.x + a.x, r.y = e.y + a.y); return r } function nadInterpolate(e, t) { var i, r = { x: e.x / t.del[0], y: e.y / t.del[1] }, n = Math.floor(r.x), a = Math.floor(r.y), o = r.x - 1 * n, s = r.y - 1 * a, l = { x: Number.NaN, y: Number.NaN }; if (n < 0 || n >= t.lim[0]) return l; if (a < 0 || a >= t.lim[1]) return l; i = a * t.lim[0] + n; var c = t.cvs[i][0], h = t.cvs[i][1]; i++; var u = t.cvs[i][0], d = t.cvs[i][1]; i += t.lim[0]; var p = t.cvs[i][0], f = t.cvs[i][1]; i--; var m = t.cvs[i][0], g = t.cvs[i][1], y = o * s, v = o * (1 - s), _ = (1 - o) * (1 - s), b = (1 - o) * s; return l.x = _ * c + v * u + b * m + y * p, l.y = _ * h + v * d + b * g + y * f, l } function adjust_axis(e, t, i) { var r, n, a, o = i.x, s = i.y, l = i.z || 0, c = {}; for (a = 0; a < 3; a++)if (!t || 2 !== a || void 0 !== i.z) switch (0 === a ? (r = o, n = -1 !== "ew".indexOf(e.axis[a]) ? "x" : "y") : 1 === a ? (r = s, n = -1 !== "ns".indexOf(e.axis[a]) ? "y" : "x") : (r = l, n = "z"), e.axis[a]) { case "e": c[n] = r; break; case "w": c[n] = -r; break; case "n": c[n] = r; break; case "s": c[n] = -r; break; case "u": void 0 !== i[n] && (c.z = r); break; case "d": void 0 !== i[n] && (c.z = -r); break; default: return null }return c } function common(e) { var t = { x: e[0], y: e[1] }; return e.length > 2 && (t.z = e[2]), e.length > 3 && (t.m = e[3]), t } function checkSanity(e) { checkCoord(e.x), checkCoord(e.y) } function checkCoord(e) { if ("function" == typeof Number.isFinite) { if (Number.isFinite(e)) return; throw new TypeError("coordinates must be finite numbers") } if ("number" != typeof e || e != e || !isFinite(e)) throw new TypeError("coordinates must be finite numbers") } function checkNotWGS(e, t) { return (e.datum.datum_type === PJD_3PARAM || e.datum.datum_type === PJD_7PARAM) && "WGS84" !== t.datumCode || (t.datum.datum_type === PJD_3PARAM || t.datum.datum_type === PJD_7PARAM) && "WGS84" !== e.datumCode } function transform(e, t, i, r) { var n; if (Array.isArray(i) && (i = common(i)), checkSanity(i), e.datum && t.datum && checkNotWGS(e, t) && (i = transform(e, n = new Projection("WGS84"), i, r), e = n), r && "enu" !== e.axis && (i = adjust_axis(e, !1, i)), "longlat" === e.projName) i = { x: i.x * D2R$1, y: i.y * D2R$1, z: i.z || 0 }; else if (e.to_meter && (i = { x: i.x * e.to_meter, y: i.y * e.to_meter, z: i.z || 0 }), !(i = e.inverse(i))) return; if (e.from_greenwich && (i.x += e.from_greenwich), i = datum_transform(e.datum, t.datum, i)) return t.from_greenwich && (i = { x: i.x - t.from_greenwich, y: i.y, z: i.z || 0 }), "longlat" === t.projName ? i = { x: i.x * R2D, y: i.y * R2D, z: i.z || 0 } : (i = t.forward(i), t.to_meter && (i = { x: i.x / t.to_meter, y: i.y / t.to_meter, z: i.z || 0 })), r && "enu" !== t.axis ? adjust_axis(t, !0, i) : i } Projection.projections = projections, Projection.projections.start(); var wgs84 = Projection("WGS84"); function transformer(e, t, i, r) { var n, a, o; return Array.isArray(i) ? (n = transform(e, t, i, r) || { x: NaN, y: NaN }, i.length > 2 ? void 0 !== e.name && "geocent" === e.name || void 0 !== t.name && "geocent" === t.name ? "number" == typeof n.z ? [n.x, n.y, n.z].concat(i.splice(3)) : [n.x, n.y, i[2]].concat(i.splice(3)) : [n.x, n.y].concat(i.splice(2)) : [n.x, n.y]) : (a = transform(e, t, i, r), 2 === (o = Object.keys(i)).length || o.forEach((function (r) { if (void 0 !== e.name && "geocent" === e.name || void 0 !== t.name && "geocent" === t.name) { if ("x" === r || "y" === r || "z" === r) return } else if ("x" === r || "y" === r) return; a[r] = i[r] })), a) } function checkProj(e) { return e instanceof Projection ? e : e.oProj ? e.oProj : Projection(e) } function proj4(e, t, i) { e = checkProj(e); var r, n = !1; return void 0 === t ? (t = e, e = wgs84, n = !0) : (void 0 !== t.x || Array.isArray(t)) && (i = t, t = e, e = wgs84, n = !0), t = checkProj(t), i ? transformer(e, t, i) : (r = { forward: function (i, r) { return transformer(e, t, i, r) }, inverse: function (i, r) { return transformer(t, e, i, r) } }, n && (r.oProj = t), r) } var NUM_100K_SETS = 6, SET_ORIGIN_COLUMN_LETTERS = "AJSAJS", SET_ORIGIN_ROW_LETTERS = "AFAFAF", A$1 = 65, I = 73, O = 79, V$1 = 86, Z = 90, mgrs = { forward: forward$s, inverse: inverse$s, toPoint: toPoint }; function forward$s(e, t) { return t = t || 5, encode$1(LLtoUTM({ lat: e[1], lon: e[0] }), t) } function inverse$s(e) { var t = UTMtoLL(decode$1(e.toUpperCase())); return t.lat && t.lon ? [t.lon, t.lat, t.lon, t.lat] : [t.left, t.bottom, t.right, t.top] } function toPoint(e) { var t = UTMtoLL(decode$1(e.toUpperCase())); return t.lat && t.lon ? [t.lon, t.lat] : [(t.left + t.right) / 2, (t.top + t.bottom) / 2] } function degToRad(e) { return e * (Math.PI / 180) } function radToDeg(e) { return e / Math.PI * 180 } function LLtoUTM(e) { var t, i, r, n, a, o, s, l = e.lat, c = e.lon, h = 6378137, u = .00669438, d = .9996, p = degToRad(l), f = degToRad(c); s = Math.floor((c + 180) / 6) + 1, 180 === c && (s = 60), l >= 56 && l < 64 && c >= 3 && c < 12 && (s = 32), l >= 72 && l < 84 && (c >= 0 && c < 9 ? s = 31 : c >= 9 && c < 21 ? s = 33 : c >= 21 && c < 33 ? s = 35 : c >= 33 && c < 42 && (s = 37)), o = degToRad(6 * (s - 1) - 180 + 3), t = .006739496752268451, i = h / Math.sqrt(1 - u * Math.sin(p) * Math.sin(p)), r = Math.tan(p) * Math.tan(p), n = t * Math.cos(p) * Math.cos(p); var m = d * i * ((a = Math.cos(p) * (f - o)) + (1 - r + n) * a * a * a / 6 + (5 - 18 * r + r * r + 72 * n - 58 * t) * a * a * a * a * a / 120) + 5e5, g = d * (h * (.9983242984503243 * p - .002514607064228144 * Math.sin(2 * p) + 2639046602129982e-21 * Math.sin(4 * p) - 3.418046101696858e-9 * Math.sin(6 * p)) + i * Math.tan(p) * (a * a / 2 + (5 - r + 9 * n + 4 * n * n) * a * a * a * a / 24 + (61 - 58 * r + r * r + 600 * n - 2.2240339282485886) * a * a * a * a * a * a / 720)); return l < 0 && (g += 1e7), { northing: Math.round(g), easting: Math.round(m), zoneNumber: s, zoneLetter: getLetterDesignator(l) } } function UTMtoLL(e) { var t = e.northing, i = e.easting, r = e.zoneLetter, n = e.zoneNumber; if (n < 0 || n > 60) return null; var a, o, s, l, c, h, u, d, p, f = .9996, m = 6378137, g = .00669438, y = (1 - Math.sqrt(.99330562)) / (1 + Math.sqrt(.99330562)), v = i - 5e5, _ = t; r < "N" && (_ -= 1e7), u = 6 * (n - 1) - 180 + 3, a = .006739496752268451, p = (d = _ / f / 6367449.145945056) + (3 * y / 2 - 27 * y * y * y / 32) * Math.sin(2 * d) + (21 * y * y / 16 - 55 * y * y * y * y / 32) * Math.sin(4 * d) + 151 * y * y * y / 96 * Math.sin(6 * d), o = m / Math.sqrt(1 - g * Math.sin(p) * Math.sin(p)), s = Math.tan(p) * Math.tan(p), l = a * Math.cos(p) * Math.cos(p), c = .99330562 * m / Math.pow(1 - g * Math.sin(p) * Math.sin(p), 1.5), h = v / (o * f); var b = p - o * Math.tan(p) / c * (h * h / 2 - (5 + 3 * s + 10 * l - 4 * l * l - 9 * a) * h * h * h * h / 24 + (61 + 90 * s + 298 * l + 45 * s * s - 1.6983531815716497 - 3 * l * l) * h * h * h * h * h * h / 720); b = radToDeg(b); var x, w = (h - (1 + 2 * s + l) * h * h * h / 6 + (5 - 2 * l + 28 * s - 3 * l * l + 8 * a + 24 * s * s) * h * h * h * h * h / 120) / Math.cos(p); if (w = u + radToDeg(w), e.accuracy) { var S = UTMtoLL({ northing: e.northing + e.accuracy, easting: e.easting + e.accuracy, zoneLetter: e.zoneLetter, zoneNumber: e.zoneNumber }); x = { top: S.lat, right: S.lon, bottom: b, left: w } } else x = { lat: b, lon: w }; return x } function getLetterDesignator(e) { var t = "Z"; return 84 >= e && e >= 72 ? t = "X" : 72 > e && e >= 64 ? t = "W" : 64 > e && e >= 56 ? t = "V" : 56 > e && e >= 48 ? t = "U" : 48 > e && e >= 40 ? t = "T" : 40 > e && e >= 32 ? t = "S" : 32 > e && e >= 24 ? t = "R" : 24 > e && e >= 16 ? t = "Q" : 16 > e && e >= 8 ? t = "P" : 8 > e && e >= 0 ? t = "N" : 0 > e && e >= -8 ? t = "M" : -8 > e && e >= -16 ? t = "L" : -16 > e && e >= -24 ? t = "K" : -24 > e && e >= -32 ? t = "J" : -32 > e && e >= -40 ? t = "H" : -40 > e && e >= -48 ? t = "G" : -48 > e && e >= -56 ? t = "F" : -56 > e && e >= -64 ? t = "E" : -64 > e && e >= -72 ? t = "D" : -72 > e && e >= -80 && (t = "C"), t } function encode$1(e, t) { var i = "00000" + e.easting, r = "00000" + e.northing; return e.zoneNumber + e.zoneLetter + get100kID(e.easting, e.northing, e.zoneNumber) + i.substr(i.length - 5, t) + r.substr(r.length - 5, t) } function get100kID(e, t, i) { var r = get100kSetForZone(i); return getLetter100kID(Math.floor(e / 1e5), Math.floor(t / 1e5) % 20, r) } function get100kSetForZone(e) { var t = e % NUM_100K_SETS; return 0 === t && (t = NUM_100K_SETS), t } function getLetter100kID(e, t, i) { var r = i - 1, n = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(r), a = SET_ORIGIN_ROW_LETTERS.charCodeAt(r), o = n + e - 1, s = a + t, l = !1; return o > Z && (o = o - Z + A$1 - 1, l = !0), (o === I || n < I && o > I || (o > I || n < I) && l) && o++, (o === O || n < O && o > O || (o > O || n < O) && l) && ++o === I && o++, o > Z && (o = o - Z + A$1 - 1), s > V$1 ? (s = s - V$1 + A$1 - 1, l = !0) : l = !1, (s === I || a < I && s > I || (s > I || a < I) && l) && s++, (s === O || a < O && s > O || (s > O || a < O) && l) && ++s === I && s++, s > V$1 && (s = s - V$1 + A$1 - 1), String.fromCharCode(o) + String.fromCharCode(s) } function decode$1(e) { if (e && 0 === e.length) throw "MGRSPoint coverting from nothing"; for (var t, i = e.length, r = null, n = "", a = 0; !/[A-Z]/.test(t = e.charAt(a));) { if (a >= 2) throw "MGRSPoint bad conversion from: " + e; n += t, a++ } var o = parseInt(n, 10); if (0 === a || a + 3 > i) throw "MGRSPoint bad conversion from: " + e; var s = e.charAt(a++); if (s <= "A" || "B" === s || "Y" === s || s >= "Z" || "I" === s || "O" === s) throw "MGRSPoint zone letter " + s + " not handled: " + e; r = e.substring(a, a += 2); for (var l = get100kSetForZone(o), c = getEastingFromChar(r.charAt(0), l), h = getNorthingFromChar(r.charAt(1), l); h < getMinNorthing(s);)h += 2e6; var u = i - a; if (u % 2 != 0) throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + e; var d, p, f, m = u / 2, g = 0, y = 0; return m > 0 && (d = 1e5 / Math.pow(10, m), p = e.substring(a, a + m), g = parseFloat(p) * d, f = e.substring(a + m), y = parseFloat(f) * d), { easting: g + c, northing: y + h, zoneLetter: s, zoneNumber: o, accuracy: d } } function getEastingFromChar(e, t) { for (var i = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(t - 1), r = 1e5, n = !1; i !== e.charCodeAt(0);) { if (++i === I && i++, i === O && i++, i > Z) { if (n) throw "Bad character: " + e; i = A$1, n = !0 } r += 1e5 } return r } function getNorthingFromChar(e, t) { if (e > "V") throw "MGRSPoint given invalid Northing " + e; for (var i = SET_ORIGIN_ROW_LETTERS.charCodeAt(t - 1), r = 0, n = !1; i !== e.charCodeAt(0);) { if (++i === I && i++, i === O && i++, i > V$1) { if (n) throw "Bad character: " + e; i = A$1, n = !0 } r += 1e5 } return r } function getMinNorthing(e) { var t; switch (e) { case "C": t = 11e5; break; case "D": t = 2e6; break; case "E": t = 28e5; break; case "F": t = 37e5; break; case "G": t = 46e5; break; case "H": t = 55e5; break; case "J": t = 64e5; break; case "K": t = 73e5; break; case "L": t = 82e5; break; case "M": t = 91e5; break; case "N": t = 0; break; case "P": t = 8e5; break; case "Q": t = 17e5; break; case "R": t = 26e5; break; case "S": t = 35e5; break; case "T": t = 44e5; break; case "U": t = 53e5; break; case "V": t = 62e5; break; case "W": t = 7e6; break; case "X": t = 79e5; break; default: t = -1 }if (t >= 0) return t; throw "Invalid zone letter: " + e } function Point(e, t, i) { if (!(this instanceof Point)) return new Point(e, t, i); if (Array.isArray(e)) this.x = e[0], this.y = e[1], this.z = e[2] || 0; else if ("object" == typeof e) this.x = e.x, this.y = e.y, this.z = e.z || 0; else if ("string" == typeof e && void 0 === t) { var r = e.split(","); this.x = parseFloat(r[0], 10), this.y = parseFloat(r[1], 10), this.z = parseFloat(r[2], 10) || 0 } else this.x = e, this.y = t, this.z = i || 0; console.warn("proj4.Point will be removed in version 3, use proj4.toPoint") } Point.fromMGRS = function (e) { return new Point(toPoint(e)) }, Point.prototype.toMGRS = function (e) { return forward$s([this.x, this.y], e) }; var C00 = 1, C02 = .25, C04 = .046875, C06 = .01953125, C08 = .01068115234375, C22 = .75, C44 = .46875, C46 = .013020833333333334, C48 = .007120768229166667, C66 = .3645833333333333, C68 = .005696614583333333, C88 = .3076171875; function pj_enfn(e) { var t = []; t[0] = C00 - e * (C02 + e * (C04 + e * (C06 + e * C08))), t[1] = e * (C22 - e * (C04 + e * (C06 + e * C08))); var i = e * e; return t[2] = i * (C44 - e * (C46 + e * C48)), i *= e, t[3] = i * (C66 - e * C68), t[4] = i * e * C88, t } function pj_mlfn(e, t, i, r) { return i *= t, t *= t, r[0] * e - i * (r[1] + t * (r[2] + t * (r[3] + t * r[4]))) } var MAX_ITER$3 = 20; function pj_inv_mlfn(e, t, i) { for (var r = 1 / (1 - t), n = e, a = MAX_ITER$3; a; --a) { var o = Math.sin(n), s = 1 - t * o * o; if (n -= s = (pj_mlfn(n, o, Math.cos(n), i) - e) * (s * Math.sqrt(s)) * r, Math.abs(s) < EPSLN) return n } return n } function init$s() { this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.es && (this.en = pj_enfn(this.es), this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en)) } function forward$r(e) { var t, i, r, n = e.x, a = e.y, o = adjust_lon(n - this.long0), s = Math.sin(a), l = Math.cos(a); if (this.es) { var c = l * o, h = Math.pow(c, 2), u = this.ep2 * Math.pow(l, 2), d = Math.pow(u, 2), p = Math.abs(l) > EPSLN ? Math.tan(a) : 0, f = Math.pow(p, 2), m = Math.pow(f, 2); t = 1 - this.es * Math.pow(s, 2), c /= Math.sqrt(t); var g = pj_mlfn(a, s, l, this.en); i = this.a * (this.k0 * c * (1 + h / 6 * (1 - f + u + h / 20 * (5 - 18 * f + m + 14 * u - 58 * f * u + h / 42 * (61 + 179 * m - m * f - 479 * f))))) + this.x0, r = this.a * (this.k0 * (g - this.ml0 + s * o * c / 2 * (1 + h / 12 * (5 - f + 9 * u + 4 * d + h / 30 * (61 + m - 58 * f + 270 * u - 330 * f * u + h / 56 * (1385 + 543 * m - m * f - 3111 * f)))))) + this.y0 } else { var y = l * Math.sin(o); if (Math.abs(Math.abs(y) - 1) < EPSLN) return 93; if (i = .5 * this.a * this.k0 * Math.log((1 + y) / (1 - y)) + this.x0, r = l * Math.cos(o) / Math.sqrt(1 - Math.pow(y, 2)), (y = Math.abs(r)) >= 1) { if (y - 1 > EPSLN) return 93; r = 0 } else r = Math.acos(r); a < 0 && (r = -r), r = this.a * this.k0 * (r - this.lat0) + this.y0 } return e.x = i, e.y = r, e } function inverse$r(e) { var t, i, r, n, a = (e.x - this.x0) * (1 / this.a), o = (e.y - this.y0) * (1 / this.a); if (this.es) if (i = pj_inv_mlfn(t = this.ml0 + o / this.k0, this.es, this.en), Math.abs(i) < HALF_PI) { var s = Math.sin(i), l = Math.cos(i), c = Math.abs(l) > EPSLN ? Math.tan(i) : 0, h = this.ep2 * Math.pow(l, 2), u = Math.pow(h, 2), d = Math.pow(c, 2), p = Math.pow(d, 2); t = 1 - this.es * Math.pow(s, 2); var f = a * Math.sqrt(t) / this.k0, m = Math.pow(f, 2); r = i - (t *= c) * m / (1 - this.es) * .5 * (1 - m / 12 * (5 + 3 * d - 9 * h * d + h - 4 * u - m / 30 * (61 + 90 * d - 252 * h * d + 45 * p + 46 * h - m / 56 * (1385 + 3633 * d + 4095 * p + 1574 * p * d)))), n = adjust_lon(this.long0 + f * (1 - m / 6 * (1 + 2 * d + h - m / 20 * (5 + 28 * d + 24 * p + 8 * h * d + 6 * h - m / 42 * (61 + 662 * d + 1320 * p + 720 * p * d)))) / l) } else r = HALF_PI * sign(o), n = 0; else { var g = Math.exp(a / this.k0), y = .5 * (g - 1 / g), v = this.lat0 + o / this.k0, _ = Math.cos(v); t = Math.sqrt((1 - Math.pow(_, 2)) / (1 + Math.pow(y, 2))), r = Math.asin(t), o < 0 && (r = -r), n = 0 === y && 0 === _ ? 0 : adjust_lon(Math.atan2(y, _) + this.long0) } return e.x = n, e.y = r, e } var names$s = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"], tmerc = { init: init$s, forward: forward$r, inverse: inverse$r, names: names$s }; function sinh(e) { var t = Math.exp(e); return t = (t - 1 / t) / 2 } function hypot(e, t) { e = Math.abs(e), t = Math.abs(t); var i = Math.max(e, t), r = Math.min(e, t) / (i || 1); return i * Math.sqrt(1 + Math.pow(r, 2)) } function log1py(e) { var t = 1 + e, i = t - 1; return 0 === i ? e : e * Math.log(t) / i } function asinhy(e) { var t = Math.abs(e); return t = log1py(t * (1 + t / (hypot(1, t) + 1))), e < 0 ? -t : t } function gatg(e, t) { for (var i, r = 2 * Math.cos(2 * t), n = e.length - 1, a = e[n], o = 0; --n >= 0;)i = r * a - o + e[n], o = a, a = i; return t + i * Math.sin(2 * t) } function clens(e, t) { for (var i, r = 2 * Math.cos(t), n = e.length - 1, a = e[n], o = 0; --n >= 0;)i = r * a - o + e[n], o = a, a = i; return Math.sin(t) * i } function cosh(e) { var t = Math.exp(e); return t = (t + 1 / t) / 2 } function clens_cmplx(e, t, i) { for (var r, n, a = Math.sin(t), o = Math.cos(t), s = sinh(i), l = cosh(i), c = 2 * o * l, h = -2 * a * s, u = e.length - 1, d = e[u], p = 0, f = 0, m = 0; --u >= 0;)r = f, n = p, d = c * (f = d) - r - h * (p = m) + e[u], m = h * f - n + c * p; return [(c = a * l) * d - (h = o * s) * m, c * m + h * d] } function init$r() { if (!this.approx && (isNaN(this.es) || this.es <= 0)) throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.'); this.approx && (tmerc.init.apply(this), this.forward = tmerc.forward, this.inverse = tmerc.inverse), this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = []; var e = this.es / (1 + Math.sqrt(1 - this.es)), t = e / (2 - e), i = t; this.cgb[0] = t * (2 + t * (-2 / 3 + t * (t * (116 / 45 + t * (26 / 45 + t * (-2854 / 675))) - 2))), this.cbg[0] = t * (t * (2 / 3 + t * (4 / 3 + t * (-82 / 45 + t * (32 / 45 + t * (4642 / 4725))))) - 2), i *= t, this.cgb[1] = i * (7 / 3 + t * (t * (-227 / 45 + t * (2704 / 315 + t * (2323 / 945))) - 1.6)), this.cbg[1] = i * (5 / 3 + t * (-16 / 15 + t * (-13 / 9 + t * (904 / 315 + t * (-1522 / 945))))), i *= t, this.cgb[2] = i * (56 / 15 + t * (-136 / 35 + t * (-1262 / 105 + t * (73814 / 2835)))), this.cbg[2] = i * (-26 / 15 + t * (34 / 21 + t * (1.6 + t * (-12686 / 2835)))), i *= t, this.cgb[3] = i * (4279 / 630 + t * (-332 / 35 + t * (-399572 / 14175))), this.cbg[3] = i * (1237 / 630 + t * (t * (-24832 / 14175) - 2.4)), i *= t, this.cgb[4] = i * (4174 / 315 + t * (-144838 / 6237)), this.cbg[4] = i * (-734 / 315 + t * (109598 / 31185)), i *= t, this.cgb[5] = i * (601676 / 22275), this.cbg[5] = i * (444337 / 155925), i = Math.pow(t, 2), this.Qn = this.k0 / (1 + t) * (1 + i * (1 / 4 + i * (1 / 64 + i / 256))), this.utg[0] = t * (t * (2 / 3 + t * (-37 / 96 + t * (1 / 360 + t * (81 / 512 + t * (-96199 / 604800))))) - .5), this.gtu[0] = t * (.5 + t * (-2 / 3 + t * (5 / 16 + t * (41 / 180 + t * (-127 / 288 + t * (7891 / 37800)))))), this.utg[1] = i * (-1 / 48 + t * (-1 / 15 + t * (437 / 1440 + t * (-46 / 105 + t * (1118711 / 3870720))))), this.gtu[1] = i * (13 / 48 + t * (t * (557 / 1440 + t * (281 / 630 + t * (-1983433 / 1935360))) - .6)), i *= t, this.utg[2] = i * (-17 / 480 + t * (37 / 840 + t * (209 / 4480 + t * (-5569 / 90720)))), this.gtu[2] = i * (61 / 240 + t * (-103 / 140 + t * (15061 / 26880 + t * (167603 / 181440)))), i *= t, this.utg[3] = i * (-4397 / 161280 + t * (11 / 504 + t * (830251 / 7257600))), this.gtu[3] = i * (49561 / 161280 + t * (-179 / 168 + t * (6601661 / 7257600))), i *= t, this.utg[4] = i * (-4583 / 161280 + t * (108847 / 3991680)), this.gtu[4] = i * (34729 / 80640 + t * (-3418889 / 1995840)), i *= t, this.utg[5] = i * (-20648693 / 638668800), this.gtu[5] = .6650675310896665 * i; var r = gatg(this.cbg, this.lat0); this.Zb = -this.Qn * (r + clens(this.gtu, 2 * r)) } function forward$q(e) { var t = adjust_lon(e.x - this.long0), i = e.y; i = gatg(this.cbg, i); var r = Math.sin(i), n = Math.cos(i), a = Math.sin(t), o = Math.cos(t); i = Math.atan2(r, o * n), t = Math.atan2(a * n, hypot(r, n * o)), t = asinhy(Math.tan(t)); var s, l, c = clens_cmplx(this.gtu, 2 * i, 2 * t); return i += c[0], t += c[1], Math.abs(t) <= 2.623395162778 ? (s = this.a * (this.Qn * t) + this.x0, l = this.a * (this.Qn * i + this.Zb) + this.y0) : (s = 1 / 0, l = 1 / 0), e.x = s, e.y = l, e } function inverse$q(e) { var t, i, r = (e.x - this.x0) * (1 / this.a), n = (e.y - this.y0) * (1 / this.a); if (n = (n - this.Zb) / this.Qn, r /= this.Qn, Math.abs(r) <= 2.623395162778) { var a = clens_cmplx(this.utg, 2 * n, 2 * r); n += a[0], r += a[1], r = Math.atan(sinh(r)); var o = Math.sin(n), s = Math.cos(n), l = Math.sin(r), c = Math.cos(r); n = Math.atan2(o * c, hypot(l, c * s)), t = adjust_lon((r = Math.atan2(l, c * s)) + this.long0), i = gatg(this.cgb, n) } else t = 1 / 0, i = 1 / 0; return e.x = t, e.y = i, e } var names$r = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"], etmerc = { init: init$r, forward: forward$q, inverse: inverse$q, names: names$r }; function adjust_zone(e, t) { if (void 0 === e) { if ((e = Math.floor(30 * (adjust_lon(t) + Math.PI) / Math.PI) + 1) < 0) return 0; if (e > 60) return 60 } return e } var dependsOn = "etmerc"; function init$q() { var e = adjust_zone(this.zone, this.long0); if (void 0 === e) throw new Error("unknown utm zone"); this.lat0 = 0, this.long0 = (6 * Math.abs(e) - 183) * D2R$1, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = .9996, etmerc.init.apply(this), this.forward = etmerc.forward, this.inverse = etmerc.inverse } var names$q = ["Universal Transverse Mercator System", "utm"], utm = { init: init$q, names: names$q, dependsOn: dependsOn }; function srat(e, t) { return Math.pow((1 - e) / (1 + e), t) } var MAX_ITER$2 = 20; function init$p() { var e = Math.sin(this.lat0), t = Math.cos(this.lat0); t *= t, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * e * e), this.C = Math.sqrt(1 + this.es * t * t / (1 - this.es)), this.phic0 = Math.asin(e / this.C), this.ratexp = .5 * this.C * this.e, this.K = Math.tan(.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(.5 * this.lat0 + FORTPI), this.C) * srat(this.e * e, this.ratexp)) } function forward$p(e) { var t = e.x, i = e.y; return e.y = 2 * Math.atan(this.K * Math.pow(Math.tan(.5 * i + FORTPI), this.C) * srat(this.e * Math.sin(i), this.ratexp)) - HALF_PI, e.x = this.C * t, e } function inverse$p(e) { for (var t = e.x / this.C, i = e.y, r = Math.pow(Math.tan(.5 * i + FORTPI) / this.K, 1 / this.C), n = MAX_ITER$2; n > 0 && (i = 2 * Math.atan(r * srat(this.e * Math.sin(e.y), -.5 * this.e)) - HALF_PI, !(Math.abs(i - e.y) < 1e-14)); --n)e.y = i; return n ? (e.x = t, e.y = i, e) : null } var names$p = ["gauss"], gauss = { init: init$p, forward: forward$p, inverse: inverse$p, names: names$p }; function init$o() { gauss.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative")) } function forward$o(e) { var t, i, r, n; return e.x = adjust_lon(e.x - this.long0), gauss.forward.apply(this, [e]), t = Math.sin(e.y), i = Math.cos(e.y), r = Math.cos(e.x), n = this.k0 * this.R2 / (1 + this.sinc0 * t + this.cosc0 * i * r), e.x = n * i * Math.sin(e.x), e.y = n * (this.cosc0 * t - this.sinc0 * i * r), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e } function inverse$o(e) { var t, i, r, n, a; if (e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a, e.x /= this.k0, e.y /= this.k0, a = Math.sqrt(e.x * e.x + e.y * e.y)) { var o = 2 * Math.atan2(a, this.R2); t = Math.sin(o), i = Math.cos(o), n = Math.asin(i * this.sinc0 + e.y * t * this.cosc0 / a), r = Math.atan2(e.x * t, a * this.cosc0 * i - e.y * this.sinc0 * t) } else n = this.phic0, r = 0; return e.x = r, e.y = n, gauss.inverse.apply(this, [e]), e.x = adjust_lon(e.x + this.long0), e } var names$o = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"], sterea = { init: init$o, forward: forward$o, inverse: inverse$o, names: names$o }; function ssfn_(e, t, i) { return t *= i, Math.tan(.5 * (HALF_PI + e)) * Math.pow((1 - t) / (1 + t), .5 * i) } function init$n() { this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && (this.k0 = .5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= EPSLN && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && (this.k0 = .5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0)) } function forward$n(e) { var t, i, r, n, a, o, s = e.x, l = e.y, c = Math.sin(l), h = Math.cos(l), u = adjust_lon(s - this.long0); return Math.abs(Math.abs(s - this.long0) - Math.PI) <= EPSLN && Math.abs(l + this.lat0) <= EPSLN ? (e.x = NaN, e.y = NaN, e) : this.sphere ? (t = 2 * this.k0 / (1 + this.sinlat0 * c + this.coslat0 * h * Math.cos(u)), e.x = this.a * t * h * Math.sin(u) + this.x0, e.y = this.a * t * (this.coslat0 * c - this.sinlat0 * h * Math.cos(u)) + this.y0, e) : (i = 2 * Math.atan(this.ssfn_(l, c, this.e)) - HALF_PI, n = Math.cos(i), r = Math.sin(i), Math.abs(this.coslat0) <= EPSLN ? (a = tsfnz(this.e, l * this.con, this.con * c), o = 2 * this.a * this.k0 * a / this.cons, e.x = this.x0 + o * Math.sin(s - this.long0), e.y = this.y0 - this.con * o * Math.cos(s - this.long0), e) : (Math.abs(this.sinlat0) < EPSLN ? (t = 2 * this.a * this.k0 / (1 + n * Math.cos(u)), e.y = t * r) : (t = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * r + this.cosX0 * n * Math.cos(u))), e.y = t * (this.cosX0 * r - this.sinX0 * n * Math.cos(u)) + this.y0), e.x = t * n * Math.sin(u) + this.x0, e)) } function inverse$n(e) { var t, i, r, n, a; e.x -= this.x0, e.y -= this.y0; var o = Math.sqrt(e.x * e.x + e.y * e.y); if (this.sphere) { var s = 2 * Math.atan(o / (2 * this.a * this.k0)); return t = this.long0, i = this.lat0, o <= EPSLN ? (e.x = t, e.y = i, e) : (i = Math.asin(Math.cos(s) * this.sinlat0 + e.y * Math.sin(s) * this.coslat0 / o), t = Math.abs(this.coslat0) < EPSLN ? this.lat0 > 0 ? adjust_lon(this.long0 + Math.atan2(e.x, -1 * e.y)) : adjust_lon(this.long0 + Math.atan2(e.x, e.y)) : adjust_lon(this.long0 + Math.atan2(e.x * Math.sin(s), o * this.coslat0 * Math.cos(s) - e.y * this.sinlat0 * Math.sin(s))), e.x = t, e.y = i, e) } if (Math.abs(this.coslat0) <= EPSLN) { if (o <= EPSLN) return i = this.lat0, t = this.long0, e.x = t, e.y = i, e; e.x *= this.con, e.y *= this.con, r = o * this.cons / (2 * this.a * this.k0), i = this.con * phi2z(this.e, r), t = this.con * adjust_lon(this.con * this.long0 + Math.atan2(e.x, -1 * e.y)) } else n = 2 * Math.atan(o * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), t = this.long0, o <= EPSLN ? a = this.X0 : (a = Math.asin(Math.cos(n) * this.sinX0 + e.y * Math.sin(n) * this.cosX0 / o), t = adjust_lon(this.long0 + Math.atan2(e.x * Math.sin(n), o * this.cosX0 * Math.cos(n) - e.y * this.sinX0 * Math.sin(n)))), i = -1 * phi2z(this.e, Math.tan(.5 * (HALF_PI + a))); return e.x = t, e.y = i, e } var names$n = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"], stere = { init: init$n, forward: forward$n, inverse: inverse$n, names: names$n, ssfn_: ssfn_ }; function init$m() { var e = this.lat0; this.lambda0 = this.long0; var t = Math.sin(e), i = this.a, r = 1 / this.rf, n = 2 * r - Math.pow(r, 2), a = this.e = Math.sqrt(n); this.R = this.k0 * i * Math.sqrt(1 - n) / (1 - n * Math.pow(t, 2)), this.alpha = Math.sqrt(1 + n / (1 - n) * Math.pow(Math.cos(e), 4)), this.b0 = Math.asin(t / this.alpha); var o = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), s = Math.log(Math.tan(Math.PI / 4 + e / 2)), l = Math.log((1 + a * t) / (1 - a * t)); this.K = o - this.alpha * s + this.alpha * a / 2 * l } function forward$m(e) { var t = Math.log(Math.tan(Math.PI / 4 - e.y / 2)), i = this.e / 2 * Math.log((1 + this.e * Math.sin(e.y)) / (1 - this.e * Math.sin(e.y))), r = -this.alpha * (t + i) + this.K, n = 2 * (Math.atan(Math.exp(r)) - Math.PI / 4), a = this.alpha * (e.x - this.lambda0), o = Math.atan(Math.sin(a) / (Math.sin(this.b0) * Math.tan(n) + Math.cos(this.b0) * Math.cos(a))), s = Math.asin(Math.cos(this.b0) * Math.sin(n) - Math.sin(this.b0) * Math.cos(n) * Math.cos(a)); return e.y = this.R / 2 * Math.log((1 + Math.sin(s)) / (1 - Math.sin(s))) + this.y0, e.x = this.R * o + this.x0, e } function inverse$m(e) { for (var t = e.x - this.x0, i = e.y - this.y0, r = t / this.R, n = 2 * (Math.atan(Math.exp(i / this.R)) - Math.PI / 4), a = Math.asin(Math.cos(this.b0) * Math.sin(n) + Math.sin(this.b0) * Math.cos(n) * Math.cos(r)), o = Math.atan(Math.sin(r) / (Math.cos(this.b0) * Math.cos(r) - Math.sin(this.b0) * Math.tan(n))), s = this.lambda0 + o / this.alpha, l = 0, c = a, h = -1e3, u = 0; Math.abs(c - h) > 1e-7;) { if (++u > 20) return; l = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + a / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(c)) / 2)), h = c, c = 2 * Math.atan(Math.exp(l)) - Math.PI / 2 } return e.x = s, e.y = c, e } var names$m = ["somerc"], somerc = { init: init$m, forward: forward$m, inverse: inverse$m, names: names$m }, TOL = 1e-7; function isTypeA(e) { var t = "object" == typeof e.PROJECTION ? Object.keys(e.PROJECTION)[0] : e.PROJECTION; return "no_uoff" in e || "no_off" in e || -1 !== ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"].indexOf(t) } function init$l() { var e, t, i, r, n, a, o, s, l, c, h, u = 0, d = 0, p = 0, f = 0, m = 0, g = 0, y = 0; this.no_off = isTypeA(this), this.no_rot = "no_rot" in this; var v = !1; "alpha" in this && (v = !0); var _ = !1; if ("rectified_grid_angle" in this && (_ = !0), v && (y = this.alpha), _ && (u = this.rectified_grid_angle * D2R$1), v || _) d = this.longc; else if (p = this.long1, m = this.lat1, f = this.long2, g = this.lat2, Math.abs(m - g) <= TOL || (e = Math.abs(m)) <= TOL || Math.abs(e - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(g) - HALF_PI) <= TOL) throw new Error; var b = 1 - this.es; t = Math.sqrt(b), Math.abs(this.lat0) > EPSLN ? (s = Math.sin(this.lat0), i = Math.cos(this.lat0), e = 1 - this.es * s * s, this.B = i * i, this.B = Math.sqrt(1 + this.es * this.B * this.B / b), this.A = this.B * this.k0 * t / e, (n = (r = this.B * t / (i * Math.sqrt(e))) * r - 1) <= 0 ? n = 0 : (n = Math.sqrt(n), this.lat0 < 0 && (n = -n)), this.E = n += r, this.E *= Math.pow(tsfnz(this.e, this.lat0, s), this.B)) : (this.B = 1 / t, this.A = this.k0, this.E = r = n = 1), v || _ ? (v ? (h = Math.asin(Math.sin(y) / r), _ || (u = y)) : (h = u, y = Math.asin(r * Math.sin(h))), this.lam0 = d - Math.asin(.5 * (n - 1 / n) * Math.tan(h)) / this.B) : (a = Math.pow(tsfnz(this.e, m, Math.sin(m)), this.B), o = Math.pow(tsfnz(this.e, g, Math.sin(g)), this.B), n = this.E / a, l = (o - a) / (o + a), c = ((c = this.E * this.E) - o * a) / (c + o * a), (e = p - f) < -Math.pi ? f -= TWO_PI : e > Math.pi && (f += TWO_PI), this.lam0 = adjust_lon(.5 * (p + f) - Math.atan(c * Math.tan(.5 * this.B * (p - f)) / l) / this.B), h = Math.atan(2 * Math.sin(this.B * adjust_lon(p - this.lam0)) / (n - 1 / n)), u = y = Math.asin(r * Math.sin(h))), this.singam = Math.sin(h), this.cosgam = Math.cos(h), this.sinrot = Math.sin(u), this.cosrot = Math.cos(u), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A, this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(r * r - 1) / Math.cos(y))), this.lat0 < 0 && (this.u_0 = -this.u_0)), n = .5 * h, this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - n)), this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + n)) } function forward$l(e) { var t, i, r, n, a, o, s, l, c = {}; if (e.x = e.x - this.lam0, Math.abs(Math.abs(e.y) - HALF_PI) > EPSLN) { if (t = .5 * ((a = this.E / Math.pow(tsfnz(this.e, e.y, Math.sin(e.y)), this.B)) - (o = 1 / a)), i = .5 * (a + o), n = Math.sin(this.B * e.x), r = (t * this.singam - n * this.cosgam) / i, Math.abs(Math.abs(r) - 1) < EPSLN) throw new Error; l = .5 * this.ArB * Math.log((1 - r) / (1 + r)), o = Math.cos(this.B * e.x), s = Math.abs(o) < TOL ? this.A * e.x : this.ArB * Math.atan2(t * this.cosgam + n * this.singam, o) } else l = e.y > 0 ? this.v_pole_n : this.v_pole_s, s = this.ArB * e.y; return this.no_rot ? (c.x = s, c.y = l) : (s -= this.u_0, c.x = l * this.cosrot + s * this.sinrot, c.y = s * this.cosrot - l * this.sinrot), c.x = this.a * c.x + this.x0, c.y = this.a * c.y + this.y0, c } function inverse$l(e) { var t, i, r, n, a, o, s, l = {}; if (e.x = (e.x - this.x0) * (1 / this.a), e.y = (e.y - this.y0) * (1 / this.a), this.no_rot ? (i = e.y, t = e.x) : (i = e.x * this.cosrot - e.y * this.sinrot, t = e.y * this.cosrot + e.x * this.sinrot + this.u_0), n = .5 * ((r = Math.exp(-this.BrA * i)) - 1 / r), a = .5 * (r + 1 / r), s = ((o = Math.sin(this.BrA * t)) * this.cosgam + n * this.singam) / a, Math.abs(Math.abs(s) - 1) < EPSLN) l.x = 0, l.y = s < 0 ? -HALF_PI : HALF_PI; else { if (l.y = this.E / Math.sqrt((1 + s) / (1 - s)), l.y = phi2z(this.e, Math.pow(l.y, 1 / this.B)), l.y === 1 / 0) throw new Error; l.x = -this.rB * Math.atan2(n * this.cosgam - o * this.singam, Math.cos(this.BrA * t)) } return l.x += this.lam0, l } var names$l = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"], omerc = { init: init$l, forward: forward$l, inverse: inverse$l, names: names$l }; function init$k() { if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < EPSLN)) { var e = this.b / this.a; this.e = Math.sqrt(1 - e * e); var t = Math.sin(this.lat1), i = Math.cos(this.lat1), r = msfnz(this.e, t, i), n = tsfnz(this.e, this.lat1, t), a = Math.sin(this.lat2), o = Math.cos(this.lat2), s = msfnz(this.e, a, o), l = tsfnz(this.e, this.lat2, a), c = tsfnz(this.e, this.lat0, Math.sin(this.lat0)); Math.abs(this.lat1 - this.lat2) > EPSLN ? this.ns = Math.log(r / s) / Math.log(n / l) : this.ns = t, isNaN(this.ns) && (this.ns = t), this.f0 = r / (this.ns * Math.pow(n, this.ns)), this.rh = this.a * this.f0 * Math.pow(c, this.ns), this.title || (this.title = "Lambert Conformal Conic") } } function forward$k(e) { var t = e.x, i = e.y; Math.abs(2 * Math.abs(i) - Math.PI) <= EPSLN && (i = sign(i) * (HALF_PI - 2 * EPSLN)); var r, n, a = Math.abs(Math.abs(i) - HALF_PI); if (a > EPSLN) r = tsfnz(this.e, i, Math.sin(i)), n = this.a * this.f0 * Math.pow(r, this.ns); else { if ((a = i * this.ns) <= 0) return null; n = 0 } var o = this.ns * adjust_lon(t - this.long0); return e.x = this.k0 * (n * Math.sin(o)) + this.x0, e.y = this.k0 * (this.rh - n * Math.cos(o)) + this.y0, e } function inverse$k(e) { var t, i, r, n, a, o = (e.x - this.x0) / this.k0, s = this.rh - (e.y - this.y0) / this.k0; this.ns > 0 ? (t = Math.sqrt(o * o + s * s), i = 1) : (t = -Math.sqrt(o * o + s * s), i = -1); var l = 0; if (0 !== t && (l = Math.atan2(i * o, i * s)), 0 !== t || this.ns > 0) { if (i = 1 / this.ns, r = Math.pow(t / (this.a * this.f0), i), -9999 === (n = phi2z(this.e, r))) return null } else n = -HALF_PI; return a = adjust_lon(l / this.ns + this.long0), e.x = a, e.y = n, e } var names$k = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_1SP", "Lambert_Conformal_Conic_2SP", "lcc"], lcc = { init: init$k, forward: forward$k, inverse: inverse$k, names: names$k }; function init$j() { this.a = 6377397.155, this.es = .006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = .863937979737193), this.long0 || (this.long0 = .4334234309119251), this.k0 || (this.k0 = .9999), this.s45 = .785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq } function forward$j(e) { var t, i, r, n, a, o, s, l = e.x, c = e.y, h = adjust_lon(l - this.long0); return t = Math.pow((1 + this.e * Math.sin(c)) / (1 - this.e * Math.sin(c)), this.alfa * this.e / 2), i = 2 * (Math.atan(this.k * Math.pow(Math.tan(c / 2 + this.s45), this.alfa) / t) - this.s45), r = -h * this.alfa, n = Math.asin(Math.cos(this.ad) * Math.sin(i) + Math.sin(this.ad) * Math.cos(i) * Math.cos(r)), a = Math.asin(Math.cos(i) * Math.sin(r) / Math.cos(n)), o = this.n * a, s = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(n / 2 + this.s45), this.n), e.y = s * Math.cos(o) / 1, e.x = s * Math.sin(o) / 1, this.czech || (e.y *= -1, e.x *= -1), e } function inverse$j(e) { var t, i, r, n, a, o, s, l = e.x; e.x = e.y, e.y = l, this.czech || (e.y *= -1, e.x *= -1), a = Math.sqrt(e.x * e.x + e.y * e.y), n = Math.atan2(e.y, e.x) / Math.sin(this.s0), r = 2 * (Math.atan(Math.pow(this.ro0 / a, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), t = Math.asin(Math.cos(this.ad) * Math.sin(r) - Math.sin(this.ad) * Math.cos(r) * Math.cos(n)), i = Math.asin(Math.cos(r) * Math.sin(n) / Math.cos(t)), e.x = this.long0 - i / this.alfa, o = t, s = 0; var c = 0; do { e.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(t / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(o)) / (1 - this.e * Math.sin(o)), this.e / 2)) - this.s45), Math.abs(o - e.y) < 1e-10 && (s = 1), o = e.y, c += 1 } while (0 === s && c < 15); return c >= 15 ? null : e } var names$j = ["Krovak", "krovak"], krovak = { init: init$j, forward: forward$j, inverse: inverse$j, names: names$j }; function mlfn(e, t, i, r, n) { return e * n - t * Math.sin(2 * n) + i * Math.sin(4 * n) - r * Math.sin(6 * n) } function e0fn(e) { return 1 - .25 * e * (1 + e / 16 * (3 + 1.25 * e)) } function e1fn(e) { return .375 * e * (1 + .25 * e * (1 + .46875 * e)) } function e2fn(e) { return .05859375 * e * e * (1 + .75 * e) } function e3fn(e) { return e * e * e * (35 / 3072) } function gN(e, t, i) { var r = t * i; return e / Math.sqrt(1 - r * r) } function adjust_lat(e) { return Math.abs(e) < HALF_PI ? e : e - sign(e) * Math.PI } function imlfn(e, t, i, r, n) { var a, o; a = e / t; for (var s = 0; s < 15; s++)if (a += o = (e - (t * a - i * Math.sin(2 * a) + r * Math.sin(4 * a) - n * Math.sin(6 * a))) / (t - 2 * i * Math.cos(2 * a) + 4 * r * Math.cos(4 * a) - 6 * n * Math.cos(6 * a)), Math.abs(o) <= 1e-10) return a; return NaN } function init$i() { this.sphere || (this.e0 = e0fn(this.es), this.e1 = e1fn(this.es), this.e2 = e2fn(this.es), this.e3 = e3fn(this.es), this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0)) } function forward$i(e) { var t, i, r = e.x, n = e.y; if (r = adjust_lon(r - this.long0), this.sphere) t = this.a * Math.asin(Math.cos(n) * Math.sin(r)), i = this.a * (Math.atan2(Math.tan(n), Math.cos(r)) - this.lat0); else { var a = Math.sin(n), o = Math.cos(n), s = gN(this.a, this.e, a), l = Math.tan(n) * Math.tan(n), c = r * Math.cos(n), h = c * c, u = this.es * o * o / (1 - this.es); t = s * c * (1 - h * l * (1 / 6 - (8 - l + 8 * u) * h / 120)), i = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, n) - this.ml0 + s * a / o * h * (.5 + (5 - l + 6 * u) * h / 24) } return e.x = t + this.x0, e.y = i + this.y0, e } function inverse$i(e) { e.x -= this.x0, e.y -= this.y0; var t, i, r = e.x / this.a, n = e.y / this.a; if (this.sphere) { var a = n + this.lat0; t = Math.asin(Math.sin(a) * Math.cos(r)), i = Math.atan2(Math.tan(r), Math.cos(a)) } else { var o = imlfn(this.ml0 / this.a + n, this.e0, this.e1, this.e2, this.e3); if (Math.abs(Math.abs(o) - HALF_PI) <= EPSLN) return e.x = this.long0, e.y = HALF_PI, n < 0 && (e.y *= -1), e; var s = gN(this.a, this.e, Math.sin(o)), l = s * s * s / this.a / this.a * (1 - this.es), c = Math.pow(Math.tan(o), 2), h = r * this.a / s, u = h * h; t = o - s * Math.tan(o) / l * h * h * (.5 - (1 + 3 * c) * h * h / 24), i = h * (1 - u * (c / 3 + (1 + 3 * c) * c * u / 15)) / Math.cos(o) } return e.x = adjust_lon(i + this.long0), e.y = adjust_lat(t), e } var names$i = ["Cassini", "Cassini_Soldner", "cass"], cass = { init: init$i, forward: forward$i, inverse: inverse$i, names: names$i }; function qsfnz(e, t) { var i; return e > 1e-7 ? (1 - e * e) * (t / (1 - (i = e * t) * i) - .5 / e * Math.log((1 - i) / (1 + i))) : 2 * t } var S_POLE = 1, N_POLE = 2, EQUIT = 3, OBLIQ = 4; function init$h() { var e, t = Math.abs(this.lat0); if (Math.abs(t - HALF_PI) < EPSLN ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(t) < EPSLN ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) switch (this.qp = qsfnz(this.e, 1), this.mmf = .5 / (1 - this.es), this.apa = authset(this.es), this.mode) { case this.N_POLE: case this.S_POLE: this.dd = 1; break; case this.EQUIT: this.rq = Math.sqrt(.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = .5 * this.qp; break; case this.OBLIQ: this.rq = Math.sqrt(.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = qsfnz(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd } else this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)) } function forward$h(e) { var t, i, r, n, a, o, s, l, c, h, u = e.x, d = e.y; if (u = adjust_lon(u - this.long0), this.sphere) { if (a = Math.sin(d), h = Math.cos(d), r = Math.cos(u), this.mode === this.OBLIQ || this.mode === this.EQUIT) { if ((i = this.mode === this.EQUIT ? 1 + h * r : 1 + this.sinph0 * a + this.cosph0 * h * r) <= EPSLN) return null; t = (i = Math.sqrt(2 / i)) * h * Math.sin(u), i *= this.mode === this.EQUIT ? a : this.cosph0 * a - this.sinph0 * h * r } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) { if (this.mode === this.N_POLE && (r = -r), Math.abs(d + this.lat0) < EPSLN) return null; i = FORTPI - .5 * d, t = (i = 2 * (this.mode === this.S_POLE ? Math.cos(i) : Math.sin(i))) * Math.sin(u), i *= r } } else { switch (s = 0, l = 0, c = 0, r = Math.cos(u), n = Math.sin(u), a = Math.sin(d), o = qsfnz(this.e, a), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (s = o / this.qp, l = Math.sqrt(1 - s * s)), this.mode) { case this.OBLIQ: c = 1 + this.sinb1 * s + this.cosb1 * l * r; break; case this.EQUIT: c = 1 + l * r; break; case this.N_POLE: c = HALF_PI + d, o = this.qp - o; break; case this.S_POLE: c = d - HALF_PI, o = this.qp + o }if (Math.abs(c) < EPSLN) return null; switch (this.mode) { case this.OBLIQ: case this.EQUIT: c = Math.sqrt(2 / c), i = this.mode === this.OBLIQ ? this.ymf * c * (this.cosb1 * s - this.sinb1 * l * r) : (c = Math.sqrt(2 / (1 + l * r))) * s * this.ymf, t = this.xmf * c * l * n; break; case this.N_POLE: case this.S_POLE: o >= 0 ? (t = (c = Math.sqrt(o)) * n, i = r * (this.mode === this.S_POLE ? c : -c)) : t = i = 0 } } return e.x = this.a * t + this.x0, e.y = this.a * i + this.y0, e } function inverse$h(e) { e.x -= this.x0, e.y -= this.y0; var t, i, r, n, a, o, s, l = e.x / this.a, c = e.y / this.a; if (this.sphere) { var h, u = 0, d = 0; if ((i = .5 * (h = Math.sqrt(l * l + c * c))) > 1) return null; switch (i = 2 * Math.asin(i), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (d = Math.sin(i), u = Math.cos(i)), this.mode) { case this.EQUIT: i = Math.abs(h) <= EPSLN ? 0 : Math.asin(c * d / h), l *= d, c = u * h; break; case this.OBLIQ: i = Math.abs(h) <= EPSLN ? this.lat0 : Math.asin(u * this.sinph0 + c * d * this.cosph0 / h), l *= d * this.cosph0, c = (u - Math.sin(i) * this.sinph0) * h; break; case this.N_POLE: c = -c, i = HALF_PI - i; break; case this.S_POLE: i -= HALF_PI }t = 0 !== c || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(l, c) : 0 } else { if (s = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) { if (l /= this.dd, c *= this.dd, (o = Math.sqrt(l * l + c * c)) < EPSLN) return e.x = this.long0, e.y = this.lat0, e; n = 2 * Math.asin(.5 * o / this.rq), r = Math.cos(n), l *= n = Math.sin(n), this.mode === this.OBLIQ ? (s = r * this.sinb1 + c * n * this.cosb1 / o, a = this.qp * s, c = o * this.cosb1 * r - c * this.sinb1 * n) : (s = c * n / o, a = this.qp * s, c = o * r) } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) { if (this.mode === this.N_POLE && (c = -c), !(a = l * l + c * c)) return e.x = this.long0, e.y = this.lat0, e; s = 1 - a / this.qp, this.mode === this.S_POLE && (s = -s) } t = Math.atan2(l, c), i = authlat(Math.asin(s), this.apa) } return e.x = adjust_lon(this.long0 + t), e.y = i, e } var P00 = .3333333333333333, P01 = .17222222222222222, P02 = .10257936507936508, P10 = .06388888888888888, P11 = .0664021164021164, P20 = .016415012942191543; function authset(e) { var t, i = []; return i[0] = e * P00, t = e * e, i[0] += t * P01, i[1] = t * P10, t *= e, i[0] += t * P02, i[1] += t * P11, i[2] = t * P20, i } function authlat(e, t) { var i = e + e; return e + t[0] * Math.sin(i) + t[1] * Math.sin(i + i) + t[2] * Math.sin(i + i + i) } var names$h = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"], laea = { init: init$h, forward: forward$h, inverse: inverse$h, names: names$h, S_POLE: S_POLE, N_POLE: N_POLE, EQUIT: EQUIT, OBLIQ: OBLIQ }; function asinz(e) { return Math.abs(e) > 1 && (e = e > 1 ? 1 : -1), Math.asin(e) } function init$g() { Math.abs(this.lat1 + this.lat2) < EPSLN || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po), this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po), this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po), Math.abs(this.lat1 - this.lat2) > EPSLN ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0) } function forward$g(e) { var t = e.x, i = e.y; this.sin_phi = Math.sin(i), this.cos_phi = Math.cos(i); var r = qsfnz(this.e3, this.sin_phi, this.cos_phi), n = this.a * Math.sqrt(this.c - this.ns0 * r) / this.ns0, a = this.ns0 * adjust_lon(t - this.long0), o = n * Math.sin(a) + this.x0, s = this.rh - n * Math.cos(a) + this.y0; return e.x = o, e.y = s, e } function inverse$g(e) { var t, i, r, n, a, o; return e.x -= this.x0, e.y = this.rh - e.y + this.y0, this.ns0 >= 0 ? (t = Math.sqrt(e.x * e.x + e.y * e.y), r = 1) : (t = -Math.sqrt(e.x * e.x + e.y * e.y), r = -1), n = 0, 0 !== t && (n = Math.atan2(r * e.x, r * e.y)), r = t * this.ns0 / this.a, this.sphere ? o = Math.asin((this.c - r * r) / (2 * this.ns0)) : (i = (this.c - r * r) / this.ns0, o = this.phi1z(this.e3, i)), a = adjust_lon(n / this.ns0 + this.long0), e.x = a, e.y = o, e } function phi1z(e, t) { var i, r, n, a, o = asinz(.5 * t); if (e < EPSLN) return o; for (var s = e * e, l = 1; l <= 25; l++)if (o += a = .5 * (n = 1 - (r = e * (i = Math.sin(o))) * r) * n / Math.cos(o) * (t / (1 - s) - i / n + .5 / e * Math.log((1 - r) / (1 + r))), Math.abs(a) <= 1e-7) return o; return null } var names$g = ["Albers_Conic_Equal_Area", "Albers", "aea"], aea = { init: init$g, forward: forward$g, inverse: inverse$g, names: names$g, phi1z: phi1z }; function init$f() { this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1 } function forward$f(e) { var t, i, r, n, a, o, s, l = e.x, c = e.y; return r = adjust_lon(l - this.long0), t = Math.sin(c), i = Math.cos(c), n = Math.cos(r), 1, (a = this.sin_p14 * t + this.cos_p14 * i * n) > 0 || Math.abs(a) <= EPSLN ? (o = this.x0 + 1 * this.a * i * Math.sin(r) / a, s = this.y0 + 1 * this.a * (this.cos_p14 * t - this.sin_p14 * i * n) / a) : (o = this.x0 + this.infinity_dist * i * Math.sin(r), s = this.y0 + this.infinity_dist * (this.cos_p14 * t - this.sin_p14 * i * n)), e.x = o, e.y = s, e } function inverse$f(e) { var t, i, r, n, a, o; return e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a, e.x /= this.k0, e.y /= this.k0, (t = Math.sqrt(e.x * e.x + e.y * e.y)) ? (n = Math.atan2(t, this.rc), i = Math.sin(n), o = asinz((r = Math.cos(n)) * this.sin_p14 + e.y * i * this.cos_p14 / t), a = Math.atan2(e.x * i, t * this.cos_p14 * r - e.y * this.sin_p14 * i), a = adjust_lon(this.long0 + a)) : (o = this.phic0, a = 0), e.x = a, e.y = o, e } var names$f = ["gnom"], gnom = { init: init$f, forward: forward$f, inverse: inverse$f, names: names$f }; function iqsfnz(e, t) { var i = 1 - (1 - e * e) / (2 * e) * Math.log((1 - e) / (1 + e)); if (Math.abs(Math.abs(t) - i) < 1e-6) return t < 0 ? -1 * HALF_PI : HALF_PI; for (var r, n, a, o, s = Math.asin(.5 * t), l = 0; l < 30; l++)if (n = Math.sin(s), a = Math.cos(s), o = e * n, s += r = Math.pow(1 - o * o, 2) / (2 * a) * (t / (1 - e * e) - n / (1 - o * o) + .5 / e * Math.log((1 - o) / (1 + o))), Math.abs(r) <= 1e-10) return s; return NaN } function init$e() { this.sphere || (this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts))) } function forward$e(e) { var t, i, r = e.x, n = e.y, a = adjust_lon(r - this.long0); if (this.sphere) t = this.x0 + this.a * a * Math.cos(this.lat_ts), i = this.y0 + this.a * Math.sin(n) / Math.cos(this.lat_ts); else { var o = qsfnz(this.e, Math.sin(n)); t = this.x0 + this.a * this.k0 * a, i = this.y0 + this.a * o * .5 / this.k0 } return e.x = t, e.y = i, e } function inverse$e(e) { var t, i; return e.x -= this.x0, e.y -= this.y0, this.sphere ? (t = adjust_lon(this.long0 + e.x / this.a / Math.cos(this.lat_ts)), i = Math.asin(e.y / this.a * Math.cos(this.lat_ts))) : (i = iqsfnz(this.e, 2 * e.y * this.k0 / this.a), t = adjust_lon(this.long0 + e.x / (this.a * this.k0))), e.x = t, e.y = i, e } var names$e = ["cea"], cea = { init: init$e, forward: forward$e, inverse: inverse$e, names: names$e }; function init$d() { this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts) } function forward$d(e) { var t = e.x, i = e.y, r = adjust_lon(t - this.long0), n = adjust_lat(i - this.lat0); return e.x = this.x0 + this.a * r * this.rc, e.y = this.y0 + this.a * n, e } function inverse$d(e) { var t = e.x, i = e.y; return e.x = adjust_lon(this.long0 + (t - this.x0) / (this.a * this.rc)), e.y = adjust_lat(this.lat0 + (i - this.y0) / this.a), e } var names$d = ["Equirectangular", "Equidistant_Cylindrical", "eqc"], eqc = { init: init$d, forward: forward$d, inverse: inverse$d, names: names$d }, MAX_ITER$1 = 20; function init$c() { this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = e0fn(this.es), this.e1 = e1fn(this.es), this.e2 = e2fn(this.es), this.e3 = e3fn(this.es), this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0) } function forward$c(e) { var t, i, r, n = e.x, a = e.y, o = adjust_lon(n - this.long0); if (r = o * Math.sin(a), this.sphere) Math.abs(a) <= EPSLN ? (t = this.a * o, i = -1 * this.a * this.lat0) : (t = this.a * Math.sin(r) / Math.tan(a), i = this.a * (adjust_lat(a - this.lat0) + (1 - Math.cos(r)) / Math.tan(a))); else if (Math.abs(a) <= EPSLN) t = this.a * o, i = -1 * this.ml0; else { var s = gN(this.a, this.e, Math.sin(a)) / Math.tan(a); t = s * Math.sin(r), i = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, a) - this.ml0 + s * (1 - Math.cos(r)) } return e.x = t + this.x0, e.y = i + this.y0, e } function inverse$c(e) { var t, i, r, n, a, o, s, l, c; if (r = e.x - this.x0, n = e.y - this.y0, this.sphere) if (Math.abs(n + this.a * this.lat0) <= EPSLN) t = adjust_lon(r / this.a + this.long0), i = 0; else { var h; for (o = this.lat0 + n / this.a, s = r * r / this.a / this.a + o * o, l = o, a = MAX_ITER$1; a; --a)if (l += c = -1 * (o * (l * (h = Math.tan(l)) + 1) - l - .5 * (l * l + s) * h) / ((l - o) / h - 1), Math.abs(c) <= EPSLN) { i = l; break } t = adjust_lon(this.long0 + Math.asin(r * Math.tan(l) / this.a) / Math.sin(i)) } else if (Math.abs(n + this.ml0) <= EPSLN) i = 0, t = adjust_lon(this.long0 + r / this.a); else { var u, d, p, f, m; for (o = (this.ml0 + n) / this.a, s = r * r / this.a / this.a + o * o, l = o, a = MAX_ITER$1; a; --a)if (m = this.e * Math.sin(l), u = Math.sqrt(1 - m * m) * Math.tan(l), d = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, l), p = this.e0 - 2 * this.e1 * Math.cos(2 * l) + 4 * this.e2 * Math.cos(4 * l) - 6 * this.e3 * Math.cos(6 * l), l -= c = (o * (u * (f = d / this.a) + 1) - f - .5 * u * (f * f + s)) / (this.es * Math.sin(2 * l) * (f * f + s - 2 * o * f) / (4 * u) + (o - f) * (u * p - 2 / Math.sin(2 * l)) - p), Math.abs(c) <= EPSLN) { i = l; break } u = Math.sqrt(1 - this.es * Math.pow(Math.sin(i), 2)) * Math.tan(i), t = adjust_lon(this.long0 + Math.asin(r * u / this.a) / Math.sin(i)) } return e.x = t, e.y = i, e } var names$c = ["Polyconic", "poly"], poly = { init: init$c, forward: forward$c, inverse: inverse$c, names: names$c }; function init$b() { this.A = [], this.A[1] = .6399175073, this.A[2] = -.1358797613, this.A[3] = .063294409, this.A[4] = -.02526853, this.A[5] = .0117879, this.A[6] = -.0055161, this.A[7] = .0026906, this.A[8] = -.001333, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = .7557853228, this.B_im[1] = 0, this.B_re[2] = .249204646, this.B_im[2] = .003371507, this.B_re[3] = -.001541739, this.B_im[3] = .04105856, this.B_re[4] = -.10162907, this.B_im[4] = .01727609, this.B_re[5] = -.26623489, this.B_im[5] = -.36249218, this.B_re[6] = -.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -.577245789, this.C_im[2] = -.007809598, this.C_re[3] = .508307513, this.C_im[3] = -.112208952, this.C_re[4] = -.15094762, this.C_im[4] = .18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = .5185406398, this.D[3] = -.03333098, this.D[4] = -.1052906, this.D[5] = -.0368594, this.D[6] = .007317, this.D[7] = .0122, this.D[8] = .00394, this.D[9] = -.0013 } function forward$b(e) { var t, i = e.x, r = e.y - this.lat0, n = i - this.long0, a = r / SEC_TO_RAD * 1e-5, o = n, s = 1, l = 0; for (t = 1; t <= 10; t++)s *= a, l += this.A[t] * s; var c, h = l, u = o, d = 1, p = 0, f = 0, m = 0; for (t = 1; t <= 6; t++)c = p * h + d * u, d = d * h - p * u, p = c, f = f + this.B_re[t] * d - this.B_im[t] * p, m = m + this.B_im[t] * d + this.B_re[t] * p; return e.x = m * this.a + this.x0, e.y = f * this.a + this.y0, e } function inverse$b(e) { var t, i, r = e.x, n = e.y, a = r - this.x0, o = (n - this.y0) / this.a, s = a / this.a, l = 1, c = 0, h = 0, u = 0; for (t = 1; t <= 6; t++)i = c * o + l * s, l = l * o - c * s, c = i, h = h + this.C_re[t] * l - this.C_im[t] * c, u = u + this.C_im[t] * l + this.C_re[t] * c; for (var d = 0; d < this.iterations; d++) { var p, f = h, m = u, g = o, y = s; for (t = 2; t <= 6; t++)p = m * h + f * u, f = f * h - m * u, m = p, g += (t - 1) * (this.B_re[t] * f - this.B_im[t] * m), y += (t - 1) * (this.B_im[t] * f + this.B_re[t] * m); f = 1, m = 0; var v = this.B_re[1], _ = this.B_im[1]; for (t = 2; t <= 6; t++)p = m * h + f * u, f = f * h - m * u, m = p, v += t * (this.B_re[t] * f - this.B_im[t] * m), _ += t * (this.B_im[t] * f + this.B_re[t] * m); var b = v * v + _ * _; h = (g * v + y * _) / b, u = (y * v - g * _) / b } var x = h, w = u, S = 1, M = 0; for (t = 1; t <= 9; t++)S *= x, M += this.D[t] * S; var T = this.lat0 + M * SEC_TO_RAD * 1e5, A = this.long0 + w; return e.x = A, e.y = T, e } var names$b = ["New_Zealand_Map_Grid", "nzmg"], nzmg = { init: init$b, forward: forward$b, inverse: inverse$b, names: names$b }; function init$a() { } function forward$a(e) { var t = e.x, i = e.y, r = adjust_lon(t - this.long0), n = this.x0 + this.a * r, a = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + i / 2.5)) * 1.25; return e.x = n, e.y = a, e } function inverse$a(e) { e.x -= this.x0, e.y -= this.y0; var t = adjust_lon(this.long0 + e.x / this.a), i = 2.5 * (Math.atan(Math.exp(.8 * e.y / this.a)) - Math.PI / 4); return e.x = t, e.y = i, e } var names$a = ["Miller_Cylindrical", "mill"], mill = { init: init$a, forward: forward$a, inverse: inverse$a, names: names$a }, MAX_ITER = 20; function init$9() { this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = pj_enfn(this.es) } function forward$9(e) { var t, i, r = e.x, n = e.y; if (r = adjust_lon(r - this.long0), this.sphere) { if (this.m) for (var a = this.n * Math.sin(n), o = MAX_ITER; o; --o) { var s = (this.m * n + Math.sin(n) - a) / (this.m + Math.cos(n)); if (n -= s, Math.abs(s) < EPSLN) break } else n = 1 !== this.n ? Math.asin(this.n * Math.sin(n)) : n; t = this.a * this.C_x * r * (this.m + Math.cos(n)), i = this.a * this.C_y * n } else { var l = Math.sin(n), c = Math.cos(n); i = this.a * pj_mlfn(n, l, c, this.en), t = this.a * r * c / Math.sqrt(1 - this.es * l * l) } return e.x = t, e.y = i, e } function inverse$9(e) { var t, i, r; return e.x -= this.x0, i = e.x / this.a, e.y -= this.y0, t = e.y / this.a, this.sphere ? (t /= this.C_y, i /= this.C_x * (this.m + Math.cos(t)), this.m ? t = asinz((this.m * t + Math.sin(t)) / this.n) : 1 !== this.n && (t = asinz(Math.sin(t) / this.n)), i = adjust_lon(i + this.long0), t = adjust_lat(t)) : (t = pj_inv_mlfn(e.y / this.a, this.es, this.en), (r = Math.abs(t)) < HALF_PI ? (r = Math.sin(t), i = adjust_lon(this.long0 + e.x * Math.sqrt(1 - this.es * r * r) / (this.a * Math.cos(t)))) : r - EPSLN < HALF_PI && (i = this.long0)), e.x = i, e.y = t, e } var names$9 = ["Sinusoidal", "sinu"], sinu = { init: init$9, forward: forward$9, inverse: inverse$9, names: names$9 }; function init$8() { } function forward$8(e) { for (var t = e.x, i = e.y, r = adjust_lon(t - this.long0), n = i, a = Math.PI * Math.sin(i); ;) { var o = -(n + Math.sin(n) - a) / (1 + Math.cos(n)); if (n += o, Math.abs(o) < EPSLN) break } n /= 2, Math.PI / 2 - Math.abs(i) < EPSLN && (r = 0); var s = .900316316158 * this.a * r * Math.cos(n) + this.x0, l = 1.4142135623731 * this.a * Math.sin(n) + this.y0; return e.x = s, e.y = l, e } function inverse$8(e) { var t, i; e.x -= this.x0, e.y -= this.y0, i = e.y / (1.4142135623731 * this.a), Math.abs(i) > .999999999999 && (i = .999999999999), t = Math.asin(i); var r = adjust_lon(this.long0 + e.x / (.900316316158 * this.a * Math.cos(t))); r < -Math.PI && (r = -Math.PI), r > Math.PI && (r = Math.PI), i = (2 * t + Math.sin(2 * t)) / Math.PI, Math.abs(i) > 1 && (i = 1); var n = Math.asin(i); return e.x = r, e.y = n, e } var names$8 = ["Mollweide", "moll"], moll = { init: init$8, forward: forward$8, inverse: inverse$8, names: names$8 }; function init$7() { Math.abs(this.lat1 + this.lat2) < EPSLN || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = e0fn(this.es), this.e1 = e1fn(this.es), this.e2 = e2fn(this.es), this.e3 = e3fn(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = msfnz(this.e, this.sinphi, this.cosphi), this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < EPSLN ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = msfnz(this.e, this.sinphi, this.cosphi), this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0)) } function forward$7(e) { var t, i = e.x, r = e.y; if (this.sphere) t = this.a * (this.g - r); else { var n = mlfn(this.e0, this.e1, this.e2, this.e3, r); t = this.a * (this.g - n) } var a = this.ns * adjust_lon(i - this.long0), o = this.x0 + t * Math.sin(a), s = this.y0 + this.rh - t * Math.cos(a); return e.x = o, e.y = s, e } function inverse$7(e) { var t, i, r, n; e.x -= this.x0, e.y = this.rh - e.y + this.y0, this.ns >= 0 ? (i = Math.sqrt(e.x * e.x + e.y * e.y), t = 1) : (i = -Math.sqrt(e.x * e.x + e.y * e.y), t = -1); var a = 0; return 0 !== i && (a = Math.atan2(t * e.x, t * e.y)), this.sphere ? (n = adjust_lon(this.long0 + a / this.ns), r = adjust_lat(this.g - i / this.a), e.x = n, e.y = r, e) : (r = imlfn(this.g - i / this.a, this.e0, this.e1, this.e2, this.e3), n = adjust_lon(this.long0 + a / this.ns), e.x = n, e.y = r, e) } var names$7 = ["Equidistant_Conic", "eqdc"], eqdc = { init: init$7, forward: forward$7, inverse: inverse$7, names: names$7 }; function init$6() { this.R = this.a } function forward$6(e) { var t, i, r = e.x, n = e.y, a = adjust_lon(r - this.long0); Math.abs(n) <= EPSLN && (t = this.x0 + this.R * a, i = this.y0); var o = asinz(2 * Math.abs(n / Math.PI)); (Math.abs(a) <= EPSLN || Math.abs(Math.abs(n) - HALF_PI) <= EPSLN) && (t = this.x0, i = n >= 0 ? this.y0 + Math.PI * this.R * Math.tan(.5 * o) : this.y0 + Math.PI * this.R * -Math.tan(.5 * o)); var s = .5 * Math.abs(Math.PI / a - a / Math.PI), l = s * s, c = Math.sin(o), h = Math.cos(o), u = h / (c + h - 1), d = u * u, p = u * (2 / c - 1), f = p * p, m = Math.PI * this.R * (s * (u - f) + Math.sqrt(l * (u - f) * (u - f) - (f + l) * (d - f))) / (f + l); a < 0 && (m = -m), t = this.x0 + m; var g = l + u; return m = Math.PI * this.R * (p * g - s * Math.sqrt((f + l) * (l + 1) - g * g)) / (f + l), i = n >= 0 ? this.y0 + m : this.y0 - m, e.x = t, e.y = i, e } function inverse$6(e) { var t, i, r, n, a, o, s, l, c, h, u, d; return e.x -= this.x0, e.y -= this.y0, u = Math.PI * this.R, a = (r = e.x / u) * r + (n = e.y / u) * n, u = 3 * (n * n / (l = -2 * (o = -Math.abs(n) * (1 + a)) + 1 + 2 * n * n + a * a) + (2 * (s = o - 2 * n * n + r * r) * s * s / l / l / l - 9 * o * s / l / l) / 27) / (c = (o - s * s / 3 / l) / l) / (h = 2 * Math.sqrt(-c / 3)), Math.abs(u) > 1 && (u = u >= 0 ? 1 : -1), d = Math.acos(u) / 3, i = e.y >= 0 ? (-h * Math.cos(d + Math.PI / 3) - s / 3 / l) * Math.PI : -(-h * Math.cos(d + Math.PI / 3) - s / 3 / l) * Math.PI, t = Math.abs(r) < EPSLN ? this.long0 : adjust_lon(this.long0 + Math.PI * (a - 1 + Math.sqrt(1 + 2 * (r * r - n * n) + a * a)) / 2 / r), e.x = t, e.y = i, e } var names$6 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"], vandg = { init: init$6, forward: forward$6, inverse: inverse$6, names: names$6 }; function init$5() { this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0) } function forward$5(e) { var t, i, r, n, a, o, s, l, c, h, u, d, p, f, m, g, y, v, _, b, x, w, S = e.x, M = e.y, T = Math.sin(e.y), A = Math.cos(e.y), E = adjust_lon(S - this.long0); return this.sphere ? Math.abs(this.sin_p12 - 1) <= EPSLN ? (e.x = this.x0 + this.a * (HALF_PI - M) * Math.sin(E), e.y = this.y0 - this.a * (HALF_PI - M) * Math.cos(E), e) : Math.abs(this.sin_p12 + 1) <= EPSLN ? (e.x = this.x0 + this.a * (HALF_PI + M) * Math.sin(E), e.y = this.y0 + this.a * (HALF_PI + M) * Math.cos(E), e) : (v = this.sin_p12 * T + this.cos_p12 * A * Math.cos(E), y = (g = Math.acos(v)) ? g / Math.sin(g) : 1, e.x = this.x0 + this.a * y * A * Math.sin(E), e.y = this.y0 + this.a * y * (this.cos_p12 * T - this.sin_p12 * A * Math.cos(E)), e) : (t = e0fn(this.es), i = e1fn(this.es), r = e2fn(this.es), n = e3fn(this.es), Math.abs(this.sin_p12 - 1) <= EPSLN ? (a = this.a * mlfn(t, i, r, n, HALF_PI), o = this.a * mlfn(t, i, r, n, M), e.x = this.x0 + (a - o) * Math.sin(E), e.y = this.y0 - (a - o) * Math.cos(E), e) : Math.abs(this.sin_p12 + 1) <= EPSLN ? (a = this.a * mlfn(t, i, r, n, HALF_PI), o = this.a * mlfn(t, i, r, n, M), e.x = this.x0 + (a + o) * Math.sin(E), e.y = this.y0 + (a + o) * Math.cos(E), e) : (s = T / A, l = gN(this.a, this.e, this.sin_p12), c = gN(this.a, this.e, T), h = Math.atan((1 - this.es) * s + this.es * l * this.sin_p12 / (c * A)), _ = 0 === (u = Math.atan2(Math.sin(E), this.cos_p12 * Math.tan(h) - this.sin_p12 * Math.cos(E))) ? Math.asin(this.cos_p12 * Math.sin(h) - this.sin_p12 * Math.cos(h)) : Math.abs(Math.abs(u) - Math.PI) <= EPSLN ? -Math.asin(this.cos_p12 * Math.sin(h) - this.sin_p12 * Math.cos(h)) : Math.asin(Math.sin(E) * Math.cos(h) / Math.sin(u)), d = this.e * this.sin_p12 / Math.sqrt(1 - this.es), g = l * _ * (1 - (b = _ * _) * (m = (p = this.e * this.cos_p12 * Math.cos(u) / Math.sqrt(1 - this.es)) * p) * (1 - m) / 6 + (x = b * _) / 8 * (f = d * p) * (1 - 2 * m) + (w = x * _) / 120 * (m * (4 - 7 * m) - 3 * d * d * (1 - 7 * m)) - w * _ / 48 * f), e.x = this.x0 + g * Math.sin(u), e.y = this.y0 + g * Math.cos(u), e)) } function inverse$5(e) { var t, i, r, n, a, o, s, l, c, h, u, d, p, f, m, g, y, v, _, b, x, w, S; if (e.x -= this.x0, e.y -= this.y0, this.sphere) { if ((t = Math.sqrt(e.x * e.x + e.y * e.y)) > 2 * HALF_PI * this.a) return; return i = t / this.a, r = Math.sin(i), n = Math.cos(i), a = this.long0, Math.abs(t) <= EPSLN ? o = this.lat0 : (o = asinz(n * this.sin_p12 + e.y * r * this.cos_p12 / t), s = Math.abs(this.lat0) - HALF_PI, a = Math.abs(s) <= EPSLN ? this.lat0 >= 0 ? adjust_lon(this.long0 + Math.atan2(e.x, -e.y)) : adjust_lon(this.long0 - Math.atan2(-e.x, e.y)) : adjust_lon(this.long0 + Math.atan2(e.x * r, t * this.cos_p12 * n - e.y * this.sin_p12 * r))), e.x = a, e.y = o, e } return l = e0fn(this.es), c = e1fn(this.es), h = e2fn(this.es), u = e3fn(this.es), Math.abs(this.sin_p12 - 1) <= EPSLN ? (o = imlfn(((d = this.a * mlfn(l, c, h, u, HALF_PI)) - (t = Math.sqrt(e.x * e.x + e.y * e.y))) / this.a, l, c, h, u), a = adjust_lon(this.long0 + Math.atan2(e.x, -1 * e.y)), e.x = a, e.y = o, e) : Math.abs(this.sin_p12 + 1) <= EPSLN ? (d = this.a * mlfn(l, c, h, u, HALF_PI), o = imlfn(((t = Math.sqrt(e.x * e.x + e.y * e.y)) - d) / this.a, l, c, h, u), a = adjust_lon(this.long0 + Math.atan2(e.x, e.y)), e.x = a, e.y = o, e) : (t = Math.sqrt(e.x * e.x + e.y * e.y), m = Math.atan2(e.x, e.y), p = gN(this.a, this.e, this.sin_p12), g = Math.cos(m), v = -(y = this.e * this.cos_p12 * g) * y / (1 - this.es), _ = 3 * this.es * (1 - v) * this.sin_p12 * this.cos_p12 * g / (1 - this.es), w = 1 - v * (x = (b = t / p) - v * (1 + v) * Math.pow(b, 3) / 6 - _ * (1 + 3 * v) * Math.pow(b, 4) / 24) * x / 2 - b * x * x * x / 6, f = Math.asin(this.sin_p12 * Math.cos(x) + this.cos_p12 * Math.sin(x) * g), a = adjust_lon(this.long0 + Math.asin(Math.sin(m) * Math.sin(x) / Math.cos(f))), S = Math.sin(f), o = Math.atan2((S - this.es * w * this.sin_p12) * Math.tan(f), S * (1 - this.es)), e.x = a, e.y = o, e) } var names$5 = ["Azimuthal_Equidistant", "aeqd"], aeqd = { init: init$5, forward: forward$5, inverse: inverse$5, names: names$5 }; function init$4() { this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0) } function forward$4(e) { var t, i, r, n, a, o, s, l = e.x, c = e.y; return r = adjust_lon(l - this.long0), t = Math.sin(c), i = Math.cos(c), n = Math.cos(r), 1, ((a = this.sin_p14 * t + this.cos_p14 * i * n) > 0 || Math.abs(a) <= EPSLN) && (o = 1 * this.a * i * Math.sin(r), s = this.y0 + 1 * this.a * (this.cos_p14 * t - this.sin_p14 * i * n)), e.x = o, e.y = s, e } function inverse$4(e) { var t, i, r, n, a, o, s; return e.x -= this.x0, e.y -= this.y0, i = asinz((t = Math.sqrt(e.x * e.x + e.y * e.y)) / this.a), r = Math.sin(i), n = Math.cos(i), o = this.long0, Math.abs(t) <= EPSLN ? (s = this.lat0, e.x = o, e.y = s, e) : (s = asinz(n * this.sin_p14 + e.y * r * this.cos_p14 / t), a = Math.abs(this.lat0) - HALF_PI, Math.abs(a) <= EPSLN ? (o = this.lat0 >= 0 ? adjust_lon(this.long0 + Math.atan2(e.x, -e.y)) : adjust_lon(this.long0 - Math.atan2(-e.x, e.y)), e.x = o, e.y = s, e) : (o = adjust_lon(this.long0 + Math.atan2(e.x * r, t * this.cos_p14 * n - e.y * this.sin_p14 * r)), e.x = o, e.y = s, e)) } var names$4 = ["ortho"], ortho = { init: init$4, forward: forward$4, inverse: inverse$4, names: names$4 }, FACE_ENUM = { FRONT: 1, RIGHT: 2, BACK: 3, LEFT: 4, TOP: 5, BOTTOM: 6 }, AREA_ENUM = { AREA_0: 1, AREA_1: 2, AREA_2: 3, AREA_3: 4 }; function init$3() { this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= HALF_PI - FORTPI / 2 ? this.face = FACE_ENUM.TOP : this.lat0 <= -(HALF_PI - FORTPI / 2) ? this.face = FACE_ENUM.BOTTOM : Math.abs(this.long0) <= FORTPI ? this.face = FACE_ENUM.FRONT : Math.abs(this.long0) <= HALF_PI + FORTPI ? this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT : this.face = FACE_ENUM.BACK, 0 !== this.es && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f) } function forward$3(e) { var t, i, r, n, a, o, s = { x: 0, y: 0 }, l = { value: 0 }; if (e.x -= this.long0, t = 0 !== this.es ? Math.atan(this.one_minus_f_squared * Math.tan(e.y)) : e.y, i = e.x, this.face === FACE_ENUM.TOP) n = HALF_PI - t, i >= FORTPI && i <= HALF_PI + FORTPI ? (l.value = AREA_ENUM.AREA_0, r = i - HALF_PI) : i > HALF_PI + FORTPI || i <= -(HALF_PI + FORTPI) ? (l.value = AREA_ENUM.AREA_1, r = i > 0 ? i - SPI : i + SPI) : i > -(HALF_PI + FORTPI) && i <= -FORTPI ? (l.value = AREA_ENUM.AREA_2, r = i + HALF_PI) : (l.value = AREA_ENUM.AREA_3, r = i); else if (this.face === FACE_ENUM.BOTTOM) n = HALF_PI + t, i >= FORTPI && i <= HALF_PI + FORTPI ? (l.value = AREA_ENUM.AREA_0, r = -i + HALF_PI) : i < FORTPI && i >= -FORTPI ? (l.value = AREA_ENUM.AREA_1, r = -i) : i < -FORTPI && i >= -(HALF_PI + FORTPI) ? (l.value = AREA_ENUM.AREA_2, r = -i - HALF_PI) : (l.value = AREA_ENUM.AREA_3, r = i > 0 ? -i + SPI : -i - SPI); else { var c, h, u, d, p, f; this.face === FACE_ENUM.RIGHT ? i = qsc_shift_lon_origin(i, +HALF_PI) : this.face === FACE_ENUM.BACK ? i = qsc_shift_lon_origin(i, +SPI) : this.face === FACE_ENUM.LEFT && (i = qsc_shift_lon_origin(i, -HALF_PI)), d = Math.sin(t), p = Math.cos(t), f = Math.sin(i), c = p * Math.cos(i), h = p * f, u = d, this.face === FACE_ENUM.FRONT ? r = qsc_fwd_equat_face_theta(n = Math.acos(c), u, h, l) : this.face === FACE_ENUM.RIGHT ? r = qsc_fwd_equat_face_theta(n = Math.acos(h), u, -c, l) : this.face === FACE_ENUM.BACK ? r = qsc_fwd_equat_face_theta(n = Math.acos(-c), u, -h, l) : this.face === FACE_ENUM.LEFT ? r = qsc_fwd_equat_face_theta(n = Math.acos(-h), u, c, l) : (n = r = 0, l.value = AREA_ENUM.AREA_0) } return o = Math.atan(12 / SPI * (r + Math.acos(Math.sin(r) * Math.cos(FORTPI)) - HALF_PI)), a = Math.sqrt((1 - Math.cos(n)) / (Math.cos(o) * Math.cos(o)) / (1 - Math.cos(Math.atan(1 / Math.cos(r))))), l.value === AREA_ENUM.AREA_1 ? o += HALF_PI : l.value === AREA_ENUM.AREA_2 ? o += SPI : l.value === AREA_ENUM.AREA_3 && (o += 1.5 * SPI), s.x = a * Math.cos(o), s.y = a * Math.sin(o), s.x = s.x * this.a + this.x0, s.y = s.y * this.a + this.y0, e.x = s.x, e.y = s.y, e } function inverse$3(e) { var t, i, r, n, a, o, s, l, c, h, u, d, p = { lam: 0, phi: 0 }, f = { value: 0 }; if (e.x = (e.x - this.x0) / this.a, e.y = (e.y - this.y0) / this.a, i = Math.atan(Math.sqrt(e.x * e.x + e.y * e.y)), t = Math.atan2(e.y, e.x), e.x >= 0 && e.x >= Math.abs(e.y) ? f.value = AREA_ENUM.AREA_0 : e.y >= 0 && e.y >= Math.abs(e.x) ? (f.value = AREA_ENUM.AREA_1, t -= HALF_PI) : e.x < 0 && -e.x >= Math.abs(e.y) ? (f.value = AREA_ENUM.AREA_2, t = t < 0 ? t + SPI : t - SPI) : (f.value = AREA_ENUM.AREA_3, t += HALF_PI), c = SPI / 12 * Math.tan(t), a = Math.sin(c) / (Math.cos(c) - 1 / Math.sqrt(2)), o = Math.atan(a), (s = 1 - (r = Math.cos(t)) * r * (n = Math.tan(i)) * n * (1 - Math.cos(Math.atan(1 / Math.cos(o))))) < -1 ? s = -1 : s > 1 && (s = 1), this.face === FACE_ENUM.TOP) l = Math.acos(s), p.phi = HALF_PI - l, f.value === AREA_ENUM.AREA_0 ? p.lam = o + HALF_PI : f.value === AREA_ENUM.AREA_1 ? p.lam = o < 0 ? o + SPI : o - SPI : f.value === AREA_ENUM.AREA_2 ? p.lam = o - HALF_PI : p.lam = o; else if (this.face === FACE_ENUM.BOTTOM) l = Math.acos(s), p.phi = l - HALF_PI, f.value === AREA_ENUM.AREA_0 ? p.lam = -o + HALF_PI : f.value === AREA_ENUM.AREA_1 ? p.lam = -o : f.value === AREA_ENUM.AREA_2 ? p.lam = -o - HALF_PI : p.lam = o < 0 ? -o - SPI : -o + SPI; else { var m, g, y; c = (m = s) * m, g = (c += (y = c >= 1 ? 0 : Math.sqrt(1 - c) * Math.sin(o)) * y) >= 1 ? 0 : Math.sqrt(1 - c), f.value === AREA_ENUM.AREA_1 ? (c = g, g = -y, y = c) : f.value === AREA_ENUM.AREA_2 ? (g = -g, y = -y) : f.value === AREA_ENUM.AREA_3 && (c = g, g = y, y = -c), this.face === FACE_ENUM.RIGHT ? (c = m, m = -g, g = c) : this.face === FACE_ENUM.BACK ? (m = -m, g = -g) : this.face === FACE_ENUM.LEFT && (c = m, m = g, g = -c), p.phi = Math.acos(-y) - HALF_PI, p.lam = Math.atan2(g, m), this.face === FACE_ENUM.RIGHT ? p.lam = qsc_shift_lon_origin(p.lam, -HALF_PI) : this.face === FACE_ENUM.BACK ? p.lam = qsc_shift_lon_origin(p.lam, -SPI) : this.face === FACE_ENUM.LEFT && (p.lam = qsc_shift_lon_origin(p.lam, +HALF_PI)) } 0 !== this.es && (h = p.phi < 0 ? 1 : 0, u = Math.tan(p.phi), d = this.b / Math.sqrt(u * u + this.one_minus_f_squared), p.phi = Math.atan(Math.sqrt(this.a * this.a - d * d) / (this.one_minus_f * d)), h && (p.phi = -p.phi)); return p.lam += this.long0, e.x = p.lam, e.y = p.phi, e } function qsc_fwd_equat_face_theta(e, t, i, r) { var n; return e < EPSLN ? (r.value = AREA_ENUM.AREA_0, n = 0) : (n = Math.atan2(t, i), Math.abs(n) <= FORTPI ? r.value = AREA_ENUM.AREA_0 : n > FORTPI && n <= HALF_PI + FORTPI ? (r.value = AREA_ENUM.AREA_1, n -= HALF_PI) : n > HALF_PI + FORTPI || n <= -(HALF_PI + FORTPI) ? (r.value = AREA_ENUM.AREA_2, n = n >= 0 ? n - SPI : n + SPI) : (r.value = AREA_ENUM.AREA_3, n += HALF_PI)), n } function qsc_shift_lon_origin(e, t) { var i = e + t; return i < -SPI ? i += TWO_PI : i > +SPI && (i -= TWO_PI), i } var names$3 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"], qsc = { init: init$3, forward: forward$3, inverse: inverse$3, names: names$3 }, COEFS_X = [[1, 22199e-21, -715515e-10, 31103e-10], [.9986, -482243e-9, -24897e-9, -13309e-10], [.9954, -83103e-8, -448605e-10, -9.86701e-7], [.99, -.00135364, -59661e-9, 36777e-10], [.9822, -.00167442, -449547e-11, -572411e-11], [.973, -.00214868, -903571e-10, 1.8736e-8], [.96, -.00305085, -900761e-10, 164917e-11], [.9427, -.00382792, -653386e-10, -26154e-10], [.9216, -.00467746, -10457e-8, 481243e-11], [.8962, -.00536223, -323831e-10, -543432e-11], [.8679, -.00609363, -113898e-9, 332484e-11], [.835, -.00698325, -640253e-10, 9.34959e-7], [.7986, -.00755338, -500009e-10, 9.35324e-7], [.7597, -.00798324, -35971e-9, -227626e-11], [.7186, -.00851367, -701149e-10, -86303e-10], [.6732, -.00986209, -199569e-9, 191974e-10], [.6213, -.010418, 883923e-10, 624051e-11], [.5722, -.00906601, 182e-6, 624051e-11], [.5322, -.00677797, 275608e-9, 624051e-11]], COEFS_Y = [[-520417e-23, .0124, 121431e-23, -845284e-16], [.062, .0124, -1.26793e-9, 4.22642e-10], [.124, .0124, 5.07171e-9, -1.60604e-9], [.186, .0123999, -1.90189e-8, 6.00152e-9], [.248, .0124002, 7.10039e-8, -2.24e-8], [.31, .0123992, -2.64997e-7, 8.35986e-8], [.372, .0124029, 9.88983e-7, -3.11994e-7], [.434, .0123893, -369093e-11, -4.35621e-7], [.4958, .0123198, -102252e-10, -3.45523e-7], [.5571, .0121916, -154081e-10, -5.82288e-7], [.6176, .0119938, -241424e-10, -5.25327e-7], [.6769, .011713, -320223e-10, -5.16405e-7], [.7346, .0113541, -397684e-10, -6.09052e-7], [.7903, .0109107, -489042e-10, -104739e-11], [.8435, .0103431, -64615e-9, -1.40374e-9], [.8936, .00969686, -64636e-9, -8547e-9], [.9394, .00840947, -192841e-9, -42106e-10], [.9761, .00616527, -256e-6, -42106e-10], [1, .00328947, -319159e-9, -42106e-10]], FXC = .8487, FYC = 1.3523, C1 = R2D / 5, RC1 = 1 / C1, NODES = 18, poly3_val = function (e, t) { return e[0] + t * (e[1] + t * (e[2] + t * e[3])) }, poly3_der = function (e, t) { return e[1] + t * (2 * e[2] + 3 * t * e[3]) }; function newton_rapshon(e, t, i, r) { for (var n = t; r; --r) { var a = e(n); if (n -= a, Math.abs(a) < i) break } return n } function init$2() { this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson" } function forward$2(e) { var t = adjust_lon(e.x - this.long0), i = Math.abs(e.y), r = Math.floor(i * C1); r < 0 ? r = 0 : r >= NODES && (r = NODES - 1), i = R2D * (i - RC1 * r); var n = { x: poly3_val(COEFS_X[r], i) * t, y: poly3_val(COEFS_Y[r], i) }; return e.y < 0 && (n.y = -n.y), n.x = n.x * this.a * FXC + this.x0, n.y = n.y * this.a * FYC + this.y0, n } function inverse$2(e) { var t = { x: (e.x - this.x0) / (this.a * FXC), y: Math.abs(e.y - this.y0) / (this.a * FYC) }; if (t.y >= 1) t.x /= COEFS_X[NODES][0], t.y = e.y < 0 ? -HALF_PI : HALF_PI; else { var i = Math.floor(t.y * NODES); for (i < 0 ? i = 0 : i >= NODES && (i = NODES - 1); ;)if (COEFS_Y[i][0] > t.y) --i; else { if (!(COEFS_Y[i + 1][0] <= t.y)) break; ++i } var r = COEFS_Y[i], n = 5 * (t.y - r[0]) / (COEFS_Y[i + 1][0] - r[0]); n = newton_rapshon((function (e) { return (poly3_val(r, e) - t.y) / poly3_der(r, e) }), n, EPSLN, 100), t.x /= poly3_val(COEFS_X[i], n), t.y = (5 * i + n) * D2R$1, e.y < 0 && (t.y = -t.y) } return t.x = adjust_lon(t.x + this.long0), t } var names$2 = ["Robinson", "robin"], robin = { init: init$2, forward: forward$2, inverse: inverse$2, names: names$2 }; function init$1() { this.name = "geocent" } function forward$1(e) { return geodeticToGeocentric(e, this.es, this.a) } function inverse$1(e) { return geocentricToGeodetic(e, this.es, this.a, this.b) } var names$1 = ["Geocentric", "geocentric", "geocent", "Geocent"], geocent = { init: init$1, forward: forward$1, inverse: inverse$1, names: names$1 }, mode = { N_POLE: 0, S_POLE: 1, EQUIT: 2, OBLIQ: 3 }, params$2 = { h: { def: 1e5, num: !0 }, azi: { def: 0, num: !0, degrees: !0 }, tilt: { def: 0, num: !0, degrees: !0 }, long0: { def: 0, num: !0 }, lat0: { def: 0, num: !0 } }; function init() { if (Object.keys(params$2).forEach(function (e) { if (void 0 === this[e]) this[e] = params$2[e].def; else { if (params$2[e].num && isNaN(this[e])) throw new Error("Invalid parameter value, must be numeric " + e + " = " + this[e]); params$2[e].num && (this[e] = parseFloat(this[e])) } params$2[e].degrees && (this[e] = this[e] * D2R$1) }.bind(this)), Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN ? this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE : Math.abs(this.lat0) < EPSLN ? this.mode = mode.EQUIT : (this.mode = mode.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10) throw new Error("Invalid height"); this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0; var e = this.tilt, t = this.azi; this.cg = Math.cos(t), this.sg = Math.sin(t), this.cw = Math.cos(e), this.sw = Math.sin(e) } function forward(e) { e.x -= this.long0; var t, i, r, n, a = Math.sin(e.y), o = Math.cos(e.y), s = Math.cos(e.x); switch (this.mode) { case mode.OBLIQ: i = this.sinph0 * a + this.cosph0 * o * s; break; case mode.EQUIT: i = o * s; break; case mode.S_POLE: i = -a; break; case mode.N_POLE: i = a }switch (t = (i = this.pn1 / (this.p - i)) * o * Math.sin(e.x), this.mode) { case mode.OBLIQ: i *= this.cosph0 * a - this.sinph0 * o * s; break; case mode.EQUIT: i *= a; break; case mode.N_POLE: i *= -o * s; break; case mode.S_POLE: i *= o * s }return n = 1 / ((r = i * this.cg + t * this.sg) * this.sw * this.h1 + this.cw), t = (t * this.cg - i * this.sg) * this.cw * n, i = r * n, e.x = t * this.a, e.y = i * this.a, e } function inverse(e) { e.x /= this.a, e.y /= this.a; var t, i, r, n = { x: e.x, y: e.y }; r = 1 / (this.pn1 - e.y * this.sw), t = this.pn1 * e.x * r, i = this.pn1 * e.y * this.cw * r, e.x = t * this.cg + i * this.sg, e.y = i * this.cg - t * this.sg; var a = hypot(e.x, e.y); if (Math.abs(a) < EPSLN) n.x = 0, n.y = e.y; else { var o, s; switch (s = 1 - a * a * this.pfact, s = (this.p - Math.sqrt(s)) / (this.pn1 / a + a / this.pn1), o = Math.sqrt(1 - s * s), this.mode) { case mode.OBLIQ: n.y = Math.asin(o * this.sinph0 + e.y * s * this.cosph0 / a), e.y = (o - this.sinph0 * Math.sin(n.y)) * a, e.x *= s * this.cosph0; break; case mode.EQUIT: n.y = Math.asin(e.y * s / a), e.y = o * a, e.x *= s; break; case mode.N_POLE: n.y = Math.asin(o), e.y = -e.y; break; case mode.S_POLE: n.y = -Math.asin(o) }n.x = Math.atan2(e.x, e.y) } return e.x = n.x + this.long0, e.y = n.y, e } var names = ["Tilted_Perspective", "tpers"], tpers = { init: init, forward: forward, inverse: inverse, names: names }; function includedProjections(e) { e.Proj.projections.add(tmerc), e.Proj.projections.add(etmerc), e.Proj.projections.add(utm), e.Proj.projections.add(sterea), e.Proj.projections.add(stere), e.Proj.projections.add(somerc), e.Proj.projections.add(omerc), e.Proj.projections.add(lcc), e.Proj.projections.add(krovak), e.Proj.projections.add(cass), e.Proj.projections.add(laea), e.Proj.projections.add(aea), e.Proj.projections.add(gnom), e.Proj.projections.add(cea), e.Proj.projections.add(eqc), e.Proj.projections.add(poly), e.Proj.projections.add(nzmg), e.Proj.projections.add(mill), e.Proj.projections.add(sinu), e.Proj.projections.add(moll), e.Proj.projections.add(eqdc), e.Proj.projections.add(vandg), e.Proj.projections.add(aeqd), e.Proj.projections.add(ortho), e.Proj.projections.add(qsc), e.Proj.projections.add(robin), e.Proj.projections.add(geocent), e.Proj.projections.add(tpers) } function guid() { function e() { return (65536 * (1 + Math.random()) | 0).toString(16).substring(1) } return e() + e() + "-" + e() + "-" + e() + "-" + e() + "-" + e() + e() + e() } proj4.defaultDatum = "WGS84", proj4.Proj = Projection, proj4.WGS84 = new proj4.Proj("WGS84"), proj4.Point = Point, proj4.toPoint = common, proj4.defs = defs, proj4.nadgrid = nadgrid, proj4.transform = transform, proj4.mgrs = mgrs, proj4.version = "__VERSION__", includedProjections(proj4); class Map$1 { constructor({ id: e = guid(), name: t = "", type: i = "color", source: r = "", intensity: n = 1 } = {}) { this._id = e, this._name = t, this._type = i, this._source = r, this._intensity = n } get id() { return this._id } get name() { return this._name } set name(e) { this._name = e } get type() { return this._type } set type(e) { this._type = e } get source() { return this._source } set source(e) { this._source = e } get intensity() { return this._intensity } set intensity(e) { this._intensity = e } getCanvas({ width: e, height: t, adjust: i = "auto", pixelRatio: r = 1 } = {}) { if (this._source) switch (this._type.toLowerCase()) { case "color": return this._colorCanvas || (this._colorCanvas = this.createColorCanvas({ width: e, width: t })), this._colorCanvas; case "file": return; case "imagebitmap": return void (this._canvas || (this._canvas = this.createCanvas({ width: e, width: t }))) } } createCanvas({ width: e, height: t, adjust: i } = {}) { if ("imagebitmap" !== this._type) return; let r = document.createElement("canvas"); return r.width = e || this._source.width, r.height = t || this._source.height, r.getContext("2d").drawImage(this._source, 0, 0), r } createColorCanvas({ width: e, height: t }) { let i = document.createElement("canvas"); return i.width = e || 64, i.height = t || 64, i.getContext("2d").fillStyle = this._source || "#ffffaa", i.getContext("2d").fillRect(0, 0, e || 64, t || 64), i } destroyCanvas() { this._canvas || this._canvas.parentElement.removeChild(this._canvas) } isColor() { return "color" === this._type.toLowerCase() } isFile() { return "file" === this._type.toLowerCase() } isImageBitmap() { return "imagebitmap" === this._type.toLowerCase() } isTexture() { return this.isFile() || this.isImageBitmap() } } Map$1._fromThreeObject = function (e, t) { if (!e) return new Map$1({ source: t }); let i = new Map$1({ id: e.uuid, name: e.name }); return e.image && (i.type = "imagebitmap", i.source = e.image, i.intensity = 1), i }; let ArticulationTypes = { numeric: "numeric", enum: "enum", boolean: "boolean", text: "text" }; var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function getAugmentedNamespace(e) { if (e.__esModule) return e; var t = Object.defineProperty({}, "__esModule", { value: !0 }); return Object.keys(e).forEach((function (i) { var r = Object.getOwnPropertyDescriptor(e, i); Object.defineProperty(t, i, r.get ? r : { enumerable: !0, get: function () { return e[i] } }) })), t } function createCommonjsModule(e) { var t = { exports: {} }; return e(t, t.exports), t.exports } function commonjsRequire(e) { throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.') }
/**
   * [js-md5]{@link https://github.com/emn178/js-md5}
   *
   * @namespace md5
   * @version 0.7.3
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   */var md5 = createCommonjsModule((function (module) { (function () { var ERROR = "input is invalid type", WINDOW = "object" == typeof window, root = WINDOW ? window : {}; root.JS_MD5_NO_WINDOW && (WINDOW = !1); var WEB_WORKER = !WINDOW && "object" == typeof self, NODE_JS = !root.JS_MD5_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node; NODE_JS ? root = commonjsGlobal : WEB_WORKER && (root = self); var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && module.exports, ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer, HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [128, 32768, 8388608, -2147483648], SHIFT = [0, 8, 16, 24], OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer", "base64"], BASE64_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), blocks = [], buffer8; if (ARRAY_BUFFER) { var buffer = new ArrayBuffer(68); buffer8 = new Uint8Array(buffer), blocks = new Uint32Array(buffer) } !root.JS_MD5_NO_NODE_JS && Array.isArray || (Array.isArray = function (e) { return "[object Array]" === Object.prototype.toString.call(e) }), !ARRAY_BUFFER || !root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function (e) { return "object" == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer }); var createOutputMethod = function (e) { return function (t) { return new Md5(!0).update(t)[e]() } }, createMethod = function () { var e = createOutputMethod("hex"); NODE_JS && (e = nodeWrap(e)), e.create = function () { return new Md5 }, e.update = function (t) { return e.create().update(t) }; for (var t = 0; t < OUTPUT_TYPES.length; ++t) { var i = OUTPUT_TYPES[t]; e[i] = createOutputMethod(i) } return e }, nodeWrap = function (method) { var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), nodeMethod = function (e) { if ("string" == typeof e) return crypto.createHash("md5").update(e, "utf8").digest("hex"); if (null == e) throw ERROR; return e.constructor === ArrayBuffer && (e = new Uint8Array(e)), Array.isArray(e) || ArrayBuffer.isView(e) || e.constructor === Buffer ? crypto.createHash("md5").update(new Buffer(e)).digest("hex") : method(e) }; return nodeMethod }; function Md5(e) { if (e) blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks, this.buffer8 = buffer8; else if (ARRAY_BUFFER) { var t = new ArrayBuffer(68); this.buffer8 = new Uint8Array(t), this.blocks = new Uint32Array(t) } else this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0 } Md5.prototype.update = function (e) { if (!this.finalized) { var t, i = typeof e; if ("string" !== i) { if ("object" !== i) throw ERROR; if (null === e) throw ERROR; if (ARRAY_BUFFER && e.constructor === ArrayBuffer) e = new Uint8Array(e); else if (!(Array.isArray(e) || ARRAY_BUFFER && ArrayBuffer.isView(e))) throw ERROR; t = !0 } for (var r, n, a = 0, o = e.length, s = this.blocks, l = this.buffer8; a < o;) { if (this.hashed && (this.hashed = !1, s[0] = s[16], s[16] = s[1] = s[2] = s[3] = s[4] = s[5] = s[6] = s[7] = s[8] = s[9] = s[10] = s[11] = s[12] = s[13] = s[14] = s[15] = 0), t) if (ARRAY_BUFFER) for (n = this.start; a < o && n < 64; ++a)l[n++] = e[a]; else for (n = this.start; a < o && n < 64; ++a)s[n >> 2] |= e[a] << SHIFT[3 & n++]; else if (ARRAY_BUFFER) for (n = this.start; a < o && n < 64; ++a)(r = e.charCodeAt(a)) < 128 ? l[n++] = r : r < 2048 ? (l[n++] = 192 | r >> 6, l[n++] = 128 | 63 & r) : r < 55296 || r >= 57344 ? (l[n++] = 224 | r >> 12, l[n++] = 128 | r >> 6 & 63, l[n++] = 128 | 63 & r) : (r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(++a)), l[n++] = 240 | r >> 18, l[n++] = 128 | r >> 12 & 63, l[n++] = 128 | r >> 6 & 63, l[n++] = 128 | 63 & r); else for (n = this.start; a < o && n < 64; ++a)(r = e.charCodeAt(a)) < 128 ? s[n >> 2] |= r << SHIFT[3 & n++] : r < 2048 ? (s[n >> 2] |= (192 | r >> 6) << SHIFT[3 & n++], s[n >> 2] |= (128 | 63 & r) << SHIFT[3 & n++]) : r < 55296 || r >= 57344 ? (s[n >> 2] |= (224 | r >> 12) << SHIFT[3 & n++], s[n >> 2] |= (128 | r >> 6 & 63) << SHIFT[3 & n++], s[n >> 2] |= (128 | 63 & r) << SHIFT[3 & n++]) : (r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(++a)), s[n >> 2] |= (240 | r >> 18) << SHIFT[3 & n++], s[n >> 2] |= (128 | r >> 12 & 63) << SHIFT[3 & n++], s[n >> 2] |= (128 | r >> 6 & 63) << SHIFT[3 & n++], s[n >> 2] |= (128 | 63 & r) << SHIFT[3 & n++]); this.lastByteIndex = n, this.bytes += n - this.start, n >= 64 ? (this.start = n - 64, this.hash(), this.hashed = !0) : this.start = n } return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this } }, Md5.prototype.finalize = function () { if (!this.finalized) { this.finalized = !0; var e = this.blocks, t = this.lastByteIndex; e[t >> 2] |= EXTRA[3 & t], t >= 56 && (this.hashed || this.hash(), e[0] = e[16], e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0), e[14] = this.bytes << 3, e[15] = this.hBytes << 3 | this.bytes >>> 29, this.hash() } }, Md5.prototype.hash = function () { var e, t, i, r, n, a, o = this.blocks; this.first ? t = ((t = ((e = ((e = o[0] - 680876937) << 7 | e >>> 25) - 271733879 << 0) ^ (i = ((i = (-271733879 ^ (r = ((r = (-1732584194 ^ 2004318071 & e) + o[1] - 117830708) << 12 | r >>> 20) + e << 0) & (-271733879 ^ e)) + o[2] - 1126478375) << 17 | i >>> 15) + r << 0) & (r ^ e)) + o[3] - 1316259209) << 22 | t >>> 10) + i << 0 : (e = this.h0, t = this.h1, i = this.h2, t = ((t += ((e = ((e += ((r = this.h3) ^ t & (i ^ r)) + o[0] - 680876936) << 7 | e >>> 25) + t << 0) ^ (i = ((i += (t ^ (r = ((r += (i ^ e & (t ^ i)) + o[1] - 389564586) << 12 | r >>> 20) + e << 0) & (e ^ t)) + o[2] + 606105819) << 17 | i >>> 15) + r << 0) & (r ^ e)) + o[3] - 1044525330) << 22 | t >>> 10) + i << 0), t = ((t += ((e = ((e += (r ^ t & (i ^ r)) + o[4] - 176418897) << 7 | e >>> 25) + t << 0) ^ (i = ((i += (t ^ (r = ((r += (i ^ e & (t ^ i)) + o[5] + 1200080426) << 12 | r >>> 20) + e << 0) & (e ^ t)) + o[6] - 1473231341) << 17 | i >>> 15) + r << 0) & (r ^ e)) + o[7] - 45705983) << 22 | t >>> 10) + i << 0, t = ((t += ((e = ((e += (r ^ t & (i ^ r)) + o[8] + 1770035416) << 7 | e >>> 25) + t << 0) ^ (i = ((i += (t ^ (r = ((r += (i ^ e & (t ^ i)) + o[9] - 1958414417) << 12 | r >>> 20) + e << 0) & (e ^ t)) + o[10] - 42063) << 17 | i >>> 15) + r << 0) & (r ^ e)) + o[11] - 1990404162) << 22 | t >>> 10) + i << 0, t = ((t += ((e = ((e += (r ^ t & (i ^ r)) + o[12] + 1804603682) << 7 | e >>> 25) + t << 0) ^ (i = ((i += (t ^ (r = ((r += (i ^ e & (t ^ i)) + o[13] - 40341101) << 12 | r >>> 20) + e << 0) & (e ^ t)) + o[14] - 1502002290) << 17 | i >>> 15) + r << 0) & (r ^ e)) + o[15] + 1236535329) << 22 | t >>> 10) + i << 0, t = ((t += ((r = ((r += (t ^ i & ((e = ((e += (i ^ r & (t ^ i)) + o[1] - 165796510) << 5 | e >>> 27) + t << 0) ^ t)) + o[6] - 1069501632) << 9 | r >>> 23) + e << 0) ^ e & ((i = ((i += (e ^ t & (r ^ e)) + o[11] + 643717713) << 14 | i >>> 18) + r << 0) ^ r)) + o[0] - 373897302) << 20 | t >>> 12) + i << 0, t = ((t += ((r = ((r += (t ^ i & ((e = ((e += (i ^ r & (t ^ i)) + o[5] - 701558691) << 5 | e >>> 27) + t << 0) ^ t)) + o[10] + 38016083) << 9 | r >>> 23) + e << 0) ^ e & ((i = ((i += (e ^ t & (r ^ e)) + o[15] - 660478335) << 14 | i >>> 18) + r << 0) ^ r)) + o[4] - 405537848) << 20 | t >>> 12) + i << 0, t = ((t += ((r = ((r += (t ^ i & ((e = ((e += (i ^ r & (t ^ i)) + o[9] + 568446438) << 5 | e >>> 27) + t << 0) ^ t)) + o[14] - 1019803690) << 9 | r >>> 23) + e << 0) ^ e & ((i = ((i += (e ^ t & (r ^ e)) + o[3] - 187363961) << 14 | i >>> 18) + r << 0) ^ r)) + o[8] + 1163531501) << 20 | t >>> 12) + i << 0, t = ((t += ((r = ((r += (t ^ i & ((e = ((e += (i ^ r & (t ^ i)) + o[13] - 1444681467) << 5 | e >>> 27) + t << 0) ^ t)) + o[2] - 51403784) << 9 | r >>> 23) + e << 0) ^ e & ((i = ((i += (e ^ t & (r ^ e)) + o[7] + 1735328473) << 14 | i >>> 18) + r << 0) ^ r)) + o[12] - 1926607734) << 20 | t >>> 12) + i << 0, t = ((t += ((a = (r = ((r += ((n = t ^ i) ^ (e = ((e += (n ^ r) + o[5] - 378558) << 4 | e >>> 28) + t << 0)) + o[8] - 2022574463) << 11 | r >>> 21) + e << 0) ^ e) ^ (i = ((i += (a ^ t) + o[11] + 1839030562) << 16 | i >>> 16) + r << 0)) + o[14] - 35309556) << 23 | t >>> 9) + i << 0, t = ((t += ((a = (r = ((r += ((n = t ^ i) ^ (e = ((e += (n ^ r) + o[1] - 1530992060) << 4 | e >>> 28) + t << 0)) + o[4] + 1272893353) << 11 | r >>> 21) + e << 0) ^ e) ^ (i = ((i += (a ^ t) + o[7] - 155497632) << 16 | i >>> 16) + r << 0)) + o[10] - 1094730640) << 23 | t >>> 9) + i << 0, t = ((t += ((a = (r = ((r += ((n = t ^ i) ^ (e = ((e += (n ^ r) + o[13] + 681279174) << 4 | e >>> 28) + t << 0)) + o[0] - 358537222) << 11 | r >>> 21) + e << 0) ^ e) ^ (i = ((i += (a ^ t) + o[3] - 722521979) << 16 | i >>> 16) + r << 0)) + o[6] + 76029189) << 23 | t >>> 9) + i << 0, t = ((t += ((a = (r = ((r += ((n = t ^ i) ^ (e = ((e += (n ^ r) + o[9] - 640364487) << 4 | e >>> 28) + t << 0)) + o[12] - 421815835) << 11 | r >>> 21) + e << 0) ^ e) ^ (i = ((i += (a ^ t) + o[15] + 530742520) << 16 | i >>> 16) + r << 0)) + o[2] - 995338651) << 23 | t >>> 9) + i << 0, t = ((t += ((r = ((r += (t ^ ((e = ((e += (i ^ (t | ~r)) + o[0] - 198630844) << 6 | e >>> 26) + t << 0) | ~i)) + o[7] + 1126891415) << 10 | r >>> 22) + e << 0) ^ ((i = ((i += (e ^ (r | ~t)) + o[14] - 1416354905) << 15 | i >>> 17) + r << 0) | ~e)) + o[5] - 57434055) << 21 | t >>> 11) + i << 0, t = ((t += ((r = ((r += (t ^ ((e = ((e += (i ^ (t | ~r)) + o[12] + 1700485571) << 6 | e >>> 26) + t << 0) | ~i)) + o[3] - 1894986606) << 10 | r >>> 22) + e << 0) ^ ((i = ((i += (e ^ (r | ~t)) + o[10] - 1051523) << 15 | i >>> 17) + r << 0) | ~e)) + o[1] - 2054922799) << 21 | t >>> 11) + i << 0, t = ((t += ((r = ((r += (t ^ ((e = ((e += (i ^ (t | ~r)) + o[8] + 1873313359) << 6 | e >>> 26) + t << 0) | ~i)) + o[15] - 30611744) << 10 | r >>> 22) + e << 0) ^ ((i = ((i += (e ^ (r | ~t)) + o[6] - 1560198380) << 15 | i >>> 17) + r << 0) | ~e)) + o[13] + 1309151649) << 21 | t >>> 11) + i << 0, t = ((t += ((r = ((r += (t ^ ((e = ((e += (i ^ (t | ~r)) + o[4] - 145523070) << 6 | e >>> 26) + t << 0) | ~i)) + o[11] - 1120210379) << 10 | r >>> 22) + e << 0) ^ ((i = ((i += (e ^ (r | ~t)) + o[2] + 718787259) << 15 | i >>> 17) + r << 0) | ~e)) + o[9] - 343485551) << 21 | t >>> 11) + i << 0, this.first ? (this.h0 = e + 1732584193 << 0, this.h1 = t - 271733879 << 0, this.h2 = i - 1732584194 << 0, this.h3 = r + 271733878 << 0, this.first = !1) : (this.h0 = this.h0 + e << 0, this.h1 = this.h1 + t << 0, this.h2 = this.h2 + i << 0, this.h3 = this.h3 + r << 0) }, Md5.prototype.hex = function () { this.finalize(); var e = this.h0, t = this.h1, i = this.h2, r = this.h3; return HEX_CHARS[e >> 4 & 15] + HEX_CHARS[15 & e] + HEX_CHARS[e >> 12 & 15] + HEX_CHARS[e >> 8 & 15] + HEX_CHARS[e >> 20 & 15] + HEX_CHARS[e >> 16 & 15] + HEX_CHARS[e >> 28 & 15] + HEX_CHARS[e >> 24 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[15 & t] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[i >> 4 & 15] + HEX_CHARS[15 & i] + HEX_CHARS[i >> 12 & 15] + HEX_CHARS[i >> 8 & 15] + HEX_CHARS[i >> 20 & 15] + HEX_CHARS[i >> 16 & 15] + HEX_CHARS[i >> 28 & 15] + HEX_CHARS[i >> 24 & 15] + HEX_CHARS[r >> 4 & 15] + HEX_CHARS[15 & r] + HEX_CHARS[r >> 12 & 15] + HEX_CHARS[r >> 8 & 15] + HEX_CHARS[r >> 20 & 15] + HEX_CHARS[r >> 16 & 15] + HEX_CHARS[r >> 28 & 15] + HEX_CHARS[r >> 24 & 15] }, Md5.prototype.toString = Md5.prototype.hex, Md5.prototype.digest = function () { this.finalize(); var e = this.h0, t = this.h1, i = this.h2, r = this.h3; return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255, 255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255, 255 & i, i >> 8 & 255, i >> 16 & 255, i >> 24 & 255, 255 & r, r >> 8 & 255, r >> 16 & 255, r >> 24 & 255] }, Md5.prototype.array = Md5.prototype.digest, Md5.prototype.arrayBuffer = function () { this.finalize(); var e = new ArrayBuffer(16), t = new Uint32Array(e); return t[0] = this.h0, t[1] = this.h1, t[2] = this.h2, t[3] = this.h3, e }, Md5.prototype.buffer = Md5.prototype.arrayBuffer, Md5.prototype.base64 = function () { for (var e, t, i, r = "", n = this.array(), a = 0; a < 15;)e = n[a++], t = n[a++], i = n[a++], r += BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[63 & (e << 4 | t >>> 4)] + BASE64_ENCODE_CHAR[63 & (t << 2 | i >>> 6)] + BASE64_ENCODE_CHAR[63 & i]; return e = n[a], r += BASE64_ENCODE_CHAR[e >>> 2] + BASE64_ENCODE_CHAR[e << 4 & 63] + "==" }; var exports = createMethod(); COMMON_JS ? module.exports = exports : root.md5 = exports })() })); window.logger = { debug: function () { }, info: function () { }, warn: function () { }, error: function () { }, dir: function () { }, time: function () { }, timeEnd: function () { } }, window.isDebug && (window.logger = { debug: console.debug.bind(window.console), info: console.info.bind(window.console), warn: console.warn.bind(window.console), error: console.error.bind(window.console), dir: console.dir.bind(window.console), time: console.time.bind(window.console), timeEnd: console.timeEnd.bind(window.console) }); const VECTOR3_Y_AXIS = new Vector3(0, 1, 0), EARTH_RADIUS = 6378137; proj4.defs("GEOCCS", "+proj=geocent +datum=WGS84"), proj4.defs("WGS84", "+proj=longlat +datum=WGS84 +no_defs"), proj4.defs("EPSG:3857", "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"); var util$1 = { degreeToRadian: (e = 0) => e / 180 * Math.PI, lookupSkyboxFogColor: (e, t) => { let i = "#cccccc"; switch (t) { case ACESFilmicToneMapping: e.toLowerCase().indexOf("skybox-day") >= 0 && e.toLowerCase().indexOf("skybox-day2") < 0 && (i = "#919da9"), e.toLowerCase().indexOf("skybox-dusk") >= 0 && (i = "#a68d7c"), e.toLowerCase().indexOf("skybox-night") >= 0 && (i = "#1f5074"), e.toLowerCase().indexOf("skybox-day2") >= 0 && (i = "#94a8ac"), e.toLowerCase().indexOf("skybox-white") >= 0 && (i = "#7d8d98"), e.toLowerCase().indexOf("skybox-blue") >= 0 && (i = "#021629"), e.toLowerCase().indexOf("skybox-blue07") >= 0 && (i = "#053452"), e.toLowerCase().indexOf("skybox-real") >= 0 && (i = "#081225"), e.toLowerCase().indexOf("skyboxsun25deg") >= 0 && (i = "#a7a399"), e.toLowerCase().indexOf("pisa") >= 0 && (i = "#9a805b"), e.toLowerCase().indexOf("skybox-day-10") >= 0 && (i = "#a4d9e7"), e.toLowerCase().indexOf("skybox-day-18") >= 0 && (i = "#bae1f0"), e.toLowerCase().indexOf("skybox-dusk-4") >= 0 && (i = "#e79f86"), e.toLowerCase().indexOf("skybox-dusk-6") >= 0 && (i = "#d1ab87"), e.toLowerCase().indexOf("skybox-night-3") >= 0 && (i = "#20517a"), e.toLowerCase().indexOf("skybox-night-24") >= 0 && (i = "#11192c"); break; default: e.toLowerCase().indexOf("skybox-day") >= 0 && e.toLowerCase().indexOf("skybox-day2") < 0 && (i = "#a0bee0"), e.toLowerCase().indexOf("skybox-dusk") >= 0 && (i = "#d39c7d"), e.toLowerCase().indexOf("skybox-night") >= 0 && (i = "#20517a"), e.toLowerCase().indexOf("skybox-day2") >= 0 && (i = "#94a8ac"), e.toLowerCase().indexOf("skybox-white") >= 0 && (i = "#7d8d98"), e.toLowerCase().indexOf("skybox-blue") >= 0 && (i = "#021629"), e.toLowerCase().indexOf("skybox-blue07") >= 0 && (i = "#053452"), e.toLowerCase().indexOf("skybox-real") >= 0 && (i = "#081225"), e.toLowerCase().indexOf("skyboxsun25deg") >= 0 && (i = "#a7a399"), e.toLowerCase().indexOf("pisa") >= 0 && (i = "#9a805b"), e.toLowerCase().indexOf("skybox-day-10") >= 0 && (i = "#a4d8e6"), e.toLowerCase().indexOf("skybox-day-18") >= 0 && (i = "#a4d8e6"), e.toLowerCase().indexOf("skybox-dusk-4") >= 0 && (i = "#e79f86"), e.toLowerCase().indexOf("skybox-dusk-6") >= 0 && (i = "#d1ab87"), e.toLowerCase().indexOf("skybox-night-3") >= 0 && (i = "#20517a"), e.toLowerCase().indexOf("skybox-night-24") >= 0 && (i = "#11192c"), e.toLowerCase().indexOf("sdr-none") >= 0 && (i = "#343434"), e.toLowerCase().indexOf("sdr-studio-03") >= 0 && (i = "#d1d1c9") }const r = new Color$1(i); switch (_context.renderer.outputEncoding) { case sRGBEncoding: r.convertLinearToSRGB(); break; case GammaEncoding: r.convertLinearToGamma() }return `#${r.getHexString()}` }, findModelInThree: (e, t) => { if (!e || !t) return; let i; return e.children instanceof Array && e.children.length > 0 && (i = e.children.find((e => e.name === t))), i }, findNodeInThree: (e, t) => { if (!e || !t) return; let i; return e.children instanceof Array && e.children.length > 0 && e.traverse((e => { e.name === t && (i = e) })), i }, findNodeRecursively: (e, t) => { if (t && t.children && t.children instanceof Array && 0 !== t.children.length) for (let i of t.children) { if (i.name === e) return i; if (i.children instanceof Array && i.children.length > 0) { let t = util$1.findNodeRecursively(e, i); if (t) return t } } }, setThreePropertyRecursively: (e, t, i) => { logger.debug("TRACE: util.setThreePropertyRecursively() - Entering.", e, t, i), e.children instanceof Array && e.children.length > 0 && e.traverse((e => { logger.debug("TRACE: util.setThreePropertyRecursively() - traverse.", e, t, i, util$1.clone(i)), e[t] = util$1.clone(i) })), logger.debug("TRACE: util.setThreePropertyRecursively() - Exiting.") }, setNodePropertyRecursively: (e, t, i) => { if (logger.debug("TRACE: util.setNodePropertyRecursively() - Entering.", e, t, i), e.children && e.children instanceof Array && 0 !== e.children.length) { for (let r of e.children) logger.debug("TRACE: util.setNodePropertyRecursively() - traverse.", r, t, i, util$1.clone(i)), r[t] = util$1.clone(i), r.children instanceof Array && r.children.length > 0 && util$1.setNodePropertyRecursively(r, t, i); logger.debug("TRACE: util.setNodePropertyRecursively() - Exiting.") } else logger.debug("TRACE: util.setNodePropertyRecursively() - Exiting.") }, capableForCastingShadow: e => !!e && ("Object3D" === e.type || "Group" === e.type || e.isMesh), genCubeUrls: (e, t) => [(e = (e + "///").replace("////", "/").replace("///", "/")) + "px" + (t = ("." + t).replace("..", ".")), e + "nx" + t, e + "py" + t, e + "ny" + t, e + "pz" + t, e + "nz" + t], genEquirectangularUrl: (e, t) => (e = (e + "///").replace("////", "").replace("///", "")) + (t = ("." + t).replace("..", ".")), url: (e, t) => `${e || ""}///${t || ""}`.replace("/////", "/").replace("////", "/").replace("///", "/"), numberOrDefault: (e, t) => "number" == typeof e ? e : t, isBoolean: e => "boolean" == typeof e, isNumber: e => "number" == typeof e, isCSSColor: e => /^#[0-9a-fA-F]{6}$/.test(e), isFunction: e => "[object Function]" === Object.prototype.toString.call(e), deepEq(e, t, i, r) { var n = Object.prototype.toString.call(e); if (n !== Object.prototype.toString.call(t)) return !1; switch (n) { case "[object RegExp]": case "[object String]": return "" + e == "" + t; case "[object Number]": return +e != +e ? +t != +t : 0 == +e ? 1 / +e == 1 / t : +e == +t; case "[object Date]": case "[object Boolean]": return +e == +t }var a = "[object Array]" === n; if (!a) { if ("object" != typeof e || "object" != typeof t) return !1; var o = e.constructor, s = t.constructor; if (o == s && !(this.isFunction(o) && o instanceof o && this.isFunction(s) && s instanceof s) && "constructor" in e && "constructor" in t) return !1 } r = r || []; for (var l = (i = i || []).length; l--;)if (i[l] === e) return r[l] === t; if (i.push(e), r.push(t), a) { if ((l = e.length) !== t.length) return !1; for (; l--;)if (!this.eq(e[l], t[l], i, r)) return !1 } else { var c, h = Object.keys(e); if (l = h.length, Object.keys(t).length !== l) return !1; for (; l--;)if (c = h[l], !t.hasOwnProperty(c) || !this.eq(e[c], t[c], i, r)) return !1 } return i.pop(), r.pop(), !0 }, eq(e, t, i, r) { if (e === t) return 0 !== e || 1 / e == 1 / t; if (null == e || null == t) return !1; if (e != e) return t != t; var n = typeof e; return ("function" === n || "object" === n || "object" == typeof t) && this.deepEq(e, t, i, r) }, clone: e => { var t; if (logger.info("util.clone(): clone obj:", e), e instanceof Array) { t = []; for (var i = e.length; i--;)t[i] = util$1.clone(e[i]); return t } if (e instanceof Object) { for (var r in t = {}, e) t[r] = util$1.clone(e[r]); return t } return e }, getSettingsRecursively: e => { if (void 0 !== e && e) { if ("function" == typeof e) return "()"; var t; if (e instanceof Array) { t = []; for (let n = 0; n < e.length; n++)if ("FolderItem" === e[n].type || "BuildingItem" === e[n].type || "BuildingFloorItem" === e[n].type) if (e[n].children.length > 0) { (i = e[n].getSettings()).children = util$1.getSettingsRecursively(e[n].children), t.push(i) } else { var i = e[n].getSettings(); t.push(i) } else if ("ModelItem" === e[n].type || "IconAsset" === e[n].type || "GroupItem" === e[n].type || "PaintItem" === e[n].type || "TileSetItem" === e[n].type || "GisItem" === e[n].type) { var r = e[n].getSettings(); t.push(r) } return t } if (e instanceof Object) { for (var n in t = {}, e) t[n] = util$1.getSettingsRecursively(e[n]); return t } return e } }, deepClone: e => { if (e) { var t = e instanceof Array ? [] : {}; for (let i in e) "object" == typeof e[i] ? t[i] = util$1.deepClone(e[i]) : t[i] = e[i]; return t } }, isObject: e => "object" == typeof e && null != e, cloneDeep: (e, t = new WeakMap) => { if (!util$1.isObject(e)) return e; if (t.has(e)) return t.get(e); if ([Date, RegExp, Set, Map, WeakMap, WeakSet].includes(e.constructor)) return new e.constructor(e); const i = Object.getOwnPropertyDescriptors(e), r = Object.create(Object.getPrototypeOf(e), i); t.set(e, r); for (let i of Reflect.ownKeys(e)) r[i] = util$1.isObject(e[i]) ? util$1.cloneDeep(e[i], t) : e[i]; return r }, guid: () => { function e() { return (65536 * (1 + Math.random()) | 0).toString(16).substring(1) } return e() + e() + "-" + e() + "-" + e() + "-" + e() + "-" + e() + e() + e() }, randomString: e => { e = e || 32; for (var t = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678", i = t.length, r = "", n = 0; n < e; n++)r += t.charAt(Math.floor(Math.random() * i)); return r }, colorMultiply: (e, t) => { if ("number" != typeof t) return e; t < 0 && (t = 0), t > 1 && (t = 1); let i = util$1.colorToInteger(e); return util$1.integerToColor(i * t) }, integerToColor: e => "number" != typeof e ? "#ffffff" : "#{colorInt.toString(16)}", colorToInteger: e => "string" != typeof e ? 16777215 : ("#" === e.charAt(0) && (e = e.substring(1)), parseInt(`0x${e}`)), colorToRGBAObject: e => "string" != typeof (e = "" + e) ? { r: 1, g: 1, b: 1, a: 1 } : ("#" === e.charAt(0) && (e = e.substring(1)), 3 === e.length && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]), 4 === e.length && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] + e[3] + e[3]), /^[0-9a-fA-F]{6}$/.test(e) ? { r: parseInt(e.substr(0, 2), 16) / 255, g: parseInt(e.substr(2, 2), 16) / 255, b: parseInt(e.substr(4, 2), 16) / 255, a: 1 } : /^[0-9a-fA-F]{8}$/.test(e) ? { r: parseInt(e.substr(0, 2), 16) / 255, g: parseInt(e.substr(2, 2), 16) / 255, b: parseInt(e.substr(4, 2), 16) / 255, a: parseInt(e.substr(6, 2), 16) / 255 } : void 0), colorToRGBAString: e => "string" != typeof (e = "" + e) ? "rgba (1, 1, 1, 1)" : ("#" === e.charAt(0) && (e = e.substring(1)), 3 === e.length && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]), 4 === e.length && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] + e[3] + e[3]), /^[0-9a-fA-F]{6}$/.test(e) ? `rgba (${parseInt(e.substr(0, 2), 16) / 255}, ${parseInt(e.substr(2, 2), 16) / 255}, ${parseInt(e.substr(4, 2), 16) / 255}, 1)` : /^[0-9a-fA-F]{8}$/.test(e) ? `rgba (${parseInt(e.substr(0, 2), 16) / 255}, ${parseInt(e.substr(2, 2), 16) / 255}, ${parseInt(e.substr(4, 2), 16) / 255}, ${parseInt(e.substr(6, 2), 16) / 255})` : void 0), rgbAStringToColor: e => "#" + ((1 << 24) + (255 * e.r << 16) + (255 * e.g << 8) + 255 * e.b).toString(16).substring(1), randomRGBAObject: () => ({ r: Math.random(), g: Math.random(), b: Math.random(), a: .5 + .5 * Math.random() }), randomRGBAString: () => `rgba (${Math.random()}, ${Math.random()}, ${Math.random()}, ${.5 + .5 * Math.random()})`, addDegrees: (e, t) => e && t && e.lon && e.lat && t.lon && t.lat ? { lon: e.lon + t.lon, lat: e.lat + t.lat, alt: e.alt ? t.alt ? e.alt + t.alt : e.alt : t.alt ? t.alt : 0 } : { lon: 0, lat: 0, alt: 0 }, unifyCoordinates: (e, t) => { if (t) { switch ("surface" === e.type.toLowerCase() && (e.type = "Surface"), "ecef" === e.type.toLowerCase() && (e.type = "ECEF"), "planarglobal" === e.type.toLowerCase() && (e.type = "PlanarGlobal"), "planarlocal" === e.type.toLowerCase() && (e.type = "PlanarLocal"), "default" === e.type.toLowerCase() && (e.type = "default"), e.type.toLowerCase()) { case "surface": let i = t({ X: e.lon, Y: e.lat, Z: e.alt }, "Surface"); e.x = i.x, e.y = 0 - i.z, e.z = 0 - i.y }return e } }, findMeshByMaterial: (e, t, i) => { if ("function" != typeof e.traverse) return []; let r = []; return e.traverse((e => { if (e.material && e.material === t && r.push(e), e.material instanceof Array) for (let i of e.material) if (i === t) { r.push(e); break } if (i instanceof Array) for (let t of i) if (e.material && e.material === t && r.push(e), e.material instanceof Array) for (let i of e.material) if (i === t) { r.push(e); break } })), r }, fetchJSON: (e, t = "GET", i, r) => { switch (t.toLowerCase()) { case "get": case "delete": case "head": case "post": case "put": break; default: t = "GET" }return new Promise((function (n, a) { let o = new XMLHttpRequest; if (o.onreadystatechange = function () { 4 == o.readyState && (200 == o.status || 204 == o.status || 304 == o.status ? n(o.responseText) : a(new Error(o.statusText))) }, o.open(t, e, !0), i instanceof Array) for (let e of i) o.setRequestHeader(e.key, e.value); o.send(JSON.stringify(r)) })) }, fetchContentLength: (e, t, i) => new Promise((function (r, n) { let a = new XMLHttpRequest; if (a.onreadystatechange = function () { if (4 == a.readyState) if (200 == a.status || 204 == a.status || 304 == a.status) { let e = a.getResponseHeader("Content-Length"); r(e) } else { if (404 == a.status || 405 == a.status) return; n(new Error(a.statusText)) } }, a.open("HEAD", e, !0), t instanceof Array) for (let e of t) a.setRequestHeader(e.key, e.value); a.send(JSON.stringify(i)) })), fetchContentLastModified: (e, t, i) => new Promise((function (r, n) { try { if (!e || "" === e) return void n(); 0 === e.indexOf("data:") && r("0"); let a = new XMLHttpRequest; if (a.onreadystatechange = function () { if (4 == a.readyState) if (200 == a.status || 204 == a.status || 304 == a.status) { let e = a.getResponseHeader("Last-Modified"); r(e, "") } else { if (404 == a.status || 405 == a.status) return; n(new Error(a.statusText)) } }, a.open("HEAD", e, !0), t instanceof Array) for (let e of t) a.setRequestHeader(e.key, e.value); a.send(JSON.stringify(i)) } catch (e) { n(e) } })), applyVertexColors(e, t) { const i = e.attributes.position, r = []; for (let e = 0; e < i.count; e++)r.push(t.r, t.g, t.b); e.setAttribute("color", new Float32BufferAttribute(r, 3)) }, formatWithRegex: e => (e + "").replace(/\d{1,3}(?=(\d{3})+$)/g, "$&,"), isImage: e => "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof Image && e instanceof Image, lonLatToWebMercator: (e, t) => { if ("number" != typeof e || "number" != typeof t) return { x: 0, y: 0 }; let i = 20037508.34 * e / 180, r = Math.log(Math.tan((90 + t) * Math.PI / 360)) / (Math.PI / 180); return r = 20037508.34 * r / 180, { x: i, y: r } }, getNodelFromModelItem: e => { if ("Group" != e.parent.type) { let t = util$1.getNodelFromModelItem(e.parent); if (t) return t } else { let t = _context.defaultObjectTree.getItemByUUID(e.uuid); if (t && ("ModelItem" === t.type || "IconAsset" === t.type || "BuildingItem" === t.type)) return t; { let t = util$1.getNodelFromModelItem(e.parent); if (t) return t } } }, nodeInModelItem: (e, t) => { for (let i = 0; i < e.length; i++)if ("ModelItem" === e[i].type) { if (util$1.nodeInModelItemRecursion(e[i].children, t)) return e[i] } else if ("IconAsset" === e[i].type) { if (util$1.judegIconAssetFromClick(e[i].name, t)) return e[i] } else if ("BuildingFloorItem" === e[i].type) for (let r = 0; r < e[i].children.length; r++)if ("ModelItem" === e[i].children[r].type) { if (util$1.nodeInModelItemRecursion(e[i].children[r].children, t)) return e[i].children[r] } else if ("IconAsset" === e[i].children[r].type && util$1.judegIconAssetFromClick(e[i].children[r].name, t)) return e[i].children[r] }, nodeInModelItemRecursion: (e, t) => { for (let i = 0; i < e.length; i++) { if (e[i].name === t) return e[i]; if (e[i].children.length > 0) { let r = util$1.nodeInModelItemRecursion(e[i].children, t); if (r) return r } } }, judegIconAssetFromClick: (e, t) => e + "底图" === t || e + "文字" === t || e + "图标" === t, getModelTransform: e => { var t = {}; return t.position = JSON.parse(JSON.stringify(e.position)), t.rotation = JSON.parse(JSON.stringify(e.rotation)), t.rotation.x = t.rotation._x, t.rotation.y = t.rotation._y, t.rotation.z = t.rotation._z, t.scale = JSON.parse(JSON.stringify(e.scale)), t.rotation.x = t.rotation._x = MathUtils.radToDeg(t.rotation._x), t.rotation.y = t.rotation._y = MathUtils.radToDeg(t.rotation._y), t.rotation.z = t.rotation._z = MathUtils.radToDeg(t.rotation._z), t }, getCopyName: (e, t = 0, i) => { let r; return r = t ? `${e}${t}` : `${e}`, i.getItemByName(r) ? util$1.getCopyName(e, t + 1, i) : r }, changeTransformFromBuildind: (e, t, i) => (e.transform.position.x = (e.transform.position.x - t.position.x) / t.scale.x, e.transform.position.y = (e.transform.position.y - t.position.y) / t.scale.y, e.transform.position.z = (e.transform.position.z - t.position.z) / t.scale.z, i ? (e.transform.position.x = (e.transform.position.x - i.position.x) / i.scale.x, e.transform.position.y = (e.transform.position.y - i.position.y) / i.scale.y, e.transform.position.z = (e.transform.position.z - i.position.z) / i.scale.z, e) : e), changeTransformFromScene: (e, t, i) => { let r = JSON.parse(JSON.stringify(e.transform)), n = new Vector3, a = (t.position.x + e.transform.position.x) * t.scale.x, o = (t.position.y + e.transform.position.y) * t.scale.y, s = (t.position.z + e.transform.position.z) * t.scale.z; if (n.set(a, o, s), r.position = n, i) { let e = new Vector3, t = (i.position.x + r.position.x) * i.scale.x, n = (i.position.y + r.position.y) * i.scale.y, a = (i.position.z + r.position.z) * i.scale.z; return e.set(t, n, a), r.position = e, r } return r }, addAllParentPosition: (e, t) => { if (!e.parent || !e.parent.position) return t; { t.set(t.x + e.parent.position.x, t.y + e.parent.position.y, t.z + e.parent.position.z); let i = util$1.addAllParentPosition(e.parent, t); if (i) return i } }, recoverShowGetSettings: (e, t) => { for (let i = 0; i < e.length; i++)t[i].isVisible = e[i].isVisible, e[i].children && e[i].children.length > 0 && "ModelItem" != t[i].type && util$1.recoverShowGetSettings(e[i].children, t[i].children) }, recoverShow: (e, t) => { for (let i = 0; i < e.length; i++)t[i].isVisible = e[i].isVisible, e[i].children && e[i].children.length > 0 && util$1.recoverShow(e[i].children, t[i].children) }, recoverIsShowOrHide: (e, t) => { if (e) for (let i = 0; i < e.length; i++)e[i].isVisible ? t[i].show() : t[i].hide(), e[i].children && e[i].children.length > 0 && "ModelItem" != t[i].type && "PaintItem" != t[i].type && util$1.recoverIsShowOrHide(e[i].children, t[i].children) }, setObjectTreeIsHideRecursion: e => { for (let t = 0; t < e.length; t++)"ModelItem" === e[t].type || "IconAsset" === e[t].type || "GroupItem" === e[t].type || "PaintItem" === e[t].type ? e[t].hide() : e[t].children && e[t].children.length > 0 && util$1.setObjectTreeIsHideRecursion(e[t].children) }, setObjectTreeShowByUUID: (e, t) => { for (let i = 0; i < e.length; i++)e[i].getGroup && e[i].getGroup() && (e[i].getGroup().uuid === t ? (e[i].show(), util$1.setParentVisible(e[i].getGroup()), "ModelItem" != e[i].type && e[i].children.length > 0 && util$1.setObjectTreeShowRecursion(e[i].children)) : e[i].children && e[i].children.length > 0 && util$1.setObjectTreeShowByUUID(e[i].children, t)) }, setObjectTreeShowRecursion: e => { for (let t = 0; t < e.length; t++)e[t].getGroup() && "IconAsset" != e[t].type && (e[t].show(), "ModelItem" != e[t].type && e[t].children.length > 0 && util$1.setObjectTreeShowRecursion(e[t].children)) }, setParentVisible: e => { e.parent && null != e.parent.visible && (e.parent.visible = !0, util$1.setParentVisible(e.parent)) }, findObjectToBuilding: e => { let t = _context.defaultObjectTree.children; for (let i = 0; i < t.length; i++)if ("BuildingItem" === t[i].type && util$1.findObjectToBuildingRecursion(t[i].getGroup(), e)) return t[i] }, findObjectToBuildingRecursion: (e, t) => { if (e.uuid === t) return e; if (e.children && e.children.length > 0) for (let i = 0; i < e.children.length; i++)if (e.children[i]) { let r = util$1.findObjectToBuildingRecursion(e.children[i], t); if (r) return r } }, findObjectToFloor: (e = []) => { let t; for (let i = 0; i < e.length; i++) { let r = _context.defaultObjectTree.getItemByUUID(e[i]); if (r && "BuildingFloorItem" === r.type) { t = r; break } } return t }, judegParentIsVisible: e => null !== e.parent ? !1 !== e.visible && util$1.judegParentIsVisible(e.parent) : !1 !== e.visible && void 0, judegParentIsModelName: (e, t) => !(!t || !t.parent) && (null !== t.parent && (t.parent.name === e && "Group" === t.parent.type || util$1.judegParentIsModelName(e, t.parent))), findModelItemNodeByName: (e, t) => { if (e.name === t) return e; if (e.children && e.children.length > 0) for (let i = 0; i < e.children.length; i++) { let r = util$1.findModelItemNodeByName(e.children[i], t); if (r) return r } }, objectTreeChildrenRecursion: (e, t, i, r) => { if ("ModelItem" === e.type && (r = e.name), e.children && e.children.length > 0) for (let n = 0; n < e.children.length; n++) { if (e.children[n].name === t && r === util$1.modelName) return e.children[n].modelName = util$1.modelName, [e.children[n]]; if (e.children[n].children && e.children[n].children.length > 0) { let a = util$1.objectTreeChildrenRecursion(e.children[n], t, i, r); if (a) return a } } }, setArticulation: (e, t) => { e.children && "ModelItem" === e.type && (t.articulations = [], t.articulationAnimations = [], e.articulations && e.articulations.forEach((e => { let i = { type: e._type, name: e._name, values: e._values, defaultValue: e.value }; t.addArticulation(i); let r = t.articulations.find((t => t._name == e._name)); r && (r.getModelNode = () => t.getGroup(), r.getModelItem = () => t, e.properties.forEach((e => { r.addProperty({ nodes: e.nodes, modifiers: e.modifiers, materials: e.materials, particles: e.particles }) })), r.type == ArticulationTypes.text && r.addOrUpdateTextArticulation(), r.set(e.value), r.remark = e.remark, r.isEnable = e.isEnable, r.openThreshold = e.openThreshold) })), e.articulationAnimations && e.articulationAnimations.forEach(((e, i) => { t.addArticulationAnimation(e.animationName), t.articulationAnimations[i].animationSpeed = e.animationSpeed, t.articulationAnimations[i].animationType = e.animationType, t.articulationAnimations[i].isEnable = e.isEnable, e.articulationAnimationItems && e.articulationAnimationItems.forEach((e => { t.articulationAnimations[i].addAnimationItem({ startTime: e.startTime, continueTime: e.continueTime, articulationName: e.articulationName, startState: e.startState, endState: e.endState }) })) }))) }, setNode: (e, t, i) => { if (e.children) { "ModelItem" === e.type && (util$1.modelName = e.name); for (let r = 0; r < e.children.length; r++)if (e.children[r].isNode) { let n = util$1.objectTreeChildrenRecursion(t, e.children[r].name, util$1.modelName, null); if (n && n.length > 0) for (let t in e.children[r]) "id" === t || "children" === t || "isNode" === t || "material" === t || "name" === t || "modelName" === t || "getNodeMesh" === t || "setProperty" === t || e.children[r][t] instanceof Function || n[0].setProperty && n[0].setProperty(t, e.children[r][t]); e.children[r].children && e.children[r].children.length > 0 && util$1.setNode(e.children[r], t, i) } else e.children[r].children && e.children[r].children.length > 0 && util$1.setNode(e.children[r], t, i) } }, oldSetNode: (e, t, i) => { if (e.children) { "ModelItem" === e.type && (util$1.modelName = e.name); for (let r = 0; r < e.children.length; r++)if (e.children[r].isNode) { util$1.modelName && i.selectNodes(util$1.objectTreeChildrenRecursion(t, e.children[r].name, util$1.modelName, null)); for (let t in e.children[r]) "children" !== t && "isNode" !== t && "material" !== t && "name" !== t && "modelName" !== t && i.setProperty(t, e.children[r][t]); e.children[r].children && e.children[r].children.length > 0 && util$1.setNode(e.children[r], t, i) } else e.children[r].children && e.children[r].children.length > 0 && util$1.setNode(e.children[r], t, i) } }, iconVisible: (e, t) => { for (let i = 0; i < e.length; i++)"IconAsset" === e[i].type ? t ? e[i].iconShow() : e[i].iconHide() : e[i].children && e[i].children.length > 0 && util$1.iconVisible(e[i].children, t) }, convertRotation: e => { var t = new Vector3(0, 0, 1); return e.quaternion.setFromEuler(e.rotation), t.applyQuaternion(e.quaternion), new Euler((MathUtils.radToDeg(Math.atan2(-t.y, -t.z)) + 180 + 180) % 360 - 180, (MathUtils.radToDeg(Math.atan2(-t.x, -t.z)) + 180 + 180) % 360 - 180, (MathUtils.radToDeg(Math.atan2(-t.x, -t.y)) + 180 + 180) % 360 - 180) }, interpolate: (e = [], t = 1, i = 50, r) => { if (!(e instanceof Array || e instanceof Float32Array)) return; if ("number" != typeof t || t < 1 || t > 3) return void logger.warn("维度（dimension）参数不正确。取值范围是 1 - 3。"); if ("number" != typeof i || i < 1) return void logger.warn("最大插值数量（max）参数不正确。取值范围是正整数。"); if (e.length % t != 0) return void logger.warn(`数组元素个数（${e.length}）与维度（${t}）不符，应为维度的整数倍。`); let n = 1 / 0, a = -1 / 0, o = [], s = []; for (let i = 0; i < e.length / t; i++) { let r = []; for (let n = 0; n < t; n++)r.push(e[i * t + n]); if (o.push(r), i > 0) { let e = 0; switch (t) { case 1: e = Math.abs(o[i][0] - o[i - 1][0]); break; case 2: e = Math.sqrt((o[i][0] - o[i - 1][0]) * (o[i][0] - o[i - 1][0]) + (o[i][1] - o[i - 1][1]) * (o[i][1] - o[i - 1][1])); break; case 3: e = Math.sqrt((o[i][0] - o[i - 1][0]) * (o[i][0] - o[i - 1][0]) + (o[i][1] - o[i - 1][1]) * (o[i][1] - o[i - 1][1]) + (o[i][2] - o[i - 1][2]) * (o[i][2] - o[i - 1][2])) }if (0 === e) continue; s.push(e), e > a && (a = e), e < n && (n = e) } } if (r && s.length > 0) return s.reduce(((e, t) => e + t)); if (!isFinite(a) || !isFinite(n)) return; if (a / n < 1.5) return e; let l = []; for (let e = 0; e < o.length && (l.push(o[e]), e !== o.length - 1); e++) { let t = Math.round(s[e] / n); logger.debug("interpolateCount, max", t, i), t = t > i ? i : t, logger.debug("interpolateCount", t); for (let i = 0; i < t - 1; i++)l.push(util$1.lerp(o[e], o[e + 1], 1 / t + 1 / t * i)) } let c = []; for (let e of l) c.push(...e); return c }, lerp: (e, t, i) => { if (e.length === t.length && !(i < 0 || i > 1)) switch (e.length) { case 1: return e + (t - e) * i; case 2: return [e[0] + (t[0] - e[0]) * i, e[1] + (t[1] - e[1]) * i]; case 3: return [e[0] + (t[0] - e[0]) * i, e[1] + (t[1] - e[1]) * i, e[2] + (t[2] - e[2]) * i] } }, base64ToBlob: e => { let t = e.split(";base64,"), i = t[0].split(":")[1], r = window.atob(t[1]), n = r.length, a = new Uint8Array(n); for (let e = 0; e < n; ++e)a[e] = r.charCodeAt(e); let o = new Blob([a], { type: i }); return URL.createObjectURL(o) }, calcEulerAngelsFromNormal: e => { let t = new Vector3; return e instanceof Vector3 && (0 !== e.x || 0 !== e.y || 0 !== e.z) ? (e.x = Math.round(1e3 * e.x) / 1e3, e.y = Math.round(1e3 * e.y) / 1e3, e.z = Math.round(1e3 * e.z) / 1e3, t.x = 0 === e.y ? e.z < 0 ? -Math.PI / 2 : Math.PI / 2 : Math.atan(e.z / e.y), t.y = 0, t.z = 0 === e.y ? e.x < 0 ? -Math.PI / 2 : Math.PI / 2 : Math.atan(e.x / e.y), logger.debug(e, t), t) : t }, calcQuaternionFromNormal: e => { let t = new Quaternion, i = new Vector3; if (!(e instanceof Vector3) || 0 === e.x && 0 === e.y && 0 === e.z) return t.setFromAxisAngle(i, 0), t; e.x = Math.round(1e3 * e.x) / 1e3, e.y = Math.round(1e3 * e.y) / 1e3, e.z = Math.round(1e3 * e.z) / 1e3, i.x = e.z, i.y = 0, i.z = 0 - e.x; let r = e.angleTo(VECTOR3_Y_AXIS); return t.setFromAxisAngle(i, r) }, isDepthTestDisabled: e => { if (!e) return !1; if ("boolean" == typeof e.depthTest) return !e.depthTest; if (e instanceof Array) { for (let t of e) if (!1 === t.depthTest) return !0; return !1 } }, markObjectsNeedsUpdate: () => { if (_context.objectsNeedsUpdate instanceof Array) for (let e of _context.objectsNeedsUpdate) e && (e.needsUpdate = !0) }, addToObjectsNeedsUpdate: e => { _context.objectsNeedsUpdate || (_context.objectsNeedsUpdate = []), _context.objectsNeedsUpdate.push(e) }, removeFromObjectsNeedsUpdate: e => { if (_context.objectsNeedsUpdate && 0 !== _context.objectsNeedsUpdate.length) for (let t = _context.objectsNeedsUpdate.length - 1; t >= 0; t--)_context.objectsNeedsUpdate[t] === e && _context.objectsNeedsUpdate.splice(t, 1) }, disposeThreeObject: e => { if (e) if (e.traverse) { if ("IconGroup" === e.type && e.parent && "InstancedGroup" === e.parent.type) return void util$1.disposeInstancedObject(e); e.traverse((function (e) { if (e.geometry && e.geometry.dispose && e.geometry.dispose(), e.material && e.material.dispose) { for (var t in e.material) e.material[t] && e.material[t].dispose && e.material[t].dispose instanceof Function && e.material[t].dispose(); e.material.dispose && e.material.dispose() } else if (e.material && e.material.length) for (let i = e.material.length - 1; i >= 0; i--) { for (var t in e.material[i]) e.material[i][t] && e.material[i][t].dispose && e.material[i][t].dispose instanceof Function && e.material[i][t].dispose(); e.material[i].dispose && e.material[i].dispose() } e.dispose && e.dispose() })) } else e && e.dispose && e.dispose() }, disposeInstancedObject(e) { e.traverse((function (e) { e.geometry && e.geometry.dispose && e.geometry.dispose() })) }, cloneMaterial: e => { let t = e.clone(); for (var i in t) t[i] instanceof Texture$1 && (t[i] = t[i].clone()); return t }, disposeMaterial: e => { for (var t in e) e[t] instanceof Texture$1 && e[t].dispose(); e.dispose() }, geoCCSToLonLat: (e, t, i) => { let r = proj4("GEOCCS", "WGS84", [e, t, i]); return { lon: r[0], lat: r[1], alt: r[2] } }, webMercatorToLonLat: (e, t, i) => { let r = proj4("EPSG:3857", "WGS84", [e, t, i]); return { lon: r[0], lat: r[1], alt: r[2] } }, lonLatToWebMercator: (e, t, i) => { let r = proj4("WGS84", "EPSG:3857", [e, t, i]); return { x: r[0], y: r[1], z: r[2] } }, lonLatDistance: (e, t) => e && t ? "number" != typeof e.lon || "number" != typeof e.lat || "number" != typeof t.lon || "number" != typeof t.lat ? 0 : 2 * Math.asin(Math.sqrt(Math.pow(Math.sin((util$1.degreeToRadian(e.lat) - util$1.degreeToRadian(t.lat)) / 2), 2) + Math.cos(util$1.degreeToRadian(e.lat)) * Math.cos(util$1.degreeToRadian(t.lat)) * Math.pow(Math.sin((util$1.degreeToRadian(e.lon) - util$1.degreeToRadian(t.lon)) / 2), 2))) * EARTH_RADIUS : 0, getAutoRotateTime(e = 1, t = "CW") { let i = 1; return "CCW" === t && (i = -1), i * (1 / e) * 60 }, setMaterialParam(e, t, i) { for (let r in e) if (t[r] instanceof Map$1) { for (let t in e[r]) if (e[r][t.replace("_", "")] = e[r][t], e[r][t.replace("_", "")] instanceof Array); else if (e[r][t.replace("_", "")] instanceof Object) for (let i in e[r][t.replace("_", "")]) e[r][t.replace("_", "")][i.replace("_", "")] = e[r][t.replace("_", "")][i]; switch (e[r].type) { case "imagebitmap": let n = "undefined" != typeof ImageBitmap && e[r].source instanceof ImageBitmap ? e[r].source : void 0 !== e[r].name ? i.get(e[r].name) || _context.customTextureStore.find(e[r].name) : i.get(t.name + "#" + r); if (("metalnessMap" === r || "roughnessMap" === r) && !n) { let t = "", a = ""; e.roughnessMap && (a = e.roughnessMap.name || e.roughnessMap._name || ""), e.metalnessMap && (t = e.metalnessMap.name || e.metalnessMap._name || ""), n = i.get(t + a), n || (n = i.get(a + t)), i.forEach((t => { t.name.indexOf(e[r].name) > -1 && t.name.indexOf("#MetalnessAndRoughness#") > -1 && (n = t) })) } if (!n && e[r].name && 0 === e[r].name.indexOf("[[origin]]")) { _context.customTextureStore.loadTexture({ url: e[r].name, name: e[r].name, onLoad: () => { let n = "undefined" != typeof ImageBitmap && e[r].source instanceof ImageBitmap ? e[r].source : void 0 !== e[r].name ? i.get(e[r].name) || _context.customTextureStore.find(e[r].name) : i.get(t.name + "#" + r); t[r] = { type: "imagebitmap", source: n, reset: !0 } } }), console.log("可能加载的模型引用了自定义贴图，自定义贴图需要重新load"); break } t[r] = { type: "imagebitmap", source: n, reset: !0 }; break; case "color": e[r].reset = !0, t[r] = e[r]; break; case "file": break; default: t[r] = e[r] } } else t[r] = e[r]; e.color && (t.color = e.color) }, getIndices(e) { const t = new Triangle; function i(e, t) { this.id = e, this.vertex = t, this.last = null, this.next = null } const r = []; function n() { return r.length } function a(e) { const t = r.findIndex((t => t === e)); -1 !== t && r.splice(t, 1), e.last.next = e.next, e.next.last = e.last } const o = e.length; if (e[0].isVector3) for (let t = 0; t < o; t++) { const n = new i(t, e[t]); r.push(n) } else for (let t = 0; t < o; t += 3) { const n = new i(t / 3, new Vector3(e[t], e[t + 1], e[t + 2])); r.push(n) } let s = r[0], l = r[r.length - 1]; for (; s.vertex.equals(l.vertex);) { if (r.splice(r.length - 1, 1), r.length < 3) return []; l = r[r.length - 1] } for (let e = 0; e < n(); e++) { const t = r[e]; 0 === e ? (t.last = r[n() - 1], t.next = r[1]) : e === n() - 1 ? (t.last = r[n() - 2], t.next = r[0]) : (t.last = r[e - 1], t.next = r[e + 1]) } function c(e, t, i, r) { const n = (new Vector3).subVectors(e, t), a = (new Vector3).subVectors(e, i), o = (new Vector3).subVectors(e, r), s = (new Vector3).crossVectors(n, a), l = (new Vector3).crossVectors(a, o), c = (new Vector3).crossVectors(o, n); return s.z > 0 && l.z > 0 && c.z > 0 || s.z < 0 && l.z < 0 && c.z < 0 } const h = []; let u; for (; n() >= 3;) { let e = r[0]; const i = []; for (let r = 0; r < n(); r++) { t.set(e.last.vertex, e.vertex, e.next.vertex); const r = t.getNormal(); void 0 === u && (u = r.y < 0), u ? r.y < 0 && i.push(e) : r.y > 0 && i.push(e), e = e.next } const o = [...i], s = i.length; for (let e = 0; e < s; e++) { const t = i[e], r = t.last.vertex, n = t.vertex, a = t.next.vertex; let s = t.next.next; for (; s !== t.last;) { if (c(s.vertex, r, n, a)) { const e = o.findIndex((e => e === t)); -1 !== e && o.splice(e, 1); break } s = s.next } } if (o.length <= 0) break; h.push(o[0].last.id), h.push(o[0].id), h.push(o[0].next.id), a(o[0]) } return h }, MeshBasicMaterialToMeshStandardMaterial: e => e instanceof MeshBasicMaterial ? new MeshStandardMaterial({ name: e.name, alphaMap: e.alphaMap, alphaTest: e.alphaTest, aoMap: e.aoMap, aoMapIntensity: e.aoMapIntensity, blendDst: e.blendDst, blendDstAlpha: e.blendDstAlpha, blendEquation: e.blendEquation, blendEquationAlpha: e.blendEquationAlpha, blendSrc: e.blendSrc, blendSrcAlpha: e.blendSrcAlpha, blending: e.blending, clipIntersection: e.clipIntersection, clipShadows: e.clipShadows, clippingPlanes: e.clippingPlanes, color: e.color, colorWrite: e.colorWrite, depthFunc: e.depthFunc, depthTest: e.depthTest, depthWrite: e.depthWrite, dithering: e.dithering, envMap: e.envMap, fog: e.fog, lightMap: e.lightMap, lightMapIntensity: e.lightMapIntensity, map: e.map, morphTargets: e.morphTargets, opacity: e.opacity, polygonOffset: e.polygonOffset, polygonOffsetFactor: e.polygonOffsetFactor, polygonOffsetUnits: e.polygonOffsetUnits, precision: e.precision, premultipliedAlpha: e.premultipliedAlpha, refractionRatio: e.refractionRatio, shadowSide: e.shadowSide, side: e.side, skinning: e.skinning, stencilFail: e.stencilFail, stencilFunc: e.stencilFunc, stencilFuncMask: e.stencilFuncMask, stencilRef: e.stencilRef, stencilWrite: e.stencilWrite, stencilWriteMask: e.stencilWriteMask, stencilZFail: e.stencilZFail, stencilZPass: e.stencilZPass, toneMapped: e.toneMapped, transparent: e.transparent, userData: e.userData, version: e.version, vertexColors: e.vertexColors, visible: e.visible, wireframe: e.wireframe, wireframeLinecap: e.wireframeLinecap, wireframeLinejoin: e.wireframeLinejoin, wireframeLinewidth: e.wireframeLinewidth }) : e, md5: md5 }; window.navigator.userAgent && window.navigator.userAgent.indexOf("AppleWebKit") >= 0 ? util$1.isAppleWebKit = !0 : util$1.isAppleWebKit = !1; const INITIAL_FRUSTUM_CULLED = Symbol("INITIAL_FRUSTUM_CULLED"), tempMat = new Matrix4, tempMat2 = new Matrix4, tempVector = new Vector3, vecX = new Vector3, vecY = new Vector3, vecZ = new Vector3, X_AXIS = new Vector3(1, 0, 0), Y_AXIS = new Vector3(0, 1, 0); function updateFrustumCulled(e, t) { e.traverse((e => { e.frustumCulled = e[INITIAL_FRUSTUM_CULLED] && t })) } class TilesRenderer extends TilesRendererBase { get autoDisableRendererCulling() { return this._autoDisableRendererCulling } set autoDisableRendererCulling(e) { this._autoDisableRendererCulling !== e && (super._autoDisableRendererCulling = e, this.forEachLoadedModel((t => { updateFrustumCulled(t, !e) }))) } constructor(...e) { super(...e), this.group = new TilesGroup(this), this.cameras = [], this.cameraMap = new Map, this.cameraInfo = [], this.activeTiles = new Set, this.visibleTiles = new Set, this._autoDisableRendererCulling = !0, this.optimizeRaycast = !0, this.onLoadTileSet = null, this.onLoadModel = null, this.onDisposeModel = null, e.length > 1 && (this.offset = e[1]), e.length > 2 && (this.rotation = e[2]), this.offset || (this.offset = { x: 0, y: 0, z: 0 }), this.rotation && (this.rotation = { x: util$1.degreeToRadian(this.rotation.x), y: util$1.degreeToRadian(this.rotation.y), z: util$1.degreeToRadian(this.rotation.z) }); const t = new LoadingManager; t.setURLModifier((e => this.preprocessURL ? this.preprocessURL(e) : e)), this.manager = t; const i = this; this._overridenRaycast = function (e, t) { i.optimizeRaycast || Object.getPrototypeOf(this).raycast.call(this, e, t) } } getBounds(e) { if (!this.root) return !1; const t = this.root.cached, i = t.box, r = t.boxTransform; return !!i && (e.copy(i), e.applyMatrix4(r), !0) } getOrientedBounds(e, t) { if (!this.root) return !1; const i = this.root.cached, r = i.box, n = i.boxTransform; return !!r && (e.copy(r), t.copy(n), !0) } getBoundingSphere(e) { if (!this.root) return !1; const t = this.root.cached.sphere; return !!t && (e.copy(t), !0) } forEachLoadedModel(e) { this.traverse((t => { const i = t.cached.scene; i && e(i, t) })) } raycast(e, t) { if (this.root) if (e.firstHitOnly) { const i = raycastTraverseFirstHit(this.root, this.group, this.activeTiles, e); i && t.push(i) } else raycastTraverse(this.root, this.group, this.activeTiles, e, t) } hasCamera(e) { return this.cameraMap.has(e) } setCamera(e) { const t = this.cameras, i = this.cameraMap; return !i.has(e) && (i.set(e, new Vector2), t.push(e), !0) } setResolution(e, t, i) { const r = this.cameraMap; return !!r.has(e) && (t instanceof Vector2 ? r.get(e).copy(t) : r.get(e).set(t, i), !0) } setResolutionFromRenderer(e, t) { const i = this.cameraMap; if (!i.has(e)) return !1; const r = i.get(e); return t.getSize(r), r.multiplyScalar(t.getPixelRatio()), !0 } deleteCamera(e) { const t = this.cameras, i = this.cameraMap; if (i.has(e)) { const r = t.indexOf(e); return t.splice(r, 1), i.delete(e), !0 } return !1 } fetchTileSet(e, ...t) { const i = super.fetchTileSet(e, ...t); return i.then((t => { this.onLoadTileSet && Promise.resolve().then((() => { this.onLoadTileSet(t, e) })) })), i } update() { const e = this.group, t = this.cameras, i = this.cameraMap, r = this.cameraInfo; if (0 === t.length) return void console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles."); for (; r.length > t.length;)r.pop(); for (; r.length < t.length;)r.push({ frustum: new Frustum, isOrthographic: !1, sseDenominator: -1, position: new Vector3, invScale: -1, pixelSize: 0 }); let n; tempMat2.copy(e.matrixWorld).invert(), tempVector.setFromMatrixScale(tempMat2), n = tempVector.x, Math.abs(Math.max(tempVector.x - tempVector.y, tempVector.x - tempVector.z)) > 1e-6 && console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error."); for (let a = 0, o = r.length; a < o; a++) { const o = t[a], s = r[a], l = s.frustum, c = s.position, h = i.get(o); 0 !== h.width && 0 !== h.height || console.warn("TilesRenderer: resolution for camera error calculation is not set."); const u = o.projectionMatrix.elements; if (s.isOrthographic = 1 === u[15], s.isOrthographic) { const e = 2 / u[0], t = 2 / u[5]; s.pixelSize = Math.max(t / h.height, e / h.width) } else s.sseDenominator = 2 / u[5] / h.height; s.invScale = n, tempMat.copy(e.matrixWorld), tempMat.premultiply(o.matrixWorldInverse), tempMat.premultiply(o.projectionMatrix), l.setFromProjectionMatrix(tempMat), c.set(0, 0, 0), c.applyMatrix4(o.matrixWorld), c.applyMatrix4(tempMat2), c.x } super.update() } preprocessNode(e, t, i) { super.preprocessNode(e, t, i), t || (TilesRenderer.boundingOffset = null, _context._tilesGroup && _context._tilesGroup.rotation.set(Math.PI / -2, 0, 0)); const r = new Matrix4; if (!e.transform && !t) { const t = e.boundingVolume; if (t.sphere || t.box) { let e = [0, 0, 0]; t.sphere && (e = [t.sphere[0], t.sphere[1], t.sphere[2]]), t.box && (e = [t.box[0], t.box[1], t.box[2]]); let i = util$1.geoCCSToLonLat(e[0], e[1], e[2]), r = new Object3D; switch (r.position.set(e[0], e[1], e[2]), _context._tilesGroup.add(r), "y".toLowerCase()) { case "z": _context._tilesGroup.rotation.set(Math.PI / -2 - util$1.degreeToRadian(90 - i.lat), 0, -util$1.degreeToRadian(90 + i.lon), "YXZ"); break; case "y": default: _context._tilesGroup.rotation.set(Math.PI / -2 - util$1.degreeToRadian(90 - i.lat), 0, -util$1.degreeToRadian(90 + i.lon), "YXZ") }if (_context._tilesGroup.updateMatrix(), _context._tilesGroup.updateMatrixWorld(), r.updateMatrixWorld(), _context._tilesGroup.position.setFromMatrixPosition(r.matrixWorld), _context._tilesGroup.position.x = -_context._tilesGroup.position.x, _context._tilesGroup.position.y = -_context._tilesGroup.position.y, _context._tilesGroup.position.z = -_context._tilesGroup.position.z, _context._tilesGroup.remove(r), TilesRenderer.customTransformOrigin) { let t = util$1.geoCCSToLonLat(e[0], e[1], e[2]); const i = TilesRenderer.customTransformOrigin; let r = util$1.lonLatDistance({ lon: i.lon, lat: (i.lat + t.lat) / 2 }, { lon: t.lon, lat: (i.lat + t.lat) / 2 }), n = .99664718932 * util$1.lonLatDistance({ lon: (i.lon + t.lon) / 2, lat: i.lat }, { lon: (i.lon + t.lon) / 2, lat: t.lat }); _context._tilesGroup.position.x += r * Math.sign(t.lon - i.lon), _context._tilesGroup.position.z += n * Math.sign(t.lat - i.lat), _context._tilesGroup.position.y += t.alt - i.alt, _context._tilesGroup.position.x += this.offset.x, _context._tilesGroup.position.y += this.offset.y, _context._tilesGroup.position.z += this.offset.z } else TilesRenderer.customTransformOrigin = util$1.geoCCSToLonLat(e[0], e[1], e[2]), _context._tilesGroup.position.x += this.offset.x, _context._tilesGroup.position.y += this.offset.y, _context._tilesGroup.position.z += this.offset.z } } if (e.transform) { const i = e.transform; for (let e = 0; e < 16; e++)r.elements[e] = i[e]; if (!t && TilesRenderer.customTransformEnabled) if (r.identity(), this.rotation && r.makeRotationFromEuler(new Euler(this.rotation.x, -this.rotation.z, this.rotation.y)), i && TilesRenderer.customTransformOrigin) { let e = util$1.geoCCSToLonLat(i[12], i[13], i[14]); const t = TilesRenderer.customTransformOrigin; if (!this.rotation) { const i = util$1.degreeToRadian(e.lon - t.lon), n = util$1.degreeToRadian(e.lat - t.lat); r.makeRotationFromEuler(new Euler(i, n, 0)) } util$1.lonLatDistance(t, { lon: e.lon, lat: t.lat }), util$1.lonLatDistance(t, { lon: t.lon, lat: e.lat }); let n = util$1.lonLatDistance({ lon: t.lon, lat: (t.lat + e.lat) / 2 }, { lon: e.lon, lat: (t.lat + e.lat) / 2 }), a = .99664718932 * util$1.lonLatDistance({ lon: (t.lon + e.lon) / 2, lat: t.lat }, { lon: (t.lon + e.lon) / 2, lat: e.lat }); util$1.lonLatDistance(e, { lon: t.lon, lat: e.lat }), util$1.lonLatDistance(e, { lon: e.lon, lat: t.lat }), r.elements[12] = n * Math.sign(e.lon - t.lon), r.elements[13] = a * Math.sign(e.lat - t.lat), r.elements[14] = e.alt - t.alt, this.absolutePosition = { x: r.elements[12], z: -r.elements[13], y: r.elements[14] }, r.elements[12] += this.offset.x, r.elements[13] -= this.offset.z, r.elements[14] += this.offset.y } else { TilesRenderer.customTransformOrigin = util$1.geoCCSToLonLat(i[12], i[13], i[14]); let e = _context.instance.getDatumShiftModel(); if (!e) { let t = { lon: TilesRenderer.customTransformOrigin.lon, lat: TilesRenderer.customTransformOrigin.lat, alt: TilesRenderer.customTransformOrigin.alt, type: "surface", scaleX: 1, scaleY: 1, scaleZ: 1 }, i = { mode: "basepoint", type: "basepoint", mapCenter: [t.lon, t.lat], alt: t.alt }; t.editor = i, _context.instance.setDatumShiftModel(t), e = t } this.absolutePosition = { x: r.elements[12], z: -r.elements[13], y: r.elements[14] }, r.elements[12] += this.offset.x, r.elements[13] -= this.offset.z, r.elements[14] += this.offset.y } } else r.identity(); t && r.premultiply(t.cached.transform); const n = (new Matrix4).copy(r).invert(); let a = null, o = null, s = null; if ("box" in e.boundingVolume) { const t = e.boundingVolume.box; a = new Box3, o = new Matrix4, s = new Matrix4, vecX.set(t[3], t[4], t[5]), vecY.set(t[6], t[7], t[8]), vecZ.set(t[9], t[10], t[11]); const i = vecX.length(), n = vecY.length(), l = vecZ.length(); vecX.normalize(), vecY.normalize(), vecZ.normalize(), 0 === i && vecX.crossVectors(vecY, vecZ), 0 === n && vecY.crossVectors(vecX, vecZ), 0 === l && vecZ.crossVectors(vecX, vecY), o.set(vecX.x, vecY.x, vecZ.x, t[0], vecX.y, vecY.y, vecZ.y, t[1], vecX.z, vecY.z, vecZ.z, t[2], 0, 0, 0, 1), o.premultiply(r), s.copy(o).invert(), a.min.set(-i, -n, -l), a.max.set(i, n, l) } let l = null; if ("sphere" in e.boundingVolume) { const t = e.boundingVolume.sphere; l = new Sphere, l.center.set(t[0], t[1], t[2]), l.radius = t[3], l.applyMatrix4(r) } else if ("box" in e.boundingVolume) { const t = e.boundingVolume.box; l = new Sphere, a.getBoundingSphere(l), l.center.set(t[0], t[1], t[2]), l.applyMatrix4(r) } "region" in e.boundingVolume && console.warn("ThreeTilesRenderer: region bounding volume not supported."), e.cached = { loadIndex: 0, transform: r, transformInverse: n, active: !1, inFrustum: [], box: a, boxTransform: o, boxTransformInverse: s, sphere: l, region: null, scene: null, geometry: null, material: null } } parseTile(e, t, i) { t._loadIndex = t._loadIndex || 0, t._loadIndex++; const r = t.content.uri.split(/[\\\/]/g); r.pop(); const n = r.join("/"), a = this.fetchOptions, o = this.manager, s = t._loadIndex; let l = null; switch (i) { case "b3dm": const t = new B3DMLoader(o); t.workingPath = n, t.fetchOptions = a, l = t.parse(e).then((e => e.scene)); break; case "pnts": l = Promise.resolve(new PNTSLoader(o).parse(e).scene); break; case "i3dm": { const t = new I3DMLoader(o); t.workingPath = n, t.fetchOptions = a, l = t.parse(e).then((e => e.scene)); break } case "cmpt": { const t = new CMPTLoader(o); t.workingPath = n, t.fetchOptions = a, l = t.parse(e).then((e => e.scene)); break } default: console.warn(`TilesRenderer: Content type "${i}" not supported.`), l = Promise.resolve(null) }return l.then((e => { if (t._loadIndex !== s) return; const r = this.rootTileSet.asset && this.rootTileSet.asset.gltfUpAxis || "y", n = t.cached, a = n.transform; switch (r.toLowerCase()) { case "x": tempMat.makeRotationAxis(Y_AXIS, -Math.PI / 2); break; case "y": tempMat.makeRotationAxis(X_AXIS, Math.PI / 2); break; case "z": tempMat.identity() }e.updateMatrix(), "pnts" !== i && e.matrix.multiply(tempMat), e.matrix.premultiply(a), e.matrix.decompose(e.position, e.quaternion, e.scale), e.traverse((e => { e[INITIAL_FRUSTUM_CULLED] = e.frustumCulled })), updateFrustumCulled(e, !this.autoDisableRendererCulling), n.scene = e, e.traverse((e => { e.raycast = this._overridenRaycast })); const o = [], l = [], c = []; e.traverse((e => { if (e.geometry && l.push(e.geometry), e.receiveShadow = !0, e.material) { if (e.geometry && e.geometry.attributes && e.geometry.attributes.position && !e.geometry.attributes.normal) { const t = []; let i = 0; e.geometry.attributes.position.data && "number" == typeof e.geometry.attributes.position.data.count && (i = e.geometry.attributes.position.data.count), "number" == typeof e.geometry.attributes.position.count && (i = e.geometry.attributes.position.count); for (let e = 0; e < i; e++)t.push(0), t.push(1), t.push(0); e.geometry.setAttribute("normal", new Float32BufferAttribute(t, 3)) } const t = new MeshLambertMaterial; t.map = e.material.map, e.material.dispose(), e.material = t; const i = e.material; i.needsUpdate = !0, o.push(i); for (const e in i) { const t = i[e]; t && t.isTexture && c.push(t) } } })), n.materials = o, n.geometry = l, n.textures = c, this.onLoadModel && this.onLoadModel(e, t) })) } disposeTile(e) { const t = e.cached; if (t.scene) { const i = t.materials, r = t.geometry, n = t.textures; for (let e = 0, t = r.length; e < t; e++)r[e].dispose(); for (let e = 0, t = i.length; e < t; e++)i[e].dispose(); for (let e = 0, t = n.length; e < t; e++) { n[e].dispose() } this.onDisposeModel && this.onDisposeModel(t.scene, e), t.scene = null, t.materials = null, t.textures = null, t.geometry = null } e._loadIndex++ } setTileVisible(e, t) { const i = e.cached.scene, r = this.visibleTiles, n = this.group; t ? (n.add(i), r.add(e), i.updateMatrixWorld(!0)) : (n.remove(i), r.delete(e)) } setTileActive(e, t) { const i = this.activeTiles; t ? i.add(e) : i.delete(e) } calculateError(e) { const t = e.cached, i = t.inFrustum, r = this.cameras, n = this.cameraInfo, a = e.boundingVolume; if ("box" in a || "sphere" in a) { const a = t.sphere, o = t.box, s = t.boxTransformInverse, l = t.transformInverse, c = o && s; let h = -1 / 0, u = 1 / 0; for (let t = 0, d = r.length; t < d; t++) { if (!i[t]) continue; const r = n[t], d = r.invScale; let p; if (r.isOrthographic) { const t = r.pixelSize; p = e.geometricError / (t * d) } else { let t; tempVector.copy(r.position), c ? (tempVector.applyMatrix4(s), t = o.distanceToPoint(tempVector)) : (tempVector.applyMatrix4(l), t = Math.max(a.distanceToPoint(tempVector), 0)); const i = t * d, n = r.sseDenominator; p = e.geometricError / (i * n), u = Math.min(u, i) } h = Math.max(h, p) } e.__distanceFromCamera = u, e.__error = h } else "region" in a && console.warn("ThreeTilesRenderer : Region bounds not supported.") } tileInView(e) { const t = e.cached, i = t.sphere, r = t.inFrustum; if (i) { const e = this.cameraInfo; let t = !1; for (let n = 0, a = e.length; n < a; n++) { e[n].frustum.intersectsSphere(i) ? (t = !0, r[n] = !0) : r[n] = !1 } return t } return !0 } } const BACKGROUND_COLOR_DEFAULT = 0, WIDTH_DEFAULT = 1024, HEIGHT_DEFAULT = 768, WIDTH_MIN = 0, HEIGHT_MIN = 0, WIDTH_MAX = 15360, HEIGHT_MAX = 8192, LIGHT_PROBE_INTENSITY_OFFSET = 0, LIGHT_INTENSITY_RATIO = 1, ENVMAP_FACTOR = 5, INDEXED_DB_NAME = "avw_scene_v2", INDEXED_DB_VERSION = 1, INDEXED_DB_OBJECT_STORE = "cache", AVW_HEADER = [10, 8, 29, 32, 43, 55, 40, 67], AVW_HEADER_VAR = [58, 64, 1, 33, 75, 26, 38, 95], AVW_STEP = 3, INSTANCE_COUNT_MAX = 65535, DRAWABLE_FOG = !1, DRAWABLE_RENDER_ORDER_BASE = 1e4; function _typeof$1(e) { return (_typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } var mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259], shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24]; function processImage(e, t, i, r, n, a) { if ("string" == typeof e && (e = document.getElementById(e)), e && "naturalWidth" in e) { var o = n ? "offset" : "natural", s = e[o + "Width"], l = e[o + "Height"]; if ("string" == typeof t && (t = document.getElementById(t)), t && "getContext" in t) { a || (t.style.width = s + "px", t.style.height = l + "px"), t.width = s, t.height = l; var c = t.getContext("2d"); c.clearRect(0, 0, s, l), c.drawImage(e, 0, 0, e.naturalWidth, e.naturalHeight, 0, 0, s, l), isNaN(i) || i < 1 || (r ? processCanvasRGBA(t, 0, 0, s, l, i) : processCanvasRGB(t, 0, 0, s, l, i)) } } } function getImageDataFromCanvas(e, t, i, r, n) { if ("string" == typeof e && (e = document.getElementById(e)), !e || "object" !== _typeof$1(e) || !("getContext" in e)) throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!"); var a = e.getContext("2d"); try { return a.getImageData(t, i, r, n) } catch (e) { throw new Error("unable to access image data: " + e) } } function processCanvasRGBA(e, t, i, r, n, a) { if (!(isNaN(a) || a < 1)) { a |= 0; var o = getImageDataFromCanvas(e, t, i, r, n); o = processImageDataRGBA(o, t, i, r, n, a), e.getContext("2d").putImageData(o, t, i) } } function processImageDataRGBA(e, t, i, r, n, a) { for (var o, s = e.data, l = 2 * a + 1, c = r - 1, h = n - 1, u = a + 1, d = u * (u + 1) / 2, p = new BlurStack, f = p, m = 1; m < l; m++)f = f.next = new BlurStack, m === u && (o = f); f.next = p; for (var g = null, y = null, v = 0, _ = 0, b = mulTable[a], x = shgTable[a], w = 0; w < n; w++) { f = p; for (var S = s[_], M = s[_ + 1], T = s[_ + 2], A = s[_ + 3], E = 0; E < u; E++)f.r = S, f.g = M, f.b = T, f.a = A, f = f.next; for (var C = 0, L = 0, R = 0, D = 0, P = u * S, O = u * M, I = u * T, k = u * A, B = d * S, N = d * M, F = d * T, U = d * A, z = 1; z < u; z++) { var G = _ + ((c < z ? c : z) << 2), H = s[G], V = s[G + 1], j = s[G + 2], W = s[G + 3], $ = u - z; B += (f.r = H) * $, N += (f.g = V) * $, F += (f.b = j) * $, U += (f.a = W) * $, C += H, L += V, R += j, D += W, f = f.next } g = p, y = o; for (var Y = 0; Y < r; Y++) { var X = U * b >> x; if (s[_ + 3] = X, 0 !== X) { var Z = 255 / X; s[_] = (B * b >> x) * Z, s[_ + 1] = (N * b >> x) * Z, s[_ + 2] = (F * b >> x) * Z } else s[_] = s[_ + 1] = s[_ + 2] = 0; B -= P, N -= O, F -= I, U -= k, P -= g.r, O -= g.g, I -= g.b, k -= g.a; var q = Y + a + 1; q = v + (q < c ? q : c) << 2, B += C += g.r = s[q], N += L += g.g = s[q + 1], F += R += g.b = s[q + 2], U += D += g.a = s[q + 3], g = g.next; var J = y, K = J.r, Q = J.g, ee = J.b, te = J.a; P += K, O += Q, I += ee, k += te, C -= K, L -= Q, R -= ee, D -= te, y = y.next, _ += 4 } v += r } for (var ie = 0; ie < r; ie++) { var re = s[_ = ie << 2], ne = s[_ + 1], ae = s[_ + 2], oe = s[_ + 3], se = u * re, le = u * ne, ce = u * ae, he = u * oe, ue = d * re, de = d * ne, pe = d * ae, fe = d * oe; f = p; for (var me = 0; me < u; me++)f.r = re, f.g = ne, f.b = ae, f.a = oe, f = f.next; for (var ge = r, ye = 0, ve = 0, _e = 0, be = 0, xe = 1; xe <= a; xe++) { _ = ge + ie << 2; var we = u - xe; ue += (f.r = re = s[_]) * we, de += (f.g = ne = s[_ + 1]) * we, pe += (f.b = ae = s[_ + 2]) * we, fe += (f.a = oe = s[_ + 3]) * we, be += re, ye += ne, ve += ae, _e += oe, f = f.next, xe < h && (ge += r) } _ = ie, g = p, y = o; for (var Se = 0; Se < n; Se++) { var Me = _ << 2; s[Me + 3] = oe = fe * b >> x, oe > 0 ? (oe = 255 / oe, s[Me] = (ue * b >> x) * oe, s[Me + 1] = (de * b >> x) * oe, s[Me + 2] = (pe * b >> x) * oe) : s[Me] = s[Me + 1] = s[Me + 2] = 0, ue -= se, de -= le, pe -= ce, fe -= he, se -= g.r, le -= g.g, ce -= g.b, he -= g.a, Me = ie + ((Me = Se + u) < h ? Me : h) * r << 2, ue += be += g.r = s[Me], de += ye += g.g = s[Me + 1], pe += ve += g.b = s[Me + 2], fe += _e += g.a = s[Me + 3], g = g.next, se += re = y.r, le += ne = y.g, ce += ae = y.b, he += oe = y.a, be -= re, ye -= ne, ve -= ae, _e -= oe, y = y.next, _ += r } } return e } function processCanvasRGB(e, t, i, r, n, a) { if (!(isNaN(a) || a < 1)) { a |= 0; var o = getImageDataFromCanvas(e, t, i, r, n); o = processImageDataRGB(o, t, i, r, n, a), e.getContext("2d").putImageData(o, t, i) } } function processImageDataRGB(e, t, i, r, n, a) { for (var o, s = e.data, l = 2 * a + 1, c = r - 1, h = n - 1, u = a + 1, d = u * (u + 1) / 2, p = new BlurStack, f = p, m = 1; m < l; m++)f = f.next = new BlurStack, m === u && (o = f); f.next = p; for (var g, y, v = null, _ = null, b = mulTable[a], x = shgTable[a], w = 0, S = 0, M = 0; M < n; M++) { var T = s[S], A = s[S + 1], E = s[S + 2], C = u * T, L = u * A, R = u * E, D = d * T, P = d * A, O = d * E; f = p; for (var I = 0; I < u; I++)f.r = T, f.g = A, f.b = E, f = f.next; for (var k = 0, B = 0, N = 0, F = 1; F < u; F++)g = S + ((c < F ? c : F) << 2), D += (f.r = T = s[g]) * (y = u - F), P += (f.g = A = s[g + 1]) * y, O += (f.b = E = s[g + 2]) * y, k += T, B += A, N += E, f = f.next; v = p, _ = o; for (var U = 0; U < r; U++)s[S] = D * b >> x, s[S + 1] = P * b >> x, s[S + 2] = O * b >> x, D -= C, P -= L, O -= R, C -= v.r, L -= v.g, R -= v.b, g = w + ((g = U + a + 1) < c ? g : c) << 2, D += k += v.r = s[g], P += B += v.g = s[g + 1], O += N += v.b = s[g + 2], v = v.next, C += T = _.r, L += A = _.g, R += E = _.b, k -= T, B -= A, N -= E, _ = _.next, S += 4; w += r } for (var z = 0; z < r; z++) { var G = s[S = z << 2], H = s[S + 1], V = s[S + 2], j = u * G, W = u * H, $ = u * V, Y = d * G, X = d * H, Z = d * V; f = p; for (var q = 0; q < u; q++)f.r = G, f.g = H, f.b = V, f = f.next; for (var J = 0, K = 0, Q = 0, ee = 1, te = r; ee <= a; ee++)S = te + z << 2, Y += (f.r = G = s[S]) * (y = u - ee), X += (f.g = H = s[S + 1]) * y, Z += (f.b = V = s[S + 2]) * y, J += G, K += H, Q += V, f = f.next, ee < h && (te += r); S = z, v = p, _ = o; for (var ie = 0; ie < n; ie++)s[g = S << 2] = Y * b >> x, s[g + 1] = X * b >> x, s[g + 2] = Z * b >> x, Y -= j, X -= W, Z -= $, j -= v.r, W -= v.g, $ -= v.b, g = z + ((g = ie + u) < h ? g : h) * r << 2, Y += J += v.r = s[g], X += K += v.g = s[g + 1], Z += Q += v.b = s[g + 2], v = v.next, j += G = _.r, W += H = _.g, $ += V = _.b, J -= G, K -= H, Q -= V, _ = _.next, S += r } return e } var BlurStack = function e() { _classCallCheck(this, e), this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null }; class BackgroundBlur { constructor(e, t) { this._definitionValue = 0, this.pmremgenrator, this._definitionValue = 0, this.canvas = document.createElement("canvas"), this.cubeTextureLoader = new CubeTextureLoader, e ? (this.pmremgenrator = new PMREMGenerator(e), this.pmremgenrator.compileEquirectangularShader()) : console.error("lost WebGLRenderer,PMERGenerator needs WebGLRender") } get definition() { return this._definitionValue } set definition(e) { this.definitionValueChange(e), this._definitionValue = e } destory() { this.canvas.remove(), this.img.remove(), this.img.destory() } cubeTextureBlur(e, t, i) { if (!(e.images instanceof Array)) return; if (new CubeTexture, !e.srcImages) { e.srcImages = []; for (let t = 0; t < e.images.length; t++)e.srcImages[t] = e.images[t] } let r = []; for (let i = 0; i < e.images.length; i++)e.srcImages[i] instanceof Image && (processImage(e.srcImages[i], this.canvas, t, !0), r.push(this.canvas.toDataURL("image/png"))); console.log(r), 6 === r.length && this.cubeTextureLoader.load(r, (e => { "function" == typeof i && i(this.pmremgenrator.fromCubemap(e).texture) })) } } class BackgroundBlur2 { constructor(e, t) { this._definitionValue = 0, this.pmremgenrator, this._definitionValue = 0, this.canvas = document.createElement("canvas"), this.textureLoader = new TextureLoader, e ? (this.pmremgenrator = new PMREMGenerator(e), this.pmremgenrator.compileEquirectangularShader()) : console.error("lost WebGLRenderer,PMERGenerator needs WebGLRender") } get definition() { return this._definitionValue } set definition(e) { this.definitionValueChange(e), this._definitionValue = e } destory() { this.canvas.remove(), this.img.remove(), this.img.destory() } cubeTextureBlur(e, t, i) { if (!(e.images instanceof Array)) return; if (new CubeTexture, !e.srcImages) { e.srcImages = []; for (let t = 0; t < e.images.length; t++)e.srcImages[t] = e.images[t] } let r = ""; window.img = this.pmremgenrator.fromCubemap(e).texture.image, processImage(img, this.canvas, t, !0), r = this.canvas.toDataURL("image/png"), this.textureLoader.load(r, (e => { "function" == typeof i && i(e) })) } textureBlur(e, t, i) { if (!e.image) return; e.srcImage || (e.srcImage = e.image), processImage(e.image, this.canvas, t, !0); let r = this.canvas.toDataURL("image/png"); this.textureLoader.load(r, (e => { e.wrapS = RepeatWrapping, "function" == typeof i && i(e) })) } } class Node { constructor({ id: e = util$1.guid(), name: t, children: i = [], material: r, isCastingShadow: n = !1, isReceivingShadow: a = !1, isRotating: o = !1, rotatingAxis: s = "y", rotatingSpeed: l = 1, isScaling: c = !1, isBreathing: h = !1, startScale: u = 1, stopScale: d = 2, fadeOutScale: p = 1.5, scalingSpeed: f = .1, breathingSpeed: m = .1, endBreathe: g = 1.5, isVisible: y = !0, isLock: v = !1, enableSSR: _ = !1, modelNode: b }) { this.id = e, this.name = t || this.id, this.children = i, this.material = r, this.isCastingShadow = n, this.isReceivingShadow = a, this.isRotating = o, this.rotatingAxis = s, this.rotatingSpeed = l, this.isScaling = c, this.isBreathing = h, this.startScale = u, this.stopScale = d, this.fadeOutScale = p, this.scalingSpeed = f, this.breathingSpeed = m, this.endBreathe = g, this.isVisible = y, this.isLock = v, this.enableSSR = _, this.isNode = !0; let x = {}; x.position = JSON.parse(JSON.stringify(b.position)), x.rotation = JSON.parse(JSON.stringify(b.rotation)), x.rotation.x = x.rotation._x, x.rotation.y = x.rotation._y, x.rotation.z = x.rotation._z, x.scale = JSON.parse(JSON.stringify(b.scale)), x.rotation.x = x.rotation._x = MathUtils.radToDeg(x.rotation._x), x.rotation.y = x.rotation._y = MathUtils.radToDeg(x.rotation._y), x.rotation.z = x.rotation._z = MathUtils.radToDeg(x.rotation._z), this.transformNode = x; var w = b; this.getNodeMesh = () => w, this.setProperty = (e, t, i) => { switch (this[e] = t, w.userData && (w.userData.nodeSettings = { isRotating: this.isRotating, rotatingAxis: this.rotatingAxis, rotatingSpeed: this.rotatingSpeed, isScaling: this.isScaling, isBreathing: this.isBreathing, startScale: this.startScale, stopScale: this.stopScale, fadeOutScale: this.fadeOutScale, scalingSpeed: this.scalingSpeed, breathingSpeed: this.breathingSpeed, endBreathe: this.endBreathe, isLock: this.isLock }), e) { case "isCastingShadow": w.castShadow = !!t, util$1.setThreePropertyRecursively(w, "castShadow", !!t), util$1.setNodePropertyRecursively(this, "isCastingShadow", !!t); break; case "isReceivingShadow": w.receiveShadow = !!t, util$1.setThreePropertyRecursively(w, "receiveShadow", !!t), util$1.setNodePropertyRecursively(this, "isReceivingShadow", !!t); break; case "isVisible": w.visible = !!t, util$1.setThreePropertyRecursively(w, "visible", !!t), util$1.setNodePropertyRecursively(this, "isVisible", !!t); break; case "isRotating": case "rotatingAxis": case "rotatingSpeed": _context.scene.setNodeRotating && _context.scene.setNodeRotating({ enabled: this.isRotating, node: w, rotatingAxis: this.rotatingAxis, rotatingSpeed: this.rotatingSpeed }); break; case "isScaling": case "startScale": case "stopScale": case "fadeOutScale": case "scalingSpeed": _context.scene.setNodeScaling && _context.scene.setNodeScaling({ enabled: this.isScaling, node: w, startScale: this.startScale, stopScale: this.stopScale, fadeOutScale: this.fadeOutScale, scalingSpeed: this.scalingSpeed }); break; case "isBreathing": case "breathingSpeed": _context.scene.setNodeBreathing && _context.scene.setNodeBreathing({ enabled: this.isBreathing, node: w, endBreathe: this.endBreathe, breathingSpeed: this.breathingSpeed }); break; case "enableSSR": this.enableSSR && _context.instance.ssrOn && setTimeout((() => { _context.instance.ssrOn(this.name, this.modelName) }), 500); break; case "transformNode": i || (this.transformNode = t, w.position.set(t.position.x, t.position.y, t.position.z), w.scale.set(t.scale.x, t.scale.y, t.scale.z), w.rotation.order = t.rotation._order, w.rotation.x = MathUtils.degToRad(t.rotation.x), w.rotation.y = MathUtils.degToRad(t.rotation.y), w.rotation.z = MathUtils.degToRad(t.rotation.z)) } } } dispose() { this.children && this.children.forEach((e => { util$1.disposeThreeObject(e) })), this.children = null, this.material instanceof Array && (this.material.forEach((e => { util$1.disposeThreeObject(e) })), this.material = null) } } Node._fromThreeObject = function (e) { let t, { uuid: i, name: r, type: n, material: a, castShadow: o, receiveShadow: s, visible: l, isLock: c, children: h, userData: u } = e; if (a instanceof Array) { t = []; for (let e of a) t.push(e.name) } else t = a ? a.name : void 0; let d = new Node({ id: i, name: r, material: t, isCastingShadow: o, isReceivingShadow: s, isVisible: l, isLock: c, modelNode: e }); if (u.nodeSettings && (d.isRotating = u.nodeSettings.isRotating, d.rotatingAxis = u.nodeSettings.rotatingAxis, d.rotatingSpeed = u.nodeSettings.rotatingSpeed, d.isScaling = u.nodeSettings.isScaling, d.isBreathing = u.nodeSettings.isBreathing, d.startScale = u.nodeSettings.startScale, d.stopScale = u.nodeSettings.stopScale, d.fadeOutScale = u.nodeSettings.fadeOutScale, d.scalingSpeed = u.nodeSettings.scalingSpeed, d.breathingSpeed = u.nodeSettings.breathingSpeed, d.endBreathe = u.nodeSettings.endBreathe, d.isLock = u.nodeSettings.isLock), h instanceof Array) for (let e of h) d.children.push(Node._fromThreeObject(e)); return d }; var axisTypeChangeEvent$1 = { type: "axisTypeChange" }, mouseDownEvent$1 = { type: "mouseDown" }, mouseUpEvent$1 = { type: "mouseUp", mode: null }; class NodeSelection extends EventDispatcher { constructor() { super("NodeSelection"); let e = "centre", t = new Map, i = new Object3D, r = new Vector3, n = new Euler, a = new Vector3, o = []; this.controlsState = !1; let s = e => { let t = {}; t.position = JSON.parse(JSON.stringify(e.threeObject.position)), t.rotation = JSON.parse(JSON.stringify(e.threeObject.rotation)), t.rotation.x = t.rotation._x, t.rotation.y = t.rotation._y, t.rotation.z = t.rotation._z, t.scale = JSON.parse(JSON.stringify(e.threeObject.scale)), t.rotation.x = t.rotation._x = MathUtils.radToDeg(t.rotation._x), t.rotation.y = t.rotation._y = MathUtils.radToDeg(t.rotation._y), t.rotation.z = t.rotation._z = MathUtils.radToDeg(t.rotation._z), e.userObject.transformNode = t }, l = e => { let i = e.target.object.position.clone().sub(r); r = e.target.object.position.clone(), t.forEach((e => { let t = i.clone(); t.divide(e.threeObject.parent.getWorldScale(new Vector3)); let r = new Matrix4; r.makeRotationFromQuaternion(e.threeObject.parent.getWorldQuaternion(new Quaternion)).invert(), t.applyMatrix4(r); let n = e.transform.position.clone().add(t); e.threeObject.position.copy(n), e.transform.position = e.threeObject.position.clone(), e.transform.rotation = e.threeObject.rotation.clone(), e.transform.scale = e.threeObject.scale.clone(), s(e) })) }, c = i => { let r = i.target.axis.toLocaleLowerCase(); if ("e" !== r && 0 !== i.target.rotationAngleDelta) if ("centre" === e) { let e = i.target.object.position.clone(); t.forEach((t => { ((e, t, i, r) => { if (!e || !e.position) return; if (!t) return; if ("x" !== i && "y" !== i && "z" !== i) return; const n = e.getWorldPosition(new Vector3); n.sub(t); const a = { x: new Vector3(1, 0, 0), y: new Vector3(0, 1, 0), z: new Vector3(0, 0, 1) }; n.applyAxisAngle(a[i], r), e.rotateOnWorldAxis(a[i], r); let o = e.parent.getWorldPosition(new Vector3); n.add(t), n.sub(o), n.divide(e.parent.getWorldScale(new Vector3)); let s = new Matrix4; s.makeRotationFromQuaternion(e.parent.getWorldQuaternion(new Quaternion)).invert(), n.applyMatrix4(s), e.position.copy(n) })(t.threeObject, e, r, i.target.rotationAngleDelta), s(t) })) } else "oneself" === e && t.forEach((e => { e.threeObject[`rotate${r.toLocaleUpperCase()}`](i.target.rotationAngleDelta), s(e) })) }, h = e => { let i = e.target.object.scale.clone(); t.forEach((e => { let t = i.clone(), r = new Matrix4; r.makeRotationFromQuaternion(e.threeObject.parent.getWorldQuaternion(new Quaternion)).invert(), t.applyMatrix4(r); let n = e.transform.scale; e.threeObject.scale.set(n.x * t.x, n.y * t.y, n.z * t.z), s(e) })) }; this.clearSelection = () => { o.length = 0, t.clear() }, this.deselectNodes = e => { logger.warn("NodeSelection.deselectNodes(): TO BE IMPLEMENTED.") }, this.dispose = () => { o.forEach((e => { e.dispose && e.dispose() })), o = [], t.clear() }, this.getAllProperties = () => { if (t.size < 1) return null; if (1 === t.size) { let e = this.getSelectionList(); return t.get(e[0]).userObject } let r = {}; return t.forEach((e => { for (let t in e.userObject) switch (t) { case "id": case "children": case "material": break; case "isCastingShadow": case "isReceivingShadow": case "isRotating": case "rotatingAxis": case "rotatingSpeed": case "isScaling": case "startScale": case "StopScale": case "FadeOutScale": case "ScalingSpeed": r.hasOwnProperty(t) ? r[t] = util$1.eq(r[t], e.userObject[t]) ? r[t] : null : r[t] = util$1.clone(e.userObject[t]) } })), "centre" == e ? (r.transformNode = {}, r.transformNode.position = JSON.parse(JSON.stringify(i.position)), r.transformNode.rotation = JSON.parse(JSON.stringify(i.rotation)), r.transformNode.rotation.x = r.transformNode.rotation._x, r.transformNode.rotation.y = r.transformNode.rotation._y, r.transformNode.rotation.z = r.transformNode.rotation._z, r.transformNode.scale = JSON.parse(JSON.stringify(i.scale)), r.transformNode.rotation.x = r.transformNode.rotation._x = MathUtils.radToDeg(r.transformNode.rotation._x), r.transformNode.rotation.y = r.transformNode.rotation._y = MathUtils.radToDeg(r.transformNode.rotation._y), r.transformNode.rotation.z = r.transformNode.rotation._z = MathUtils.radToDeg(r.transformNode.rotation._z)) : "oneself" == e && (r.transformNode = {}, t.forEach((e => { let t = {}; for (var i in t.position = JSON.parse(JSON.stringify(e.threeObject.position)), t.rotation = JSON.parse(JSON.stringify(e.threeObject.rotation)), t.rotation.x = t.rotation._x, t.rotation.y = t.rotation._y, t.rotation.z = t.rotation._z, t.scale = JSON.parse(JSON.stringify(e.threeObject.scale)), t.rotation.x = t.rotation._x = MathUtils.radToDeg(t.rotation._x), t.rotation.y = t.rotation._y = MathUtils.radToDeg(t.rotation._y), t.rotation.z = t.rotation._z = MathUtils.radToDeg(t.rotation._z), t) if (r.transformNode.hasOwnProperty(i)) for (let e in t[i]) r.transformNode[i] && !r.transformNode[i].hasOwnProperty(e) ? r.transformNode[i][e] = util$1.clone(t[i][e]) : r.transformNode[i][e] = util$1.eq(r.transformNode[i][e], t[i][e]) ? r.transformNode[i][e] : "--"; else r.transformNode[i] = util$1.clone(t[i]) }))), delete r.id, delete r.children, delete r.material, r }, this.getProperty = (e = "") => { if (t.size < 1) return null; if (1 === t.size) { let e = this.getSelectionList(); return t.get(e[0]).userObject } switch (e) { case "id": case "children": case "material": needContinue = !0 }if (needContinue) return null; let i; return t.forEach((t => { i = void 0 === i ? util$1.clone(t.userObject[e]) : util$1.eq(i, t.userObject[e]) ? i : null })), i }, this.merge = () => (logger.warn("NodeSelection.merge(): TO BE IMPLEMENTED."), new Node), this.setProperties = e => { if ("object" == typeof e) for (let i in e) { let r = !1; switch (i) { case "id": case "name": case "children": case "material": r = !0 }r || t.forEach((t => { t.userObject[i] = e[i] })) } else logger.warn("NodeSelection.setProperties(): Invalid properties object specified.") }, this.setProperty = (e = "", i, r) => { if (logger.debug("TRACE: NodeSelection.setProperty (propertyName, propertyValue) - Entering.", e, i), "" === e) return logger.warn("NodeSelection.setProperty(): No propertyName specified."), void logger.debug("TRACE: NodeSelection.setProperty (propertyName, propertyValue) - Exiting."); if (e.indexOf("transformNode") > -1) this.setPropertyTransformNode(e, i); else switch (e) { case "id": case "name": case "children": case "material": return logger.warn("NodeSelection.setProperty(): Given propertyName conflicts with an reserved property."), void logger.debug("TRACE: NodeSelection.    (propertyName, propertyValue) - Exiting."); default: t.forEach((t => { if (_context.scene) { let n = t.threeObject, a = t.userObject; "Object3D" !== n.type && "Group" !== n.type && !n.isMesh || n.name !== a.name || a.setProperty(e, i, r) } })) } }, this.setPropertyByUUID = (e, t = "", i, r) => { if (logger.debug("TRACE: NodeSelection.setProperty (propertyName, propertyValue) - Entering.", t, i), "" === t) return logger.warn("NodeSelection.setProperty(): No propertyName specified."), void logger.debug("TRACE: NodeSelection.setProperty (propertyName, propertyValue) - Exiting."); let n = _context.instance.defaultObjectTree.getItemByUUID(e); n instanceof Node && n.setProperty(t, i, r) }, this.setPropertyTransformNode = (r = "", n) => { if ("" === r) return; if (-1 === r.indexOf("transformNode")) return; let a = r.split("-"); if (_context.transformControls.dispatchEvent(mouseDownEvent$1), "oneself" === e) t.forEach(((e, t) => { let i = JSON.parse(JSON.stringify(_context.instance.getModelTransformByUUID(t))); 3 == a.length ? i[a[1]][a[2]] = n : 2 == a.length && (i[a[1]] = n), _context.instance.setModelTransformByUUID(t, i) })), this.enableTransformControl(); else if ("centre" === e) { let e = ["x", "y", "z"]; if ("rotation" === a[1]) if (3 == a.length) { let e = i.rotation[a[2]]; i[`rotate${a[2].toUpperCase()}`](MathUtils.degToRad(n) - e); let t = { target: { axis: a[2], object: i, rotationAngleDelta: MathUtils.degToRad(n) - e } }; c(t) } else 2 == a.length && e.forEach((e => { let t = i.rotation[e]; i[`rotate${e.toUpperCase()}`](MathUtils.degToRad(n[e]) - t); let r = { target: { axis: e, object: i, rotationAngleDelta: MathUtils.degToRad(n[e]) - t } }; c(r) })); else if ("position" === a[1]) if (3 == a.length) { i.position[`set${a[2].toUpperCase()}`](n), l({ target: { object: i } }) } else 2 == a.length && e.forEach((e => { i.position[`set${e.toUpperCase()}`](n[e]), l({ target: { object: i } }) })); else if ("scale" === a[1]) if (3 == a.length) { i.scale[`set${a[2].toUpperCase()}`](n), h({ target: { object: i } }) } else 2 == a.length && e.forEach((e => { i.scale[`set${e.toUpperCase()}`](n[e]), h({ target: { object: i } }) })) } mouseUpEvent$1.mode = _context.transformControls.mode, _context.transformControls.dispatchEvent(mouseUpEvent$1) }, this.selectNodes = (e, t = !1) => { if (t || (o.length = 0), !(e instanceof Array) || e.length < 1) return void logger.warn("NodeSelection.selectNodes(): No node selected."); let i = !1; for (let t of e) t instanceof Node ? o.push(t) : i = !0; return i && logger.warn("NodeSelection.selectNodes(): Invalid input found."), o.length }, this.getSelectionList = () => { let e = []; return t.forEach(((t, i) => { e.push(i) })), e }, this.selectObjectByUUID = (e = []) => (t.clear(), _context.effectStore.highlightObject(null), e.forEach((e => { let i = { threeObject: null, userObject: null, transform: {} }, r = _context.instance.defaultObjectTree.getItemByUUID(e), n = _context.scene.getObjectByProperty("uuid", e); r && r instanceof Node ? (i.userObject = r, i.threeObject = n, i.transform.position = n.position.clone(), i.transform.rotation = n.rotation.clone(), i.transform.scale = n.scale.clone(), t.set(e, i), _context.effectStore.highlightObject(i.threeObject, !0)) : logger.warn("ModeSelection.selectObjectByUUID(): Invalid input found.") })), this.controlsState && this.enableTransformControl(), this.getSelectionList()), this.setSelectNodeByUUID = e => { t.forEach(((e, t) => { e.transform.scale = e.threeObject.scale.clone(), e.transform.position = e.threeObject.position.clone(), e.transform.rotation = e.threeObject.rotation.clone() })); let i = { threeObject: null, userObject: null, transform: {} }, r = _context.instance.defaultObjectTree.getItemByUUID(e), n = _context.scene.getObjectByProperty("uuid", e); return r && r instanceof Node ? (i.userObject = r, i.threeObject = n, i.transform.position = n.position.clone(), i.transform.rotation = n.rotation.clone(), i.transform.scale = n.scale.clone(), 1 == t.size && t.forEach((e => { e.transform.position = e.threeObject.position.clone(), e.transform.rotation = e.threeObject.rotation.clone(), e.transform.scale = e.threeObject.scale.clone() })), t.set(e, i), _context.effectStore.highlightObject(i.threeObject, !0), this.controlsState && this.enableTransformControl()) : logger.warn("ModeSelection.selectObjectByUUID(): Invalid input found."), this.getSelectionList() }, this.deleteSelectNodeByUUID = e => (t.forEach(((e, t) => { e.transform.scale = e.threeObject.scale.clone(), e.transform.position = e.threeObject.position.clone(), e.transform.rotation = e.threeObject.rotation.clone() })), t.get(e) ? (_context.effectStore.cancleHighlightObject(t.get(e).threeObject), t.delete(e), this.controlsState && this.enableTransformControl(), this.getSelectionList()) : (logger.warn("ModeSelection.deleteSelectObjectByUUID(): Invalid input found."), this.getSelectionList())), this.toggleSelectObjectByUUID = e => (t.get(e) ? this.deleteSelectNodeByUUID(e) : this.setSelectNodeByUUID(e), this.getSelectionList()), this.getCenterPosition = () => { let e = []; if (t.forEach((t => { t.threeObject.traverse((t => { let i = t.getWorldPosition(new Vector3); if (t.geometry) { t.geometry.computeBoundingBox(); let r = t.geometry.boundingBox.getCenter(new Vector3); i.add(r), e.push(i) } else t.children && t.children.length || e.push(i) })) })), !e.length) return new Vector3; let i = e[0].clone(), r = e[0].clone(); return e.forEach((e => { i.min(e), r.max(e) })), new Box3(i, r).getCenter(new Vector3) }, this.enableTransformControl = () => { if (this.disableTransformControl(), 1 === t.size) { let e = this.getSelectionList(); return void _context.transformControls.attach(t.get(e[0]).threeObject) } if (t.size < 1) return; this.controlsState = !0; let e = this.getCenterPosition(); i.position.copy(e), i.rotation.set(0, 0, 0), i.scale.set(1, 1, 1), r.copy(e), n.copy(i.rotation), a.copy(i.scale), _context.scene.add(i), _context.transformControls.addEventListener("translate", l), _context.transformControls.addEventListener("rotate", c), _context.transformControls.addEventListener("scale", h), _context.transformControls.attach(i), _context.transformControls.showE = !1 }, this.disableTransformControl = () => { _context.transformControls.removeEventListener("translate", l), _context.transformControls.removeEventListener("rotate", c), _context.transformControls.removeEventListener("scale", h), _context.transformControls.showE = !0, this.controlsState = !1, _context.transformControls.object && _context.transformControls.detach() }, this.onTransformControlsEvent = (e, t) => (_context.transformControls.addEventListener(e, t), 1), this.offTransformControlsEvent = (e, t) => (_context.transformControls.removeEventListener(e, t), 1), this.getAxisType = () => e, this.setAxisType = t => ("centre" != t && "oneself" != t || (e = t, this.dispatchEvent(axisTypeChangeEvent$1)), e), this.getSelectedNodeMap = () => t } } class ObjectTreeItem { constructor(e) { let t = e; function i(e) { return e = e.sort(((e, t) => e.index - t.index)) } this.children = [], this.isVisible = !0, this.isLock = !1, this._nodeSelection = new NodeSelection(_context.scene), this.getType = () => this.type, this.transform = { position: { x: 0, y: 0, z: 0 }, rotation: { _x: 0, _y: 0, _z: 0, _order: "XYZ" }, scale: { x: 1, y: 1, z: 1 } }, this.isModel = () => "modelitem" === t.toLowerCase(), this.isFolder = () => "folderitem" === t.toLowerCase(), this.dispose = (e, t) => { _context.instance.disableTransform(), this.modelItemSSROffRecursion(this.children, e); for (let t = this.children.length - 1; t >= 0; t--)if (this.children[t].name === e) { if (this.children[t].key, util$1.disposeThreeObject(this.children[t].getGroup()), this.children[t].isInstancedItem) { let e = this.modelInstanced.find((e => e.name == this.children[t].parent)); if ("ModelAsset" == this.children[t].type || "ModelItem" == this.children[t].type) for (let i = 0; i < this.children.length; i++)this.children[i].isInstancedItem && this.children[i].parent == e.name && this.children[i].key > this.children[t].key && (this.children[i].key = this.children[i].key - 1); this.children[t].remove() } else this.children[t].dispose && this.children[t].dispose(), this.getGroup().remove(this.children[t].getGroup()); this.children.splice(t, 1), "PaintItem" !== this.type || this.children.length || _context.defaultObjectTree.remove(this.name) } i(this.children).forEach(((e, t) => { e.index = t })), _context.instance.cutLevelByUUID(this.getGroup().uuid, !1), t && t(1, "删除成功") }, this.traverse = (e, t) => { if (e && "function" == typeof e && this.children && this.children instanceof Array) { t || (t = this.children, e(this)); for (let i of t) e(i), i.children instanceof Array && this.traverse(e, i.children) } }, this.remove = (e, t) => { _context.instance.disableTransform(), this.modelItemSSROffRecursion(this.children, e); for (let t = this.children.length - 1; t >= 0; t--)this.children[t].name === e && (this.getGroup().remove(this.children[t].getGroup()), this.children.splice(t, 1)); i(this.children).forEach(((e, t) => { e.index = t })), _context.instance.cutLevelByUUID(this.getGroup().uuid, !1), t && t(1, "删除成功") }, this.hide = () => { _context.scene && _context.scene.children.map((e => { "__sysObjectsWater" === e.name && e.children.map((e => { e.userData.modelName === this.name && (e.visible = !1) })) })); let e = this.getGroup(); e && (e.visible = !1), this.isVisible = !1 }, this.show = () => { _context.scene && _context.scene.children.map((e => { "__sysObjectsWater" === e.name && e.children.map((e => { e.userData.modelName === this.name && (e.visible = !0) })) })); let e = this.getGroup(); e && (e.visible = !0), this.isVisible = !0 }, this.rename = (e, t) => { if (e) { for (let t = 0; t < _context.ssr.length; t++)_context.ssr[t].modelName === this.name && (_context.ssr[t].modelName = e); if (this.name = e, this.getGroup().name = e, this.materialStore) for (let t in this.materialStore._materials) this.materialStore._materials[t]._modelName = e; for (let t = 0; t < this.children.length; t++)this.children[t].parent && (this.children[t].parent = e); t && t(1, "模型重命名成功") } }, this.copy = (e, t) => { if (e) { _context.copyModel = null; for (let i = 0; i < this.children.length; i++)switch (this.children[i].type) { case "ModelItem": case "IconAsset": if (this.children[i].name === e) return _context.copyModel = this.children[i].getSettings(), _context.copyModel.transform.position = util$1.changeTransformFromScene(_context.copyModel, this.getGroup().parent, this.getGroup()).position, void (t && t(1, "复制成功")); break; case "BuildingFloorItem": for (let r = 0; r < this.children[i].children.length; r++)if (this.children[i].children[r].name === e) return _context.copyModel = this.children[i].children[r].getSettings(), _context.copyModel.transform.position = util$1.changeTransformFromScene(_context.copyModel, this.getGroup().parent, this.getGroup()).position, void (t && t(1, "复制成功")) } } }, this.paste = e => { if (_context.copyModel) { let t = JSON.parse(JSON.stringify(_context.copyModel)); switch (t.name = util$1.getCopyName(t.name + "副本", 0, _context.defaultObjectTree), this.type) { case "BuildingItem": case "BuildingFloorItem": return t.parent = this.name, t.index = this.children.length, delete t.id, void this.addNoneFloor(t, (i => { 1 === i && ("ModelItem" === t.type ? this.pasteLater(this, t, (t => { 1 === t && e && e(1, "粘贴成功") })) : e && e(1, "粘贴成功")) })); case "ModelItem": case "IconAsset": if ("objectTree" === this.parent) t.parent = "objectTree", t.index = _context.defaultObjectTree.children.length, delete t.id, "ModelItem" === t.type ? _context.defaultObjectTree.addModel(t, (i => { 1 === i && this.pasteLater(_context.defaultObjectTree, t, (t => { 1 === t && e && e(1, "粘贴成功") })) })) : "IconAsset" === t.type && _context.defaultObjectTree.addIconAsset(t, null, (t => { 1 === t && e && e(1, "粘贴成功") })); else { let i = _context.defaultObjectTree.getItemByUUID(this.getGroup().parent.uuid); i ? (t.parent = i.name, t.index = i.children.length, delete t.id, i.addNoneFloor(t, (r => { 1 === r && ("ModelItem" === t.type ? this.pasteLater(i, t, (t => { 1 === t && e && e(1, "粘贴成功") })) : e && e(1, "粘贴成功")) }))) : _context.instance.defaultObjectTree.children.forEach((i => { "BuildingItem" === i.type && i.children.forEach((i => { "BuildingFloorItem" === i.type && this.parent === i.name && (t.parent = i.name, t.index = i.children.length, delete t.id, i.addNoneFloor(t, (r => { 1 === r && ("ModelItem" === t.type ? this.pasteLater(i, t, (t => { 1 === t && e && e(1, "粘贴成功") })) : e && e(1, "粘贴成功")) }))) })) })) } } } else e && e(0, "用户没有进行复制无法粘贴") }, this.pasteLater = (e, t, i) => { if (e && t) { if ("ModelItem" === t.type) { let i = e.getItemByName(t.name); e.getItemByName(t.name).materialStore.applySettings(t.materials), util$1.setNode(t, i, this._nodeSelection), util$1.setArticulation(t, i), _context.instance.cutLevelByUUID(e.getGroup().uuid, !1), t.children && this.modelItemSSROnRecursion(t.children, t.name); for (let e in t.materials) t.materials[e].enableTranslation && _context.instance.setMaterialAnimation({ name: t.materials[e].name, enableTranslation: t.materials[e].enableTranslation, translationSpeedU: t.materials[e].translationSpeedU, translationSpeedV: t.materials[e].translationSpeedV, modelName: t.name }) } else t.type; i && i(1, "成功") } else i && i(0, "参数错误") }, this.move = (e, t) => { e || t && t(0, "参数错误"); let i = _context.defaultObjectTree.getItemByName(e), r = null; i.getSettings().children && (r = JSON.parse(JSON.stringify(i.getSettings().children))), i || t && t(0, "目标不存在"); let n = JSON.parse(JSON.stringify(i.getGroup().parent.uuid)); i.parent = this.name, i.clipping = !1, this.children.push(i), this.getGroup().add(i.getGroup()), "objectTree" === parent ? _context.defaultObjectTree.remove(i.name) : _context.defaultObjectTree.getItemByUUID(n).remove(i.name), r && this.modelItemSSROnRecursion(r, i.name), t && t(1, "移动成功") }, this.getModelTransform = (e, t) => { var i = {}; for (let t = 0; t < this.children.length; t++)if ("ModelItem" === this.children[t].type || "IconAsset" === this.children[t].type) this.children[t].name === e && (i = util$1.getModelTransform(this.children[t].getGroup())); else if ("BuildingFloorItem" === this.children[t].type) if (this.children[t].name === e) i = util$1.getModelTransform(this.children[t].getGroup()); else for (let r = 0; r < this.children[t].children.length; r++)this.children[t].children[r].name === e && (i = util$1.getModelTransform(this.children[t].children[r].getGroup())); return t && t(1, "获取成功"), i }, this.setModelTransform = (e, t, i) => { for (let i = 0; i < this.children.length; i++)if ("ModelItem" === this.children[i].type || "IconAsset" === this.children[i].type) this.children[i].name === e && _context.instance.setTransform(this.children[i].getGroup(), t); else if ("BuildingFloorItem" === this.children[i].type) if (this.children[i].name === e) _context.instance.setTransform(this.children[i].getGroup(), t); else for (let r = 0; r < this.children[i].children.length; r++)this.children[i].children[r].name === e && _context.instance.setTransform(this.children[i].children[r].getGroup(), t); i && i(1, "设置成功") }, this.addModelFromScene = (e, t) => { e || t && t(0, "参数错误"), _context.instance.disableTransform(); let i = _context.instance.defaultObjectTree.children.find((t => t.name === e)), r = null; i.getSettings().children && (r = JSON.parse(JSON.stringify(i.getSettings().children))), i || t && t(0, "对象不存在"), i.index = this.children.length, i.parent = this.name, i.parentUUID = this.getGroup().uuid, this.children.push(i); var n = { transform: { position: i.getGroup().position } }; "BuildingItem" === this.type ? util$1.changeTransformFromBuildind(n, this.getGroup()) : "BuildingFloorItem" === this.type && util$1.changeTransformFromBuildind(n, this.getGroup().parent, this.getGroup()), this.getGroup().add(i.getGroup()), _context.instance.defaultObjectTree.remove(e), r && this.modelItemSSROnRecursion(r, i.name), t && t(1, "添加成功"), "BuildingItem" == this.type ? _context.instance.cutLevel(this.getGroup().uuid, this.floor) : "BuildingFloorItem" === this.type && _context.instance.cutLevel(this.getGroup().parent.uuid, _context.defaultObjectTree.getItemByUUID(this.getGroup().parent.uuid).floor) }, this.removeFromBuilding = (e, t) => { e || t && t(0, "参数错误"), _context.instance.disableTransform(); let i = this.getItemByName(e), r = null; i.getSettings().children && (r = JSON.parse(JSON.stringify(i.getSettings().children))), i || t && t(0, "对象不存在"), i.index = _context.instance.defaultObjectTree.children.length, i.parent = "objectTree", _context.instance.defaultObjectTree.children.push(i); var n = { transform: { position: i.getGroup().position } }; if ("BuildingItem" === this.type) { let e = util$1.changeTransformFromScene(n, this.getGroup()).position; i.getGroup().position.set(e.x, e.y, e.z) } else if ("BuildingFloorItem" === this.type) { let e = util$1.changeTransformFromScene(n, this.getGroup().parent, this.getGroup()).position; i.getGroup().position.set(e.x, e.y, e.z) } _context.scene.models.add(i.getGroup()), this.remove(e), _context.instance.clipNode(this.name, 0, 0, 0, 0), _context.instance.cutLevel(this.getGroup().uuid, this.floor), r && this.modelItemSSROnRecursion(r, i.name), t && t(1, "移除成功") }, this.modelItemSSROnRecursion = (e, t) => { for (let i = 0; i < e.length; i++)e[i].enableSSR && _context.instance.ssrOn(e[i].name, t), e[i].children && e[i].children.length > 0 && this.modelItemSSROnRecursion(e[i].children, t) }, this.modelItemSSROffRecursion = (e, t) => { for (let i = 0; i < e.length; i++)e[i].enableSSR && _context.instance.ssrOff(e[i].name, t), e[i].children && e[i].children.length > 0 && this.modelItemSSROffRecursion(e[i].children, t) }, this._getVisible = () => this.isVisible, this._setVisible = e => { this.isVisible = e }, this._getLock = () => this.isLock, this._setLock = e => { this.isLock = e }, this.lock = () => { this.isLock = !0 }, this.unLock = () => { this.isLock = !1 } } } class IconItem extends ObjectTreeItem { constructor(e, t, i, r = _context.defaultObjectTree, n) { super("IconItem"), this.type = e.type, this.name = e.name, this.param = e.param, this.textParam = e.textParam, this.index = e.index ? e.index : null, this.parent = e.parent ? e.parent : null, this.transform = e.transform ? e.transform : this.transform, this.isEditor = !0, this.isCustom = e.isCustom || !1, this._cliiping = !1, this.children = []; let a = new Group, o = null; function s(e) { Object.assign(e.uniforms, this.uniforms), e.fragmentShader = "uniform vec3 outlineColor;\n" + e.fragmentShader, e.fragmentShader = "uniform float outlineThickness;\n" + e.fragmentShader, e.fragmentShader = "uniform vec2 resolution;\n" + e.fragmentShader, e.fragmentShader = "uniform float outline;\n" + e.fragmentShader, e.fragmentShader = e.fragmentShader.replace("#include <map_fragment>", ["#ifdef USE_MAP", " vec4 texelColor = mapTexelToLinear( texture2D( map, vUv ) );", " texelColor = mapTexelToLinear( texelColor );", " if (outline == 0.) {", "\tdiffuseColor = diffuseColor * texelColor;", " } else { ", "\tfloat width = 0.0;", "\tif (resolution.x > resolution.y) {", "\t\twidth = resolution.y;", "\t} else {", "\t\twidth = resolution.x;", "\t}", " \tvec2 texel = vec2( 1.0 / resolution.y, 1.0 / resolution.x );", " \t#define OFFSET_COUNT_FLOAT 32.", " \t#define OFFSET_COUNT 8", " \tfloat aspect = resolution.x / resolution.y;", " \tvec2 offsets[OFFSET_COUNT];", " \toffsets[0] = vec2( 0., 1.);", " \toffsets[1] = vec2( 0., -1.);", " \toffsets[2] = vec2( 1., 0. );", " \toffsets[3] = vec2( -1., 0. );", " \toffsets[4] = vec2( -0.5, 0.5);", " \toffsets[5] = vec2( 0.5, -0.5);", " \toffsets[6] = vec2( 0.5, 0.5);", " \toffsets[7] = vec2( -0.5, -0.5);", " \tfloat a = 0.0;", " \tfloat theta = 0.;", " \tfor( float i = 0.; i < OFFSET_COUNT_FLOAT; i ++ ) {", "\t\ttheta = (6.283185307179586 / OFFSET_COUNT_FLOAT) * i;", " \t\tvec2 samplePoint = vec2(cos(theta) * outlineThickness, sin(theta) * outlineThickness * aspect);", "  \t\tfloat val = texture2D( map, vUv + texel * samplePoint).a;", "  \t\ta = max(a, val);", " \t}", " \tif (texelColor.a > 0.95) {", "\t\tdiffuseColor = diffuseColor * texelColor;", " \t} else {", " \t\ttexelColor = mix( vec4(outlineColor, a), texelColor, texelColor.a );", "\t\tdiffuseColor = vec4(outlineColor.x + 0.5, outlineColor.g + 0.5, outlineColor.b + 0.5, a) * texelColor;", " \t}", " }", "#endif"].join("\n")) } a.renderOrder = 1, a.type = "IconGroup", this.getGroup = () => a, this.add = (e, t, i, r = _context.defaultObjectTree, n) => { if ("IconItem" !== e.type && "IconAsset" !== e.type) return; if (a.name = e.name, a.position.set(e.transform.position.x, e.transform.position.y, e.transform.position.z), e.transform.scale && a.scale.set(Number(e.transform.scale.x) <= 0 ? 1 : e.transform.scale.x, Number(e.transform.scale.y) <= 0 ? 1 : e.transform.scale.y, Number(e.transform.scale.z) <= 0 ? 1 : e.transform.scale.z), "" != e.param.background) { let t = _context.loaders.textureLoader.load(util$1.url(_context.instance.resourceBasePath, "texture/iconBackground/" + e.param.background + ".png"), (e => { this.backgroundMap = h(e) })); (o = new SpriteMaterial({ map: t, color: new Color$1(e.param.backgroundColor), fog: !1, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, alphaTest: .1, transparent: !0, sizeAttenuation: e.param.sizeAttenuation, polygonOffset: e.param.polygonOffset, polygonOffsetFactor: e.param.polygonOffsetFactor, polygonOffsetUnits: e.param.polygonOffsetUnits })).uniforms = { outlineColor: { value: new Color$1("#ffff00") }, outlineThickness: { value: 65 }, resolution: { value: new Vector2(_context.renderer.domElement.width, _context.renderer.domElement.height) }, outline: { value: 0 } }, o.onBeforeCompile = s, (u = new Sprite(o)).name = e.name + "底图", u.type = "IconBackground", u.scale.set(e.param.sizeAttenuation ? Number(e.param.width) / 25 : Number(e.param.width) / 2500, e.param.sizeAttenuation ? Number(e.param.height) / 25 : Number(e.param.height) / 2500, 1); let i = -1; if (u.center = new Vector2(i * e.param.offsetV + .5, i * e.param.offsetH + .5), e.param.backgroundColor && "rgba" === e.param.backgroundColor.substring(0, 4)) { let t = e.param.backgroundColor.slice(4); t = t.split(","), t = parseFloat(t[3].replace(/[^0-9.]/gi, "")), u.material.opacity = t } a.add(u) } else { var o, u; (o = new SpriteMaterial).uniforms = { outlineColor: { value: new Color$1("#ffff00") }, outlineThickness: { value: 65 }, resolution: { value: new Vector2(_context.renderer.domElement.width, _context.renderer.domElement.height) }, outline: { value: 0 } }, (u = new Sprite(o)).visible = !1, a.add(u) } if (-1 != e.param.path.indexOf("[[origin]]")) var d = e.param.path.replace("[[origin]]", _context.origin); else d = e.param.path; e.map && (d = e.map); let p = _context.loaders.textureLoader.load(d, (e => { this.map = h(e), n && n(1, this) })); var f = new SpriteMaterial({ map: p, color: new Color$1("#ffffff"), fog: !1, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, alphaTest: .1, transparent: !0, sizeAttenuation: e.param.sizeAttenuation, polygonOffset: e.param.polygonOffset, polygonOffsetFactor: e.param.polygonOffsetFactor, polygonOffsetUnits: e.param.polygonOffsetUnits }), m = new Sprite(f); m.name = e.name + "图标", m.type = "IconAsset", m.scale.set(e.param.sizeAttenuation ? Number(e.param.width) / 50 : Number(e.param.width) / 5e3, e.param.sizeAttenuation ? Number(e.param.height) / 50 : Number(e.param.height) / 5e3, 1); "" == e.param.background ? m.center = new Vector2(-1 * e.param.offsetV + .5, -1 * e.param.offsetH + .5) : m.center = new Vector2(-2 * e.param.offsetV + .5, -2 * e.param.offsetH + .5), a.add(m); return null != e.textParam && e.textParam.enableText ? (e.textParam.canvas = c(e.textParam.fontFamily, e.textParam.fontSize, e.textParam.fontBold, e.textParam.enableItalic, e.textParam.background, e.textParam.color, e.textParam.text), l(a, e).name = e.name + "文字") : a.add(new Group), t ? (t.add(a), "GroupItem" !== t.type && "PaintItem" != t.type || t.childrenAdd(this), i && i(1, this)) : (_context.scene.models.add(a), r.addItem(this), i && i(1, this)), a }, this.update = function (e, t, i = !0) { if (a.clear(), this.type = e.type, this.name = e.name, this.param = e.param, this.textParam = e.textParam, this.transform = e.transform, null != a) { if (a.name = e.name, "" != e.param.background) { let t = _context.loaders.textureLoader.load(util$1.url(_context.instance.resourceBasePath, "texture/iconBackground/" + e.param.background + ".png"), (e => { this.backgroundMap = e })); (r = new SpriteMaterial({ map: t, color: new Color$1(e.param.backgroundColor), fog: !1, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, alphaTest: .1, transparent: !0, sizeAttenuation: e.param.sizeAttenuation, polygonOffset: e.param.polygonOffset, polygonOffsetFactor: e.param.polygonOffsetFactor, polygonOffsetUnits: e.param.polygonOffsetUnits })).uniforms = { outlineColor: { value: new Color$1("#ffff00") }, outlineThickness: { value: 65 }, resolution: { value: new Vector2(_context.renderer.domElement.width, _context.renderer.domElement.height) }, outline: { value: i ? 1 : 0 } }, r.onBeforeCompile = s, (n = new Sprite(r)).name = e.name + "底图", n.type = "IconBackground", n.scale.set(e.param.sizeAttenuation ? Number(e.param.width) / 25 : Number(e.param.width) / 2500, e.param.sizeAttenuation ? Number(e.param.height) / 25 : Number(e.param.height) / 2500, 1); let o = -1; if (n.center = new Vector2(e.param.offsetV * o + .5, e.param.offsetH * o + .5), "rgba" === e.param.backgroundColor.substring(0, 4)) { let t = e.param.backgroundColor.slice(4); t = t.split(","), t = parseFloat(t[3].replace(/[^0-9.]/gi, "")), n.material.opacity = t } a.add(n) } else { var r, n; (r = new SpriteMaterial).uniforms = { outlineColor: { value: new Color$1("#ffff00") }, outlineThickness: { value: 65 }, resolution: { value: new Vector2(_context.renderer.domElement.width, _context.renderer.domElement.height) }, outline: { value: 0 } }, (n = new Sprite(r)).visible = !1, a.add(n) } if (-1 != e.param.path.indexOf("[[origin]]")) var o = e.param.path.replace("[[origin]]", _context.origin); else o = e.param.path; e.map && (o = e.map); let t = _context.loaders.textureLoader.load(o, (e => { this.map = h(e) })); var u = new SpriteMaterial({ map: t, color: new Color$1("#ffffff"), fog: !1, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, alphaTest: .1, transparent: !0, sizeAttenuation: e.param.sizeAttenuation, polygonOffset: e.param.polygonOffset, polygonOffsetFactor: e.param.polygonOffsetFactor, polygonOffsetUnits: e.param.polygonOffsetUnits }), d = new Sprite(u); d.name = e.name + "图标", d.type = "IconAsset", d.scale.set(e.param.sizeAttenuation ? Number(e.param.width) / 50 : Number(e.param.width) / 5e3, e.param.sizeAttenuation ? Number(e.param.height) / 50 : Number(e.param.height) / 5e3, 1); let p = -1; "" == e.param.background ? d.center = new Vector2(p * e.param.offsetV + .5, p * e.param.offsetH + .5) : d.center = new Vector2(2 * p * e.param.offsetV + .5, 2 * p * e.param.offsetH + .5), a.add(d); null != e.textParam && e.textParam.enableText ? (e.textParam.canvas = c(e.textParam.fontFamily, e.textParam.fontSize, e.textParam.fontBold, e.textParam.enableItalic, e.textParam.background, e.textParam.color, e.textParam.text), l(a, e).name = e.name + "文字") : a.add(new Group) } t && t(1) }, this.iconHide = () => { o = a.visible, a.visible = !1 }, this.iconShow = () => { a.visible = o, o = null }, this.getSettings = () => (a && (this.transform.position = a.position, this.transform.rotation = a.rotation, this.transform.scale = a.scale), { name: this.name, type: this.getType(), isVisible: this._getVisible(), isLock: this._getLock(), index: this.index, param: this.param, map: this.map, backgroundMap: this.backgroundMap, textParam: this.textParam, transform: this.transform, parent: this.parent, isCustom: this.isCustom, isEditor: this.isEditor }); let l = (e, t) => { var i; if (null != t.textParam) { var r = t.textParam.canvas, n = new CanvasTexture(r), a = new SpriteMaterial({ map: n, color: 16777215, fog: DRAWABLE_FOG, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, sizeAttenuation: t.param.sizeAttenuation }); (i = new Sprite(a)).scale.set(t.param.sizeAttenuation ? .045 * t.textParam.canvas.width : 405e-6 * t.textParam.canvas.width, t.param.sizeAttenuation ? .045 * t.textParam.canvas.height : 405e-6 * t.textParam.canvas.height, 1); let o = -1; return i.center = new Vector2(t.textParam.offsetV * o + .5, t.textParam.offsetH * o + .5), i.type = "IconAsset", i.name = t.name + "文字", i.visible = t.textParam.enableText, e ? e.add(i) : _objectStore.add(i), i } }, c = (e, t, i, r, n, a, o) => { let s = document.createElement("canvas"), l = s.getContext("2d"); var c = 4.5 * t, h = ""; i && (h = "bold"); var u = ""; return r && (u = "italic"), l.font = `${u} ${h} ${c}px ${e}`, s.width = 1.8 * (l.measureText(o).width + c), s.height = 3.2 * c, l.fillStyle = n, l.fillRect(0, 0, s.width, s.height), l.font = `${u} ${h} ${2 * c}px ${e}`, l.fillStyle = a, l.textAlign = "center", l.textBaseline = "middle", l.fillText(o, s.width / 2, s.height / 2), s }, h = e => { var t = document.createElement("canvas"); return t.width = e.image.width, t.height = e.image.height, t.getContext("2d").drawImage(e.image, 0, 0, t.width, t.height), t.toDataURL() }; this.add(e, t, i, r, n), e.isVisible ? this.show() : this.hide() } get clipping() { return this._cliiping } set clipping(e) { this._cliiping = e, e ? this.iconHide() : this.isVisible && this.iconShow() } } class ArticulationProperty { constructor({ nodes: e = [], modifiers: t, materials: i = [], particles: r = [] } = {}) { this.nodes = e, this.modifiers = t, this.materials = i, this.particles = r, this.addModifier = (e, t) => { }, this.updateModifier = (e, t) => { }, this.removeModifier = e => { }, this.clone = () => { const e = [...this.nodes], t = [...this.materials], i = [...this.particles], r = []; for (const e of this.modifiers) r.push({ key: e.key, values: [...e.values] }); return new this.constructor({ nodes: e, modifiers: r, materials: t, particles: i }) } } } class AnimationController { constructor(e) { var t = !1; this._type = e, this.pause = () => { t = !0 }, this.resume = () => { t = !1 }, this.update = e => { t || "function" == typeof this.render && this.render(e) }, this.reset = () => { }, this.dispose = () => { }, this.getIsPaused = () => t } get type() { return this._type } } let ArticulationModifierTypes = { translationX: "translationX", translationY: "translationY", translationZ: "translationZ", rotationX: "rotationX", rotationY: "rotationY", rotationZ: "rotationZ", scaleX: "scaleX", scaleY: "scaleY", scaleZ: "scaleZ", opacity: "opacity", colorOverlay: "colorOverlay", colorReplace: "colorReplace", stroke: "stroke", quantityFactor: "quantityFactor", USpeed: "USpeed", VSpeed: "VSpeed" }; class UVAnimationController extends AnimationController { constructor(e, t, i, r, n) { super("UVAnimationController"), this.material = e, this.enableU = t, this.enableV = i, this.uSpeed = r, this.vSpeed = n; let a = this._findFirstAvailableMapForUV(); a && !this.material._uvDefault && (this.material._uvDefault = { wrapS: a.wrapS, wrapT: a.wrapT, repeat: a.repeat ? a.repeat.clone() : void 0, offset: a.offset ? a.offset.clone() : void 0 }), this.reset = () => { let e = this._findFirstAvailableMapForUV(); e && this.material && this.material._uvDefault && (e.repeat.x = this.material._uvDefault.repeat.x, e.repeat.y = this.material._uvDefault.repeat.y, e.offset.x = this.material._uvDefault.offset.x, e.offset.y = this.material._uvDefault.offset.y) }, this.dispose = () => { util$1.disposeThreeObject(this.material) } } _findFirstAvailableMapForUV() { if (this.material) return this.material.map || this.material.specularMap || this.material.displacementMap || this.material.normalMap || this.material.bumpMap || this.material.roughnessMap || this.material.metalnessMap || this.material.alphaMap || this.material.emissiveMap } render(e) { null != this.material && (this.enableU && (null != this.material.map && (this.material.map.offset.x = (this.material.map.offset.x + this.uSpeed * e) % 1), null != this.material.emissiveMap && (this.material.emissiveMap.offset.x = (this.material.emissiveMap.offset.x + this.uSpeed * e) % 1), null != this.material.alphaMap && (this.material.alphaMap.offset.x = (this.material.alphaMap.offset.x + this.uSpeed * e) % 1), null != this.material.normalMap && (this.material.normalMap.offset.x = (this.material.normalMap.offset.x + this.uSpeed * e) % 1), null != this.material.bumpMap && (this.material.bumpMap.offset.x = (this.material.bumpMap.offset.x + this.uSpeed * e) % 1)), this.enableV && (null != this.material.map && (this.material.map.offset.y = (this.material.map.offset.y + this.vSpeed * e) % 1), null != this.material.emissiveMap && (this.material.emissiveMap.offset.y = (this.material.emissiveMap.offset.y + this.vSpeed * e) % 1), null != this.material.alphaMap && (this.material.alphaMap.offset.y = (this.material.alphaMap.offset.y + this.vSpeed * e) % 1), null != this.material.normalMap && (this.material.normalMap.offset.y = (this.material.normalMap.offset.y + this.vSpeed * e) % 1), null != this.material.bumpMap && (this.material.bumpMap.offset.y = (this.material.bumpMap.offset.y + this.vSpeed * e) % 1))) } } UVAnimationController.type = "UVAnimationController"; class RGBAColor { constructor(e, t, i, r) { null == t && null == i && null == r ? (this.color = new Color$1(this._getrgbaNum(e, 0) / 255, this._getrgbaNum(e, 1) / 255, this._getrgbaNum(e, 2) / 255), this.alpha = this._getrgbaNum(e, 3)) : (this.color = new Color$1(e, t, i), this.alpha = r) } _getrgbaNum(e = "rgba(255,255,255,0)", t) { let i = e.match(/(\d(\.\d+)?)+/g); return i[t] ? parseFloat(i[t]) : 0 } copy(e) { return this.color = e.color.clone(), this.alpha = e.alpha, this } lerp(e, t) { return this.color.r = this.color.r + (e.color.r - this.color.r) * t, this.color.g = this.color.g + (e.color.g - this.color.g) * t, this.color.b = this.color.b + (e.color.b - this.color.b) * t, this.alpha = this.alpha + (e.alpha - this.alpha) * t, this } clone() { return new this.constructor(this.color.r, this.color.g, this.color.b, this.alpha) } } class ArticulationAnimationController extends AnimationController { constructor(e, t, i = 1, r, n, a, o, s, l) { super("ArticulationAnimationController"), this.name = e + t.name + r, this.animationObject = t, this.duration = i, this.animationType = r, this.initVal = n, this.targetVal = a, this.bindType = l, this._currentTime = 0, this._diffValue, [ArticulationModifierTypes.stroke, ArticulationModifierTypes.colorOverlay, ArticulationModifierTypes.colorReplace].includes(this.animationType) || (this._diffValue = (a - n) / i), this._checkOpacity = e => (e < 0 && (e = 0), e > 1 && (e = 1), e), this.render = e => { if (null != this.animationObject) { if (i - this._currentTime < e || this._currentTime >= i) { switch (this.animationType) { case ArticulationModifierTypes.rotationX: this.animationObject.rotation.x = a / 180 * Math.PI; break; case ArticulationModifierTypes.rotationY: this.animationObject.rotation.y = a / 180 * Math.PI; break; case ArticulationModifierTypes.rotationZ: this.animationObject.rotation.z = a / 180 * Math.PI; break; case ArticulationModifierTypes.translationX: this.animationObject.position.x = a; break; case ArticulationModifierTypes.translationY: this.animationObject.position.y = a; break; case ArticulationModifierTypes.translationZ: this.animationObject.position.z = a; break; case ArticulationModifierTypes.scaleX: this.animationObject.scale.x = a; break; case ArticulationModifierTypes.scaleY: this.animationObject.scale.y = a; break; case ArticulationModifierTypes.scaleZ: this.animationObject.scale.z = a; break; case ArticulationModifierTypes.opacity: "nodes" === l ? t.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { e.transparent = !0, e.opacity = this._checkOpacity(a) })) : (e.material.transparent = !0, e.material.opacity = this._checkOpacity(a))) })) : "particles" === l && t.particleGroup.forEach((e => { e.opacity = this._checkOpacity(a) })); break; case ArticulationModifierTypes.quantityFactor: "particles" === l && t.particleGroup.forEach((e => { e.density = this._checkOpacity(a) })); break; case ArticulationModifierTypes.colorOverlay: t.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { e.color = a.color.clone(), e.opacity = a.alpha, e.opacity <= 0 && (e.opacity = 1, e.color = s && s(e.name, this.animationType) && s(e.name, this.animationType).articulationVal.color) })) : (e.material.color = a.color.clone(), e.material.opacity = a.alpha, e.material.opacity <= 0 && (e.material.opacity = 1, e.material.color = s && s(e.name, this.animationType) && s(e.name, this.animationType).articulationVal.color))) })); break; case ArticulationModifierTypes.colorReplace: t.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { e.map = null, e.color = a.color.clone(), e.opacity = a.alpha, e.opacity <= 0 && (e.opacity = 1, e.color = s && s(e.name, this.animationType) && s(e.name, this.animationType).articulationVal.color, e.map = s && s(e.name, this.animationType) && s(e.name, this.animationType).articulationVal.map, e.needsUpdate = !0) })) : (e.material.map = null, e.material.color = a.color.clone(), e.material.opacity = a.alpha, e.material.opacity <= 0 && (e.material.opacity = 1, e.material.color = s && s(e.name, this.animationType) && s(e.name, this.animationType).articulationVal.color, e.material.map = s && s(e.name, this.animationType) && s(e.name, this.animationType).articulationVal.map, e.material.needsUpdate = !0))) })); break; case ArticulationModifierTypes.stroke: _context.effectStore.initOutlinePass(t, !1, a); break; case ArticulationModifierTypes.USpeed: if ("materials" === l) { let e = _context.animationStore.findMaterialAnimation(this.animationObject._material(), UVAnimationController.type); if (e) e.enableU = 0 !== a, e.uSpeed = a; else { let t = new UVAnimationController(this.animationObject._material(), 0 !== a, !1, a, 0); e = t, _context.animationStore.add(t) } 0 === e.uSpeed && 0 === e.vSpeed && _context.animationStore.remove(e) } break; case ArticulationModifierTypes.VSpeed: if ("materials" === l) { let e = _context.animationStore.findMaterialAnimation(this.animationObject._material(), UVAnimationController.type); if (e) e.enableV = 0 !== a, e.vSpeed = a; else { let t = new UVAnimationController(this.animationObject._material(), !1, 0 !== a, 0, a); e = t, _context.animationStore.add(t) } 0 === e.uSpeed && 0 === e.vSpeed && _context.animationStore.remove(e) } }return this.needsRemove = !0, void (this._currentTime = 0) } switch (this._currentTime += e, this.animationType) { case ArticulationModifierTypes.rotationX: this.animationObject.rotation.x += this._diffValue / 180 * Math.PI * e; break; case ArticulationModifierTypes.rotationY: this.animationObject.rotation.y += this._diffValue / 180 * Math.PI * e; break; case ArticulationModifierTypes.rotationZ: this.animationObject.rotation.z += this._diffValue / 180 * Math.PI * e; break; case ArticulationModifierTypes.translationX: this.animationObject.position.x += this._diffValue * e; break; case ArticulationModifierTypes.translationY: this.animationObject.position.y += this._diffValue * e; break; case ArticulationModifierTypes.translationZ: this.animationObject.position.z += this._diffValue * e; break; case ArticulationModifierTypes.scaleX: this.animationObject.scale.x += this._diffValue * e; break; case ArticulationModifierTypes.scaleY: this.animationObject.scale.y += this._diffValue * e; break; case ArticulationModifierTypes.scaleZ: this.animationObject.scale.z += this._diffValue * e; break; case ArticulationModifierTypes.opacity: "nodes" === l ? t.traverse((t => { "Mesh" == t.type && (t.material instanceof Array ? t.material.forEach((t => { this._diffValue = (a - t.opacity) / i, t.transparent = !0, t.opacity += this._diffValue * e, t.opacity = this._checkOpacity(t.opacity), o && (t.opacity = o(t.opacity)) })) : (this._diffValue = (a - t.material.opacity) / i, t.material.transparent = !0, t.material.opacity += this._diffValue * e, t.material.opacity = this._checkOpacity(t.material.opacity), o && (t.material.opacity = o(t.material.opacity)))) })) : "particles" === l && t.particleGroup.forEach((t => { t.opacity += this._diffValue * e, t.opacity = this._checkOpacity(t.opacity), o && (t.opacity = o(t.opacity)) })); break; case ArticulationModifierTypes.quantityFactor: "particles" === l && t.particleGroup.forEach((t => { t.density += this._diffValue * e, t.density = this._checkOpacity(t.density), o && (t.density = o(t.density)) })); break; case ArticulationModifierTypes.colorOverlay: "nodes" === l && t.traverse((t => { if ("Mesh" == t.type) { let r; t.material instanceof Array ? t.material.forEach((t => { a.alpha > 0 ? (t.transparent = !0, this._diffValue = new RGBAColor((t.color.r - a.color.r) / i, (t.color.g - a.color.g) / i, (t.color.b - a.color.b) / i, (t.opacity - a.alpha) / i), r = new RGBAColor(t.color.r + this._diffValue.color.r * e, t.color.g + this._diffValue.color.g * e, t.color.b + this._diffValue.color.b * e, t.opacity + this._diffValue.alpha * e), o && (t.color = o(r.color)), t.opacity = this._checkOpacity(r.alpha)) : (t.opacity = 1, t.color = s && s(t.name, this.animationType) && s(t.name, this.animationType).articulationVal.color) })) : a.alpha > 0 ? (t.material.transparent = !0, this._diffValue = new RGBAColor((t.material.color.r - a.color.r) / i, (t.material.color.g - a.color.g) / i, (t.material.color.b - a.color.b) / i, (t.material.opacity - a.alpha) / i), r = new RGBAColor(t.material.color.r + this._diffValue.color.r * e, t.material.color.g + this._diffValue.color.g * e, t.material.color.b + this._diffValue.color.b * e, t.material.opacity + this._diffValue.alpha * e), o && (t.material.color = o(r.color)), t.material.opacity = this._checkOpacity(r.alpha)) : (t.material.opacity = 1, t.material.color = s && s(t.name, this.animationType) && s(t.name, this.animationType).articulationVal.color) } })); break; case ArticulationModifierTypes.colorReplace: "nodes" === l && t.traverse((t => { if ("Mesh" == t.type) { let r; t.material instanceof Array ? t.material.forEach((t => { a.alpha > 0 ? (t.map = null, t.transparent = !0, this._diffValue = new RGBAColor((t.color.r - a.color.r) / i, (t.color.g - a.color.g) / i, (t.color.b - a.color.b) / i, (t.opacity - a.alpha) / i), r = new RGBAColor(t.color.r + this._diffValue.color.r * e, t.color.g + this._diffValue.color.g * e, t.color.b + this._diffValue.color.b * e, t.opacity + this._diffValue.alpha * e), o && (t.color = o(r.color)), t.opacity = this._checkOpacity(r.alpha)) : (t.opacity = 1, t.color = s && s(t.name, this.animationType) && s(t.name, this.animationType).articulationVal.color, t.map = s && s(t.name, this.animationType) && s(t.name, this.animationType).articulationVal.map, t.needsUpdate = !0) })) : a.alpha > 0 ? (t.material.map = null, t.material.transparent = !0, this._diffValue = new RGBAColor((t.material.color.r - a.color.r) / i, (t.material.color.g - a.color.g) / i, (t.material.color.b - a.color.b) / i, (t.material.opacity - a.alpha) / i), r = new RGBAColor(t.material.color.r + this._diffValue.color.r * e, t.material.color.g + this._diffValue.color.g * e, t.material.color.b + this._diffValue.color.b * e, t.material.opacity + this._diffValue.alpha * e), o && (t.material.color = o(r.color)), t.material.opacity = this._checkOpacity(r.alpha)) : (t.material.opacity = 1, t.material.color = s && s(t.name, this.animationType) && s(t.name, this.animationType).articulationVal.color, t.material.map = s && s(t.name, this.animationType) && s(t.name, this.animationType).articulationVal.map, t.material.needsUpdate = !0) } })); break; case ArticulationModifierTypes.stroke: "nodes" === l && (this._diffValue = new RGBAColor((a.color.r - n.color.r) / i, (a.color.g - n.color.g) / i, (a.color.b - n.color.b) / i, (a.alpha - n.alpha) / i), n.color.r += this._diffValue.color.r * e, n.color.g += this._diffValue.color.g * e, n.color.b += this._diffValue.color.b * e, n.alpha += this._diffValue.alpha * e, n.alpha = this._checkOpacity(n.alpha), _context.effectStore.initOutlinePass(t, !1, new RGBAColor(n.color.r, n.color.g, n.color.b, n.alpha))); break; case ArticulationModifierTypes.USpeed: if ("materials" === l) { let t = _context.animationStore.findMaterialAnimation(this.animationObject._material(), UVAnimationController.type); if (t) t.uSpeed += this._diffValue * e, t.enableU = 0 !== t.uSpeed; else { let i = new UVAnimationController(this.animationObject._material(), this._diffValue * e != 0, !1, this._diffValue * e, 0); t = i, _context.animationStore.add(i) } 0 === t.uSpeed && 0 === t.vSpeed && _context.animationStore.remove(t) } break; case ArticulationModifierTypes.VSpeed: if ("materials" === l) { let t = _context.animationStore.findMaterialAnimation(this.animationObject._material(), UVAnimationController.type); if (t) t.vSpeed += this._diffValue * e, t.enableV = 0 !== t.vSpeed; else { let i = new UVAnimationController(this.animationObject._material(), !1, this._diffValue * e != 0, 0, this._diffValue * e); t = i, _context.animationStore.add(i) } 0 === t.uSpeed && 0 === t.vSpeed && _context.animationStore.remove(t) } } } }, this.dispose = () => { this.animationObject = null } } } ArticulationAnimationController.type = "ArticulationAnimationController"; class AreaLineAnimationController extends AnimationController { constructor(e, t) { super("AreaLineAnimationController"), this.animationObject = e, this.resolution = t, this.render = e => { null != this.animationObject && this.animationObject.resolution.set(this.resolution.x / 4, this.resolution.y / 4) }, this.reset = () => { }, this.dispose = () => { util$1.disposeThreeObject(this.animationObject), this.animationObject = null } } } AreaLineAnimationController.type = "AreaLineAnimationController"; let AnimationTypes = { NONE: "none", ROUND: "round", REPEAT: "repeat" }; class ArticulationAnimationGroupController extends AnimationController { constructor(e, t, i, r, n) { super("ArticulationAnimationGroupController"), this.animationName = this.name = e, this.animationType = t, this.animationSpeed = i, this.articulationAnimations = r; let a, o = this.articulationAnimations.map((e => e.startTime + e.continueTime)), s = [...new Set(this.articulationAnimations.map((e => e.startTime)))], l = [...new Set(o)].sort(((e, t) => e - t)), c = Math.max(...o) / i, h = 0, u = !1, d = []; this._recordDefaultVal = (e, t, i, r, n, a = "nodes") => { d.find((r => r.startTime == e && r.articulationName === t && r.articulationProperty === i)) || d.push({ startTime: e, articulationName: t, articulationProperty: i, articulationVal: r, articulationDiff: n, articulationType: a }) }; let p = -1, f = -1; this._recordDefaultStateAnimations = () => { this.articulationAnimations.forEach((e => { a || (a = _context.defaultObjectTree.getItemByName(e.modelId)); let t = a && a.articulations.find((t => t._name == e.articulationName)); if (t) for (let r of t.properties) { let n = 0, o = 0, s = []; for (let e of r.nodes) a.getGroup().getObjectByName(e) && s.push(a.getGroup().getObjectByName(e)); if (s.length) for (let a of r.modifiers) for (let r of s) switch (a.key) { case ArticulationModifierTypes.rotationX: n = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, a.values, e.startState), o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, a.values, e.endState), this._recordDefaultVal(e.startTime, r.name, a.key, r.rotation.x, (o - n) / e.continueTime * i); break; case ArticulationModifierTypes.rotationY: n = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, a.values, e.startState), o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, a.values, e.endState), this._recordDefaultVal(e.startTime, r.name, a.key, r.rotation.y, (o - n) / e.continueTime * i); break; case ArticulationModifierTypes.rotationZ: n = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, a.values, e.startState), o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, a.values, e.endState), this._recordDefaultVal(e.startTime, r.name, a.key, r.rotation.z, (o - n) / e.continueTime * i); break; case ArticulationModifierTypes.translationX: n = t._interpolateAbsoluteNumeric(a.values, e.startState), o = t._interpolateAbsoluteNumeric(a.values, e.endState), this._recordDefaultVal(e.startTime, r.name, a.key, r.position.x, (o - n) / e.continueTime * i); break; case ArticulationModifierTypes.translationY: n = t._interpolateAbsoluteNumeric(a.values, e.startState), o = t._interpolateAbsoluteNumeric(a.values, e.endState), this._recordDefaultVal(e.startTime, r.name, a.key, r.position.y, (o - n) / e.continueTime * i); break; case ArticulationModifierTypes.translationZ: n = t._interpolateAbsoluteNumeric(a.values, e.startState), o = t._interpolateAbsoluteNumeric(a.values, e.endState), this._recordDefaultVal(e.startTime, r.name, a.key, r.position.z, (o - n) / e.continueTime * i); break; case ArticulationModifierTypes.scaleX: n = t._interpolateAbsoluteNumeric(a.values, e.startState), o = t._interpolateAbsoluteNumeric(a.values, e.endState), this._recordDefaultVal(e.startTime, r.name, a.key, r.scale.x, (o - n) / e.continueTime * i); break; case ArticulationModifierTypes.scaleY: n = t._interpolateAbsoluteNumeric(a.values, e.startState), o = t._interpolateAbsoluteNumeric(a.values, e.endState), this._recordDefaultVal(e.startTime, r.name, a.key, r.scale.y, (o - n) / e.continueTime * i); break; case ArticulationModifierTypes.scaleZ: n = t._interpolateAbsoluteNumeric(a.values, e.startState), o = t._interpolateAbsoluteNumeric(a.values, e.endState), this._recordDefaultVal(e.startTime, r.name, a.key, r.scale.z, (o - n) / e.continueTime * i); break; case ArticulationModifierTypes.opacity: n = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, a.values, e.startState), o = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, a.values, e.endState), r.traverse((t => { "Mesh" == t.type && (t.material instanceof Array ? t.material.forEach((r => { r.transparent = !0, this._recordDefaultVal(e.startTime, t.name + ":" + r.name, a.key, r.opacity, (o - n) / e.continueTime * i) })) : (t.material.transparent = !0, this._recordDefaultVal(e.startTime, t.name + ":" + t.name, a.key, t.material.opacity, (o - n) / e.continueTime * i))) })); break; case ArticulationModifierTypes.colorOverlay: n = t._interpolateColor(a.values, e.startState), o = t._interpolateColor(a.values, e.endState), r.traverse((t => { if ("Mesh" == t.type) if (t.material instanceof Array) t.material.forEach((r => { let s = new RGBAColor((o.color.r - n.color.r) / e.continueTime * i, (o.color.g - n.color.g) / e.continueTime * i, (o.color.b - n.color.b) / e.continueTime * i, (o.alpha - n.alpha) / e.continueTime * i); this._recordDefaultVal(e.startTime, t.name + ":" + r.name, a.key, { color: r.color, opacity: r.opacity }, s), r.transparent = !0 })); else { let s = new RGBAColor((o.color.r - n.color.r) / e.continueTime * i, (o.color.g - n.color.g) / e.continueTime * i, (o.color.b - n.color.b) / e.continueTime * i, (o.alpha - n.alpha) / e.continueTime * i); this._recordDefaultVal(e.startTime, r.name + ":" + t.name, a.key, { color: t.material.color, opacity: t.material.opacity }, s), t.material.transparent = !0 } })); break; case ArticulationModifierTypes.colorReplace: n = t._interpolateColor(a.values, e.startState), o = t._interpolateColor(a.values, e.endState), r.traverse((t => { if ("Mesh" == t.type) if (t.material instanceof Array) t.material.forEach((r => { let s = new RGBAColor((o.color.r - n.color.r) / e.continueTime * i, (o.color.g - n.color.g) / e.continueTime * i, (o.color.b - n.color.b) / e.continueTime * i, (o.alpha - n.alpha) / e.continueTime * i); this._recordDefaultVal(e.startTime, t.name + ":" + r.name, a.key, { map: r.map, color: r.color, opacity: r.opacity }, s), r.map = null, r.transparent = !0 })); else { let s = new RGBAColor((o.color.r - n.color.r) / e.continueTime * i, (o.color.g - n.color.g) / e.continueTime * i, (o.color.b - n.color.b) / e.continueTime * i, (o.alpha - n.alpha) / e.continueTime * i); this._recordDefaultVal(e.startTime, r.name + ":" + t.name, a.key, { map: t.material.map, color: t.material.color, opacity: t.material.opacity }, s), t.material.map = null, t.material.transparent = !0 } })); break; case ArticulationModifierTypes.stroke: n = t._interpolateColor(a.values, e.startState), o = t._interpolateColor(a.values, e.endState); let s = new RGBAColor((o.color.r - n.color.r) / e.continueTime * i, (o.color.g - n.color.g) / e.continueTime * i, (o.color.b - n.color.b) / e.continueTime * i, (o.alpha - n.alpha) / e.continueTime * i); this._recordDefaultVal(e.startTime, r.name, a.key, { color: n, tempColor: n.clone() }, s) }let l = []; for (let e of r.particles) { let t = a.particleStoreArray.find((t => t.name === e)); t && l.push(t) } if (l.length) for (let a of r.modifiers) for (let r of l) switch (a.key) { case ArticulationModifierTypes.rotationX: n = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, a.values, e.startState), o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, a.values, e.endState), this._recordDefaultVal(e.startTime, r.particleModelGroup.name, a.key, r.particleModelGroup.rotation.x, (o - n) / e.continueTime * i, "particles"); break; case ArticulationModifierTypes.rotationY: n = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, a.values, e.startState), o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, a.values, e.endState), this._recordDefaultVal(e.startTime, r.particleModelGroup.name, a.key, r.particleModelGroup.rotation.y, (o - n) / e.continueTime * i, "particles"); break; case ArticulationModifierTypes.rotationZ: n = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, a.values, e.startState), o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, a.values, e.endState), this._recordDefaultVal(e.startTime, r.particleModelGroup.name, a.key, r.particleModelGroup.rotation.z, (o - n) / e.continueTime * i, "particles"); break; case ArticulationModifierTypes.translationX: n = t._interpolateAbsoluteNumeric(a.values, e.startState), o = t._interpolateAbsoluteNumeric(a.values, e.endState), this._recordDefaultVal(e.startTime, r.particleModelGroup.name, a.key, r.particleModelGroup.position.x, (o - n) / e.continueTime * i, "particles"); break; case ArticulationModifierTypes.translationY: n = t._interpolateAbsoluteNumeric(a.values, e.startState), o = t._interpolateAbsoluteNumeric(a.values, e.endState), this._recordDefaultVal(e.startTime, r.particleModelGroup.name, a.key, r.particleModelGroup.position.y, (o - n) / e.continueTime * i, "particles"); break; case ArticulationModifierTypes.translationZ: n = t._interpolateAbsoluteNumeric(a.values, e.startState), o = t._interpolateAbsoluteNumeric(a.values, e.endState), this._recordDefaultVal(e.startTime, r.particleModelGroup.name, a.key, r.particleModelGroup.position.z, (o - n) / e.continueTime * i, "particles"); break; case ArticulationModifierTypes.scaleX: n = t._interpolateAbsoluteNumeric(a.values, e.startState), o = t._interpolateAbsoluteNumeric(a.values, e.endState), this._recordDefaultVal(e.startTime, r.particleModelGroup.name, a.key, r.particleModelGroup.scale.x, (o - n) / e.continueTime * i, "particles"); break; case ArticulationModifierTypes.scaleY: n = t._interpolateAbsoluteNumeric(a.values, e.startState), o = t._interpolateAbsoluteNumeric(a.values, e.endState), this._recordDefaultVal(e.startTime, r.particleModelGroup.name, a.key, r.particleModelGroup.scale.y, (o - n) / e.continueTime * i, "particles"); break; case ArticulationModifierTypes.scaleZ: n = t._interpolateAbsoluteNumeric(a.values, e.startState), o = t._interpolateAbsoluteNumeric(a.values, e.endState), this._recordDefaultVal(e.startTime, r.particleModelGroup.name, a.key, r.particleModelGroup.scale.z, (o - n) / e.continueTime * i, "particles"); break; case ArticulationModifierTypes.opacity: n = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, a.values, e.startState), o = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, a.values, e.endState), r.particleGroup.forEach((t => { this._recordDefaultVal(e.startTime, r.particleModelGroup.name + ":" + t.id, a.key, t.opacity, (o - n) / e.continueTime * i, "particles") })); break; case ArticulationModifierTypes.quantityFactor: n = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, a.values, e.startState), o = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, a.values, e.endState), r.particleGroup.forEach((t => { this._recordDefaultVal(e.startTime, r.particleModelGroup.name + ":" + t.id, a.key, t.density, (o - n) / e.continueTime * i, "particles") })) } } })) }, this._initAnimation = () => { p = -1; let e = [], t = [], i = []; this.articulationAnimations.forEach((r => { a || (a = _context.defaultObjectTree.getItemByName(r.modelId)); let n = a && a.articulations.find((e => e._name == r.articulationName)); if (n) for (let s of n.properties) { let l = []; for (let e of s.nodes) { let t = a.getGroup().getObjectByName(e); t && l.push(t) } let c = 0; if (_context.effectStore.initOutlinePass(), l.length) for (let t of s.modifiers) for (let i of l) { let a = e.find((e => e.nodeName == i.name && e.modifierKey == t.key)); if ([ArticulationModifierTypes.colorOverlay, ArticulationModifierTypes.colorReplace].includes(t.key) && (a = e.find((e => e.nodeName == i.name && [ArticulationModifierTypes.colorOverlay, ArticulationModifierTypes.colorReplace].includes(e.modifierKey)))), !a) switch (e.push({ nodeName: i.name, modifierKey: t.key }), t.key) { case ArticulationModifierTypes.rotationX: c = n._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, t.values, r.startState), i.rotation.x = c / 180 * Math.PI; break; case ArticulationModifierTypes.rotationY: c = n._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, t.values, r.startState), i.rotation.y = c / 180 * Math.PI; break; case ArticulationModifierTypes.rotationZ: c = n._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, t.values, r.startState), i.rotation.z = c / 180 * Math.PI; break; case ArticulationModifierTypes.translationX: c = n._interpolateAbsoluteNumeric(t.values, r.startState), i.position.x = c; break; case ArticulationModifierTypes.translationY: c = n._interpolateAbsoluteNumeric(t.values, r.startState), i.position.y = c; break; case ArticulationModifierTypes.translationZ: c = n._interpolateAbsoluteNumeric(t.values, r.startState), i.position.z = c; break; case ArticulationModifierTypes.scaleX: c = n._interpolateAbsoluteNumeric(t.values, r.startState), i.scale.x = c; break; case ArticulationModifierTypes.scaleY: c = n._interpolateAbsoluteNumeric(t.values, r.startState), i.scale.y = c; break; case ArticulationModifierTypes.scaleZ: c = n._interpolateAbsoluteNumeric(t.values, r.startState), i.scale.z = c; break; case ArticulationModifierTypes.opacity: c = n._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, t.values, r.startState), i.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { e.transparent = !0, e.opacity = c })) : (e.material.transparent = !0, e.material.opacity = c)) })); break; case ArticulationModifierTypes.colorOverlay: c = n._interpolateColor(t.values, r.startState), i.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { c.alpha > 0 ? (e.transparent = !0, e.color = c.color, e.opacity = c.alpha) : (e.opacity = 1, e.color = n.getDefaultVal(e.name, t.key) && n.getDefaultVal(e.name, t.key).articulationVal.color) })) : c.alpha > 0 ? (e.material.transparent = !0, e.material.color = c.color, e.material.opacity = c.alpha) : (e.material.opacity = 1, e.material.color = n.getDefaultVal(e.name, t.key) && n.getDefaultVal(e.name, t.key).articulationVal.color)) })); break; case ArticulationModifierTypes.colorReplace: c = n._interpolateColor(t.values, r.startState), i.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { c.alpha > 0 ? (e.map = null, e.transparent = !0, e.color = c.color, e.opacity = c.alpha) : (e.map = n.getDefaultVal(e.name, t.key) && n.getDefaultVal(e.name, t.key).articulationVal.map, e.color = n.getDefaultVal(e.name, t.key) && n.getDefaultVal(e.name, t.key).articulationVal.color, e.opacity = 1), e.needsUpdate = !0 })) : (c.alpha > 0 ? (e.material.map = null, e.material.transparent = !0, e.material.color = c.color, e.material.opacity = c.alpha) : (e.material.map = n.getDefaultVal(e.name, t.key) && n.getDefaultVal(e.name, t.key).articulationVal.map, e.material.color = n.getDefaultVal(e.name, t.key) && n.getDefaultVal(e.name, t.key).articulationVal.color, e.material.opacity = 1), e.material.needsUpdate = !0)) })); break; case ArticulationModifierTypes.stroke: c = n._interpolateColor(t.values, r.startState); let e = d.find((e => e.startTime == r.startTime && e.articulationName === i.name && e.articulationProperty === t.key)); e && (e.articulationVal.tempColor.color = c.color.clone(), e.articulationVal.tempColor.alpha = c.alpha), _context.effectStore.initOutlinePass(i, !0, c) } } let h = []; for (let e of s.materials) { let t = a.findMaterial(e); t && h.push(t) } if (h.length) for (let e of s.modifiers) for (let t of h) { if (!i.find((i => i.materialName === t.name && i.modifierKey === e.key))) switch (i.push({ materialName: t.name, modifierKey: e.key }), e.key) { case ArticulationModifierTypes.USpeed: if (c = n._interpolateAbsoluteNumeric(e.values, r.startState), o = _context.animationStore.findMaterialAnimation(t._material(), UVAnimationController.type)) o.enableU = 0 !== c, o.uSpeed = c; else { let e = new UVAnimationController(t._material(), 0 !== c, !1, c, 0); o = e, _context.animationStore.add(e) } 0 === o.uSpeed && 0 === o.vSpeed && _context.animationStore.remove(o); break; case ArticulationModifierTypes.VSpeed: var o; if (c = n._interpolateAbsoluteNumeric(e.values, r.startState), o = _context.animationStore.findMaterialAnimation(t._material(), UVAnimationController.type)) o.enableV = 0 !== c, o.vSpeed = c; else { let e = new UVAnimationController(t._material(), !1, 0 !== c, 0, c); o = e, _context.animationStore.add(e) } 0 === o.uSpeed && 0 === o.vSpeed && _context.animationStore.remove(o) } } let u = []; for (let e of s.particles) { let t = a.particleStoreArray.find((t => t.name === e)); t && u.push(t) } if (u.length) for (let e of s.modifiers) for (let i of u) { if (!t.find((t => t.particleName == i.name && t.modifierKey == e.key))) switch (t.push({ particleName: i.name, modifierKey: e.key }), e.key) { case ArticulationModifierTypes.rotationX: c = n._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, e.values, r.startState), i.particleModelGroup.rotation.x = c / 180 * Math.PI; break; case ArticulationModifierTypes.rotationY: c = n._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, e.values, r.startState), i.particleModelGroup.rotation.y = c / 180 * Math.PI; break; case ArticulationModifierTypes.rotationZ: c = n._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, e.values, r.startState), i.particleModelGroup.rotation.z = c / 180 * Math.PI; break; case ArticulationModifierTypes.translationX: c = n._interpolateAbsoluteNumeric(e.values, r.startState), i.particleModelGroup.position.x = c; break; case ArticulationModifierTypes.translationY: c = n._interpolateAbsoluteNumeric(e.values, r.startState), i.particleModelGroup.position.y = c; break; case ArticulationModifierTypes.translationZ: c = n._interpolateAbsoluteNumeric(e.values, r.startState), i.particleModelGroup.position.z = c; break; case ArticulationModifierTypes.scaleX: c = n._interpolateAbsoluteNumeric(e.values, r.startState), i.particleModelGroup.scale.x = c; break; case ArticulationModifierTypes.scaleY: c = n._interpolateAbsoluteNumeric(e.values, r.startState), i.particleModelGroup.scale.y = c; break; case ArticulationModifierTypes.scaleZ: c = n._interpolateAbsoluteNumeric(e.values, r.startState), i.particleModelGroup.scale.z = c; break; case ArticulationModifierTypes.opacity: c = n._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, e.values, r.startState), i.particleGroup.forEach((e => { e.opacity = c })); break; case ArticulationModifierTypes.quantityFactor: c = n._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, e.values, r.startState), i.particleGroup.forEach((e => { e.density = c })) } } } })) }, this._recordDefaultStateAnimations(), this._initAnimation(), this._setEndAnimation = e => { let t = l[e]; this.articulationAnimations.filter((e => e.startTime + e.continueTime == t)).forEach((e => { a || (a = _context.defaultObjectTree.getItemByName(e.modelId)); let t = a && a.articulations.find((t => t._name == e.articulationName)); if (t) for (let r of t.properties) { let n = []; for (let e of r.nodes) a.getGroup().getObjectByName(e) && n.push(a.getGroup().getObjectByName(e)); let o = 0; if (_context.effectStore.initOutlinePass(), n.length) for (let i of r.modifiers) for (let r of n) switch (i.key) { case ArticulationModifierTypes.rotationX: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, i.values, e.endState), r.rotation.x = o / 180 * Math.PI; break; case ArticulationModifierTypes.rotationY: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, i.values, e.endState), r.rotation.y = o / 180 * Math.PI; break; case ArticulationModifierTypes.rotationZ: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, i.values, e.endState), r.rotation.z = o / 180 * Math.PI; break; case ArticulationModifierTypes.translationX: o = t._interpolateAbsoluteNumeric(i.values, e.endState), r.position.x = o; break; case ArticulationModifierTypes.translationY: o = t._interpolateAbsoluteNumeric(i.values, e.endState), r.position.y = o; break; case ArticulationModifierTypes.translationZ: o = t._interpolateAbsoluteNumeric(i.values, e.endState), r.position.z = o; break; case ArticulationModifierTypes.scaleX: o = t._interpolateAbsoluteNumeric(i.values, e.endState), r.scale.x = o; break; case ArticulationModifierTypes.scaleY: o = t._interpolateAbsoluteNumeric(i.values, e.endState), r.scale.y = o; break; case ArticulationModifierTypes.scaleZ: o = t._interpolateAbsoluteNumeric(i.values, e.endState), r.scale.z = o; break; case ArticulationModifierTypes.opacity: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, i.values, e.endState), r.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { e.transparent = !0, e.opacity = o })) : (e.material.transparent = !0, e.material.opacity = o)) })); break; case ArticulationModifierTypes.colorOverlay: o = t._interpolateColor(i.values, e.endState), r.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { o.alpha > 0 ? (e.color = o.color, e.opacity = o.alpha) : (e.color = t.getDefaultVal(e.name, i.key) && t.getDefaultVal(e.name, i.key).articulationVal.color, e.opacity = 1) })) : o.alpha > 0 ? (e.material.color = o.color, e.material.opacity = o.alpha) : (e.material.color = t.getDefaultVal(e.name, i.key) && t.getDefaultVal(e.name, i.key).articulationVal.color, e.material.opacity = 1)) })); break; case ArticulationModifierTypes.colorReplace: o = t._interpolateColor(i.values, e.endState), r.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { o.alpha > 0 ? (e.map = null, e.color = o.color, e.opacity = o.alpha) : (e.map = t.getDefaultVal(e.name, i.key) && t.getDefaultVal(e.name, i.key).articulationVal.map, e.color = t.getDefaultVal(e.name, i.key) && t.getDefaultVal(e.name, i.key).articulationVal.color, e.opacity = 1), e.needsUpdate = !0 })) : (o.alpha > 0 ? (e.material.map = null, e.material.color = o.color, e.material.opacity = o.alpha) : (e.material.map = t.getDefaultVal(e.name, i.key) && t.getDefaultVal(e.name, i.key).articulationVal.map, e.material.color = t.getDefaultVal(e.name, i.key) && t.getDefaultVal(e.name, i.key).articulationVal.color, e.material.opacity = 1), e.material.needsUpdate = !0)) })); break; case ArticulationModifierTypes.stroke: o = t._interpolateColor(i.values, e.endState), _context.effectStore.initOutlinePass(r, !0, o) }let s = []; for (let e of r.materials) { let t = a.findMaterial(e); t && s.push(t) } if (s.length) for (let n of r.modifiers) for (let r of s) switch (n.key) { case ArticulationModifierTypes.USpeed: if (o = t._interpolateAbsoluteNumeric(n.values, e.endState), i = _context.animationStore.findMaterialAnimation(r._material(), UVAnimationController.type)) i.enableU = 0 !== o, i.uSpeed = o; else { let e = new UVAnimationController(r._material(), 0 !== o, !1, o, 0); i = e, _context.animationStore.add(e) } 0 === i.uSpeed && 0 === i.vSpeed && _context.animationStore.remove(i); break; case ArticulationModifierTypes.VSpeed: var i; if (o = t._interpolateAbsoluteNumeric(n.values, e.endState), i = _context.animationStore.findMaterialAnimation(r._material(), UVAnimationController.type)) i.enableV = 0 !== o, i.vSpeed = o; else { let e = new UVAnimationController(r._material(), !1, 0 !== o, 0, o); i = e, _context.animationStore.add(e) } 0 === i.uSpeed && 0 === i.vSpeed && _context.animationStore.remove(i) }let l = []; for (let e of r.particles) { let t = a.particleStoreArray.find((t => t.name === e)); t && l.push(t) } if (l.length) for (let i of r.modifiers) for (let r of l) switch (i.key) { case ArticulationModifierTypes.rotationX: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, i.values, e.endState), r.particleModelGroup.rotation.x = o / 180 * Math.PI; break; case ArticulationModifierTypes.rotationY: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, i.values, e.endState), r.particleModelGroup.rotation.y = o / 180 * Math.PI; break; case ArticulationModifierTypes.rotationZ: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, i.values, e.endState), r.particleModelGroup.rotation.z = o / 180 * Math.PI; break; case ArticulationModifierTypes.translationX: o = t._interpolateAbsoluteNumeric(i.values, e.endState), r.particleModelGroup.position.x = o; break; case ArticulationModifierTypes.translationY: o = t._interpolateAbsoluteNumeric(i.values, e.endState), r.particleModelGroup.position.y = o; break; case ArticulationModifierTypes.translationZ: o = t._interpolateAbsoluteNumeric(i.values, e.endState), r.particleModelGroup.position.z = o; break; case ArticulationModifierTypes.scaleX: o = t._interpolateAbsoluteNumeric(i.values, e.endState), r.particleModelGroup.scale.x = o; break; case ArticulationModifierTypes.scaleY: o = t._interpolateAbsoluteNumeric(i.values, e.endState), r.particleModelGroup.scale.y = o; break; case ArticulationModifierTypes.scaleZ: o = t._interpolateAbsoluteNumeric(i.values, e.endState), r.particleModelGroup.scale.z = o; break; case ArticulationModifierTypes.opacity: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, i.values, e.endState), r.particleGroup.forEach((e => { e.opacity = o })); break; case ArticulationModifierTypes.quantityFactor: o = o = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, i.values, e.endState), r.particleGroup.forEach((e => { e.density = o })) } } })) }, this._setStartAnimation = e => { s[e] == parseInt(h) && this.articulationAnimations.filter((t => t.startTime == s[e])).forEach((e => { a || (a = _context.defaultObjectTree.getItemByName(e.modelId)); let t = a && a.articulations.find((t => t._name == e.articulationName)); if (t) for (let r of t.properties) { let n = []; for (let e of r.nodes) a.getGroup().getObjectByName(e) && n.push(a.getGroup().getObjectByName(e)); let o = 0; if (_context.effectStore.initOutlinePass(), n.length) for (let i of r.modifiers) for (let r of n) switch (i.key) { case ArticulationModifierTypes.rotationX: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, i.values, e.startState), r.rotation.x = o / 180 * Math.PI; break; case ArticulationModifierTypes.rotationY: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, i.values, e.startState), r.rotation.y = o / 180 * Math.PI; break; case ArticulationModifierTypes.rotationZ: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, i.values, e.startState), r.rotation.z = o / 180 * Math.PI; break; case ArticulationModifierTypes.translationX: o = t._interpolateAbsoluteNumeric(i.values, e.startState), r.position.x = o; break; case ArticulationModifierTypes.translationY: o = t._interpolateAbsoluteNumeric(i.values, e.startState), r.position.y = o; break; case ArticulationModifierTypes.translationZ: o = t._interpolateAbsoluteNumeric(i.values, e.startState), r.position.z = o; break; case ArticulationModifierTypes.scaleX: o = t._interpolateAbsoluteNumeric(i.values, e.startState), r.scale.x = o; break; case ArticulationModifierTypes.scaleY: o = t._interpolateAbsoluteNumeric(i.values, e.startState), r.scale.y = o; break; case ArticulationModifierTypes.scaleZ: o = t._interpolateAbsoluteNumeric(i.values, e.startState), r.scale.z = o; break; case ArticulationModifierTypes.opacity: r.traverse((r => { "Mesh" == r.type && (r.material instanceof Array ? r.material.forEach((r => { r.transparent = !0, o = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, i.values, e.startState), r.opacity = o })) : (r.material.transparent = !0, o = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, i.values, e.startState), r.material.opacity = o)) })); break; case ArticulationModifierTypes.colorOverlay: o = t._interpolateColor(i.values, e.startState), r.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { o.alpha > 0 ? (e.transparent = !0, e.color = o.color, e.opacity = o.alpha) : (e.color = t.getDefaultVal(e.name, i.key) && t.getDefaultVal(e.name, i.key).articulationVal.color, e.opacity = 1) })) : o.alpha > 0 ? (e.material.transparent = !0, e.material.color = o.color, e.material.opacity = o.alpha) : (e.material.color = t.getDefaultVal(e.name, i.key) && t.getDefaultVal(e.name, i.key).articulationVal.color, e.material.opacity = 1)) })); break; case ArticulationModifierTypes.colorReplace: o = t._interpolateColor(i.values, e.startState), r.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { o.alpha > 0 ? (e.map = null, e.transparent = !0, e.color = o.color, e.opacity = o.alpha) : (e.map = t.getDefaultVal(e.name, i.key) && t.getDefaultVal(e.name, i.key).articulationVal.map, e.color = t.getDefaultVal(e.name, i.key) && t.getDefaultVal(e.name, i.key).articulationVal.color, e.opacity = 1) })) : o.alpha > 0 ? (e.material.map = null, e.material.transparent = !0, e.material.color = o.color, e.material.opacity = o.alpha) : (e.material.map = t.getDefaultVal(e.name, i.key) && t.getDefaultVal(e.name, i.key).articulationVal.map, e.material.color = t.getDefaultVal(e.name, i.key) && t.getDefaultVal(e.name, i.key).articulationVal.color, e.material.opacity = 1)) })); break; case ArticulationModifierTypes.stroke: o = t._interpolateColor(i.values, e.startState); let n = d.find((t => t.startTime == e.startTime && t.articulationName === r.name && t.articulationProperty === i.key)); n && (n.articulationVal.tempColor.color = o.color.clone(), n.articulationVal.tempColor.alpha = o.alpha), _context.effectStore.initOutlinePass(r, !0, o) }let s = []; for (let e of r.materials) { let t = a.findMaterial(e); t && s.push(t) } if (s.length) for (let n of r.modifiers) for (let r of s) switch (n.key) { case ArticulationModifierTypes.USpeed: if (o = t._interpolateAbsoluteNumeric(n.values, e.startState), i = _context.animationStore.findMaterialAnimation(r._material(), UVAnimationController.type)) i.enableU = 0 !== o, i.uSpeed = o; else { let e = new UVAnimationController(r._material(), 0 !== o, !1, o, 0); i = e, _context.animationStore.add(e) } 0 === i.uSpeed && 0 === i.vSpeed && _context.animationStore.remove(i); break; case ArticulationModifierTypes.VSpeed: var i; if (o = t._interpolateAbsoluteNumeric(n.values, e.startState), i = _context.animationStore.findMaterialAnimation(r._material(), UVAnimationController.type)) i.enableV = 0 !== o, i.vSpeed = o; else { let e = new UVAnimationController(r._material(), !1, 0 !== o, 0, o); i = e, _context.animationStore.add(e) } 0 === i.uSpeed && 0 === i.vSpeed && _context.animationStore.remove(i) }let l = []; for (let e of r.particles) { let t = a.particleStoreArray.find((t => t.name === e)); t && l.push(t) } if (l.length) for (let i of r.modifiers) for (let r of l) switch (i.key) { case ArticulationModifierTypes.rotationX: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, i.values, e.startState), r.particleModelGroup.rotation.x = o / 180 * Math.PI; break; case ArticulationModifierTypes.rotationY: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, i.values, e.startState), r.particleModelGroup.rotation.y = o / 180 * Math.PI; break; case ArticulationModifierTypes.rotationZ: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, i.values, e.startState), r.particleModelGroup.rotation.z = o / 180 * Math.PI; break; case ArticulationModifierTypes.translationX: o = t._interpolateAbsoluteNumeric(i.values, e.startState), r.particleModelGroup.position.x = o; break; case ArticulationModifierTypes.translationY: o = t._interpolateAbsoluteNumeric(i.values, e.startState), r.particleModelGroup.position.y = o; break; case ArticulationModifierTypes.translationZ: o = t._interpolateAbsoluteNumeric(i.values, e.startState), r.particleModelGroup.position.z = o; break; case ArticulationModifierTypes.scaleX: o = t._interpolateAbsoluteNumeric(i.values, e.startState), r.particleModelGroup.scale.x = o; break; case ArticulationModifierTypes.scaleY: o = t._interpolateAbsoluteNumeric(i.values, e.startState), r.particleModelGroup.scale.y = o; break; case ArticulationModifierTypes.scaleZ: o = t._interpolateAbsoluteNumeric(i.values, e.startState), r.particleModelGroup.scale.z = o; break; case ArticulationModifierTypes.opacity: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, i.values, e.startState), r.particleGroup.forEach((e => { e.opacity = o })); break; case ArticulationModifierTypes.quantityFactor: o = t._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, i.values, e.startState), r.particleGroup.forEach((e => { e.density = o })) } } })) }, this.render = e => { if (this.articulationAnimations && !(this.articulationAnimations.length <= 0) && (h += e, this.articulationAnimations.forEach((e => { f = l.findIndex((t => t == e.startTime + e.continueTime)), h >= (e.startTime + e.continueTime) / i && p == f && this._setEndAnimation(f) })), this.articulationAnimations.forEach((t => { if (t.startTime / i <= h && h <= (t.startTime + t.continueTime) / i) { f = l.findIndex((e => h < e / i)), f >= 0 && p != f && (u ? (this._setStartAnimation(f + 1), this._setEndAnimation(f)) : (f > 0 && this._setEndAnimation(f - 1), this._setStartAnimation(f)), p = f), a || (a = _context.defaultObjectTree.getItemByName(t.modelId)); let s = a && a.articulations.find((e => e._name == t.articulationName)); if (s) { let l = 0; for (let c of s.properties) { let h = []; for (let e of c.nodes) { let t = a.getGroup().getObjectByName(e); t && h.push(t) } if (_context.effectStore.initOutlinePass(), h.length) for (let i of c.modifiers) for (let r of h) { if (![ArticulationModifierTypes.opacity, ArticulationModifierTypes.stroke, ArticulationModifierTypes.colorOverlay, ArticulationModifierTypes.colorReplace].includes(i.key)) { let e = d.find((e => e.startTime == t.startTime && e.articulationName === r.name && e.articulationProperty === i.key)); l = e ? e.articulationDiff : null } switch (i.key) { case ArticulationModifierTypes.rotationX: u ? r.rotation.x -= l / 180 * Math.PI * e : r.rotation.x += l / 180 * Math.PI * e; break; case ArticulationModifierTypes.rotationY: u ? r.rotation.y -= l / 180 * Math.PI * e : r.rotation.y += l / 180 * Math.PI * e; break; case ArticulationModifierTypes.rotationZ: u ? r.rotation.z -= l / 180 * Math.PI * e : r.rotation.z += l / 180 * Math.PI * e; break; case ArticulationModifierTypes.translationX: u ? r.position.x -= l * e : r.position.x += l * e; break; case ArticulationModifierTypes.translationY: u ? r.position.y -= l * e : r.position.y += l * e; break; case ArticulationModifierTypes.translationZ: u ? r.position.z -= l * e : r.position.z += l * e; break; case ArticulationModifierTypes.scaleX: u ? r.scale.x -= l * e : r.scale.x += l * e; break; case ArticulationModifierTypes.scaleY: u ? r.scale.y -= l * e : r.scale.y += l * e; break; case ArticulationModifierTypes.scaleZ: u ? r.scale.z -= l * e : r.scale.z += l * e; break; case ArticulationModifierTypes.opacity: r.traverse((r => { "Mesh" == r.type && (r.material instanceof Array ? r.material.forEach((r => { l = d.find((e => e.startTime == t.startTime && e.articulationName.split(":")[1] === r.name && e.articulationProperty === i.key)).articulationDiff, r.transparent = !0, u ? r.opacity -= l * e : r.opacity += l * e, r.opacity = s._checkOpacity(r.opacity) })) : (l = d.find((e => e.startTime == t.startTime && e.articulationName.split(":")[1] === r.name && e.articulationProperty === i.key)).articulationDiff, r.material.transparent = !0, u ? r.material.opacity -= l * e : r.material.opacity += l * e, r.material.opacity = s._checkOpacity(r.material.opacity))) })); break; case ArticulationModifierTypes.colorOverlay: r.traverse((r => { if ("Mesh" == r.type) { let n; r.material instanceof Array ? r.material.forEach((r => { l = d.find((e => e.startTime == t.startTime && e.articulationName.split(":")[1] === r.name && e.articulationProperty === i.key)).articulationDiff, n = u ? new RGBAColor(r.color.r - l.color.r * e, r.color.g - l.color.g * e, r.color.b - l.color.b * e, r.opacity - l.alpha * e) : new RGBAColor(r.color.r + l.color.r * e, r.color.g + l.color.g * e, r.color.b + l.color.b * e, r.opacity + l.alpha * e), n.alpha > 0 ? (r.color = s._checkColor(n.color), r.opacity = s._checkOpacity(n.alpha)) : (r.opacity = 1, r.color = s.getDefaultVal(r.name, i.key) && s.getDefaultVal(r.name, i.key).articulationVal.color) })) : (l = d.find((e => e.startTime == t.startTime && e.articulationName.split(":")[1] === r.name && e.articulationProperty === i.key)).articulationDiff, n = u ? new RGBAColor(r.material.color.r - l.color.r * e, r.material.color.g - l.color.g * e, r.material.color.b - l.color.b * e, r.material.opacity - l.alpha * e) : new RGBAColor(r.material.color.r + l.color.r * e, r.material.color.g + l.color.g * e, r.material.color.b + l.color.b * e, r.material.opacity + l.alpha * e), n.alpha > 0 ? (r.material.color = s._checkColor(n.color), r.material.opacity = s._checkColor(n.alpha)) : (r.material.opacity = 1, r.material.color = s.getDefaultVal(r.name, i.key) && s.getDefaultVal(r.name, i.key).articulationVal.color)) } })); break; case ArticulationModifierTypes.colorReplace: r.traverse((r => { if ("Mesh" == r.type) { let n; r.material instanceof Array ? r.material.forEach((r => { l = d.find((e => e.startTime == t.startTime && e.articulationName.split(":")[1] === r.name && e.articulationProperty === i.key)).articulationDiff, n = u ? new RGBAColor(r.color.r - l.color.r * e, r.color.g - l.color.g * e, r.color.b - l.color.b * e, r.opacity - l.alpha * e) : new RGBAColor(r.color.r + l.color.r * e, r.color.g + l.color.g * e, r.color.b + l.color.b * e, r.opacity + l.alpha * e), n.alpha > 0 ? (r.map = null, r.color = s._checkColor(n.color), r.opacity = s._checkOpacity(n.alpha)) : (r.opacity = 1, r.color = s.getDefaultVal(r.name, i.key) && s.getDefaultVal(r.name, i.key).articulationVal.color, r.map = s.getDefaultVal(r.name, i.key) && s.getDefaultVal(r.name, i.key).articulationVal.map), r.needsUpdate = !0 })) : (l = d.find((e => e.startTime == t.startTime && e.articulationName.split(":")[1] === r.name && e.articulationProperty === i.key)).articulationDiff, n = u ? new RGBAColor(r.material.color.r - l.color.r * e, r.material.color.g - l.color.g * e, r.material.color.b - l.color.b * e, r.material.opacity - l.alpha * e) : new RGBAColor(r.material.color.r + l.color.r * e, r.material.color.g + l.color.g * e, r.material.color.b + l.color.b * e, r.material.opacity + l.alpha * e), n.alpha > 0 ? (r.material.map = null, r.material.color = s._checkColor(n.color), r.material.opacity = s._checkOpacity(n.alpha)) : (r.material.opacity = 1, r.material.color = s.getDefaultVal(r.name, i.key) && s.getDefaultVal(r.name, i.key).articulationVal.color, r.material.map = s.getDefaultVal(r.name, i.key) && s.getDefaultVal(r.name, i.key).articulationVal.map), r.material.needsUpdate = !0) } })); break; case ArticulationModifierTypes.stroke: let n, a = d.find((e => e.startTime == t.startTime && e.articulationName === r.name && e.articulationProperty === i.key)); u ? (a.articulationVal.tempColor.color.r -= a.articulationDiff.color.r * e, a.articulationVal.tempColor.color.g -= a.articulationDiff.color.g * e, a.articulationVal.tempColor.color.b -= a.articulationDiff.color.b * e, a.articulationVal.tempColor.alpha -= a.articulationDiff.alpha * e) : (a.articulationVal.tempColor.color.r += a.articulationDiff.color.r * e, a.articulationVal.tempColor.color.g += a.articulationDiff.color.g * e, a.articulationVal.tempColor.color.b += a.articulationDiff.color.b * e, a.articulationVal.tempColor.alpha += a.articulationDiff.alpha * e), n = new RGBAColor(a.articulationVal.tempColor.color.r, a.articulationVal.tempColor.color.g, a.articulationVal.tempColor.color.b, a.articulationVal.tempColor.alpha), a.articulationVal.tempColor.color = s._checkColor(n.color), a.articulationVal.tempColor.alpha = s._checkOpacity(n.alpha), _context.effectStore.initOutlinePass(r, !0, new RGBAColor(a.articulationVal.tempColor.color.r, a.articulationVal.tempColor.color.g, a.articulationVal.tempColor.color.b, a.articulationVal.tempColor.alpha)) } } let p = []; for (let e of c.materials) { let t = a.findMaterial(e); t && p.push(t) } if (p.length) for (let a of c.modifiers) for (let c of p) { var r, n; switch (a.key) { case ArticulationModifierTypes.USpeed: if (r = s._interpolateAbsoluteNumeric(a.values, t.startState), n = s._interpolateAbsoluteNumeric(a.values, t.endState), l = (n - r) / t.continueTime * i, o = _context.animationStore.findMaterialAnimation(c._material(), UVAnimationController.type)) o.uSpeed += l * e, o.enableU = 0 !== o.uSpeed; else { let t = new UVAnimationController(c._material(), l * e != 0, !1, l * e, 0); o = t, _context.animationStore.add(t) } 0 === o.uSpeed && 0 === o.vSpeed && _context.animationStore.remove(o); break; case ArticulationModifierTypes.VSpeed: var o; if (r = s._interpolateAbsoluteNumeric(a.values, t.startState), n = s._interpolateAbsoluteNumeric(a.values, t.endState), l = (n - r) / t.continueTime * i, o = _context.animationStore.findMaterialAnimation(c._material(), UVAnimationController.type)) o.vSpeed += l * e, o.enableV = 0 !== o.vSpeed; else { let t = new UVAnimationController(c._material(), !1, l * e != 0, 0, l * e); o = t, _context.animationStore.add(t) } 0 === o.uSpeed && 0 === o.vSpeed && _context.animationStore.remove(o) } } let f = []; for (let e of c.particles) { let t = a.particleStoreArray.find((t => t.name === e)); t && f.push(t) } if (f.length) for (let i of c.modifiers) for (let r of f) { if (![ArticulationModifierTypes.opacity, ArticulationModifierTypes.stroke, ArticulationModifierTypes.colorOverlay, ArticulationModifierTypes.colorReplace].includes(i.key)) { let e = d.find((e => e.startTime == t.startTime && e.articulationName === r.particleModelGroup.name && e.articulationProperty === i.key)); l = e ? e.articulationDiff : null } switch (i.key) { case ArticulationModifierTypes.rotationX: u ? r.particleModelGroup.rotation.x -= l / 180 * Math.PI * e : r.particleModelGroup.rotation.x += l / 180 * Math.PI * e; break; case ArticulationModifierTypes.rotationY: u ? r.particleModelGroup.rotation.y -= l / 180 * Math.PI * e : r.particleModelGroup.rotation.y += l / 180 * Math.PI * e; break; case ArticulationModifierTypes.rotationZ: u ? r.particleModelGroup.rotation.z -= l / 180 * Math.PI * e : r.particleModelGroup.rotation.z += l / 180 * Math.PI * e; break; case ArticulationModifierTypes.translationX: u ? r.particleModelGroup.position.x -= l * e : r.particleModelGroup.position.x += l * e; break; case ArticulationModifierTypes.translationY: u ? r.particleModelGroup.position.y -= l * e : r.particleModelGroup.position.y += l * e; break; case ArticulationModifierTypes.translationZ: u ? r.particleModelGroup.position.z -= l * e : r.particleModelGroup.position.z += l * e; break; case ArticulationModifierTypes.scaleX: u ? r.particleModelGroup.scale.x -= l * e : r.particleModelGroup.scale.x += l * e; break; case ArticulationModifierTypes.scaleY: u ? r.particleModelGroup.scale.y -= l * e : r.particleModelGroup.scale.y += l * e; break; case ArticulationModifierTypes.scaleZ: u ? r.particleModelGroup.scale.z -= l * e : r.particleModelGroup.scale.z += l * e; break; case ArticulationModifierTypes.opacity: r.particleGroup.forEach((n => { l = d.find((e => e.startTime == t.startTime && e.articulationName === r.particleModelGroup.name + ":" + n.id && e.articulationProperty === i.key)).articulationDiff, u ? n.opacity -= l * e : n.opacity += l * e, n.opacity = s._checkOpacity(n.opacity) })); break; case ArticulationModifierTypes.quantityFactor: r.particleGroup.forEach((n => { l = d.find((e => e.startTime == t.startTime && e.articulationName === r.particleModelGroup.name + ":" + n.id && e.articulationProperty === i.key)).articulationDiff, u ? n.density -= l * e : n.density += l * e, n.density = s._checkOpacity(n.density) })) } } } } } })), n && n({ progress: h / c }), h > c || 1 == u)) switch (h > c && this._setEndAnimation(l.length - 1), this.animationType) { case AnimationTypes.NONE: h = 0; let t = _context.animationStore.findAnimation(this.animationName, ArticulationAnimationGroupController.type); t && _context.animationStore.remove(t), p = -1; break; case AnimationTypes.ROUND: h = 0, this._initAnimation(); break; case AnimationTypes.REPEAT: u = !0, h -= 2 * e, h <= 0 && (h = 0, u = !1, this._initAnimation()) } }, this.reset = () => { this._initAnimation() } } } ArticulationAnimationGroupController.type = "ArticulationAnimationGroupController"; var BaseCarrierController = function (e) { this.targetObjects = {}, this.update = function (t, i) { if (void 0 === this.targetObjects[i]) return; const r = this.targetObjects[i]; if (!0 !== r.userData.moveComplete) { if (r.userData.currentTime < r.userData.duration && r.userData.duration > 0) { r.userData.currentTime += t; var n = r.userData.currentTime / r.userData.duration, a = { x: r.userData.startPos.x + (r.userData.targetPos.x - r.userData.startPos.x) * n, y: r.userData.startPos.y + (r.userData.targetPos.y - r.userData.startPos.y) * n, z: r.userData.startPos.z + (r.userData.targetPos.z - r.userData.startPos.z) * n }; r.position.set(a.x, a.y, a.z) } else r.position.set(r.userData.targetPos.x, r.userData.targetPos.y, r.userData.targetPos.z), r.userData.moveComplete = !0; e && e(r) } }, this.add = function (e, t) { this.targetObjects[e] = t }, this.remove = function (e) { delete this.targetObjects[e] }, this.dispose = function () { } }; class ClippingController { constructor({ meshes: e = [], clippingPlanes: t = [] }) { _context.renderer.localClippingEnabled = !0; let i = [], r = []; if (e instanceof Array || !(meshs.length > 0)) { for (let t of e) t instanceof Mesh && i.push(t), t.traverse((e => { e instanceof Mesh && i.push(e) })); for (let e of t) "number" == typeof e.nx && "number" == typeof e.ny && "number" == typeof e.nz && "number" == typeof e.d ? r.push(new Plane(new Vector3(e.nx, e.ny, e.nz), e.d)) : logger.warn("剪裁面参数错误。"); for (let e of i) if (e.material instanceof Array) for (const t of e.material) t.clippingPlanes = r, t.clipShadows = !0; else e.material && (e.material.clippingPlanes = r, e.material.clipShadows = !0); this.clear = () => { for (let e of i) if (e.material instanceof Array) for (const t of e.material) t.clippingPlanes = null, t.clipShadows = null; else e.material && (e.material.clippingPlanes = null, e.material.clipShadows = null); i = null, r = null }, this.pointClipTest = e => { let t = !0; return r.forEach((i => { t = t && i.distanceToPoint(e) < 0 })), t }, this.dispose = () => { i.forEach((e => { util$1.disposeThreeObject(e) })), i = [], r.forEach((e => { util$1.disposeThreeObject(e) })), r = [] } } } get type() { return "ClippingController" } set enabled(e) { _context.renderer.localClippingEnabled = e } } class DistanceController extends AnimationController { constructor(e, t, i) { super("DistanceController"), this.camera = e, this.object = t, this.object0 = t, this.name = i, this.render = () => { var e = this.camera.position.clone(); if (null != this.object) if (this.object.enableAutoHidebyDistance) { if (null != this.object.distance && this.object.distance) var t = this.object.distance.distanceTo(e); else if (this.object.getWorldPosition) t = this.object.getWorldPosition(new Vector3).distanceTo(e); else t = this.object.position.distanceTo(e); if (t >= this.object.minDistance && t <= this.object.maxDistance) { if (!this.object) return; this.object.visible = this.object.activeVisible && !0 } else { if (!this.object) return; this.object.visible = !1 } } else this.object.visible = this.object.activeVisible }, this.reset = () => { this.object = this.object0 } } } DistanceController.type = "DistanceController"; class FireflyAnimationController extends AnimationController { constructor(e) { super("FireflyAnimationController"), this.animationObject = e, this.value = this.animationObject.uniforms.time.value, this.render = e => { this.animationObject.uniforms.time.value += e }, this.reset = () => { this.animationObject.uniforms.time.value = this.value } } } FireflyAnimationController.type = "FireflyAnimationController"; class FireworksAnimationController extends AnimationController { constructor(e, t) { super("FireworksAnimationController"), this.firworksArr = e, this.option = t, this.name = t.name, this.reDraw = function (e) { let t = this.option.centerPos.x + Number(this.option.offset.x) + 2 * this.option.range * Math.random() - this.option.range, i = Number(this.option.offset.y) + this.option.bottomHeight + (this.option.topHeight - this.option.bottomHeight) * Math.random(), r = this.option.centerPos.z + Number(this.option.offset.z) + 2 * this.option.range * Math.random() - this.option.range; for (var n of (e.pos.x = t, e.pos.y = i, e.pos.z = r, e.speed = this.option.speed + this.option.speedR * Math.random(), e.lifetime = this.option.lifetime + this.option.lifetimeR * Math.random(), e.leaveTime = e.lifetime, e.currentTime = 0, e.color = 16777215 * Math.random(), e.children)) n.position.set(e.pos.x, e.pos.y, e.pos.z), n.dir = new Vector3(2 * Math.random() - 1, 2 * Math.random() - 1, 2 * Math.random() - 1).normalize(), n.material.opacity = 1 }, this.operationFireWork = function (e, t) { for (var i of e.children) i.position.set(i.position.x + i.dir.x * e.speed * t, i.position.y + i.dir.y * e.speed * t, i.position.z + i.dir.z * e.speed * t), .1 * e.lifetime > e.leaveTime && (i.material.opacity = e.leaveTime / (10 * e.lifetime)); e.leaveTime -= t, e.currentTime += t }, this.render = e => { for (var t of this.firworksArr.children) t.leaveTime <= 0 ? this.reDraw(t) : this.operationFireWork(t, e) }, this.reset = () => { } } } FireworksAnimationController.type = "FireworksAnimationController"; class FollowAnimationController extends AnimationController { constructor(e, t, i) { super("FollowAnimationController"), this.animationObject = e, this.target = t, this.params = i, this.targetWorldPosition = new Vector3, this.position0 = this.animationObject.position.clone(), this.rotation0 = this.animationObject.rotation.clone(), this.scale0 = this.animationObject.scale.clone(), this.distance0 = this.params.distance0, this.animationObject.material && (this.color0 = this.animationObject.material.color.clone(), this.transparent0 = this.animationObject.material.transparent, this.opacity0 = this.animationObject.material.opacity, this.animationObject.material.transparent = !0), this.validate = e => { if (e && "string" == typeof e.type && (e.type = e.type.toLowerCase(), !("number" != typeof e.limitDistance || e.limitDistance <= 0))) { switch (e.type) { case "disappear": ("number" != typeof e.disappearDistance || e.disappearDistance > e.limitDistance) && (e.disappearDistance = e.limitDistance); break; case "freeze": this.established = !1; break; default: return }return e.limitColor ? e.limitColor = new Color$1(e.limitColor) : e.limitColor = void 0, e } }, this.params.limit = this.validate(this.params.limit), this.render = e => { if (this.animationObject && this.target && void 0 !== e && this.params.followType) { switch (this.params.followType.toLowerCase()) { case "position": if (!this.animationObject.position || !this.target.position) return; this.animationObject.position.copy(this.target.position), this.params.offset && (this.animationObject.position.x += this.params.offset.x || 0, this.animationObject.position.y += this.params.offset.y || 0, this.animationObject.position.z += this.params.offset.z || 0); break; case "rotation": if (!this.animationObject.rotation || !this.target.rotation) return; this.animationObject.rotation.copy(this.target.rotation), this.params.offset && (this.animationObject.rotation.x += MathUtils.degToRad(this.params.offset.x || 0), this.animationObject.rotation.y += MathUtils.degToRad(this.params.offset.y || 0), this.animationObject.rotation.z += MathUtils.degToRad(this.params.offset.z || 0)); break; case "scale": if (!this.animationObject.scale || !this.target.scale) return; this.animationObject.scale.copy(this.target.scale), this.animationObject.scale.x *= this.scale0.x, this.animationObject.scale.y *= this.scale0.y, this.animationObject.scale.z *= this.scale0.z; break; case "orientation": if (!this.target.position) return; if (!this.animationObject.rotation || !this.animationObject.scale) return; const e = this.animationObject.position.distanceTo(this.target.position); if (this.params.limit) { if (this.params.limit.limitColor && this.animationObject.material && this.animationObject.material.color.copy(this.color0), "freeze" === this.params.limit.type && e > this.params.limit.limitDistance && this.established) { this.params.limit.limitColor && this.animationObject.material && this.animationObject.material.color.copy(this.params.limit.limitColor); break } if ("disappear" === this.params.limit.type && e > this.params.limit.disappearDistance && this.animationObject.material) { const t = (e - this.params.limit.disappearDistance) / (this.params.limit.limitDistance - this.params.limit.disappearDistance); this.animationObject.material.opacity = this.opacity0 * (1 - t), this.params.limit.limitColor && (this.animationObject.material.color = this.animationObject.material.color.lerp(this.params.limit.limitColor, t)) } } (this.params.enableRotation || this.params.enableRotate) && (this.target.getWorldPosition(this.targetWorldPosition), this.targetWorldPosition.y -= 1, this.animationObject.lookAt(this.targetWorldPosition)), this.params.enableScale && (this.animationObject.scale.z = this.scale0.z * (e / this.distance0)) }this.established || (this.animationObject.scale.x = this.scale0.x, this.animationObject.scale.y = this.scale0.y, this.animationObject.scale.z = this.scale0.z, this.established = !0) } }, this.reset = () => { this.animationObject.position.copy(this.position0), this.animationObject.rotation.copy(this.rotation0), this.animationObject.scale.copy(this.scale0), this.animationObject.material && (this.animationObject.material.transparent = this.transparent0, this.animationObject.material.opacity = this.opacity0, this.animationObject.material.color.copy(this.color0)) } } } FollowAnimationController.type = "FollowAnimationController"; class InstancedBubbleAnimationController extends AnimationController { constructor(e, t, i, r, n, a, o = !1, s) { super("InstancedBubbleAnimationController"), this.instancedMesh = e, this.instanceId = t, this.startScale = i, this.endScale = r, this.startDisappearScale = n, this.diffusionSpeed = a, this.yScale = o, this.camera = s, this.dummy = new Object3D, this.dummy.matrixAutoUpdate = !1, this.instancedMesh.getMatrixAt(t, this.dummy.matrix), this.matrix0 = this.dummy.matrix.clone(), this.dummy.matrix.decompose(this.dummy.position, this.dummy.quaternion, this.dummy.scale), this.render = e => { if (this.instancedMesh instanceof InstancedMesh) { if (void 0 === e) { var t = this.endScale / 100; this.dummy.scale.x += this.diffusionSpeed * t, this.dummy.scale.z += this.diffusionSpeed * t, this.yScale && (this.dummy.scale.y += this.diffusionSpeed * t) } else this.dummy.scale.x += this.diffusionSpeed * e, this.dummy.scale.z += this.diffusionSpeed * e, this.yScale && (this.dummy.scale.y += this.diffusionSpeed * e); if (this.diffusionSpeed >= 0 ? this.dummy.scale.x > this.endScale && (this.dummy.scale.x = this.startScale, this.dummy.scale.z = this.startScale, this.yScale && (this.dummy.scale.y = this.startScale)) : this.dummy.scale.x < this.endScale && (this.dummy.scale.x = this.startScale, this.dummy.scale.z = this.startScale, this.yScale && (this.dummy.scale.y = this.startScale)), this.instancedMesh.hideByDistance[this.instanceId]) { let e = this.camera.position.clone(), t = new Matrix4, r = new Vector3; this.instancedMesh.getMatrixAt(this.instanceId, t), r.setFromMatrixPosition(t); var i = r.distanceTo(e); (i < this.instancedMesh.minDistances[this.instanceId] || i > this.instancedMesh.maxDistances[this.instanceId] || !this.instancedMesh.activeVisible[this.instanceId]) && (this.dummy.scale.x = 0, this.dummy.scale.y = 0, this.dummy.scale.z = 0) } this.instancedMesh.visible[this.instanceId] || (this.dummy.scale.x = 0, this.dummy.scale.y = 0, this.dummy.scale.z = 0), this.dummy.updateMatrix(), this.instancedMesh.setMatrixAt(this.instanceId, this.dummy.matrix), this.instancedMesh.instanceMatrix.needsUpdate = !0 } }, this.reset = () => { this.dummy.scale.set(this.scaleX0, this.scaleY0, this.scaleZ0), this.instanceMatrix.scale(this.dummy.scale.x, this.dummy.scale.y, this.dummy.scale.z), this.instancedMesh.setMatrixAt(this.instanceId, this.instanceMatrix), this.instancedMesh.instanceMatrix.needsUpdate = !0 } } } InstancedBubbleAnimationController.type = "InstancedBubbleAnimationController"; class ModelTransformAnimationController extends AnimationController { constructor(e, t) { if (super("ModelTransformAnimationController"), this.animationObject = e, this.params = t, this.position = t.position, this.rotation = t.rotation, this.scale = t.scale, this.duration = t.duration, this.diffPostion = { x: 0, y: 0, z: 0 }, t.isChangeCoordX && (this.diffPostion.x = (this.position.x - this.animationObject.position.x) / this.duration), t.isChangeCoordY && (this.diffPostion.y = (this.position.y - this.animationObject.position.y) / this.duration), t.isChangeCoordZ && (this.diffPostion.z = (this.position.z - this.animationObject.position.z) / this.duration), this.diffRoation = { x: 0, y: 0, z: 0 }, t.isChangeRotationX) { let e = this.rotation.x - MathUtils.radToDeg(this.animationObject.rotation.x), t = Math.abs(e); t > 180 ? (this.rotation.x = MathUtils.degToRad(this.rotation.x), this.diffRoation.x = MathUtils.degToRad(360 - t) / this.duration, e > 0 && (this.diffRoation.x = -this.diffRoation.x)) : (this.rotation.x = MathUtils.degToRad(this.rotation.x), this.diffRoation.x = (this.rotation.x - this.animationObject.rotation.x) / this.duration) } if (t.isChangeRotationY) { let e = this.rotation.y - MathUtils.radToDeg(this.animationObject.rotation.y), t = Math.abs(e); t > 180 ? (this.rotation.y = MathUtils.degToRad(this.rotation.y), this.diffRoation.y = MathUtils.degToRad(360 - t) / this.duration, e > 0 && (this.diffRoation.y = -this.diffRoation.y)) : (this.rotation.y = MathUtils.degToRad(this.rotation.y), this.diffRoation.y = (this.rotation.y - this.animationObject.rotation.y) / this.duration) } if (t.isChangeRotationZ) { let e = this.rotation.z - MathUtils.radToDeg(this.animationObject.rotation.z), t = Math.abs(e); t > 180 ? (this.rotation.z = MathUtils.degToRad(this.rotation.z), this.diffRoation.z = MathUtils.degToRad(360 - t) / this.duration, e > 0 && (this.diffRoation.z = -this.diffRoation.z)) : (this.rotation.z = MathUtils.degToRad(this.rotation.z), this.diffRoation.z = (this.rotation.z - this.animationObject.rotation.z) / this.duration) } this.diffScale = { x: 1, y: 1, z: 1 }, t.isChangeScaleX && (this.diffScale.x = (this.scale.x - this.animationObject.scale.x) / this.duration), t.isChangeScaleY && (this.diffScale.y = (this.scale.y - this.animationObject.scale.y) / this.duration), t.isChangeScaleZ && (this.diffScale.z = (this.scale.z - this.animationObject.scale.z) / this.duration), this.animationDurationTime = 0 } render(e) { if (this.params.isChangeCoordX && (this.animationObject.position.x += this.diffPostion.x * e, _context.eventHandlerStore.cameraMove()), this.params.isChangeCoordY && (this.animationObject.position.y += this.diffPostion.y * e, _context.eventHandlerStore.cameraMove()), this.params.isChangeCoordZ && (this.animationObject.position.z += this.diffPostion.z * e, _context.eventHandlerStore.cameraMove()), this.params.isChangeRotationX && (this.animationObject.rotation.x += this.diffRoation.x * e), this.params.isChangeRotationY && (this.animationObject.rotation.y += this.diffRoation.y * e), this.params.isChangeRotationZ && (this.animationObject.rotation.z += this.diffRoation.z * e), this.params.isChangeScaleX && (this.animationObject.scale.x += this.diffScale.x * e), this.params.isChangeScaleY && (this.animationObject.scale.y += this.diffScale.y * e), this.params.isChangeScaleZ && (this.animationObject.scale.z += this.diffScale.z * e), this.animationDurationTime += e, this.animationDurationTime > this.duration) { this.params.isChangeCoordX && (this.animationObject.position.x = this.position.x, _context.eventHandlerStore.cameraMove()), this.params.isChangeCoordY && (this.animationObject.position.y = this.position.y, _context.eventHandlerStore.cameraMove()), this.params.isChangeCoordZ && (this.animationObject.position.z = this.position.z, _context.eventHandlerStore.cameraMove()), this.params.isChangeRotationX && (this.animationObject.rotation.x = this.rotation.x), this.params.isChangeRotationY && (this.animationObject.rotation.y = this.rotation.y), this.params.isChangeRotationZ && (this.animationObject.rotation.z = this.rotation.z), this.params.isChangeScaleX && (this.animationObject.scale.x = this.scale.x), this.params.isChangeScaleY && (this.animationObject.scale.y = this.scale.y), this.params.isChangeScaleZ && (this.animationObject.scale.z = this.scale.z); let e = _context.animationStore.findNodeAnimation(this.animationObject, ModelTransformAnimationController.type); e && _context.animationStore.remove(e) } } } ModelTransformAnimationController.type = "ModelTransformAnimationController"; class NodeBlinkingAnimationController extends AnimationController { constructor(e, t = 1, i = "", r = "default") { super("NodeBlinkingAnimationController"), this.animationObject = e, this.targetColor = new Color$1(1, 1, 1), this.defaultColors = {}, this.animationObject.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((t => { t.transparent = !0, this.defaultColors[e.name + t.name] = t.color.clone() })) : (e.material.transparent = !0, this.defaultColors[e.name] = e.material.color.clone())) })), this.animationObject.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { e.color = this.targetColor })) : e.material.color = this.targetColor) })), this.blinkingColor = new Color$1(i), this.r = (this.targetColor.r - this.blinkingColor.r) / t, this.g = (this.targetColor.g - this.blinkingColor.g) / t, this.b = (this.targetColor.b - this.blinkingColor.b) / t, this.currentColor = this.targetColor, this.render = e => { null != this.animationObject && (this.currentColor = 0 == t ? this.blinkingColor : this._changeColor(this.currentColor, e), this.animationObject.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((e => { e.color = this.currentColor })) : e.material.color = this.currentColor) }))) }, this.reset = () => { this.animationObject.traverse((e => { "Mesh" == e.type && (e.material instanceof Array ? e.material.forEach((t => { t.transparent = !1, t.color = this.defaultColors[e.name + t.name] })) : (e.material.transparent = !1, e.material.color = this.defaultColors[e.name])) })) }, this._changeColor = (e, t) => (e.r += this.r * t, e.r >= 1 && (e.r = this.blinkingColor.r), e.g += this.g * t, e.g >= 1 && (e.g = this.blinkingColor.g), e.b += this.b * t, e.b >= 1 && (e.b = this.blinkingColor.b), e) } } NodeBlinkingAnimationController.type = "NodeBlinkingAnimationController"; class NodeBreatheAnimationController extends AnimationController { constructor(e, t, i, r = !1) { super("NodeBreatheAnimationController"), this.animationObject = e, this.endBreathe = t, this.diffusionSpeed = i, this.yScale = r, this.scaleX0 = this.animationObject.scale.x, this.scaleY0 = this.animationObject.scale.y, this.scaleZ0 = this.animationObject.scale.z, this.isScale = !0, this.render = e => { if (null != this.animationObject) if (this.animationObject.scale.x < this.endBreathe && !0 === this.isScale) if (void 0 === e) { var t = this.endBreathe / 100; this.animationObject.scale.x += this.diffusionSpeed * t, this.animationObject.scale.z += this.diffusionSpeed * t, this.yScale && (this.animationObject.scale.y += this.diffusionSpeed * t), this.animationObject.scale.x >= this.endBreathe && (this.isScale = !1) } else this.animationObject.scale.x += this.diffusionSpeed * e, this.animationObject.scale.z += this.diffusionSpeed * e, this.yScale && (this.animationObject.scale.y += this.diffusionSpeed * e), this.animationObject.scale.x >= this.endBreathe && (this.isScale = !1); else if (void 0 === e) { t = this.endBreathe / 100; this.animationObject.scale.x -= this.diffusionSpeed * t, this.animationObject.scale.z -= this.diffusionSpeed * t, this.yScale && (this.animationObject.scale.y -= this.diffusionSpeed * t), this.animationObject.scale.x <= 1 && (this.isScale = !0) } else this.animationObject.scale.x -= this.diffusionSpeed * e, this.animationObject.scale.z -= this.diffusionSpeed * e, this.yScale && (this.animationObject.scale.y -= this.diffusionSpeed * e), this.animationObject.scale.x <= 1 && (this.isScale = !0) }, this.reset = () => { this.animationObject.scale.set(this.scaleX0, this.scaleY0, this.scaleZ0) } } } NodeBreatheAnimationController.type = "NodeBreatheAnimationController"; class NodeMovingAnimationController extends AnimationController { constructor(e, t = "round", i = !1, r = "path", n = [], a = [0, 0, 0], o = "", s = "") { super("NodeMovingAnimationController"), this.animationObject = e, this.loopMode = t, this.reverse = i, this.direction = r, this.points = n, this.offset = a, this.pathId = o, this.defaultPosition = this.animationObject.position.clone(), this.defaultRotation = this.animationObject.rotation.clone(), this.isReverse = !1, this.reverse && (this.points = this.points.reverse()), this.times = []; let l = 0; for (let e = 1; e < this.points.length; e++) { const t = this.points[e]; t.speed = t.speed || 0; const i = this.points[e - 1]; let r = new Vector3(t.x, t.y, t.z).distanceTo(new Vector3(i.x, i.y, i.z)), n = 0; n = this.reverse ? r / this.points[0].speed : r / t.speed, l += n, this.times.push(l) } this.time = 0, this.render = e => { if (null != this.animationObject) { if (this.isReverse && this.time < 0 && (this.time = 0, this.isReverse = !1), this.time >= 0) { if (this.time >= this.times[this.times.length - 1]) switch (this.loopMode) { case "none": this.time = -1; break; case "round": this.time = this.times[this.times.length - 1], this.time -= e, this.isReverse = !0; break; case "repeat": this.time = 0, this.reset() } else this.isReverse ? this.time -= e : this.time += e; if (this.time >= 0) { for (let e = 0; e < this.times.length; e++) { if (this.times[e] >= this.time) { this.currentIndex = e; break } } let e; e = this.isReverse ? new Vector3(this.points[this.currentIndex + 1].x, this.points[this.currentIndex + 1].y, this.points[this.currentIndex + 1].z) : new Vector3(this.points[this.currentIndex].x, this.points[this.currentIndex].y, this.points[this.currentIndex].z); let t, i = 0; if (i = 0 == this.currentIndex ? this.time / this.times[this.currentIndex] : (this.time - this.times[this.currentIndex - 1]) / (this.times[this.currentIndex] - this.times[this.currentIndex - 1]), this.isReverse && (i = 1 - i), t = this.isReverse ? this.currentIndex > 0 ? e.lerp(new Vector3(this.points[this.currentIndex].x, this.points[this.currentIndex].y, this.points[this.currentIndex].z), i) : e.lerp(new Vector3(this.points[0].x, this.points[0].y, this.points[0].z), i) : e.lerp(new Vector3(this.points[this.currentIndex + 1].x, this.points[this.currentIndex + 1].y, this.points[this.currentIndex + 1].z), i), "path" == this.direction) { let t = new Vector3(this.animationObject.rotation.x, this.animationObject.rotation.y, this.animationObject.rotation.z).angleTo(e); this.isReverse ? this.animationObject.rotation.y = this.reverse ? t : -t : this.animationObject.rotation.y = this.reverse ? -t : t } this.offset ? (this.animationObject.position.x = t.x + this.offset[0], this.animationObject.position.y = t.y + this.offset[1], this.animationObject.position.z = t.z + this.offset[2]) : (this.animationObject.position.x = t.x, this.animationObject.position.y = t.y, this.animationObject.position.z = t.z), s instanceof Function && s({ id: this.pathId, pass: this.currentIndex, ratio: this.isReverse ? 1 - i : i }) } } _context.eventHandlerStore.cameraMove() } }, this.reset = () => { this.animationObject.position.x = this.defaultPosition.x, this.animationObject.position.y = this.defaultPosition.y, this.animationObject.position.z = this.defaultPosition.z, this.animationObject.rotation.x = this.defaultRotation.x, this.animationObject.rotation.y = this.defaultRotation.y, this.animationObject.rotation.z = this.defaultRotation.z } } } NodeMovingAnimationController.type = "NodeMovingAnimationController"; class NodeRotationAnimationController extends AnimationController { constructor(e, t, i, r, n, a, o) { super("NodeRotationAnimationController"), this.animationObject = e, this.isX = t, this.isY = i, this.isZ = r, this.xSpeed = n, this.ySpeed = a, this.zSpeed = o, this.rotationX0 = this.animationObject.rotation.x, this.rotationY0 = this.animationObject.rotation.y, this.rotationZ0 = this.animationObject.rotation.z, this.render = e => { null != this.animationObject && (this.isX && (this.animationObject.rotation.x += this.xSpeed * e * 20 / Math.PI), this.isY && (this.animationObject.rotation.y += this.ySpeed * e * 20 / Math.PI), this.isZ && (this.animationObject.rotation.z += this.zSpeed * e * 20 / Math.PI)) }, this.reset = () => { this.animationObject.rotation.x = this.rotationX0, this.animationObject.rotation.y = this.rotationY0, this.animationObject.rotation.z = this.rotationZ0 } } } NodeRotationAnimationController.type = "NodeRotationAnimationController"; class NodeScaleAnimationController extends AnimationController { constructor(e, t, i, r, n, a = !1) { super("NodeScaleAnimationController"), this.animationObject = e, this.startScale = t, this.endScale = i, this.startDisappearScale = r, this.diffusionSpeed = n, this.yScale = a, this.scaleX0 = this.animationObject.scale.x, this.scaleY0 = this.animationObject.scale.y, this.scaleZ0 = this.animationObject.scale.z, e.material ? this.opacity = e.material.opacity || 1 : this.opacity = 1, this.render = e => { if (null != this.animationObject) { if (void 0 === e) { var t = this.endScale / 100; this.animationObject.scale.x += this.diffusionSpeed * t, this.animationObject.scale.z += this.diffusionSpeed * t, this.yScale && (this.animationObject.scale.y += this.diffusionSpeed * t) } else this.animationObject.scale.x += this.diffusionSpeed * e, this.animationObject.scale.z += this.diffusionSpeed * e, this.yScale && (this.animationObject.scale.y += this.diffusionSpeed * e); if (this.diffusionSpeed >= 0) { if (this.animationObject.scale.x > this.endScale) if (this.animationObject.scale.x = this.startScale, this.animationObject.scale.z = this.startScale, this.yScale && (this.animationObject.scale.y = this.startScale), this.animationObject.material) this.animationObject.material.opacity = this.opacity; else if (this.animationObject.children.length > 0) { var i = this; this.animationObject.traverse((function (e) { e.material && (e.material.opacity = i.opacity) })) } if (this.animationObject.scale.x > this.startDisappearScale) { var r = (1 - (this.animationObject.scale.x - this.startDisappearScale) / (this.endScale - this.startDisappearScale)) * this.opacity; this.animationObject.material ? (this.animationObject.material.opacity = r, this.animationObject.material.transparent = !0) : this.animationObject.children.length > 0 && this.animationObject.traverse((function (e) { e.material && (e.material.opacity = r, e.material.transparent = !0) })) } } else { if (this.animationObject.scale.x < this.endScale) if (this.animationObject.scale.x = this.startScale, this.animationObject.scale.z = this.startScale, this.yScale && (this.animationObject.scale.y = this.startScale), this.animationObject.material) this.animationObject.material.opacity = this.opacity; else if (this.animationObject.children.length > 0) { i = this; this.animationObject.traverse((function (e) { e.material && (e.material.opacity = i.opacity) })) } if (this.animationObject.scale.x < this.startDisappearScale) { r = (1 - (this.startDisappearScale - this.animationObject.scale.x) / (this.endScale - this.startDisappearScale)) * this.opacity; this.animationObject.material ? (this.animationObject.material.opacity = r, this.animationObject.material.transparent = !0) : this.animationObject.children.length > 0 && this.animationObject.traverse((function (e) { e.material && (e.material.opacity = r, e.material.transparent = !0) })) } } } }, this.reset = () => { this.animationObject.scale.set(this.scaleX0, this.scaleY0, this.scaleZ0), this.animationObject.material ? this.animationObject.material.opacity = this.opacity : this.animationObject.children.length > 0 && this.animationObject.traverse((e => { e.material && (e.material.opacity = this.opacity) })) } } } NodeScaleAnimationController.type = "NodeScaleAnimationController"; class ODLineRollingAnimationController extends AnimationController { constructor(e, t) { super("ODLineRollingAnimationController"), this.animationObject = e, this.speed = t, this.value = this.animationObject.userData.mesh.material.uniforms.dashOffset.value, this.render = e => { this.animationObject.userData.mesh.material.uniforms.dashOffset.value -= parseFloat(this.speed * e / 10) }, this.reset = () => { this.animationObject.userData.mesh.material.uniforms.dashOffset.value = this.value } } } ODLineRollingAnimationController.type = "ODLineRollingAnimationController"; class RainAnimationController extends AnimationController { constructor(e, t) { super("RainAnimationController"), this.animationObject = e, this.isFollowCamera = t, this.render = e => { for (var t = 0; t < this.animationObject.children.length; t++) { var i = this.animationObject.children[t]; i.position.y -= 3 * (1 + .05 * t), i.position.y < 0 && (i.position.y = 250) } if (this.isFollowCamera) { let e = _context.camera.position.x, t = _context.camera.position.y, i = _context.camera.position.z; this.animationObject.position.set(e, t, i) } }, this.reset = () => { } } } RainAnimationController.type = "RainAnimationController"; class RainlineAnimationController extends AnimationController { constructor(e) { super("RainlineAnimationController"), this.animationObject = e, this.value = this.animationObject.uniforms.time.value, this.render = e => { this.animationObject.uniforms.time.value += e }, this.reset = () => { this.animationObject.uniforms.time.value = this.value } } } RainlineAnimationController.type = "RainlineAnimationController"; class SmoothTransformController extends AnimationController { constructor(e, t, i = 1) { if (super("SmoothTransformController"), e.isObject3D) if (t && (t.position || t.rotation || t.scale)) { if (i <= 0) return t.position instanceof Vector3 && this._node.position.set(t.position.x, t.position.y, t.position.z), t.rotation, t.scale instanceof Vector3 && this._node.scale.set(t.scale.x, t.scale.y, t.scale.z), e.getDirectionalLightHelper && e.getDirectionalLightHelper().update(), void (this.needsRemove = !0); this._node = e, this._transform = t, this._duration = i, this._elapseTimeTotal = 0, this._originalTransform = { position: e.position.clone(), rotation: e.rotation.clone(), scale: e.scale.clone() }, this._skipFrame = 2, this._skipFrameCounter = 0 } else this.needsRemove = !0; else this.needsRemove = !0 } render(e) { if (!this._node) return void (this.needsRemove = !0); if (this._elapseTimeTotal += e, this._skipFrameCounter < this._skipFrame) return void this._skipFrameCounter++; this._skipFrameCounter = 0; let t = 1 * this._elapseTimeTotal / this._duration; return this._transform.position instanceof Vector3 && this._node.position.set(this._originalTransform.position.x + t * (this._transform.position.x - this._originalTransform.position.x), this._originalTransform.position.y + t * (this._transform.position.y - this._originalTransform.position.y), this._originalTransform.position.z + t * (this._transform.position.z - this._originalTransform.position.z)), this._transform.rotation, this._transform.scale instanceof Vector3 && this._node.scale.set(this._originalTransform.scale.x + t * (this._transform.scale.x - this._originalTransform.scale.x), this._originalTransform.scale.y + t * (this._transform.scale.y - this._originalTransform.scale.y), this._originalTransform.scale.z + t * (this._transform.scale.z - this._originalTransform.scale.z)), this._node.getDirectionalLightHelper && this._node.getDirectionalLightHelper().update(), this._elapseTimeTotal > this._duration ? (this._transform.position instanceof Vector3 && this._node.position.set(this._transform.position.x, this._transform.position.y, this._transform.position.z), this._transform.rotation, this._transform.scale instanceof Vector3 && this._node.scale.set(this._transform.scale.x, this._transform.scale.y, this._transform.scale.z), this._node.getDirectionalLightHelper && this._node.getDirectionalLightHelper().update(), void (this.needsRemove = !0)) : void 0 } } SmoothTransformController.type = "SmoothTransformController"; class SnowAnimationController extends AnimationController { constructor(e, t) { super("SnowAnimationController"), this.animationObject = e, this.isFollowCamera = t, this.render = e => { for (var t = 0; t < this.animationObject.children.length; t++) { var i = this.animationObject.children[t]; i.position.y -= 1, i.position.y < 0 && (i.position.y = 250) } if (this.isFollowCamera) { let e = _context.camera.position.x, t = _context.camera.position.y, i = _context.camera.position.z; this.animationObject.position.set(e, t, i) } }, this.reset = () => { } } } SnowAnimationController.type = "SnowAnimationController"; class TrailAnimationController extends AnimationController { constructor(e, t, i) { super("TrailAnimationController"), this.baseCarrierController = e, this.trailCon = t, this.name = i, this.render = e => { null == this.baseCarrierController && null == this.trailCon || (this.baseCarrierController.update(e, this.name), this.trailCon.update(e)) }, this.dispose = () => { this.baseCarrierController.dispose(), this.trailCon.dispose(), this.baseCarrierController = void 0, this.trailCon = void 0 } } } TrailAnimationController.type = "TrailAnimationController"; var require$$0 = getAugmentedNamespace(THREE), THREE_MeshLine$1 = createCommonjsModule((function (e, t) { (function () { var i = void 0 !== commonjsRequire, r = this.THREE || i && require$$0; if (!r) throw new Error("MeshLine requires three.js"); function n() { r.BufferGeometry.call(this), this.type = "MeshLine", this.positions = [], this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [], this.counters = [], this._points = [], this._geom = null, this.widthCallback = null, this.matrixWorld = new r.Matrix4, Object.defineProperties(this, { geometry: { enumerable: !0, get: function () { return this } }, geom: { enumerable: !0, get: function () { return this._geom }, set: function (e) { this.setGeometry(e, this.widthCallback) } }, points: { enumerable: !0, get: function () { return this._points }, set: function (e) { this.setPoints(e, this.widthCallback) } } }) } function a(e, t) { var i = new r.Matrix4, n = new r.Ray, a = new r.Sphere, o = new r.Vector3, s = this.geometry; if (a.copy(s.boundingSphere), a.applyMatrix4(this.matrixWorld), !1 !== e.ray.intersectSphere(a, o)) { i.getInverse(this.matrixWorld), n.copy(e.ray).applyMatrix4(i); var l = new r.Vector3, c = new r.Vector3, h = new r.Vector3, u = this instanceof r.LineSegments ? 2 : 1, d = s.index, p = s.attributes; if (null !== d) for (var f = d.array, m = p.position.array, g = p.width.array, y = 0, v = f.length - 1; y < v; y += u) { var _ = f[y], b = f[y + 1]; l.fromArray(m, 3 * _), c.fromArray(m, 3 * b); var x = null != g[Math.floor(y / 3)] ? g[Math.floor(y / 3)] : 1, w = e.params.Line.threshold + this.material.lineWidth * x / 2, S = w * w; if (!(n.distanceSqToSegment(l, c, o, h) > S)) { o.applyMatrix4(this.matrixWorld); var M = e.ray.origin.distanceTo(o); M < e.near || M > e.far || (t.push({ distance: M, point: h.clone().applyMatrix4(this.matrixWorld), index: y, face: null, faceIndex: null, object: this }), y = v) } } } } function o(e, t, i, r, n) { var a; if (e = e.subarray || e.slice ? e : e.buffer, i = i.subarray || i.slice ? i : i.buffer, e = t ? e.subarray ? e.subarray(t, n && t + n) : e.slice(t, n && t + n) : e, i.set) i.set(e, r); else for (a = 0; a < e.length; a++)i[a + r] = e[a]; return i } function s(e) { r.ShaderMaterial.call(this, { uniforms: Object.assign({}, r.UniformsLib.fog, { lineWidth: { value: 1 }, map: { value: null }, useMap: { value: 0 }, alphaMap: { value: null }, useAlphaMap: { value: 0 }, color: { value: new r.Color(16777215) }, opacity: { value: 1 }, resolution: { value: new r.Vector2(1, 1) }, sizeAttenuation: { value: 1 }, dashArray: { value: 0 }, dashOffset: { value: 0 }, dashRatio: { value: .5 }, useDash: { value: 0 }, visibility: { value: 1 }, alphaTest: { value: 0 }, repeat: { value: new r.Vector2(1, 1) } }), vertexShader: r.ShaderChunk.meshline_vert, fragmentShader: r.ShaderChunk.meshline_frag }), this.type = "MeshLineMaterial", Object.defineProperties(this, { lineWidth: { enumerable: !0, get: function () { return this.uniforms.lineWidth.value }, set: function (e) { this.uniforms.lineWidth.value = e } }, map: { enumerable: !0, get: function () { return this.uniforms.map.value }, set: function (e) { this.uniforms.map.value = e } }, useMap: { enumerable: !0, get: function () { return this.uniforms.useMap.value }, set: function (e) { this.uniforms.useMap.value = e } }, alphaMap: { enumerable: !0, get: function () { return this.uniforms.alphaMap.value }, set: function (e) { this.uniforms.alphaMap.value = e } }, useAlphaMap: { enumerable: !0, get: function () { return this.uniforms.useAlphaMap.value }, set: function (e) { this.uniforms.useAlphaMap.value = e } }, color: { enumerable: !0, get: function () { return this.uniforms.color.value }, set: function (e) { this.uniforms.color.value = e } }, opacity: { enumerable: !0, get: function () { return this.uniforms.opacity.value }, set: function (e) { this.uniforms.opacity.value = e } }, resolution: { enumerable: !0, get: function () { return this.uniforms.resolution.value }, set: function (e) { this.uniforms.resolution.value.copy(e) } }, sizeAttenuation: { enumerable: !0, get: function () { return this.uniforms.sizeAttenuation.value }, set: function (e) { this.uniforms.sizeAttenuation.value = e } }, dashArray: { enumerable: !0, get: function () { return this.uniforms.dashArray.value }, set: function (e) { this.uniforms.dashArray.value = e, this.useDash = 0 !== e ? 1 : 0 } }, dashOffset: { enumerable: !0, get: function () { return this.uniforms.dashOffset.value }, set: function (e) { this.uniforms.dashOffset.value = e } }, dashRatio: { enumerable: !0, get: function () { return this.uniforms.dashRatio.value }, set: function (e) { this.uniforms.dashRatio.value = e } }, useDash: { enumerable: !0, get: function () { return this.uniforms.useDash.value }, set: function (e) { this.uniforms.useDash.value = e } }, visibility: { enumerable: !0, get: function () { return this.uniforms.visibility.value }, set: function (e) { this.uniforms.visibility.value = e } }, alphaTest: { enumerable: !0, get: function () { return this.uniforms.alphaTest.value }, set: function (e) { this.uniforms.alphaTest.value = e } }, repeat: { enumerable: !0, get: function () { return this.uniforms.repeat.value }, set: function (e) { this.uniforms.repeat.value.copy(e) } } }), this.setValues(e) } n.prototype = Object.create(r.BufferGeometry.prototype), n.prototype.constructor = n, n.prototype.isMeshLine = !0, n.prototype.setMatrixWorld = function (e) { this.matrixWorld = e }, n.prototype.setGeometry = function (e, t) { this._geometry = e, e instanceof r.Geometry ? this.setPoints(e.vertices, t) : e instanceof r.BufferGeometry ? this.setPoints(e.getAttribute("position").array, t) : this.setPoints(e, t) }, n.prototype.setPoints = function (e, t) { if (e instanceof Float32Array || e instanceof Array) { if (this._points = e, this.widthCallback = t, this.positions = [], this.counters = [], e.length && e[0] instanceof r.Vector3) for (var i = 0; i < e.length; i++) { var n = e[i], a = i / e.length; this.positions.push(n.x, n.y, n.z), this.positions.push(n.x, n.y, n.z), this.counters.push(a), this.counters.push(a) } else for (i = 0; i < e.length; i += 3) { a = i / e.length; this.positions.push(e[i], e[i + 1], e[i + 2]), this.positions.push(e[i], e[i + 1], e[i + 2]), this.counters.push(a), this.counters.push(a) } this.process() } else console.error("ERROR: The BufferArray of points is not instancied correctly.") }, n.prototype.raycast = a, n.prototype.compareV3 = function (e, t) { var i = 6 * e, r = 6 * t; return this.positions[i] === this.positions[r] && this.positions[i + 1] === this.positions[r + 1] && this.positions[i + 2] === this.positions[r + 2] }, n.prototype.copyV3 = function (e) { var t = 6 * e; return [this.positions[t], this.positions[t + 1], this.positions[t + 2]] }, n.prototype.process = function () { var e, t, i = this.positions.length / 6; this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [], t = this.compareV3(0, i - 1) ? this.copyV3(i - 2) : this.copyV3(0), this.previous.push(t[0], t[1], t[2]), this.previous.push(t[0], t[1], t[2]); for (var n = 0; n < i; n++) { if (this.side.push(1), this.side.push(-1), e = this.widthCallback ? this.widthCallback(n / (i - 1)) : 1, this.width.push(e), this.width.push(e), this.uvs.push(n / (i - 1), 0), this.uvs.push(n / (i - 1), 1), n < i - 1) { t = this.copyV3(n), this.previous.push(t[0], t[1], t[2]), this.previous.push(t[0], t[1], t[2]); var a = 2 * n; this.indices_array.push(a, a + 1, a + 2), this.indices_array.push(a + 2, a + 1, a + 3) } n > 0 && (t = this.copyV3(n), this.next.push(t[0], t[1], t[2]), this.next.push(t[0], t[1], t[2])) } t = this.compareV3(i - 1, 0) ? this.copyV3(1) : this.copyV3(i - 1), this.next.push(t[0], t[1], t[2]), this.next.push(t[0], t[1], t[2]), this._attributes && this._attributes.position.count === this.positions.length ? (this._attributes.position.copyArray(new Float32Array(this.positions)), this._attributes.position.needsUpdate = !0, this._attributes.previous.copyArray(new Float32Array(this.previous)), this._attributes.previous.needsUpdate = !0, this._attributes.next.copyArray(new Float32Array(this.next)), this._attributes.next.needsUpdate = !0, this._attributes.side.copyArray(new Float32Array(this.side)), this._attributes.side.needsUpdate = !0, this._attributes.width.copyArray(new Float32Array(this.width)), this._attributes.width.needsUpdate = !0, this._attributes.uv.copyArray(new Float32Array(this.uvs)), this._attributes.uv.needsUpdate = !0, this._attributes.index.copyArray(new Uint16Array(this.indices_array)), this._attributes.index.needsUpdate = !0) : this._attributes = { position: new r.BufferAttribute(new Float32Array(this.positions), 3), previous: new r.BufferAttribute(new Float32Array(this.previous), 3), next: new r.BufferAttribute(new Float32Array(this.next), 3), side: new r.BufferAttribute(new Float32Array(this.side), 1), width: new r.BufferAttribute(new Float32Array(this.width), 1), uv: new r.BufferAttribute(new Float32Array(this.uvs), 2), index: new r.BufferAttribute(new Uint16Array(this.indices_array), 1), counters: new r.BufferAttribute(new Float32Array(this.counters), 1) }, this.setAttribute("position", this._attributes.position), this.setAttribute("previous", this._attributes.previous), this.setAttribute("next", this._attributes.next), this.setAttribute("side", this._attributes.side), this.setAttribute("width", this._attributes.width), this.setAttribute("uv", this._attributes.uv), this.setAttribute("counters", this._attributes.counters), this.setIndex(this._attributes.index), this.computeBoundingSphere(), this.computeBoundingBox() }, n.prototype.advance = function (e) { var t = this._attributes.position.array, i = this._attributes.previous.array, r = this._attributes.next.array, n = t.length; o(t, 0, i, 0, n), o(t, 6, t, 0, n - 6), t[n - 6] = e.x, t[n - 5] = e.y, t[n - 4] = e.z, t[n - 3] = e.x, t[n - 2] = e.y, t[n - 1] = e.z, o(t, 6, r, 0, n - 6), r[n - 6] = e.x, r[n - 5] = e.y, r[n - 4] = e.z, r[n - 3] = e.x, r[n - 2] = e.y, r[n - 1] = e.z, this._attributes.position.needsUpdate = !0, this._attributes.previous.needsUpdate = !0, this._attributes.next.needsUpdate = !0 }, r.ShaderChunk.meshline_vert = ["", r.ShaderChunk.logdepthbuf_pars_vertex, r.ShaderChunk.fog_pars_vertex, "", "attribute vec3 previous;", "attribute vec3 next;", "attribute float side;", "attribute float width;", "attribute float counters;", "", "uniform vec2 resolution;", "uniform float lineWidth;", "uniform vec3 color;", "uniform float opacity;", "uniform float sizeAttenuation;", "", "varying vec2 vUV;", "varying vec4 vColor;", "varying float vCounters;", "", "vec2 fix( vec4 i, float aspect ) {", "", "    vec2 res = i.xy / i.w;", "    res.x *= aspect;", "\t vCounters = counters;", "    return res;", "", "}", "", "void main() {", "", "    float aspect = resolution.x / resolution.y;", "", "    vColor = vec4( color, opacity );", "    vUV = uv;", "", "    mat4 m = projectionMatrix * modelViewMatrix;", "    vec4 finalPosition = m * vec4( position, 1.0 );", "    vec4 prevPos = m * vec4( previous, 1.0 );", "    vec4 nextPos = m * vec4( next, 1.0 );", "", "    vec2 currentP = fix( finalPosition, aspect );", "    vec2 prevP = fix( prevPos, aspect );", "    vec2 nextP = fix( nextPos, aspect );", "", "    float w = lineWidth * width;", "", "    vec2 dir;", "    if( nextP == currentP ) dir = normalize( currentP - prevP );", "    else if( prevP == currentP ) dir = normalize( nextP - currentP );", "    else {", "        vec2 dir1 = normalize( currentP - prevP );", "        vec2 dir2 = normalize( nextP - currentP );", "        dir = normalize( dir1 + dir2 );", "", "        vec2 perp = vec2( -dir1.y, dir1.x );", "        vec2 miter = vec2( -dir.y, dir.x );", "        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );", "", "    }", "", "    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;", "    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );", "    normal.xy *= .5 * w;", "    normal *= projectionMatrix;", "    if( sizeAttenuation == 0. ) {", "        normal.xy *= finalPosition.w;", "        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;", "    }", "", "    finalPosition.xy += normal.xy * side;", "", "    gl_Position = finalPosition;", "", r.ShaderChunk.logdepthbuf_vertex, r.ShaderChunk.fog_vertex && "    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", r.ShaderChunk.fog_vertex, "}"].join("\n"), r.ShaderChunk.meshline_frag = ["", r.ShaderChunk.fog_pars_fragment, r.ShaderChunk.logdepthbuf_pars_fragment, "", "uniform sampler2D map;", "uniform sampler2D alphaMap;", "uniform float useMap;", "uniform float useAlphaMap;", "uniform float useDash;", "uniform float dashArray;", "uniform float dashOffset;", "uniform float dashRatio;", "uniform float visibility;", "uniform float alphaTest;", "uniform vec2 repeat;", "", "varying vec2 vUV;", "varying vec4 vColor;", "varying float vCounters;", "", "void main() {", "", r.ShaderChunk.logdepthbuf_fragment, "", "    vec4 c = vColor;", "    if( useMap == 1. ) c *= texture2D( map, vUV * repeat );", "    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;", "    if( c.a < alphaTest ) discard;", "    if( useDash == 1. ){", "        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));", "    }", "    gl_FragColor = c;", "    gl_FragColor.a *= step(vCounters, visibility);", "", r.ShaderChunk.fog_fragment, "}"].join("\n"), s.prototype = Object.create(r.ShaderMaterial.prototype), s.prototype.constructor = s, s.prototype.isMeshLineMaterial = !0, s.prototype.copy = function (e) { return r.ShaderMaterial.prototype.copy.call(this, e), this.lineWidth = e.lineWidth, this.map = e.map, this.useMap = e.useMap, this.alphaMap = e.alphaMap, this.useAlphaMap = e.useAlphaMap, this.color.copy(e.color), this.opacity = e.opacity, this.resolution.copy(e.resolution), this.sizeAttenuation = e.sizeAttenuation, this.dashArray.copy(e.dashArray), this.dashOffset.copy(e.dashOffset), this.dashRatio.copy(e.dashRatio), this.useDash = e.useDash, this.visibility = e.visibility, this.alphaTest = e.alphaTest, this.repeat.copy(e.repeat), this }, e.exports && (t = e.exports = { MeshLine: n, MeshLineMaterial: s, MeshLineRaycast: a }), t.MeshLine = n, t.MeshLineMaterial = s, t.MeshLineRaycast = a }).call(commonjsGlobal) })), TrailController = function (e) { var t = [], i = e; this.g = new THREE_MeshLine$1.MeshLine, this.update = function (e) { for (var r = i.userData.trailDuration, n = t.length - 1; n >= 0; n--)t[n].currentTime + e > r ? t.splice(n, 1) : t[n].currentTime += e; var a = i.position.clone(); if (t.length <= 0 ? t.push({ pos: a, currentTime: 0 }) : a.x == t[t.length - 1].pos.x && a.y == t[t.length - 1].pos.y && a.z == t[t.length - 1].pos.z || t.push({ pos: a, currentTime: 0 }), t.length > 2) { for (var o = i.userData.mesh, s = [], l = 0; l < t.length; l++)s.push(t[l].pos.x), s.push(t[l].pos.y), s.push(t[l].pos.z); this.g.setPoints(s), o.geometry = this.g.geometry } }, this.dispose = function () { } }; class UVMeshLineAnimationController extends AnimationController { constructor(e, t, i, r, n) { super("UVMeshLineAnimationController"), this.material = e, this.enableU = t, this.enableV = i, this.uSpeed = r, this.vSpeed = n, this.reset = () => { this.material.map && (this.material.offset.x = 0, this.material.offset.y = 0) } } render(e) { null != this.material && (this.enableU && (this.material.offset.x += this.uSpeed * e), this.enableV && (this.material.offset.y += this.vSpeed * e)) } } UVMeshLineAnimationController.type = "UVMeshLineAnimationController"; class WaterAnimationController extends AnimationController { constructor(e, t = 1) { super("WaterAnimationController"), this._material = e, this._speed = t, this.dispose = () => { util$1.disposeThreeObject(this._material) } } get speed() { return this._speed } set speed(e) { this._speed = e } render(e) { null != this._material && (this._material.uniforms.time.value += e * this._speed) } } WaterAnimationController.type = "WaterAnimationController"; class CameraFollowingController extends AnimationController { constructor(e) { super("CameraFollowingController"), this.name = e, this.isPaused = !1, this.needIgnoreOne = !0, _context.orbitControls.addEventListener("pan", this.pause), this.pause = function () { this.isPaused = !0 }.bind(this), this.continue = function () { this.isPaused = !1 }.bind(this), this.set = function (e, t, i, r) { this.object = e, this.distance = t, this.pitch = i, this.heading = r; const n = this.object.position.clone(); _context.instance.setCamera({ target: { x: n.x, y: n.y, z: n.z }, azimuthAngle: this.heading, inclinationAngle: this.pitch, distance: this.distance }), this.needIgnoreOne = !0 }.bind(this) } render() { if (!0 === this.isPaused) return; if (void 0 === this.object) return; if (!0 === this.needIgnoreOne) return void (this.needIgnoreOne = !1); const e = this.object.position.clone(); _context.instance.setCamera({ target: { x: e.x, y: e.y, z: e.z } }) } } CameraFollowingController.type = "CameraFollowingController"; class Articulation { constructor({ type: e = "numeric", name: t = "", values: i = [], defaultValue: r } = {}) { let n = e, a = t, o = i, s = r, l = !1; this.properties = [], this.value = r, this.remark, this.isEnable = !0, this.openThreshold = !1; let c = [], h = []; function u(e, t, i, r) { if ("string" == typeof e) if ("string" == typeof t && "" !== t) if (i instanceof Array && !(i.length < 1)) { switch (e) { case ArticulationTypes.numeric: if (2 !== i.length) return void logger.warn(`关节参数错误（values）：${i}，numeric 类型的关节 values 参数应为 2 个数字组成的数组。`); if ("number" != typeof i[0] || "number" != typeof i[1]) return void logger.warn(`关节参数错误（values）：${i}，numeric 类型的关节 values 参数应为 2 个数字组成的数组。`); if (i[0] > i[1]) return void logger.warn(`关节参数错误（values）：${i}，numeric 类型的关节 values[0] 应小于等于 values[1]。`); if ("number" != typeof r) return void logger.warn(`关节参数错误（values）：${i}，numeric 类型的关节 defaultValue 值应为数值。`); if (r < i[0] || r > i[1]) return void logger.warn(`关节参数错误（defaultValue）：${r}，numeric 类型的关节 defaultValue 值应在 values[0] 和 values[1] 之间。`); break; case ArticulationTypes.enum: let t = !1; for (let e of i) { if ("string" != typeof e && "number" != typeof e) return void logger.warn(`关节参数错误（values）：${i}，enum 类型的关节 values 参数应为字符串或数值组成的数组。`); r === e && (t = !0) } if (!t) return void logger.warn(`关节参数错误（defaultValue）：${r}，enum 类型的关节 defaultValue 应该为 values 参数中定义过的枚举值之一。`); break; case ArticulationTypes.boolean: if (i = [!1, !0], "boolean" != typeof r) return void logger.warn(`关节参数错误（defaultValue）：${r}，boolean 类型的关节 defaultValue 应该为 true 或 false 之一。`); break; case ArticulationTypes.text: break; default: return void logger.warn(`关节参数错误（type）：${e}，不支持的类型`) }l = !0 } else logger.warn(`关节参数错误（values）：${i}。`); else logger.warn(`关节参数错误（name）：${t}。`); else logger.warn(`关节参数错误（type）：${e}。`) } this._recordDefaultVal = (e, t, i, r = "nodes") => { h.find((i => i.articulationName === e && i.articulationProperty === t)) || h.push({ articulationName: e, articulationProperty: t, articulationVal: i, articulationType: r }) }, this._delDefaultVal = (e, t) => { let i = h.findIndex((i => i.articulationName === e && i.articulationProperty === t)); i > -1 && h.splice(i, 1) }, u(e, t, i, r), this.update = ({ type: e, name: t, values: i, defaultValue: r } = {}) => { "string" != typeof e || e === n ? u(e, t = t || a, i = i || o, r = null == r ? s : r) : logger.warn(`关节参数错误（type）：${e}，不支持修改关节的类型。`) }, this.addProperty = ({ nodes: e, modifiers: t, materials: i, particles: r }) => { let n = new ArticulationProperty({ nodes: e, modifiers: t, materials: i, particles: r }); this.properties.push(n) }, this.removePropertyByIndex = e => { this.properties.splice(e, 1) }, this.getSettings = () => ({ openThreshold: this.openThreshold, type: n, _type: n, name: a, _name: a, values: o ? o.map((e => e instanceof Object ? JSON.parse(JSON.stringify(e)) : e)) : void 0, _values: o ? o.map((e => e instanceof Object ? JSON.parse(JSON.stringify(e)) : e)) : void 0, defaultValue: s || 0 === s ? JSON.parse(JSON.stringify(s)) : void 0, _defaultValue: s || 0 === s ? JSON.parse(JSON.stringify(s)) : void 0, isValid: l, _isValid: l, value: this.value instanceof Object ? JSON.parse(JSON.stringify(this.value)) : this.value, isEnable: this.isEnable, textArticulations: c ? JSON.parse(JSON.stringify(c)) : void 0, _textArticulations: c ? JSON.parse(JSON.stringify(c)) : void 0, _properties: this.properties ? this.properties.map((e => ({ nodes: e.nodes.map((e => e instanceof Object ? JSON.parse(JSON.stringify(e)) : e)), materials: e.materials.map((e => e instanceof Object ? JSON.parse(JSON.stringify(e)) : e)), particles: e.particles.map((e => e instanceof Object ? JSON.parse(JSON.stringify(e)) : e)), modifiers: e.modifiers.map((e => e instanceof Object ? JSON.parse(JSON.stringify(e)) : e)) }))) : void 0, properties: this.properties ? this.properties.map((e => ({ nodes: e.nodes.map((e => e instanceof Object ? JSON.parse(JSON.stringify(e)) : e)), materials: e.materials.map((e => e instanceof Object ? JSON.parse(JSON.stringify(e)) : e)), particles: e.particles.map((e => e instanceof Object ? JSON.parse(JSON.stringify(e)) : e)), modifiers: e.modifiers.map((e => e instanceof Object ? JSON.parse(JSON.stringify(e)) : e)) }))) : void 0, remark: this.remark }), this.getName = () => a, this.setName = e => { e && "" !== e && (a = e) }, this.getType = () => n, this.setType = e => { n = e }, this.getModifierTypes = () => ({ translationX: "translateX", translationY: "translateY", translationZ: "translateZ", rotationX: "rotateX", rotationY: "rotateY", rotationZ: "rotateZ", scaleX: "scaleX", scaleY: "scaleY", scaleZ: "scaleZ", opacity: "opacity", colorOverlay: "colorOverlay", colorReplace: "colorReplace", stroke: "stroke" }), this._interpolateAbsoluteNumeric = (t, i) => { if (o[1] === o[0] || t[1] === t[0]) return Number(t[0]); switch (e) { case ArticulationTypes.numeric: let e = Number(t[0]), n = Number(t[1]); if (this.openThreshold) return Number(i - o[0]) / Number(o[1] - o[0]) * Number(n - e) + e; { let r = Math.max(...o), a = Math.min(...o); return i >= r ? Number(t[o.indexOf(r)]) : i <= a ? Number(t[o.indexOf(a)]) : Number(i - o[0]) / Number(o[1] - o[0]) * Number(n - e) + e } case ArticulationTypes.enum: case ArticulationTypes.boolean: let a = o.findIndex((e => e === i)); return a < 0 ? s : Number(t[a]); default: return Number(r) } }, this._interpolateRelativeNumeric = (t, i, r) => { if (t == ArticulationModifierTypes.rotationX || t == ArticulationModifierTypes.rotationY || t == ArticulationModifierTypes.rotationZ) { if (o[1] === o[0] || i[1] === i[0]) return Number(i[0]); switch (e) { case ArticulationTypes.numeric: let e = Number(i[0]), t = Number(i[1]); if (this.openThreshold) return Number(r - o[0]) / Number(o[1] - o[0]) * Number(t - e) + e; { let n = Math.max(...o), a = Math.min(...o); return r >= n ? Number(i[o.indexOf(n)]) : r <= a ? Number(i[o.indexOf(a)]) : Number(r - o[0]) / Number(o[1] - o[0]) * Number(t - e) + e } case ArticulationTypes.enum: case ArticulationTypes.boolean: let n = o.findIndex((e => e === r)); return Number(n < 0 ? s : i[n]) } } else if (t == ArticulationModifierTypes.opacity) { if (o[1] === o[0] || i[1] === i[0]) return .01 * Number(i[0]); let t = Number(i[0]), a = Number(i[1]), l = 0; switch (e) { case ArticulationTypes.numeric: l = Number(r - o[0]) / Number(o[1] - o[0]) * Number(a - t) + t, l *= .01; break; case ArticulationTypes.enum: a = Number(i[i.length - 1]), l = (n = o.findIndex((e => e === r))) < 0 ? .01 * Number(s) : .01 * Number(i[n]); break; case ArticulationTypes.boolean: var n; l = (n = o.findIndex((e => e === r))) < 0 ? .01 * Number(s) : .01 * Number(i[n]) }return l <= 0 ? 0 : l >= 1 ? 1 : l } }, this._interpolateColor = (t, r) => { if (i[1] === i[0]) return new RGBAColor(t[0]); switch (e) { case ArticulationTypes.numeric: let e = Number(r - i[0]) / Number(i[1] - i[0]), n = new RGBAColor(t[0]), a = new RGBAColor(t[1]); return n.lerp(a, e); case ArticulationTypes.enum: case ArticulationTypes.boolean: let s = o.findIndex((e => e === r)); return s < 0 ? new RGBAColor(255, 255, 255, 0) : new RGBAColor(t[s]) } }, this._checkColor = e => (e.r < 0 && (e.r = 0), e.r > 1 && (e.r = 1), e.g < 0 && (e.g = 0), e.g > 1 && (e.g = 1), e.b < 0 && (e.b = 0), e.b > 1 && (e.b = 1), e), this._checkOpacity = e => (e < 0 && (e = 0), e > 1 && (e = 1), e), this.set = (e, t) => { if (!this.isValid() || "function" != typeof this.getModelNode || null == _context || null == _context.animationStore) return void logger.warn("正在设置的关节无效。"); this.value = s = e; let i = this.getModelNode(); if (n != ArticulationTypes.text) for (let r of this.properties) { let n = []; for (let e of r.nodes) i.getObjectByName(e) && n.push(i.getObjectByName(e)); if (n.length) { _context.effectStore && _context.effectStore.initOutlinePass(); for (let a of r.modifiers) for (let r of n) { let n, o = _context && _context.animationStore && _context.animationStore.findAnimation && _context.animationStore.findAnimation(i.name + r.name + a.key, ArticulationAnimationController.type); switch (o && _context.animationStore.remove(o), a.key) { case ArticulationModifierTypes.rotationX: this._recordDefaultVal(r.name, a.key, r.rotation.x), h.find((e => e.articulationName === r.name && e.articulationProperty === a.key)).articulationVal, t && t > 0 ? n = new ArticulationAnimationController(i.name, r, t, a.key, r.rotation.x / Math.PI * 180, this._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, a.values, e)) : r.rotation.set(this._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, a.values, e) / 180 * Math.PI, r.rotation.y, r.rotation.z); break; case ArticulationModifierTypes.rotationY: this._recordDefaultVal(r.name, a.key, r.rotation.y), h.find((e => e.articulationName === r.name && e.articulationProperty === a.key)).articulationVal, t && t > 0 ? n = new ArticulationAnimationController(i.name, r, t, a.key, r.rotation.y / Math.PI * 180, this._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, a.values, e)) : r.rotation.set(r.rotation.x, this._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, a.values, e) / 180 * Math.PI, r.rotation.z); break; case ArticulationModifierTypes.rotationZ: this._recordDefaultVal(r.name, a.key, r.rotation.z), h.find((e => e.articulationName === r.name && e.articulationProperty === a.key)).articulationVal, t && t > 0 ? n = new ArticulationAnimationController(i.name, r, t, a.key, r.rotation.z / Math.PI * 180, this._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, a.values, e)) : r.rotation.set(r.rotation.x, r.rotation.y, this._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, a.values, e) / 180 * Math.PI); break; case ArticulationModifierTypes.translationX: this._recordDefaultVal(r.name, a.key, r.position.x), h.find((e => e.articulationName === r.name && e.articulationProperty === a.key)).articulationVal, t && t > 0 ? n = new ArticulationAnimationController(i.name, r, t, a.key, r.position.x, this._interpolateAbsoluteNumeric(a.values, e)) : r.position.set(this._interpolateAbsoluteNumeric(a.values, e), r.position.y, r.position.z); break; case ArticulationModifierTypes.translationY: this._recordDefaultVal(r.name, a.key, r.position.y), h.find((e => e.articulationName === r.name && e.articulationProperty === a.key)).articulationVal, t && t > 0 ? n = new ArticulationAnimationController(i.name, r, t, a.key, r.position.y, this._interpolateAbsoluteNumeric(a.values, e)) : r.position.set(r.position.x, this._interpolateAbsoluteNumeric(a.values, e), r.position.z); break; case ArticulationModifierTypes.translationZ: this._recordDefaultVal(r.name, a.key, r.position.z), h.find((e => e.articulationName === r.name && e.articulationProperty === a.key)).articulationVal, t && t > 0 ? n = new ArticulationAnimationController(i.name, r, t, a.key, r.position.z, this._interpolateAbsoluteNumeric(a.values, e)) : r.position.set(r.position.x, r.position.y, this._interpolateAbsoluteNumeric(a.values, e)); break; case ArticulationModifierTypes.scaleX: this._recordDefaultVal(r.name, a.key, r.scale.x), h.find((e => e.articulationName === r.name && e.articulationProperty === a.key)).articulationVal, t && t > 0 ? n = new ArticulationAnimationController(i.name, r, t, a.key, r.scale.x, this._interpolateAbsoluteNumeric(a.values, e)) : r.scale.set(this._interpolateAbsoluteNumeric(a.values, e), r.scale.y, r.scale.z); break; case ArticulationModifierTypes.scaleY: this._recordDefaultVal(r.name, a.key, r.scale.y), h.find((e => e.articulationName === r.name && e.articulationProperty === a.key)).articulationVal, t && t > 0 ? n = new ArticulationAnimationController(i.name, r, t, a.key, r.scale.y, this._interpolateAbsoluteNumeric(a.values, e)) : r.scale.set(r.scale.x, this._interpolateAbsoluteNumeric(a.values, e), r.scale.z); break; case ArticulationModifierTypes.scaleZ: this._recordDefaultVal(r.name, a.key, r.scale.z), h.find((e => e.articulationName === r.name && e.articulationProperty === a.key)).articulationVal, t && t > 0 ? n = new ArticulationAnimationController(i.name, r, t, a.key, r.scale.z, this._interpolateAbsoluteNumeric(a.values, e)) : r.scale.set(r.scale.x, r.scale.y, this._interpolateAbsoluteNumeric(a.values, e)); break; case ArticulationModifierTypes.opacity: t && t > 0 ? n = new ArticulationAnimationController(i.name, r, t, a.key, a.values[0], this._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, a.values, e), this._checkOpacity) : (r.traverse((e => { if ("Mesh" == e.type) if (e.material instanceof Array) e.material.forEach((t => { let i = t.opacity, r = h.find((e => e.articulationName.indexOf(t.name) > -1 && e.articulationProperty === ArticulationModifierTypes.opacity)); r && (i = r.articulationVal); let n = h.find((e => e.articulationName.indexOf(t.name) > -1 && e.articulationProperty === ArticulationModifierTypes.colorOverlay)); n && (i = n.articulationVal.opacity); let o = h.find((e => e.articulationName.indexOf(t.name) > -1 && e.articulationProperty === ArticulationModifierTypes.colorReplace)); o && (i = o.articulationVal.opacity), this._recordDefaultVal(e.name + ":" + t.name, a.key, i) })); else { let t = e.material.opacity, i = h.find((t => t.articulationName.indexOf(e.name) > -1 && t.articulationProperty === ArticulationModifierTypes.opacity)); i && (t = i.articulationVal); let n = h.find((t => t.articulationName.indexOf(e.name) > -1 && t.articulationProperty === ArticulationModifierTypes.colorOverlay)); n && (t = n.articulationVal.opacity); let o = h.find((t => t.articulationName.indexOf(e.name) > -1 && t.articulationProperty === ArticulationModifierTypes.colorReplace)); o && (t = o.articulationVal.opacity), this._recordDefaultVal(r.name + ":" + e.name, a.key, t) } })), r.traverse((t => { "Mesh" == t.type && (t.material instanceof Array ? t.material.forEach((t => { t.transparent = !0, t.opacity = this._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, a.values, e) })) : (t.material.transparent = !0, t.material.opacity = this._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, a.values, e))) }))); break; case ArticulationModifierTypes.colorOverlay: let o = this._interpolateColor(a.values, e); t && t > 0 ? n = new ArticulationAnimationController(i.name, r, t, a.key, new RGBAColor(a.values[0]), o, this._checkColor, this.getDefaultVal) : (r.traverse((e => { if ("Mesh" == e.type) if (e.material instanceof Array) e.material.forEach((t => { let i = t.opacity, r = new Color$1(t.color), n = h.find((e => e.articulationName.indexOf(t.name) > -1 && e.articulationProperty === ArticulationModifierTypes.colorOverlay)); n && (r = new Color$1(n.articulationVal.color), i = n.articulationVal.opacity); let o = h.find((e => e.articulationName.indexOf(t.name) > -1 && e.articulationProperty === ArticulationModifierTypes.opacity)); o && (i = o); let s = h.find((e => e.articulationName.indexOf(t.name) > -1 && e.articulationProperty === ArticulationModifierTypes.colorReplace)); s && (r = new Color$1(s.articulationVal.color), i = s.articulationVal.opacity), this._recordDefaultVal(e.name + ":" + t.name, a.key, { color: r, opacity: i }) })); else { let t = e.material.opacity, i = new Color$1(e.material.color), n = h.find((t => t.articulationName.indexOf(e.name) > -1 && t.articulationProperty === ArticulationModifierTypes.colorOverlay)); n && (i = new Color$1(n.articulationVal.color), t = n.articulationVal.opacity); let o = h.find((t => t.articulationName.indexOf(e.name) > -1 && t.articulationProperty === ArticulationModifierTypes.opacity)); o && (t = o); let s = h.find((t => t.articulationName.indexOf(e.name) > -1 && t.articulationProperty === ArticulationModifierTypes.colorReplace)); s && (i = new Color$1(s.articulationVal.color), t = s.articulationVal.opacity), this._recordDefaultVal(r.name + ":" + e.name, a.key, { color: i, opacity: t }) } })), r.traverse((e => { if ("Mesh" == e.type) if (e.material instanceof Array) e.material.forEach((e => { let t = h.find((t => t.articulationName.indexOf(e.name) > -1 && t.articulationProperty === ArticulationModifierTypes.colorReplace)); t || (e.transparent = !0, e.color = o.color, e.opacity = o.alpha, t = h.find((t => t.articulationName.indexOf(e.name) > -1 && t.articulationProperty === ArticulationModifierTypes.colorOverlay)), e.opacity <= 0 && (e.opacity = 1, e.color = t && new Color$1(t.articulationVal.color))) })); else { let t = h.find((t => t.articulationName.indexOf(e.name) > -1 && t.articulationProperty === ArticulationModifierTypes.colorReplace)); t || (e.material.transparent = !0, e.material.color = o.color, e.material.opacity = o.alpha, t = h.find((t => t.articulationName.indexOf(e.name) > -1 && t.articulationProperty === ArticulationModifierTypes.colorOverlay)), e.material.opacity <= 0 && (e.material.opacity = 1, e.material.color = t && new Color$1(t.articulationVal.color))) } }))); break; case ArticulationModifierTypes.colorReplace: let s = this._interpolateColor(a.values, e); if (t && t > 0) n = new ArticulationAnimationController(i.name, r, t, a.key, new RGBAColor(a.values[0]), s, this._checkColor, this.getDefaultVal); else { let e = []; r.traverse((t => { if ("Mesh" == t.type) if (t.material instanceof Array) t.material.forEach((i => { let r = i.opacity, n = new Color$1(i.color), o = h.find((e => e.articulationName.indexOf(i.name) > -1 && e.articulationProperty === ArticulationModifierTypes.colorReplace)); o && (r = o.articulationVal.opacity, n = new Color$1(o.articulationVal.color)); let s = h.find((e => e.articulationName.indexOf(i.name) > -1 && e.articulationProperty === ArticulationModifierTypes.opacity)); s && (r = s); let l = h.find((e => e.articulationName.indexOf(i.name) > -1 && e.articulationProperty === ArticulationModifierTypes.colorOverlay)); l && (r = l.articulationVal.opacity, n = new Color$1(l.articulationVal.color)), this._recordDefaultVal(t.name + ":" + i.name, a.key, { map: i.map, color: n, opacity: r }), e.push(i) })); else { let i = t.material.opacity, n = new Color$1(t.material.color), o = h.find((e => e.articulationName.indexOf(t.name) > -1 && e.articulationProperty === ArticulationModifierTypes.colorReplace)); o && (i = o.articulationVal.opacity, n = new Color$1(o.articulationVal.color)); let s = h.find((e => e.articulationName.indexOf(t.name) > -1 && e.articulationProperty === ArticulationModifierTypes.opacity)); s && (i = s); let l = h.find((e => e.articulationName.indexOf(t.name) > -1 && e.articulationProperty === ArticulationModifierTypes.colorOverlay)); l && (i = l.articulationVal.opacity, n = new Color$1(l.articulationVal.color)), this._recordDefaultVal(r.name + ":" + t.name, a.key, { map: t.material.map, color: n, opacity: i }), e.push(t.material) } })), e.forEach((e => { e.map = null, e.transparent = !0, e.needsUpdate = !0 })), r.traverse((e => { if ("Mesh" == e.type) if (e.material instanceof Array) e.material.forEach((e => { if (s.alpha > 0) e.transparent = !0, e.map = null, e.color = s.color, e.opacity = s.alpha; else { let t = h.find((t => t.articulationName.indexOf(e.name) > -1 && t.articulationProperty === ArticulationModifierTypes.colorReplace)); t && (e.opacity = 1, e.map = t.articulationVal.map, e.color = new Color$1(t.articulationVal.color), e.needsUpdate = !0) } })); else if (s.alpha > 0) e.material.transparent = !0, e.material.map = null, e.material.color = s.color, e.material.opacity = s.alpha; else { let t = h.find((t => t.articulationName.indexOf(e.name) > -1 && t.articulationProperty === ArticulationModifierTypes.colorReplace)); t && (e.material.opacity = 1, e.material.map = t.articulationVal.map, e.material.color = new Color$1(t.articulationVal.color), e.material.needsUpdate = !0) } })) } break; case ArticulationModifierTypes.stroke: if (t && t > 0) { let o, s = h.find((e => e.articulationName === r.name && e.articulationProperty === a.key)); s ? (o = s.articulationVal, this._delDefaultVal(r.name, a.key), this._recordDefaultVal(r.name, a.key, this._interpolateColor(a.values, e))) : (this._recordDefaultVal(r.name, a.key, this._interpolateColor(a.values, e)), o = new RGBAColor(a.values[0])), n = new ArticulationAnimationController(i.name, r, t, a.key, o, this._interpolateColor(a.values, e), this._checkColor) } else _context.effectStore && _context.effectStore.initOutlinePass(r, !0, this._interpolateColor(a.values, e)) }n && _context.animationStore.add(n) } } else logger.warn("正在设置的关节无效，无法找到指定的节点。"); let a = []; for (let e of r.materials) { let t = this.getModelItem().findMaterial(e); t && a.push(t) } if (a.length) for (let n of r.modifiers) for (let r of a) { let a, o = _context && _context.animationStore && _context.animationStore.findAnimation && _context.animationStore.findAnimation(i.name + r.name + n.key, ArticulationAnimationController.type); switch (o && _context.animationStore.remove(o), n.key) { case ArticulationModifierTypes.USpeed: if (t && t > 0) a = new ArticulationAnimationController(i.name, r, t, n.key, r.translationSpeedU, this._interpolateAbsoluteNumeric(n.values, e), (() => { }), (() => { }), "materials"); else { let t = _context.animationStore.findMaterialAnimation(r._material(), UVAnimationController.type); if (t) t.enableU = 0 !== this._interpolateAbsoluteNumeric(n.values, e), t.uSpeed = this._interpolateAbsoluteNumeric(n.values, e); else { let i = new UVAnimationController(r._material(), 0 !== this._interpolateAbsoluteNumeric(n.values, e), !1, this._interpolateAbsoluteNumeric(n.values, e), 0); t = i, _context.animationStore.add(i) } 0 === t.uSpeed && 0 === t.vSpeed && _context.animationStore.remove(t) } break; case ArticulationModifierTypes.VSpeed: if (t && t > 0) a = new ArticulationAnimationController(i.name, r, t, n.key, r.translationSpeedV, this._interpolateAbsoluteNumeric(n.values, e), (() => { }), (() => { }), "materials"); else { let t = _context.animationStore.findMaterialAnimation(r._material(), UVAnimationController.type); if (t) t.enableV = 0 !== this._interpolateAbsoluteNumeric(n.values, e), t.vSpeed = this._interpolateAbsoluteNumeric(n.values, e); else { let i = new UVAnimationController(r._material(), !1, 0 !== this._interpolateAbsoluteNumeric(n.values, e), 0, this._interpolateAbsoluteNumeric(n.values, e)); t = i, _context.animationStore.add(i) } 0 === t.uSpeed && 0 === t.vSpeed && _context.animationStore.remove(t) } }a && _context.animationStore.add(a) } let o = []; for (let e of r.particles) { let t = this.getModelItem().particleStoreArray.find((t => t.name === e)); t && o.push(t) } if (o.length) for (let n of r.modifiers) for (let r of o) { let a, o = _context && _context.animationStore && _context.animationStore.findAnimation && _context.animationStore.findAnimation(i.name + r.particleModelGroup.name + n.key, ArticulationAnimationController.type); switch (o && _context.animationStore.remove(o), n.key) { case ArticulationModifierTypes.rotationX: this._recordDefaultVal(r.particleModelGroup.name, n.key, r.particleModelGroup.rotation.x, "particles"), h.find((e => e.articulationName === r.particleModelGroup.name && e.articulationProperty === n.key)).articulationVal, t && t > 0 ? a = new ArticulationAnimationController(i.name, r.particleModelGroup, t, n.key, r.particleModelGroup.rotation.x / Math.PI * 180, this._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, n.values, e)) : r.particleModelGroup.rotation.set(this._interpolateRelativeNumeric(ArticulationModifierTypes.rotationX, n.values, e) / 180 * Math.PI, r.particleModelGroup.rotation.y, r.particleModelGroup.rotation.z); break; case ArticulationModifierTypes.rotationY: this._recordDefaultVal(r.particleModelGroup.name, n.key, r.particleModelGroup.rotation.y, "particles"), h.find((e => e.articulationName === r.particleModelGroup.name && e.articulationProperty === n.key)).articulationVal, t && t > 0 ? a = new ArticulationAnimationController(i.name, r.particleModelGroup, t, n.key, node.rotation.y / Math.PI * 180, this._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, n.values, e)) : r.particleModelGroup.rotation.set(r.particleModelGroup.rotation.x, this._interpolateRelativeNumeric(ArticulationModifierTypes.rotationY, n.values, e) / 180 * Math.PI, r.particleModelGroup.rotation.z); break; case ArticulationModifierTypes.rotationZ: this._recordDefaultVal(r.particleModelGroup.name, n.key, r.particleModelGroup.rotation.z, "particles"), h.find((e => e.articulationName === r.particleModelGroup.name && e.articulationProperty === n.key)).articulationVal, t && t > 0 ? a = new ArticulationAnimationController(i.name, r.particleModelGroup, t, n.key, r.particleModelGroup.rotation.z / Math.PI * 180, this._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, n.values, e)) : r.particleModelGroup.rotation.set(r.particleModelGroup.rotation.x, r.particleModelGroup.rotation.y, this._interpolateRelativeNumeric(ArticulationModifierTypes.rotationZ, n.values, e) / 180 * Math.PI); break; case ArticulationModifierTypes.translationX: this._recordDefaultVal(r.particleModelGroup.name, n.key, r.particleModelGroup.position.x, "particles"), h.find((e => e.articulationName === r.particleModelGroup.name && e.articulationProperty === n.key)).articulationVal, t && t > 0 ? a = new ArticulationAnimationController(i.name, r.particleModelGroup, t, n.key, r.particleModelGroup.position.x, this._interpolateAbsoluteNumeric(n.values, e)) : r.particleModelGroup.position.set(this._interpolateAbsoluteNumeric(n.values, e), r.particleModelGroup.position.y, r.particleModelGroup.position.z); break; case ArticulationModifierTypes.translationY: this._recordDefaultVal(r.particleModelGroup.name, n.key, r.particleModelGroup.position.y, "particles"), h.find((e => e.articulationName === r.particleModelGroup.name && e.articulationProperty === n.key)).articulationVal, t && t > 0 ? a = new ArticulationAnimationController(i.name, r.particleModelGroup, t, n.key, r.particleModelGroup.position.y, this._interpolateAbsoluteNumeric(n.values, e)) : r.particleModelGroup.position.set(r.particleModelGroup.position.x, this._interpolateAbsoluteNumeric(n.values, e), r.particleModelGroup.position.z); break; case ArticulationModifierTypes.translationZ: this._recordDefaultVal(r.particleModelGroup.name, n.key, r.particleModelGroup.position.z, "particles"), h.find((e => e.articulationName === r.particleModelGroup.name && e.articulationProperty === n.key)).articulationVal, t && t > 0 ? a = new ArticulationAnimationController(i.name, r.particleModelGroup, t, n.key, r.particleModelGroup.position.z, this._interpolateAbsoluteNumeric(n.values, e)) : r.particleModelGroup.position.set(r.particleModelGroup.position.x, r.particleModelGroup.position.y, this._interpolateAbsoluteNumeric(n.values, e)); break; case ArticulationModifierTypes.scaleX: this._recordDefaultVal(r.particleModelGroup.name, n.key, r.particleModelGroup.scale.x, "particles"), h.find((e => e.articulationName === r.particleModelGroup.name && e.articulationProperty === n.key)).articulationVal, t && t > 0 ? a = new ArticulationAnimationController(i.name, r.particleModelGroup, t, n.key, r.particleModelGroup.scale.x, this._interpolateAbsoluteNumeric(n.values, e)) : r.particleModelGroup.scale.set(this._interpolateAbsoluteNumeric(n.values, e), r.particleModelGroup.scale.y, r.particleModelGroup.scale.z); break; case ArticulationModifierTypes.scaleY: this._recordDefaultVal(r.particleModelGroup.name, n.key, r.particleModelGroup.scale.y, "particles"), h.find((e => e.articulationName === r.particleModelGroup.name && e.articulationProperty === n.key)).articulationVal, t && t > 0 ? a = new ArticulationAnimationController(i.name, r.particleModelGroup, t, n.key, r.particleModelGroup.scale.y, this._interpolateAbsoluteNumeric(n.values, e)) : r.particleModelGroup.scale.set(r.particleModelGroup.scale.x, this._interpolateAbsoluteNumeric(n.values, e), r.particleModelGroup.scale.z); break; case ArticulationModifierTypes.scaleZ: this._recordDefaultVal(r.particleModelGroup.name, n.key, r.particleModelGroup.scale.z, "particles"), h.find((e => e.articulationName === r.particleModelGroup.name && e.articulationProperty === n.key)).articulationVal, t && t > 0 ? a = new ArticulationAnimationController(i.name, r.particleModelGroup, t, n.key, r.particleModelGroup.scale.z, this._interpolateAbsoluteNumeric(n.values, e)) : r.particleModelGroup.scale.set(r.particleModelGroup.scale.x, r.particleModelGroup.scale.y, this._interpolateAbsoluteNumeric(n.values, e)); break; case ArticulationModifierTypes.opacity: t && t > 0 ? a = new ArticulationAnimationController(i.name, r, t, n.key, n.values[0], this._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, n.values, e), this._checkOpacity, (() => { }), "particles") : r.particleGroup.forEach((t => { this._recordDefaultVal(r.particleModelGroup.name + ":" + t.id, n.key, t.opacity, "particles"), t.opacity = this._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, n.values, e) })); break; case ArticulationModifierTypes.quantityFactor: t && t > 0 ? a = new ArticulationAnimationController(i.name, r, t, n.key, n.values[0], this._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, n.values, e), (() => { }), (() => { }), "particles") : r.particleGroup.forEach((t => { this._recordDefaultVal(r.particleModelGroup.name + ":" + t.id, n.key, t.density, "particles"), t.density = this._interpolateRelativeNumeric(ArticulationModifierTypes.opacity, n.values, e) })) }a && _context.animationStore.add(a) } } }, this.nodesReset = (e, t) => { if (h.length <= 0) return; let i = this.getModelNode(); if (n != ArticulationTypes.text) for (let r of e) { let e = i.getObjectByName(r); e && t && t.forEach((t => { let i; switch (t) { case ArticulationModifierTypes.rotationX: i = h.find((i => i.articulationName === e.name && i.articulationProperty === t)), i && (e.rotation.x = i.articulationVal, this._delDefaultVal(e.name, t)); break; case ArticulationModifierTypes.rotationY: i = h.find((i => i.articulationName === e.name && i.articulationProperty === t)), i && (e.rotation.y = i.articulationVal, this._delDefaultVal(e.name, t)); break; case ArticulationModifierTypes.rotationZ: i = h.find((i => i.articulationName === e.name && i.articulationProperty === t)), i && (e.rotation.z = i.articulationVal, this._delDefaultVal(e.name, t)); break; case ArticulationModifierTypes.translationX: i = h.find((i => i.articulationName === e.name && i.articulationProperty === t)), i && (e.position.x = i.articulationVal, this._delDefaultVal(e.name, t)); break; case ArticulationModifierTypes.translationY: i = h.find((i => i.articulationName === e.name && i.articulationProperty === t)), i && (e.position.y = i.articulationVal, this._delDefaultVal(e.name, t)); break; case ArticulationModifierTypes.translationZ: i = h.find((i => i.articulationName === e.name && i.articulationProperty === t)), i && (e.position.z = i.articulationVal, this._delDefaultVal(e.name, t)); break; case ArticulationModifierTypes.scaleX: i = h.find((i => i.articulationName === e.name && i.articulationProperty === t)), i && (e.scale.x = i.articulationVal, this._delDefaultVal(e.name, t)); break; case ArticulationModifierTypes.scaleY: i = h.find((i => i.articulationName === e.name && i.articulationProperty === t)), i && (e.scale.y = i.articulationVal, this._delDefaultVal(e.name, t)); break; case ArticulationModifierTypes.scaleZ: i = h.find((i => i.articulationName === e.name && i.articulationProperty === t)), i && (e.scale.z = i.articulationVal, this._delDefaultVal(e.name, t)); break; case ArticulationModifierTypes.opacity: e.traverse((r => { "Mesh" == r.type && (r.material instanceof Array ? r.material.forEach((e => { i = h.find((i => i.articulationName === r.name + ":" + e.name && i.articulationProperty === t)), i && (e.opacity = i.articulationVal, this._delDefaultVal(r.name + ":" + e.name, t)) })) : (i = h.find((i => i.articulationName === e.name + ":" + r.name && i.articulationProperty === t)), i && (r.material.opacity = i.articulationVal, this._delDefaultVal(e.name + ":" + r.name, t)))) })); break; case ArticulationModifierTypes.colorOverlay: e.traverse((r => { "Mesh" == r.type && (r.material instanceof Array ? r.material.forEach((e => { i = h.find((i => i.articulationName.indexOf(e.name) > -1 && i.articulationProperty === t)), i && (e.color = i.articulationVal.color, e.opacity = i.articulationVal.opacity, this._delDefaultVal(r.name + ":" + e.name, t)) })) : (i = h.find((e => e.articulationName.indexOf(r.name) > -1 && e.articulationProperty === t)), i && (r.material.color = i.articulationVal.color, r.material.opacity = i.articulationVal.opacity, this._delDefaultVal(e.name + ":" + r.name, t)))) })); break; case ArticulationModifierTypes.colorReplace: e.traverse((r => { if ("Mesh" == r.type) if (r.material instanceof Array) r.material.forEach((e => { if (i = h.find((i => i.articulationName.indexOf(e.name) > -1 && i.articulationProperty === t)), i) { let n = i.articulationVal; e.map = n.map, e.color = new Color$1(n.color), e.opacity = n.opacity, e.needsUpdate = !0, this._delDefaultVal(r.name + ":" + e.name, t) } })); else if (i = h.find((e => e.articulationName.indexOf(r.name) > -1 && e.articulationProperty === t)), i) { let n = i.articulationVal; r.material.map = n.map, r.material.color = new Color$1(n.color), r.material.opacity = n.opacity, r.material.needsUpdate = !0, this._delDefaultVal(e.name + ":" + r.name, t) } })); break; case ArticulationModifierTypes.stroke: _context.effectStore.initOutlinePass() } })) } else c.forEach((t => { t.traverse((t => { if (e.inclues(t.name)) { let e = i.getObjectByName(t.parent.name), r = e.children.findIndex((e => e.name == t.name)); e.children.splice(r, 1), t.material && t.material.dispose(), t.geometry && t.geometry.dispose() } })) })) }, this.particlesReset = (e, t) => { if (!(h.length <= 0) && n != ArticulationTypes.text) for (let i of e) { let e = this.getModelItem().particleStoreArray.find((e => e.name === i)); e && t && t.forEach((t => { let i; switch (t) { case ArticulationModifierTypes.rotationX: i = h.find((i => i.articulationName === e.particleModelGroup.name && i.articulationProperty === t)), i && (e.particleModelGroup.rotation.x = i.articulationVal, this._delDefaultVal(e.particleModelGroup.name, t)); break; case ArticulationModifierTypes.rotationY: i = h.find((i => i.articulationName === e.particleModelGroup.name && i.articulationProperty === t)), i && (e.particleModelGroup.rotation.y = i.articulationVal, this._delDefaultVal(e.particleModelGroup.name, t)); break; case ArticulationModifierTypes.rotationZ: i = h.find((i => i.articulationName === e.particleModelGroup.name && i.articulationProperty === t)), i && (e.particleModelGroup.rotation.z = i.articulationVal, this._delDefaultVal(e.particleModelGroup.name, t)); break; case ArticulationModifierTypes.translationX: i = h.find((i => i.articulationName === e.particleModelGroup.name && i.articulationProperty === t)), i && (e.particleModelGroup.position.x = i.articulationVal, this._delDefaultVal(e.particleModelGroup.name, t)); break; case ArticulationModifierTypes.translationY: i = h.find((i => i.articulationName === e.particleModelGroup.name && i.articulationProperty === t)), i && (e.particleModelGroup.position.y = i.articulationVal, this._delDefaultVal(e.particleModelGroup.name, t)); break; case ArticulationModifierTypes.translationZ: i = h.find((i => i.articulationName === e.particleModelGroup.name && i.articulationProperty === t)), i && (e.particleModelGroup.position.z = i.articulationVal, this._delDefaultVal(e.particleModelGroup.name, t)); break; case ArticulationModifierTypes.scaleX: i = h.find((i => i.articulationName === e.particleModelGroup.name && i.articulationProperty === t)), i && (e.particleModelGroup.scale.x = i.articulationVal, this._delDefaultVal(e.particleModelGroup.name, t)); break; case ArticulationModifierTypes.scaleY: i = h.find((i => i.articulationName === e.particleModelGroup.name && i.articulationProperty === t)), i && (e.particleModelGroup.scale.y = i.articulationVal, this._delDefaultVal(e.particleModelGroup.name, t)); break; case ArticulationModifierTypes.scaleZ: i = h.find((i => i.articulationName === e.particleModelGroup.name && i.articulationProperty === t)), i && (e.particleModelGroup.scale.z = i.articulationVal, this._delDefaultVal(e.particleModelGroup.name, t)); break; case ArticulationModifierTypes.opacity: e.particleGroup.forEach((r => { i = h.find((i => i.articulationName === e.particleModelGroup.name + ":" + r.id && i.articulationProperty === t)), r.opacity = i.articulationVal, this._delDefaultVal(e.particleModelGroup.name + ":" + r.id, t) })); break; case ArticulationModifierTypes.quantityFactor: e.particleGroup.forEach((r => { i = h.find((i => i.articulationName === e.particleModelGroup.name + ":" + r.id && i.articulationProperty === t)), r.density = i.articulationVal, this._delDefaultVal(e.particleModelGroup.name + ":" + r.id, t) })) } })) } }, this.materialsReset = (e, t) => { if (!(h.length <= 0) && n != ArticulationTypes.text) for (let i of e) { let e = this.getModelItem().findMaterial(i); e && t && t.forEach((t => { switch (t) { case ArticulationModifierTypes.USpeed: (i = _context.animationStore.findMaterialAnimation(e._material(), UVAnimationController.type)) && (i.enableU = 0 !== e.translationSpeedU && e.enableTranslation, i.uSpeed = e.enableTranslation ? e.translationSpeedU : 0, 0 === i.uSpeed && 0 === i.vSpeed && _context.animationStore.remove(i)); break; case ArticulationModifierTypes.VSpeed: var i; (i = _context.animationStore.findMaterialAnimation(e._material(), UVAnimationController.type)) && (i.enableV = 0 !== e.translationSpeedV && e.enableTranslation, i.vSpeed = e.enableTranslation ? e.translationSpeedV : 0, 0 === i.uSpeed && 0 === i.vSpeed && _context.animationStore.remove(i)) } })) } }, this.addOrUpdateTextArticulation = () => { let e = this.getModelNode(); c.forEach((t => { t.traverse((t => { let i = e.getObjectByName(t.parent.name), r = i.children.findIndex((e => e.name == t.name)); i.children.splice(r, 1), t.material && t.material.dispose(), t.geometry && t.geometry.dispose() })) })), c = [], this.properties.forEach(((t, i) => { t.nodes.forEach(((r, n) => { let s = e.getObjectByName(r); if (s) { let e = s.name + a + i + n, r = s.children.findIndex((t => t.name == e)); r > -1 && (s.children[r].material.dispose(), s.children[r].geometry.dispose(), s.children.splice(r, 1)); let l = function ({ labelFontFamily: e = "微软雅黑", labelFontSize: t = 3, labelFontBold: i = !1, labelEnableItalic: r = !1, labelBackground: n = "rgb(0,0,0)", labelColor: a = "rgb(1,1,1)", labelText: o = "标题文字" }) { let s = document.createElement("canvas"), l = s.getContext("2d"), c = t, h = ""; i && (h = "bold"); let u = ""; return r && (u = "italic"), l.font = `${u} ${h} ${c}px ${e}`, l.textAlign = "center", l.textBaseline = "middle", s.width = 1.8 * (l.measureText(o).width + c), s.height = 3.2 * c, l.fillStyle = n, l.fillRect(0, 0, s.width, s.height), l.font = `${u} ${h} ${2 * c}px ${e}`, l.fillStyle = a, l.textAlign = "center", l.textBaseline = "middle", l.fillText(o, s.width / 2, s.height / 2), s }(o[0]), h = new CanvasTexture(l), u = new SpriteMaterial({ map: h, color: 16777215, fog: DRAWABLE_FOG, depthWrite: !0, depthTest: !1, depthFunc: AlwaysDepth, sizeAttenuation: !0 }), d = new Sprite(u); d.scale.set(.005 * l.width, .005 * l.height, 1); let p = t.modifiers.find((e => "x" == e.key)).values[0], f = t.modifiers.find((e => "y" == e.key)).values[0], m = t.modifiers.find((e => "z" == e.key)).values[0]; d.position.set(p, f, m), d.name = e, d.parent = s, s.children.push(d), c.push(d) } })) })) }, this.deleteArticulation = () => { let e = this.getModelNode(); if (n != ArticulationTypes.text) for (let i of this.properties) { let r = []; for (let t of i.nodes) e.getObjectByName(t) && r.push(e.getObjectByName(t)); if (r.length) for (let e of i.modifiers) for (let t of r) { let i = 0; switch (e.key) { case ArticulationModifierTypes.rotationX: i = h.find((i => i.articulationName === t.name && i.articulationProperty === e.key)).articulationVal, t.rotation.set(i, t.rotation.y, t.rotation.z), this._delDefaultVal(t.name, e.key); break; case ArticulationModifierTypes.rotationY: i = h.find((i => i.articulationName === t.name && i.articulationProperty === e.key)).articulationVal, t.rotation.set(t.rotation.x, i, t.rotation.z), this._delDefaultVal(t.name, e.key); break; case ArticulationModifierTypes.rotationZ: i = h.find((i => i.articulationName === t.name && i.articulationProperty === e.key)).articulationVal, t.rotation.set(t.rotation.x, t.rotation.y, i), this._delDefaultVal(t.name, e.key); break; case ArticulationModifierTypes.translationX: i = h.find((i => i.articulationName === t.name && i.articulationProperty === e.key)).articulationVal, t.position.set(i, t.position.y, t.position.z), this._delDefaultVal(t.name, e.key); break; case ArticulationModifierTypes.translationY: i = h.find((i => i.articulationName === t.name && i.articulationProperty === e.key)).articulationVal, t.position.set(t.position.x, i, t.position.z), this._delDefaultVal(t.name, e.key); break; case ArticulationModifierTypes.translationZ: i = h.find((i => i.articulationName === t.name && i.articulationProperty === e.key)).articulationVal, t.position.set(t.position.x, t.position.y, i), this._delDefaultVal(t.name, e.key); break; case ArticulationModifierTypes.scaleX: i = h.find((i => i.articulationName === t.name && i.articulationProperty === e.key)).articulationVal, t.scale.set(i, t.scale.y, t.scale.z), this._delDefaultVal(t.name, e.key); break; case ArticulationModifierTypes.scaleY: i = h.find((i => i.articulationName === t.name && i.articulationProperty === e.key)).articulationVal, t.scale.set(t.scale.x, i, t.scale.z), this._delDefaultVal(t.name, e.key); break; case ArticulationModifierTypes.scaleZ: i = h.find((i => i.articulationName === t.name && i.articulationProperty === e.key)).articulationVal, t.scale.set(t.scale.x, t.scale.y, i), this._delDefaultVal(t.name, e.key); break; case ArticulationModifierTypes.opacity: t.traverse((r => { if ("Mesh" == r.type) if (r.material instanceof Array) r.material.forEach((t => { t.transparent = !1; let n = h.find((i => i.articulationName.indexOf(t.name) > -1 && i.articulationProperty === e.key)); n && (i = n.articulationVal, t.opacity = i, this._delDefaultVal(r.name + ":" + t.name, e.key)) })); else { let n = h.find((t => t.articulationName.indexOf(r.name) > -1 && t.articulationProperty === e.key)); n && (i = n.articulationVal, r.material.transparent = !1, r.material.opacity = i, this._delDefaultVal(t.name + ":" + r.name, e.key)) } })); break; case ArticulationModifierTypes.colorOverlay: t.traverse((r => { if ("Mesh" == r.type) if (r.material instanceof Array) r.material.forEach((t => { let n = h.find((i => i.articulationName === r.name + ":" + t.name && i.articulationProperty === e.key)); n && (i = n.articulationVal, t.color = i.color, t.opacity = i.opacity, this._delDefaultVal(r.name + ":" + t.name, e.key)) })); else { let n = h.find((i => i.articulationName === t.name + ":" + r.name && i.articulationProperty === e.key)); n && (i = n.articulationVal, r.material.color = i.color, r.material.opacity = i.opacity, this._delDefaultVal(t.name + ":" + r.name, e.key)) } })); break; case ArticulationModifierTypes.colorReplace: t.traverse((r => { if ("Mesh" == r.type) if (r.material instanceof Array) r.material.forEach((t => { let n = h.find((i => i.articulationName.indexOf(t.name) > -1 && i.articulationProperty === e.key)); n && (i = n.articulationVal, t.map = i.map, t.color = i.color, t.opacity = i.opacity, t.needsUpdate = !0, this._delDefaultVal(r.name + ":" + t.name, e.key)) })); else { let n = h.find((t => t.articulationName.indexOf(r.name) > -1 && t.articulationProperty === e.key)); n && (i = n.articulationVal, r.material.map = i.map, r.material.color = i.color, r.material.transparent = i.opacity, r.material.needsUpdate = !0, this._delDefaultVal(t.name + ":" + r.name, e.key)) } })); break; case ArticulationModifierTypes.stroke: _context.effectStore.initOutlinePass() } } else logger.warn("正在设置的关节无效，无法找到指定的节点。"); let n = []; for (let e of i.materials) { let t = this.getModelItem().findMaterial(e); t && n.push(t) } if (n.length) for (let e of i.modifiers) for (let i of n) switch (e.key) { case ArticulationModifierTypes.USpeed: (t = _context.animationStore.findMaterialAnimation(i._material(), UVAnimationController.type)) && (t.enableU = 0 !== i.translationSpeedU && i.enableTranslation, t.uSpeed = i.enableTranslation ? i.translationSpeedU : 0, 0 === t.uSpeed && 0 === t.vSpeed && _context.animationStore.remove(t)); break; case ArticulationModifierTypes.VSpeed: var t; (t = _context.animationStore.findMaterialAnimation(i._material(), UVAnimationController.type)) && (t.enableV = 0 !== i.translationSpeedV && i.enableTranslation, t.vSpeed = i.enableTranslation ? i.translationSpeedV : 0, 0 === t.uSpeed && 0 === t.vSpeed && _context.animationStore.remove(t)) }let a = []; for (let e of i.particles) { let t = this.getModelItem().particleStoreArray.find((t => t.name === e)); t && a.push(t) } if (a.length) for (let e of i.modifiers) for (let t of a) { let i = 0; switch (e.key) { case ArticulationModifierTypes.rotationX: i = h.find((i => i.articulationName === t.particleModelGroup.name && i.articulationProperty === e.key)), i && (t.particleModelGroup.rotation.x = i.articulationVal, this._delDefaultVal(t.particleModelGroup.name, e.key)); break; case ArticulationModifierTypes.rotationY: i = h.find((i => i.articulationName === t.particleModelGroup.name && i.articulationProperty === e.key)), i && (t.particleModelGroup.rotation.y = i.articulationVal, this._delDefaultVal(t.particleModelGroup.name, e.key)); break; case ArticulationModifierTypes.rotationZ: i = h.find((i => i.articulationName === t.particleModelGroup.name && i.articulationProperty === e.key)), i && (t.particleModelGroup.rotation.z = i.articulationVal, this._delDefaultVal(t.particleModelGroup.name, e.key)); break; case ArticulationModifierTypes.translationX: i = h.find((i => i.articulationName === t.particleModelGroup.name && i.articulationProperty === e.key)), i && (t.particleModelGroup.position.x = i.articulationVal, this._delDefaultVal(t.particleModelGroup.name, e.key)); break; case ArticulationModifierTypes.translationY: i = h.find((i => i.articulationName === t.particleModelGroup.name && i.articulationProperty === e.key)), i && (t.particleModelGroup.position.y = i.articulationVal, this._delDefaultVal(t.particleModelGroup.name, e.key)); break; case ArticulationModifierTypes.translationZ: i = h.find((i => i.articulationName === t.particleModelGroup.name && i.articulationProperty === e.key)), i && (t.particleModelGroup.position.z = i.articulationVal, this._delDefaultVal(t.particleModelGroup.name, e.key)); break; case ArticulationModifierTypes.scaleX: i = h.find((i => i.articulationName === t.particleModelGroup.name && i.articulationProperty === e.key)), i && (t.particleModelGroup.scale.x = i.articulationVal, this._delDefaultVal(t.particleModelGroup.name, e.key)); break; case ArticulationModifierTypes.scaleY: i = h.find((i => i.articulationName === t.particleModelGroup.name && i.articulationProperty === e.key)), i && (t.particleModelGroup.scale.y = i.articulationVal, this._delDefaultVal(t.particleModelGroup.name, e.key)); break; case ArticulationModifierTypes.scaleZ: i = h.find((i => i.articulationName === t.particleModelGroup.name && i.articulationProperty === e.key)), i && (t.particleModelGroup.scale.z = i.articulationVal, this._delDefaultVal(t.particleModelGroup.name, e.key)); break; case ArticulationModifierTypes.opacity: t.particleGroup.forEach((r => { i = h.find((i => i.articulationName === t.particleModelGroup.name + ":" + r.id && i.articulationProperty === e.key)), r.opacity = i.articulationVal, this._delDefaultVal(t.particleModelGroup.name + ":" + r.id, e.key) })); break; case ArticulationModifierTypes.quantityFactor: t.particleGroup.forEach((r => { i = h.find((i => i.articulationName === t.particleModelGroup.name + ":" + r.id && i.articulationProperty === e.key)), r.density = i.articulationVal, this._delDefaultVal(t.particleModelGroup.name + ":" + r.id, e.key) })) } } } }, this.getDefaultVal = (e, t) => h.find((i => i.articulationName.indexOf(e) > -1 && i.articulationProperty === t)), this.isValid = () => l, this.getValues = () => o, this.setValues = e => { o = e }, this.getDefaultValue = () => s, this.setDefaultValue = e => { s = e }, this.clone = () => { const e = new this.constructor({ type: n, name: a, values: o, defaultValue: s }); e.value = this.value, e.remark = this.remark, e.isEnable = this.isEnable; for (const t of this.properties) e.properties.push(t.clone()); return e } } get name() { return this.getName() } set name(e) { this.setName(e) } get type() { return this.getType() } set type(e) { logger.warn("不支持修改关节的类型。") } toJSON() { return this.getSettings() } } class Texture { constructor({ id: e = util$1.guid(), name: t = "", type: i = "imagebitmap", textureSource: r = "", wrapS: n, wrapT: a } = {}) { this._id = e, this._name = t, this._type = i, this._textureSource = r, this._wrapS = n, this._wrapT = a } get id() { return this._id } get name() { return this._name } get type() { return this._type } get textureSource() { return this._textureSource } set textureSource(e) { this._textureSource = e } getCanvas({ width: e, height: t, adjust: i } = {}) { if (this._textureSource && "imagebitmap" === this._type) { if (!this._canvas) { this._canvas = document.createElement("canvas"), this._canvas.width = e || this._textureSource.width, this._canvas.height = t || this._textureSource.height, this._canvas.getContext("2d").drawImage(this._textureSource, 0, 0, this._canvas.width, this._canvas.height) } return this._canvas } } destroyCanvas() { this._canvas && (this._canvas.parentElement.removeChild(this._canvas), this._canvas = void 0) } } Texture._fromThreeObject = function ({ uuid: e, name: t, type: i, image: r, rotation: n, center: a, flipY: o, wrapS: s, wrapT: l } = {}) { return new Texture({ id: e, name: t, type: "imagebitmap", textureSource: r, wrapS: s, wrapT: l }) }; class Water extends Mesh { constructor(e, t = {}) { super(e); const i = this, r = void 0 !== t.textureWidth ? t.textureWidth : 512, n = void 0 !== t.textureHeight ? t.textureHeight : 512, a = void 0 !== t.clipBias ? t.clipBias : 0, o = void 0 !== t.alpha ? t.alpha : 1, s = void 0 !== t.time ? t.time : 0, l = void 0 !== t.waterNormals ? t.waterNormals : null, c = void 0 !== t.sunDirection ? t.sunDirection : new Vector3(.70707, .70707, 0), h = new Color$1(void 0 !== t.sunColor ? t.sunColor : 16777215), u = new Color$1(void 0 !== t.waterColor ? t.waterColor : 8355711), d = void 0 !== t.eye ? t.eye : new Vector3(0, 0, 0), p = void 0 !== t.distortionScale ? t.distortionScale : 20, f = void 0 !== t.side ? t.side : FrontSide, m = void 0 !== t.fog && t.fog; var g = void 0 !== t.reflectionRate ? t.reflectionRate : .9, y = void 0 !== t.yUp && t.yUp; i.reflectionAutoUpdate = void 0 === t.reflectionAutoUpdate || t.reflectionAutoUpdate; const v = new Plane, _ = new Vector3, b = new Vector3, x = new Vector3, w = new Matrix4, S = new Vector3(0, 0, -1), M = new Vector4, T = new Vector3, A = new Vector3, E = new Vector4, C = new Matrix4, L = new PerspectiveCamera, R = new WebGLRenderTarget(r, n, { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBFormat }); MathUtils.isPowerOfTwo(r) && MathUtils.isPowerOfTwo(n) || (R.texture.generateMipmaps = !1); const D = { uniforms: UniformsUtils.merge([UniformsLib.fog, UniformsLib.lights, { normalSampler: { value: null }, mirrorSampler: { value: null }, alpha: { value: 1 }, time: { value: 0 }, size: { value: 1 }, distortionScale: { value: 20 }, textureMatrix: { value: new Matrix4 }, sunColor: { value: new Color$1(8355711) }, sunDirection: { value: new Vector3(.70707, .70707, 0) }, eye: { value: new Vector3 }, waterColor: { value: new Color$1(5592405) }, reflectionRate: { value: .9 } }]), vertexShader: "\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n        \n        #include <clipping_planes_vertex>\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}", fragmentShader: "\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n        uniform float distortionScale;\n        uniform float reflectionRate;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n        #include <shadowmask_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n          #include <clipping_planes_fragment>\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 * reflectionRate + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}" }, P = new ShaderMaterial({ fragmentShader: D.fragmentShader, vertexShader: D.vertexShader, uniforms: UniformsUtils.clone(D.uniforms), lights: !0, side: f, fog: m }); P.clipping = !0, P.uniforms.mirrorSampler.value = R.texture, P.uniforms.textureMatrix.value = C, P.uniforms.alpha.value = o, P.uniforms.time.value = s, P.uniforms.normalSampler.value = l, P.uniforms.sunColor.value = h, P.uniforms.waterColor.value = u, P.uniforms.sunDirection.value = c, P.uniforms.distortionScale.value = p, P.uniforms.reflectionRate.value = g, P.uniforms.eye.value = d, i.material = P, i.getRenderTarget = function () { return R }, i.onBeforeRender = function (e, t, r) { if (i.paused) return; if (b.setFromMatrixPosition(i.matrixWorld), x.setFromMatrixPosition(r.matrixWorld), w.extractRotation(i.matrixWorld), _.set(0, y ? 1 : 0, y ? 0 : 1), _.applyMatrix4(w), T.subVectors(b, x), T.dot(_) > 0) return; T.reflect(_).negate(), T.add(b), w.extractRotation(r.matrixWorld), S.set(0, 0, -1), S.applyMatrix4(w), S.add(x), A.subVectors(b, S), A.reflect(_).negate(), A.add(b), L.position.copy(T), L.up.set(0, 1, 0), L.up.applyMatrix4(w), L.up.reflect(_), L.lookAt(A), L.far = r.far, L.updateMatrixWorld(), L.projectionMatrix.copy(r.projectionMatrix), C.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), C.multiply(L.projectionMatrix), C.multiply(L.matrixWorldInverse), v.setFromNormalAndCoplanarPoint(_, b), v.applyMatrix4(L.matrixWorldInverse), M.set(v.normal.x, v.normal.y, v.normal.z, v.constant); const n = L.projectionMatrix; if (E.x = (Math.sign(M.x) + n.elements[8]) / n.elements[0], E.y = (Math.sign(M.y) + n.elements[9]) / n.elements[5], E.z = -1, E.w = (1 + n.elements[10]) / n.elements[14], M.multiplyScalar(2 / M.dot(E)), n.elements[2] = M.x, n.elements[6] = M.y, n.elements[10] = M.z + 1 - a, n.elements[14] = M.w, d.setFromMatrixPosition(r.matrixWorld), i.reflectionAutoUpdate || i.needsUpdate) { const r = e.getRenderTarget(), n = e.xr.enabled, a = e.shadowMap.autoUpdate; i.visible = !1; var o = null; for (let e = 0; e < _context.scene.children.length; e++)"__objects" === _context.scene.children[e].name && (o = _context.scene.children[e].visible, _context.scene.children[e].visible = !1); util$1.iconVisible(_context.defaultObjectTree.children, !1), e.xr.enabled = !1, e.shadowMap.autoUpdate = !1, e.setRenderTarget(R), e.state.buffers.depth.setMask(!0), !1 === e.autoClear && e.clear(), e.render(t, L), i.needsUpdate = void 0, i.visible = !0; for (let e = 0; e < _context.scene.children.length; e++)"__objects" === _context.scene.children[e].name && (_context.scene.children[e].visible = o); util$1.iconVisible(_context.defaultObjectTree.children, !0), e.xr.enabled = n, e.shadowMap.autoUpdate = a, e.setRenderTarget(r) } const s = r.viewport; void 0 !== s && e.state.viewport(s) } } } Water.prototype.isWater = !0; class Material { constructor({ materialOfThree: e, id: t = util$1.guid(), name: i, type: r = "metalness", mapType: n = "metalness", color: a, map: o, mapIntensit: s = 1, metalnessMap: l, metalnessIntensity: c = 1, specularF0Texture: h, roughnessMap: u, roughnessIntensity: d = 1, enableSpecularMap: p = !0, specularMapType: f, specularMap: m, specularMapIntensity: g = 0, enableNormalMap: y, normalMapType: v, normalMap: _, normalMapFlipY: b, normalMapIntensity: x = 1, enableDisplacement: w, displacementMap: S, displacementIntensity: M = 1, enableOpacity: T, opacityType: A, opacityMap: E, opacityIntensity: C = 1, opacityInverted: L = !1, emissive: R, enableEmissive: D, emissiveMap: P, emissiveIntensity: O = 1, enableClearcoat: I, clearcoatMap: k, sheen: B, clearcoatThickness: N = 0, clearcoatNormalMap: F, clearcoatNormalScale: U, clearcoatRoughness: z = 0, clearcoatRoughnessMap: G, enableAOMap: H, aoMap: V, aoMapIntensity: j = 1, enableLightMap: W, lightMap: $, lightMapIntensity: Y = 1, enableUV: X = !1, repeatU: Z = 1, repeatV: q = 1, offsetU: J = 0, offsetV: K = 0, enableTranslation: Q = !1, translationSpeedU: ee = 0, translationSpeedV: te = 0, enableSSR: ie = !1, envMapIntensity: re = 1, side: ne, depth: ae, waterFlowSpeed: oe, waterOffsetY: se, waterColor: le, waterOpacity: ce, waterReflectionRate: he, waterWave: ue, polygonOffset: de, polygonOffsetFactor: pe, polygonOffsetUnits: fe }) { var me, ge = e; ge.disableSSR = !0, this._replacePath; let ye = [], ve = new Map; this._material = () => ge, this._getRelatedNodes = () => ye, this._getWaterAnimationList = () => ve, this.initData = function ({ materialOfThree: e, id: t = util$1.guid(), name: i, type: r = "metalness", mapType: n = "metalness", color: a, map: o, mapIntensit: s = 1, metalnessMap: l, metalnessIntensity: c = 1, specularF0Texture: h, roughnessMap: u, roughnessIntensity: d = 1, enableSpecularMap: p = !0, specularMapType: f, specularMap: m, specularMapIntensity: g = 0, enableNormalMap: y, normalMapType: v, normalMap: _, normalMapFlipY: b, normalMapIntensity: x = 1, enableDisplacement: w, displacementMap: S, displacementIntensity: M = 1, enableOpacity: T, opacityType: A, opacityMap: E, opacityIntensity: C = 1, opacityInverted: L = !1, emissive: R, enableEmissive: D, emissiveMap: P, emissiveIntensity: O = 1, enableClearcoat: I, clearcoatMap: k, sheen: B, clearcoatThickness: N = 0, clearcoatNormalMap: F, clearcoatNormalScale: U, clearcoatRoughness: z = 0, clearcoatRoughnessMap: G, enableAOMap: H, aoMap: V, aoMapIntensity: j = 1, enableLightMap: W, lightMap: $, lightMapIntensity: Y = 1, enableUV: X = !1, repeatU: Z = 1, repeatV: q = 1, offsetU: J = 0, offsetV: K = 0, enableTranslation: Q = !1, translationSpeedU: ee = 0, translationSpeedV: te = 0, enableSSR: ie = !1, envMapIntensity: re = 1, side: ne, depth: ae, waterFlowSpeed: oe, waterOffsetY: se, waterColor: le, waterOpacity: ce, waterReflectionRate: he, waterWave: ue, polygonOffset: de, polygonOffsetFactor: pe, polygonOffsetUnits: fe }) { this._id = t, this._name = i, this.type = r, this._mapType = n, this._color = `#${a.getHexString()}`, this._map = Map$1._fromThreeObject(o, this._color), this._mapIntensit = s, this._metalnessMap = Map$1._fromThreeObject(l), this._metalnessIntensity = c, "color" === this._metalnessMap._type && (this._metalnessMap._source = "#ffffff"), this._roughnessMap = Map$1._fromThreeObject(u), "color" === this._roughnessMap._type && (this._roughnessMap._source = "#ffffff"), this._roughnessIntensity = 1 - Number(d), this._enableSpecularMap = !0, this._specularMapType = f, this._specularMap = Map$1._fromThreeObject(m), "color" === this._specularMap._type && (this._specularMap._source = "#ffffff"), this._specularMapIntensity = g, this._enableNormalMap = y, y ? ge.bumpMap ? this._normalMapType = "bump" : this._normalMapType = "normal" : this._normalMapType = "bump", this._normalMap = Map$1._fromThreeObject(_), this._normalMapFlipY = b, this._normalMapIntensity = x, "color" === this._normalMap._type && (this._normalMap._source = "#ffffff"), this._enableDisplacement = w, this._displacementMap = Map$1._fromThreeObject(S), "color" === this._displacementMap._type && (this._displacementMap._source = "#ffffff"), this._displacementIntensity = M, this._enableOpacity = T, this._opacityType = A, this._opacityMap = Map$1._fromThreeObject(E), this._opacityIntensity = C, this._opacityInverted = L, "color" === this._opacityMap._type && (this._opacityMap._source = "#ffffff"), this._enableEmissive = D, this._emissiveMap = Map$1._fromThreeObject(P), this._emissiveIntensity = O, this._emissiveMapColor = "#ffffff", "color" === this._emissiveMap._type && (this._emissiveMapColor = "#" + R.getHexString()), this._enableClearcoat = I, this._clearcoatMap = Map$1._fromThreeObject(k), this._clearcoatColor = B ? `#${B.getHexString()}` : null, this._clearcoatThickness = N, this._clearcoatNormalMap = Map$1._fromThreeObject(F), this._clearcoatNormalMapFlipY = !!F && F.flipY, this._clearcoatNormalScale = U ? U.x : 1, this._clearcoatRoughness = z, this._clearcoatRoughnessMap = Map$1._fromThreeObject(G), this._enableAOMap = H, this._aoMap = Map$1._fromThreeObject(V), this._aoMapIntensity = j, "color" === this._aoMap._type && (this._aoMap._source = "#ffffff"), this._enableLightMap = W, this._lightMap = Map$1._fromThreeObject($), this._lightMapIntensity = Y, "color" === this._lightMap._type && (this._lightMap._source = "#ffffff"), this._enableUV = X, this._repeatU = Z, this._repeatV = q, this._offsetU = J, this._offsetV = K, this._enableTranslation = Q, this._translationSpeedU = ee, this._translationSpeedV = te, this._enableSSR = ie, this._envMapIntensity = re, this.side = ne, this._depth = ae, this._waterFlowSpeed = .25, this._waterOffsetY = 0, this._waterColor = "#001e0f", this._waterReflectionAutoUpdate = !0, this._waterReflectionQuality = 512, this._waterOpacity = .65, this._waterReflectionRate = 1, this._waterWave = 3.7, this._polygonOffset = de, this._polygonOffsetFactor = pe, this._polygonOffsetUnits = fe }, this.initData({ materialOfThree: e, id: t, name: i, type: r, mapType: n, color: a, map: o, mapIntensit: s, metalnessMap: l, metalnessIntensity: c, specularF0Texture: h, roughnessMap: u, roughnessIntensity: d, enableSpecularMap: p, specularMapType: f, specularMap: m, specularMapIntensity: g, enableNormalMap: y, normalMapType: v, normalMap: _, normalMapFlipY: b, normalMapIntensity: x, enableDisplacement: w, displacementMap: S, displacementIntensity: M, enableOpacity: T, opacityType: A, opacityMap: E, opacityIntensity: C, opacityInverted: L, emissive: R, enableEmissive: D, emissiveMap: P, emissiveIntensity: O, enableClearcoat: I, clearcoatMap: k, sheen: B, clearcoatThickness: N, clearcoatNormalMap: F, clearcoatNormalScale: U, clearcoatRoughness: z, clearcoatRoughnessMap: G, enableAOMap: H, aoMap: V, aoMapIntensity: j, enableLightMap: W, lightMap: $, lightMapIntensity: Y, enableUV: X, repeatU: Z, repeatV: q, offsetU: J, offsetV: K, enableTranslation: Q, translationSpeedU: ee, translationSpeedV: te, enableSSR: ie, envMapIntensity: re, side: ne, depth: ae, waterFlowSpeed: oe, waterOffsetY: se, waterColor: le, waterOpacity: ce, waterReflectionRate: he, waterWave: ue, polygonOffset: de, polygonOffsetFactor: pe, polygonOffsetUnits: fe }), this.getCacheMaterial = e => { let t = _context.instance.defaultObjectTree.getItemByUUID(e); if (!t) return; let i = _context.cacheStore.find(t.modelPath); if (!i) return; let r = null; return i.resource.traverse((e => { if (e.material) if (e.material instanceof Array) for (var t of e.material) t.name == this.name && (r = t); else e.material.name == this.name && (r = e.material) })), r }, this.addRelatedNode = function (e) { this._getRelatedNodes().push(e) }, this.addModelName = function (e) { this._modelName = e }, this.replace = (e, t) => { me || (me = ge.clone()), "water" === this.type && (this.type = "metalness"), this.replacePath = t; let i = util$1.cloneMaterial(e); if (i.name = this.name, this._getRelatedNodes() instanceof Array) { for (let e of this._getRelatedNodes()) if (e.material === ge) e.material.dispose(), e.material = i; else if (e.material instanceof Array) for (let t in e.material) e.material[t] === ge && (e.material[t].dispose(), e.material[t] = i); util$1.disposeMaterial(ge), ge = i } ge.needsUpdate = !0, this.initData({ materialOfThree: ge, id: ge.uuid, name: ge.name, type: "metalness", mapType: "metalness", color: ge.color, map: ge.map, mapIntensit: ge.mapIntensit, metalnessMap: ge.metalnessMap, metalnessIntensity: ge.metalness, roughnessMap: ge.roughnessMap, roughnessIntensity: ge.roughness, enableSpecularMap: !!ge.envMap, specularMapType: ge.envMap ? "custom" : "envmap", specularMap: ge.envMap, specularMapIntensity: ge.envMapIntensity / ENVMAP_FACTOR, enableNormalMap: !!ge.normalMap, normalMapType: "", normalMap: ge.normalMap, normalMapFlipY: ge.normalMapFlipY, normalMapIntensity: ge.normalScale ? ge.normalScale.x : 1, enableDisplacement: !!ge.displacementMap, displacementMap: ge.displacementMap, displacementIntensity: ge.displacementScale, enableOpacity: ge.transparent || !!ge.alphaMap, opacityType: "blend", opacityMap: ge.alphaMap, opacityIntensity: ge.opacity, opacityInverted: !1, emissive: ge.emissive || new Color$1(0, 0, 0), enableEmissive: !!ge.emissiveMap || !!ge.emissive && (0 !== ge.emissive.r || 0 !== ge.emissive.g || 0 !== ge.emissive.b), emissiveMap: ge.emissiveMap, emissiveIntensity: ge.emissiveIntensity, enableClearcoat: ge instanceof MeshPhysicalMaterial && "" === ge.defines.PHYSICAL, clearcoatMap: ge.clearcoatMap, sheen: ge.sheen, clearcoatThickness: ge.clearcoat, clearcoatNormalMap: ge.clearcoatNormalMap, clearcoatNormalScale: ge.clearcoatNormalScale, clearcoatRoughness: ge.clearcoatRoughness, clearcoatRoughnessMap: ge.clearcoatRoughnessMap, enableAOMap: !!ge.aoMap, aoMap: ge.aoMap, aoMapIntensity: ge.aoMapIntensity, enableLightMap: !!ge.lightMap, lightMap: ge.lightMap, lightMapIntensity: ge.lightMapIntensity, enableSSR: ge.enableSSR, envMapIntensity: ge.envMapIntensity, side: ge.side, depth: ge.depthTest && ge.depthWrite ? 2 : ge.depthTest || ge.depthWrite ? 1 : 0, polygonOffset: ge.polygonOffset, polygonOffsetFactor: ge.polygonOffsetFactor, polygonOffsetUnits: ge.polygonOffsetUnits }) }, this.restore = e => { if (!me) return; let t = this.getCacheMaterial(e); if (!t) return; "water" === this.type && (this.type = "metalness"); let i = util$1.cloneMaterial(t); if (this.replacePath = void 0, i.name = this.name, this._getRelatedNodes() instanceof Array) { for (let e of this._getRelatedNodes()) if (e.material === ge) e.material.dispose(), e.material = i; else if (e.material instanceof Array) for (let t in e.material) e.material[t] === ge && (e.material[t].dispose(), e.material[t] = i); util$1.disposeMaterial(ge), ge = i } me.dispose(); for (let e in ge) ge[e] instanceof Texture$1 && ge[e].image && (ge[e].name || (ge[e].name = `${ge.name}#${e}`)); this.initData({ materialOfThree: ge, id: ge.uuid, name: ge.name, type: "metalness", mapType: "metalness", color: ge.color, map: ge.map, mapIntensit: ge.mapIntensit, metalnessMap: ge.metalnessMap, metalnessIntensity: ge.metalness, roughnessMap: ge.roughnessMap, roughnessIntensity: ge.roughness, enableSpecularMap: !!ge.envMap, specularMapType: ge.envMap ? "custom" : "envmap", specularMap: ge.envMap, specularMapIntensity: ge.envMapIntensity / ENVMAP_FACTOR, enableNormalMap: !!ge.normalMap, normalMapType: "", normalMap: ge.normalMap, normalMapFlipY: ge.normalMapFlipY, normalMapIntensity: ge.normalScale ? ge.normalScale.x : 1, enableDisplacement: !!ge.displacementMap, displacementMap: ge.displacementMap, displacementIntensity: ge.displacementScale, enableOpacity: ge.transparent || !!ge.alphaMap, opacityType: "blend", opacityMap: ge.alphaMap, opacityIntensity: ge.opacity, opacityInverted: !1, emissive: ge.emissive || new Color$1(0, 0, 0), enableEmissive: !!ge.emissiveMap || !!ge.emissive && (0 !== ge.emissive.r || 0 !== ge.emissive.g || 0 !== ge.emissive.b), emissiveMap: ge.emissiveMap, emissiveIntensity: ge.emissiveIntensity, enableClearcoat: ge instanceof MeshPhysicalMaterial && "" === ge.defines.PHYSICAL, clearcoatMap: ge.clearcoatMap, sheen: ge.sheen, clearcoatThickness: ge.clearcoat, clearcoatNormalMap: ge.clearcoatNormalMap, clearcoatNormalScale: ge.clearcoatNormalScale, clearcoatRoughness: ge.clearcoatRoughness, clearcoatRoughnessMap: ge.clearcoatRoughnessMap, enableAOMap: !!ge.aoMap, aoMap: ge.aoMap, aoMapIntensity: ge.aoMapIntensity, enableLightMap: !!ge.lightMap, lightMap: ge.lightMap, lightMapIntensity: ge.lightMapIntensity, enableSSR: ge.enableSSR, envMapIntensity: ge.envMapIntensity, side: ge.side, depth: ge.depthTest && ge.depthWrite ? 2 : ge.depthTest || i.depthWrite ? 1 : 0, polygonOffset: ge.polygonOffset, polygonOffsetFactor: ge.polygonOffsetFactor, polygonOffsetUnits: ge.polygonOffsetUnits }), ge.needsUpdate = !0 }, this.toPhysicalMaterial = () => { if (!(ge instanceof MeshStandardMaterial)) return; if (ge instanceof MeshPhysicalMaterial) return; const e = new MeshPhysicalMaterial(ge); if (e.defines.PHYSICAL = "", this._getRelatedNodes() instanceof Array) { for (let t of this._getRelatedNodes()) if (t.material === ge) t.material.dispose(), t.material = e; else if (t.material instanceof Array) for (let i in t.material) t.material[i] === ge && (t.material[i].dispose(), t.material[i] = e); ge = e } }, this.toStandardMaterial = () => { ge instanceof MeshPhysicalMaterial && (ge = new MeshStandardMaterial(ge)) } } get replacePath() { return this._replacePath } set replacePath(e) { this._replacePath = e } get material() { return this._material } get id() { return this._id } get name() { return this._name } set name(e) { this._name = e } get type() { return this._type } set type(e) { if (e !== this._type) { switch (e.toLowerCase()) { case "specular": if ("water" === this._type) { let e = util$1.findMeshByMaterial(_context.scene, this._material()); e && e.length || _context.materialPreview && _context.materialPreview.scene && (e = util$1.findMeshByMaterial(_context.materialPreview.scene, this._material(), this._copies)); for (let t of e) { let e = t.getObjectByName(t.name + this._material().name + "_water_"); if (e && (util$1.removeFromObjectsNeedsUpdate(e), e.geometry.dispose(), e.material.dispose(), t.remove(e), this._getWaterAnimationList())) { let e = this._getWaterAnimationList().get(t); e && (e.needsRemove = !0) } t.position.y -= this._waterOffsetY } this._material().transparent = this._material().userData.transparent, this._material().opacity = this._material().userData.opacity } let t = { "skybox-blue": "texture/cubemap/CubeMap-CityDay-01_Cube.dds", "skybox-blue07": "texture/cubemap/CubeMap-CityDay-01_Cube.dds", "skybox-day": "texture/cubemap/CubeMap-CityDay-01_Cube.dds", "skybox-day2": "texture/cubemap/CubeMap-CityDay-01_Cube.dds", "skybox-dusk": "texture/cubemap/CubeMap-CityDay-01_Cube.dds", "skybox-night": "texture/cubemap/CubeMap-CityDay-01_Cube.dds", "skybox-real": "texture/cubemap/CubeMap-CityDay-01_Cube.dds", "skybox-day-10": "texture/cubemap/skybox-day-10/specularmap.dds", "skybox-day-18": "texture/cubemap/skybox-day-18/specularmap.dds", "skybox-dusk-4": "texture/cubemap/skybox-dusk-4/specularmap.dds", "skybox-dusk-6": "texture/cubemap/skybox-dusk-6/specularmap.dds", "skybox-night-3": "texture/cubemap/skybox-night-3/specularmap.dds", "skybox-night-24": "texture/cubemap/skybox-night-24/specularmap.dds" }, i = _context.instance && _context.instance.getSkyboxName && _context.instance.getSkyboxName() || null; if (!i || "" === i) return; let r = t[i] || "texture/cubemap/CubeMap-CityDay-01_Cube.dds"; if (r) { let e = (new DDSLoader).load(this.url(r), (function (e) { e.magFilter = LinearFilter, e.minFilter = LinearFilter, e.mapping = CubeReflectionMapping })); if (this._material().envMap = e, this.specularMapIntensity = .4, this._material().envMap.needsUpdate = !0, this._material().needsUpdate = !0, this._copies instanceof Array) for (let t of this._copies) t.envMap = e, t.envMapIntensity = 2, t.envMap.needsUpdate = !0 } if ("custom" === this._specularMapType) { if (this._material().envMap = null, this._material().needsUpdate = !0, this._copies instanceof Array) for (let e of this._copies) e.envMap = null; this.specularMap = this._specularMap } break; case "water": if ("specular" === this._type && ("envmap" === this._specularMapType ? this._material().envMap = void 0 : "regular" === this._specularMapType && (this.specularMap = this._specularMap), this.specularMapIntensity = .2, this._material().needsUpdate = !0, this._copies instanceof Array)) for (let e of this._copies) e.envMap = null, e.envMapIntensity = 1; let n = util$1.findMeshByMaterial(_context.scene, this._material(), this._copies); n && n.length || _context.materialPreview && _context.materialPreview.scene && (n = util$1.findMeshByMaterial(_context.materialPreview.scene, this._material(), this._copies)); for (let e of n) { if (e.isWater = !0, e.parent instanceof Object3D) { let t = e.parent.getObjectByName(e.parent.name + this._material().name + "_water_"); if (t instanceof Mesh && (t.geometry.dispose(), t.material.dispose(), t.parent.remove(t), this._getWaterAnimationList())) { let t = this._getWaterAnimationList().get(e); t && (t.needsRemove = !0) } } for (let t = 0; t < e.children.length; t++)if (-1 != e.children[t].name.indexOf(e.name + this._material().name + "_water_") && (util$1.removeFromObjectsNeedsUpdate(e.children[t]), e.children[t].geometry.dispose(), e.children[t].material.dispose(), e.remove(e.children[t]), t--, this._getWaterAnimationList())) { let t = this._getWaterAnimationList().get(e); t && (t.needsRemove = !0) } if (e.geometry, e.geometry instanceof BufferGeometry) { let t = e.geometry.clone(); if (e.geometry.groups.length > 0) { let i = 0; for (let t in e.material) e.material[t] === this._material() && (i = parseInt(t)); let r = e.geometry.groups.find((e => e.materialIndex === i)); t.clearGroups(), t.addGroup(r.start, r.count, 0), t.setDrawRange(r.start, r.count) } let i = new Water(t, { textureWidth: this.waterReflectionQuality, textureHeight: this.waterReflectionQuality, waterNormals: (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, "texture/water/waternormals.jpg"), (function (e) { e.wrapS = e.wrapT = RepeatWrapping })), alpha: this.waterOpacity || .65, sunDirection: new Vector3, sunColor: 16777215, waterColor: this.waterColor || 7695, distortionScale: this.waterWave || 3.7, fog: !0, reflectionRate: this.waterReflectionRate || 1, yUp: !0, reflectionAutoUpdate: this.waterReflectionAutoUpdate }); i.name = e.name + this._material().name + "_water_"; const r = .39 * Math.PI, n = 2 * Math.PI * (.205 - .5); let a = new Vector3; a.x = Math.cos(n), a.y = Math.sin(n) * Math.sin(r), a.z = Math.sin(n) * Math.cos(r), i.receiveShadow = !0, i.material.transparent = !0, i.material.uniforms.sunDirection.value.copy(a).normalize(), i.needsUpdate = !0, e.add(i), util$1.addToObjectsNeedsUpdate(i), e.userData.y = e.position.y, e.position.y = e.userData.y + this._waterOffsetY; let o = new WaterAnimationController(i.material, this.waterFlowSpeed || .25); this._getWaterAnimationList().set(e, o), _context.animationStore && _context.animationStore.add(o) } } if (this._material().userData || (this._material().userData = {}), this._material(), this._material().userData.transparent = this._material().transparent, this._material().userData.opacity = this._material().opacity, this._material().transparent = !0, this._material().opacity = 0, this._copies instanceof Array) for (let e of this._copies) e.userData || (e.userData = {}), e.userData.transparent = e.transparent, e.userData.opacity = e.opacity, e.transparent = !0, e.opacity = 0; break; case "metalness": if ("water" === this._type) { let e = util$1.findMeshByMaterial(_context.scene, this._material(), this._copies); e && e.length || _context.materialPreview && _context.materialPreview.scene && (e = util$1.findMeshByMaterial(_context.materialPreview.scene, this._material(), this._copies)); for (let t of e) { let e = t.getObjectByName(t.name + this._material().name + "_water_"); if (e && (util$1.removeFromObjectsNeedsUpdate(e), e.geometry.dispose(), e.material.dispose(), t.remove(e), this._getWaterAnimationList())) { let e = this._getWaterAnimationList().get(t); e && (e.needsRemove = !0) } t.position.y -= this._waterOffsetY } if (this._material().transparent = this._material().userData.transparent, this._material().opacity = this._material().userData.opacity, this._copies instanceof Array) for (let e of this._copies) e.transparent = e.userData.transparent, e.opacity = e.userData.opacity } if ("specular" === this._type && (this._type = e, "envmap" === this._specularMapType ? this._material().envMap = void 0 : "regular" === this._specularMapType && (this.specularMap = this._specularMap), this.specularMapIntensity = .2, this._material().needsUpdate = !0, this._copies instanceof Array)) for (let e of this._copies) e.envMap = null, e.envMapIntensity = 1 }this._type = e } } get mapType() { return this._mapType } set mapType(e) { } get color() { return logger.debug("TRACE: Material.color (getter) - Entering."), this._color } set color(e) { logger.debug("TRACE: Material.color (setter) - Entering."), logger.debug("TRACE: Material.color (setter) - Exiting."), this._color = e; let t = new Color$1(e); if (this._material()) { if (this._material().color) { let e = util$1.colorToRGBAObject(this._color); this._material().color.r = e.r * this._mapIntensit, this._material().color.g = e.g * this._mapIntensit, this._material().color.b = e.b * this._mapIntensit } else { this._material().color = t; let e = util$1.colorToRGBAObject(this._color); this._material().color.r = e.r * this._mapIntensit, this._material().color.g = e.g * this._mapIntensit, this._material().color.b = e.b * this._mapIntensit } this._material().needsUpdate = !0 } if (this._copies instanceof Array) for (let e of this._copies) if (e) if (e.color) { let t = util$1.colorToRGBAObject(this._color); e.color.r = t.r * this._mapIntensit, e.color.g = t.g * this._mapIntensit, e.color.b = t.b * this._mapIntensit } else { e.color = new Color$1(t); let t = util$1.colorToRGBAObject(this._color); e.color.r = t.r * this._mapIntensit, e.color.g = t.g * this._mapIntensit, e.color.b = t.b * this._mapIntensit } } get map() { return logger.debug("TRACE: Material.map (getter) - Entering."), logger.debug("TRACE: Material.map (getter) - Exiting."), void 0 === this._map._source && "imagebitmap" === this._map._type && (this._map._source = this._color, this._map._type = "color"), this._map } set map({ type: e = "color", source: t = "#ffffff", reset: i = !1 }) { if (logger.debug("TRACE: Material.map (setter) - Entering."), "color" !== e.toLowerCase()) if ("imagebitmap" !== e.toLowerCase()) e.toLowerCase(), logger.debug("TRACE: Material.map (setter) - Exiting."); else { if (t && "#ffffff" !== t && "" !== t) { if (this._map.type = "imagebitmap", this._map._name = t.name, this._map.source = t, this._material() && (this._material().map ? this._material().map.image !== t.textureSource && (this._material().map = this._material().map.clone(), this._material().map.image = t.textureSource, this._material().map.name = t.name, this._material().map.needsUpdate = !0) : (this._material().map = new Texture$1(t.textureSource), this._material().map.name = t.name, this._material().map.encoding = 3001, this._material().map.flipY = !1, this._material().map.format = 1022, this._material().map.version = 10, this._material().needsUpdate = !0), "number" == typeof this._map.source._wrapS && this._map.source._wrapS >= 1e3 && (this._material().map.wrapS = this._map.source._wrapS), "number" == typeof this._map.source._wrapT && this._map.source._wrapT >= 1e3 && (this._material().map.wrapT = this._map.source._wrapT), this.enableUV && (this.enableUV = !0), this._material().color ? this._material().color.setStyle(this._color) : this._material().color = new Color$1(this._color)), this._copies instanceof Array) for (let e of this._copies) e && (e.map ? (e.map = e.map.clone(), e.map.image = t.textureSource, e.map.name = t.name) : (e.map = new Texture$1(t.textureSource), e.map.name = t.name, e.map.encoding = 3001, e.map.flipY = !1, e.map.format = 1022, e.map.version = 10), "number" == typeof this._map.source._wrapS && this._map.source._wrapS >= 1e3 && (e.map.wrapS = this._map.source._wrapS), "number" == typeof this._map.source._wrapT && this._map.source._wrapT >= 1e3 && (e.map.wrapT = this._map.source._wrapT), this.enableUV && (this.enableUV = !0), e.color ? e.color.setStyle(this._color) : e.color = new Color$1(this._color)); return this.mapIntensit = this.mapIntensit, void logger.debug("TRACE: Material.map (setter) - Exiting.") } if (this._map._type = "imagebitmap", this._map._name = "", this._map._source = "", this._material() && this._material().map && (this._material().map.dispose && this._material().map.dispose(), this._material().map = void 0, this._material().needsUpdate = !0), this._copies instanceof Array) for (let e of this._copies) e && e.map && (e.map.dispose && e.map.dispose(), e.map = void 0, e.needsUpdate = !0); logger.debug("TRACE: Material.map (setter) - Exiting.") } else { if (!util$1.isCSSColor(t)) return void logger.debug("TRACE: Material.map (setter) - Exiting."); if (this._map._source ? this._map._name = this._map._source._name : this._map._name = null, this._color = t, this._material()) if (this._material().map && (this._material().needsUpdate = !0), this._material().color) { let e = util$1.colorToRGBAObject(this._color); this._material().color.r = e.r * this._mapIntensit, this._material().color.g = e.g * this._mapIntensit, this._material().color.b = e.b * this._mapIntensit, this._material().map = null } else { this._material().color = new Color$1(this._color); let e = util$1.colorToRGBAObject(this._color); this._material().color.r = e.r * this._mapIntensit, this._material().color.g = e.g * this._mapIntensit, this._material().color.b = e.b * this._mapIntensit, this._material().map = null } if (this._copies instanceof Array) for (let e of this._copies) if (e) if (e.color) { let t = util$1.colorToRGBAObject(this._color); e.color.r = t.r * this._mapIntensit, e.color.g = t.g * this._mapIntensit, e.color.b = t.b * this._mapIntensit, e.map = null } else { e.color = new Color$1(this._color); let t = util$1.colorToRGBAObject(this._color); e.color.r = t.r * this._mapIntensit, e.color.g = t.g * this._mapIntensit, e.color.b = t.b * this._mapIntensit, e.map = null } if (i) { if (this._map._type = "imagebitmap", this._map._name = void 0, this._map._source = void 0, this._material() && this._material().map && (this._material().map.dispose(), this._material().map = null, this._material().needsUpdate = !0), this._copies instanceof Array) for (let e of this._copies) e && e.map && (e.map.dispose(), e.map = null); logger.debug("TRACE: Material.map (setter) - Exiting.") } logger.debug("TRACE: Material.map (setter) - Exiting.") } } get mapIntensit() { return logger.debug("TRACE: Material.mapIntensit (getter) - Entering."), this._mapIntensit } set mapIntensit(e) { if (logger.debug("TRACE: Material.mapIntensit (setter) - Entering."), logger.debug("TRACE: Material.mapIntensit (setter) - Exiting."), this._mapIntensit = e, this._material()) { if (this._color) { let t = util$1.colorToRGBAObject(this._color); this._material().color.r = t.r * e, this._material().color.g = t.g * e, this._material().color.b = t.b * e } this._material().needsUpdate = !0 } if (this._copies instanceof Array) for (let t of this._copies) if (t && this._color) { let i = util$1.colorToRGBAObject(this._color); t.color.r = i.r * e, t.color.g = i.g * e, t.color.b = i.b * e } } get metalnessMap() { return logger.debug("TRACE: Material.metalnessMap (getter) - Entering."), logger.debug("TRACE: Material.metalnessMap (getter) - Exiting."), this._metalnessMap } set metalnessMap({ type: e, source: t }) { if (logger.debug("TRACE: Material.metalnessMap (setter) - Entering."), "imagebitmap" === e.toLowerCase() && t instanceof Texture) { if (this._metalnessMap.type = "imagebitmap", this._metalnessMap._name = t.name, this._metalnessMap.source = t, this._material() && (this._material().metalnessMap && this._material().metalnessMap.image !== this._metalnessMap.source.textureSource ? (this._material().metalnessMap.image = this._metalnessMap.source.textureSource, this._material().metalnessMap.name = this._metalnessMap.source.name, this._material().metalnessMap.needsUpdate = !0, this._material().needsUpdate = !0) : this._material().metalnessMap || (this._material().metalnessMap = new Texture$1(this._metalnessMap.source.textureSource), this._material().metalnessMap.name = this._metalnessMap.source.name, this._material().metalnessMap.flipY = !1, this._material().metalnessMap.needsUpdate = !0, this._material().needsUpdate = !0), "number" == typeof this._metalnessMap.source._wrapS && this._metalnessMap.source._wrapS >= 1e3 && (this._material().metalnessMap.wrapS = this._metalnessMap.source._wrapS), "number" == typeof this._metalnessMap.source._wrapT && this._metalnessMap.source._wrapT >= 1e3 && (this._material().metalnessMap.wrapT = this._metalnessMap.source._wrapT), this.enableUV && (this.enableUV = !0)), this._copies instanceof Array) for (let e of this._copies) e && (e.metalnessMap ? (e.metalnessMap.image = this._metalnessMap.source.textureSource, e.metalnessMap.name = this._metalnessMap.source.name) : (e.metalnessMap = new Texture$1(this._metalnessMap.source.textureSource), e.metalnessMap.name = this._metalnessMap.source.name, e.metalnessMap.flipY = !1), "number" == typeof this._metalnessMap.source._wrapS && this._metalnessMap.source._wrapS >= 1e3 && (e.metalnessMap.wrapS = this._metalnessMap.source._wrapS), "number" == typeof this._metalnessMap.source._wrapT && this._metalnessMap.source._wrapT >= 1e3 && (e.metalnessMap.wrapT = this._metalnessMap.source._wrapT), this.enableUV && (this.enableUV = !0), e.metalnessMap.needsUpdate = !0), e.needsUpdate = !0; logger.debug("TRACE: Material.metalnessMap (setter) - Exiting.") } else { if ("imagebitmap" === e.toLowerCase() && !t) { if (this._material() && (this._material().metalnessMap = null, this._material().needsUpdate = !0), this._copies instanceof Array) for (let e of this._copies) e && (e.metalnessMap = null), e.needsUpdate = !0; return this._metalnessMap.type = "imagebitmap", this._metalnessMap._name = "", this._metalnessMap.source = "", void logger.debug("TRACE: Material.metalnessMap (setter) - Exiting.") } e.toLowerCase(), logger.debug("TRACE: Material.metalnessMap (setter) - Exiting.") } } get metalnessIntensity() { return logger.debug("TRACE: Material.metalnessIntensity (getter) - Entering."), logger.debug("TRACE: Material.metalnessIntensity (getter) - Exiting."), this._metalnessIntensity } set metalnessIntensity(e) { if (logger.debug("TRACE: Material.metalnessIntensity (setter) - Entering."), this._metalnessIntensity = e, this._material().metalness = this._metalnessIntensity, this._copies instanceof Array) for (let e of this._copies) e.metalness = this._metalnessIntensity; logger.debug("TRACE: Material.metalnessIntensity (setter) - Exiting.") } get roughnessMap() { return logger.debug("TRACE: Material.roughnessMap (getter) - Entering."), logger.debug("TRACE: Material.roughnessMap (getter) - Exiting."), this._roughnessMap } set roughnessMap({ type: e, source: t }) { if (logger.debug("TRACE: Material.roughnessMap (setter) - Entering."), "imagebitmap" === e.toLowerCase() && t instanceof Texture) { if (this._roughnessMap.type = "imagebitmap", this._roughnessMap._name = t.name, this._roughnessMap.source = t, this._material() && (this._material().roughnessMap && this._material().roughnessMap.image !== this._roughnessMap.source.textureSource ? (this._material().roughnessMap.image = this._roughnessMap.source.textureSource, this._material().roughnessMap.name = this._roughnessMap.source.name, this._material().roughnessMap.needsUpdate = !0, this._material().needsUpdate = !0) : this._material().roughnessMap || (this._material().roughnessMap = new Texture$1(this._roughnessMap.source.textureSource), this._material().roughnessMap.name = this._roughnessMap.source.name, this._material().roughnessMap.flipY = !1, this._material().roughnessMap.needsUpdate = !0, this._material().needsUpdate = !0), "number" == typeof this._roughnessMap.source._wrapS && this._roughnessMap.source._wrapS >= 1e3 && (this._material().roughnessMap.wrapS = this._roughnessMap.source._wrapS), "number" == typeof this._roughnessMap.source._wrapT && this._roughnessMap.source._wrapT >= 1e3 && (this._material().roughnessMap.wrapT = this._roughnessMap.source._wrapT), this.enableUV && (this.enableUV = !0)), this._copies instanceof Array) for (let e of this._copies) e && (e.roughnessMap ? (e.roughnessMap.image = this._roughnessMap.source.textureSource, e.roughnessMap.name = this._roughnessMap.source.name) : (e.roughnessMap = new Texture$1(this._roughnessMap.source.textureSource), e.roughnessMap.name = this._roughnessMap.source.name, e.roughnessMap.flipY = !1), "number" == typeof this._roughnessMap.source._wrapS && this._roughnessMap.source._wrapS >= 1e3 && (e.roughnessMap.wrapS = this._roughnessMap.source._wrapS), "number" == typeof this._roughnessMap.source._wrapT && this._roughnessMap.source._wrapT >= 1e3 && (e.roughnessMap.wrapT = this._roughnessMap.source._wrapT), this.enableUV && (this.enableUV = !0), e.roughnessMap.needsUpdate = !0); logger.debug("TRACE: Material.roughnessMap (setter) - Exiting.") } else { if ("imagebitmap" === e.toLowerCase() && !t) { if (this._material() && (this._material().roughnessMap = null, this._material().needsUpdate = !0), this._copies instanceof Array) for (let e of this._copies) e && (e.roughnessMap = null); return this._roughnessMap.type = "imagebitmap", this._roughnessMap._name = "", this._roughnessMap.source = "", void logger.debug("TRACE: Material.metalnessMap (setter) - Exiting.") } e.toLowerCase(), logger.debug("TRACE: Material.roughnessMap (setter) - Exiting.") } } get roughnessIntensity() { return logger.debug("TRACE: Material.roughnessIntensity (getter) - Entering."), logger.debug("TRACE: Material.roughnessIntensity (getter) - Exiting."), this._roughnessIntensity } set roughnessIntensity(e) { if (logger.debug("TRACE: Material.roughnessIntensity (setter) - Entering."), this._roughnessIntensity = e, this._material().roughness = 1 - Number(this._roughnessIntensity), this._copies instanceof Array) for (let e of this._copies) e.roughness = 1 - Number(this._roughnessIntensity); logger.debug("TRACE: Material.roughnessIntensity (setter) - Exiting.") } get enableSpecularMap() { return logger.debug("TRACE: Material.enableSpecularMap (getter) - Entering."), logger.debug("TRACE: Material.enableSpecularMap (getter) - Exiting."), this._enableSpecularMap } set enableSpecularMap(e) { if (logger.debug("TRACE: Material.enableSpecularMap (setter) - Entering."), "specular" !== this._type) if ("boolean" == typeof e) { if (this._enableSpecularMap = e, this._enableSpecularMap) this.specularMap = this._specularMap; else if ("specular" !== this.type && (this._material() && (this._material().envMap = null, this._material().needsUpdate = !0), this._copies instanceof Array)) for (let e of this._copies) e.envMap = null; logger.debug("TRACE: Material.enableSpecularMap (setter) - Exiting.") } else logger.debug("TRACE: Material.enableSpecularMap (setter) - Exiting."); else logger.debug("TRACE: Material.enableSpecularMap (setter) - Exiting.") } get specularMapType() { return this._specularMapType } set specularMapType(e) { this._specularMapType = e, "specular" !== this._type ? "envmap" === e ? (this._material().envMap = void 0, this._material().needsUpdate = !0) : "regular" === e && (this.specularMap = this._specularMap) : logger.debug("TRACE: Material.specularMapType (setter) - Exiting.") } get specularMap() { return logger.debug("TRACE: Material.specularMap (getter) - Entering."), logger.debug("TRACE: Material.specularMap (getter) - Exiting."), this._specularMap } set specularMap({ type: e, source: t }) { if (logger.debug("TRACE: Material.specularMap (setter) - Entering."), "specular" !== this._type) if ("color" === e.toLowerCase() && (this._material().envMap = void 0, this._material().needsUpdate = !0), "imagebitmap" === e.toLowerCase() && (t instanceof Texture || util$1.isImage(t) || "" === t)) { if (this._specularMap.type = "imagebitmap", this._specularMap._name = t.name, this._specularMap.source = t, "envmap" === this._specularMapType) return void logger.debug("TRACE: Material.specularMap (setter) - Exiting."); if ("specular" === this._type) return void logger.debug("TRACE: Material.specularMap (setter) - Exiting."); if (!this._enableSpecularMap) return void logger.debug("TRACE: Material.specularMap (setter) - Exiting."); if (this._material() && (t ? (this._material().envMap = new Texture$1(this._specularMap.source.textureSource), this._material().envMap.name = this._specularMap.source.name, this._material().envMap.flipY = !1, this._material().envMap.mapping = EquirectangularReflectionMapping, this._material().envMap.needsUpdate = !0, this._material().needsUpdate = !0) : (this._material().envMap = void 0, this._material().needsUpdate = !0)), this._copies instanceof Array) for (let e of this._copies) if (e) { let t = (new DDSLoader).load(this.url("texture/cubemap/CubeMap-CityDay-01_Cube.dds"), (function (e) { e.magFilter = LinearFilter, e.minFilter = LinearFilter, e.mapping = CubeReflectionMapping })); e.envMap = t, e.envMap.needsUpdate = !0 } logger.debug("TRACE: Material.specularMap (setter) - Exiting.") } else if ("file" !== e.toLowerCase() || "string" != typeof t || "" === t) logger.debug("TRACE: Material.specularMap (setter) - Exiting."); else { if (this._material()) { if (this._specularMap.type = "file", this._specularMap.source = t, this._material().envMap) { let e = (new DDSLoader).load(this.url(t), (function (e) { e.magFilter = LinearFilter, e.minFilter = LinearFilter, e.mapping = CubeReflectionMapping })); this._material().envMap = e } else { let e = (new DDSLoader).load(this.url(t), (function (e) { e.magFilter = LinearFilter, e.minFilter = LinearFilter, e.mapping = CubeReflectionMapping })); this._material().envMap = e } this._material().envMap.needsUpdate = !0 } if (this._copies instanceof Array) for (let e of this._copies) if (e) { if (this._specularMap.type = "file", this._specularMap.source = t, e.envMap) { let i = (new DDSLoader).load(this.url(t), (function (e) { e.magFilter = LinearFilter, e.minFilter = LinearFilter, e.mapping = CubeReflectionMapping })); e.envMap = i } else { let i = (new DDSLoader).load(this.url(t), (function (e) { e.magFilter = LinearFilter, e.minFilter = LinearFilter, e.mapping = CubeReflectionMapping })); e.envMap = i } e.envMap.needsUpdate = !0 } logger.debug("TRACE: Material.specularMap (setter) - Exiting.") } else logger.debug("TRACE: Material.specularMap (setter) - Exiting.") } get specularMapIntensity() { return logger.debug("TRACE: Material.specularMapIntensity (getter) - Entering."), logger.debug("TRACE: Material.specularMapIntensity (getter) - Exiting."), this._specularMapIntensity } set specularMapIntensity(e) { if (logger.debug("TRACE: Material.specularMapIntensity (setter) - Entering."), this._specularMapIntensity = e, logger.debug("TRACE: Material.specularMapIntensity (setter) - Exiting."), this._material().envMapIntensity = this._specularMapIntensity * ENVMAP_FACTOR, this._copies instanceof Array) for (let e of this._copies) e.envMapIntensity = this._specularMapIntensity * ENVMAP_FACTOR } get enableNormalMap() { return logger.debug("TRACE: Material.enableNormalMap (getter) - Entering."), logger.debug("TRACE: Material.enableNormalMap (getter) - Exiting."), this._enableNormalMap } set enableNormalMap(e) { if (logger.debug("TRACE: Material.enableNormalMap (setter) - Entering."), "boolean" == typeof e) { if (this._enableNormalMap = e, this._enableNormalMap) this.normalMap = { type: this._normalMap.type, source: this._normalMap.source, name: this._normalMap.name }; else if (this._material().normalMap = null, this._material().bumpMap = null, this._material().needsUpdate = !0, this._copies instanceof Array) for (let e of this._copies) e.normalMap = null, e.bumpMap = null; logger.debug("TRACE: Material.enableNormalMap (setter) - Exiting.") } else logger.debug("TRACE: Material.enableNormalMap (setter) - Exiting.") } get normalMapType() { return logger.debug("TRACE: Material.normalMapType (getter) - Entering."), logger.debug("TRACE: Material.normalMapType (getter) - Exiting."), this._normalMapType } set normalMapType(e) { if (logger.debug("TRACE: Material.normalMapType (setter) - Entering."), this._normalMapType = e, this._enableNormalMap) { if (logger.debug("TRACE: Material.normalMapType (setter) - Exiting."), this._material() && "imagebitmap" === this._normalMap.type && ("normal" === this._normalMapType ? (this._material().bumpMap = null, this._material().bumpScale = 0, this._normalMap.source ? (this._material().normalMap ? this._normalMap.source.textureSource ? (this._material().normalMap.image = this._normalMap.source.textureSource, this._material().normalMap.name = this._normalMap.source.name) : (this._material().normalMap.image = this._normalMap.source, this._material().normalMap.name = this._normalMap.name) : (this._material().normalMap = new Texture$1(this._normalMap.source.textureSource || this._normalMap.source), this._material().normalMap.name = this._normalMap.source.name || this._normalMap.name, this._material().normalMap.flipY = !1, this._material().normalMap.encoding = 3001, this._material().normalMap.format = 1022, this._material().normalMap.version = 10), "number" == typeof this._normalMap.source._wrapS && this._normalMap.source._wrapS >= 1e3 && (this._material().normalMap.wrapS = this._normalMap.source._wrapS), "number" == typeof this._normalMap.source._wrapT && this._normalMap.source._wrapT >= 1e3 && (this._material().normalMap.wrapT = this._normalMap.source._wrapT), this.enableUV && (this.enableUV = !0), this._material().normalMap.needsUpdate = !0) : this._material().normalMap = null, this._material().normalScale ? (this._material().normalScale.x = this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, this._material().normalScale.y = this._material().normalScale.x) : this._material().normalScale = new Vector2(this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity)) : "bump" === this._normalMapType && (this._material().normalMap = null, this._normalMap.source ? (this._material().bumpMap ? this._normalMap.source.textureSource ? (this._material().bumpMap.image = this._normalMap.source.textureSource, this._material().bumpMap.name = this._normalMap.source.name) : (this._material().bumpMap.image = this._normalMap.source, this._material().bumpMap.name = this._normalMap.name) : (this._material().bumpMap = new Texture$1(this._normalMap.source.textureSource || this._normalMap.source), this._material().bumpMap.name = this._normalMap.source.name || this._normalMap.name, this._material().bumpMap.encoding = 3001, this._material().bumpMap.flipY = !1, this._material().bumpMap.format = 1022, this._material().bumpMap.version = 10), "number" == typeof this._normalMap.source._wrapS && this._normalMap.source._wrapS >= 1e3 && (this._material().bumpMap.wrapS = this._normalMap.source._wrapS), "number" == typeof this._normalMap.source._wrapT && this._normalMap.source._wrapT >= 1e3 && (this._material().bumpMap.wrapT = this._normalMap.source._wrapT), this.enableUV && (this.enableUV = !0), this._material().bumpMap.needsUpdate = !0) : this._material().bumpMap = null, this._normalMapIntensity >= 0 && this._normalMapIntensity <= 10 && (this._material().bumpScale = this._normalMapIntensity)), this._material().needsUpdate = !0), this._copies instanceof Array) for (let e of this._copies) e && "imagebitmap" === this._normalMap.type && ("normal" === this._normalMapType ? (e.bumpMap = null, e.bumpScale = 0, this._normalMap.source ? (e.normalMap ? this._normalMap.source.textureSource ? (e.normalMap.image = this._normalMap.source.textureSource, e.normalMap.name = this._normalMap.source.name) : e.normalMap.image = this._normalMap.source : (e.normalMap = new Texture$1(this._normalMap.source.textureSource), e.normalMap.name = this._normalMap.source.name, e.normalMap.flipY = !1, e.normalMap.encoding = 3001, e.normalMap.format = 1022, e.normalMap.version = 10, this.enableUV && (this.enableUV = !0)), "number" == typeof this._normalMap.source._wrapS && this._normalMap.source._wrapS >= 1e3 && (e.normalMap.wrapS = this._normalMap.source._wrapS), "number" == typeof this._normalMap.source._wrapT && this._normalMap.source._wrapT >= 1e3 && (e.normalMap.wrapT = this._normalMap.source._wrapT), this.enableUV && (this.enableUV = !0), e.normalMap.needsUpdate = !0) : e.normalMap = null, e.normalScale ? (e.normalScale.x = this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, e.normalScale.y = e.normalScale.x) : e.normalScale = new Vector2(this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity)) : "bump" === this._normalMapType && (e.normalMap = null, this._normalMap.source ? (e.bumpMap ? this._normalMap.source.textureSource ? (e.bumpMap.image = this._normalMap.source.textureSource, e.bumpMap.name = this._normalMap.source.name) : (e.bumpMap.image = this._normalMap.source, e.bumpMap.name = this._normalMap.name) : (e.bumpMap = new Texture$1(this._normalMap.source.textureSource), e.bumpMap.name = this._normalMap.source.name, e.bumpMap.encoding = 3001, e.bumpMap.flipY = !1, e.bumpMap.format = 1022, e.bumpMap.version = 10, this.enableUV && (this.enableUV = !0)), "number" == typeof this._normalMap.source._wrapS && this._normalMap.source._wrapS >= 1e3 && (e.bumpMap.wrapS = this._normalMap.source._wrapS), "number" == typeof this._normalMap.source._wrapT && this._normalMap.source._wrapT >= 1e3 && (e.bumpMap.wrapT = this._normalMap.source._wrapT), this.enableUV && (this.enableUV = !0), e.bumpMap.needsUpdate = !0) : e.bumpMap = null, this._normalMapIntensity >= 0 && this._normalMapIntensity <= 10 && (e.bumpScale = this._normalMapIntensity))) } else logger.debug("TRACE: Material.normalMapType (setter) - Exiting.") } get normalMap() { return logger.debug("TRACE: Material.normalMap (getter) - Entering."), logger.debug("TRACE: Material.normalMap (getter) - Exiting."), this._normalMap } set normalMap({ type: e, source: t, name: i = "" }) { if (logger.debug("TRACE: Material.normalMap (setter) - Entering."), "imagebitmap" === e.toLowerCase() && (t instanceof Texture || util$1.isImage(t) || "" === t || void 0 === t)) { if (this._normalMap.type = "imagebitmap", t && t.name ? this._normalMap._name = t.name : this._normalMap._name = "" !== i ? i : null, t && (this._normalMap.name = t.name, this._normalMap.source = t), "" !== t && void 0 !== t || (this._normalMap.source = void 0), !this._enableNormalMap) return void logger.debug("TRACE: Material.normalMap (setter) - Exiting."); if (this._material() && ("normal" === this._normalMapType ? (this._material().bumpMap = null, this._normalMap.source ? (this._material().normalMap ? this._normalMap.source.textureSource ? (this._material().normalMap.image = this._normalMap.source.textureSource, this._material().normalMap.name = this._normalMap.source.name) : (this._material().normalMap.image = this._normalMap.source, this._material().normalMap.name = this._normalMap.name) : (this._material().normalMap = new Texture$1(this._normalMap.source.textureSource), this._material().normalMap.name = this._normalMap.source.name, this._material().normalMap.encoding = 3001, this._material().normalMap.flipY = !1, this._material().normalMap.format = 1022, this._material().normalMap.version = 10, this.enableUV && (this.enableUV = !0)), "number" == typeof this._normalMap.source._wrapS && this._normalMap.source._wrapS >= 1e3 && (this._material().normalMap.wrapS = this._normalMap.source._wrapS), "number" == typeof this._normalMap.source._wrapT && this._normalMap.source._wrapT >= 1e3 && (this._material().normalMap.wrapT = this._normalMap.source._wrapT), this.enableUV && (this.enableUV = !0), this._material().normalMap.needsUpdate = !0) : this._material().normalMap = null, this._material().normalScale ? (this._material().normalScale.x = this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, this._material().normalScale.y = this._material().normalScale.x) : this._material().normalScale = new Vector2(this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity)) : "bump" === this._normalMapType && (this._material().normalMap = null, this._normalMap.source ? (this._material().bumpMap ? this._normalMap.source.textureSource ? (this._material().bumpMap.image = this._normalMap.source.textureSource, this._material().bumpMap.name = this._normalMap.source.name) : (this._material().bumpMap.image = this._normalMap.source, this._material().bumpMap.name = this._normalMap.name) : (this._material().bumpMap = new Texture$1(this._normalMap.source.textureSource), this._material().bumpMap.name = this._normalMap.source.name, this._material().bumpMap.encoding = 3001, this._material().bumpMap.flipY = !1, this._material().bumpMap.format = 1022, this._material().bumpMap.version = 10, this.enableUV && (this.enableUV = !0)), "number" == typeof this._normalMap.source._wrapS && this._normalMap.source._wrapS >= 1e3 && (this._material().bumpMap.wrapS = this._normalMap.source._wrapS), "number" == typeof this._normalMap.source._wrapT && this._normalMap.source._wrapT >= 1e3 && (this._material().bumpMap.wrapT = this._normalMap.source._wrapT), this.enableUV && (this.enableUV = !0), this._material().bumpMap.needsUpdate = !0) : this._material().bumpMap = null, this._normalMapIntensity >= 0 && this._normalMapIntensity <= 10 && (this._material().bumpScale = this._normalMapIntensity)), this._material().needsUpdate = !0), this._copies instanceof Array) for (let e of this._copies) e && ("normal" === this._normalMapType ? (e.bumpMap = null, this._normalMap.source ? (e.normalMap ? this._normalMap.source.textureSource ? (e.normalMap.image = this._normalMap.source.textureSource, e.normalMap.name = this._normalMap.source.name) : (e.normalMap.image = this._normalMap.source, e.normalMap.name = this._normalMap.name) : (e.normalMap = new Texture$1(this._normalMap.source.textureSource || this._normalMap.source), e.normalMap.name = this._normalMap.source.name || this._normalMap.name, e.normalMap.encoding = 3001, e.normalMap.flipY = !1, e.normalMap.format = 1022, e.normalMap.version = 10, this.enableUV && (this.enableUV = !0)), "number" == typeof this._normalMap.source._wrapS && this._normalMap.source._wrapS >= 1e3 && (e.normalMap.wrapS = this._normalMap.source._wrapS), "number" == typeof this._normalMap.source._wrapT && this._normalMap.source._wrapT >= 1e3 && (e.normalMap.wrapT = this._normalMap.source._wrapT), this.enableUV && (this.enableUV = !0), e.normalMap.needsUpdate = !0) : e.normalMap = null, e.normalScale ? (e.normalScale.x = this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, e.normalScale.y = e.normalScale.x) : e.normalScale = new Vector2(this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity)) : "bump" === this._normalMapType && (e.normalMap = null, this._normalMap.source ? (e.bumpMap ? this._normalMap.source.textureSource ? (e.bumpMap.image = this._normalMap.source.textureSource, e.bumpMap.name = this._normalMap.source.name) : (e.bumpMap.image = this._normalMap.source, e.bumpMap.name = this._normalMap.name) : (e.bumpMap = new Texture$1(this._normalMap.source.textureSource || this._normalMap.source), e.bumpMap.name = this._normalMap.source.name || this._normalMap.name, e.bumpMap.encoding = 3001, e.bumpMap.flipY = !1, e.bumpMap.format = 1022, e.bumpMap.version = 10, this.enableUV && (this.enableUV = !0)), "number" == typeof this._normalMap.source._wrapS && this._normalMap.source._wrapS >= 1e3 && (e.bumpMap.wrapS = this._normalMap.source._wrapS), "number" == typeof this._normalMap.source._wrapT && this._normalMap.source._wrapT >= 1e3 && (e.bumpMap.wrapT = this._normalMap.source._wrapT), this.enableUV && (this.enableUV = !0), e.bumpMap.needsUpdate = !0) : e.bumpMap = null, this._normalMapIntensity >= 0 && this._normalMapIntensity <= 10 && (e.bumpScale = this._normalMapIntensity))); logger.debug("TRACE: Material.normalMap (setter) - Exiting.") } else e.toLowerCase(), logger.debug("TRACE: Material.normalMap (setter) - Exiting.") } get normalMapIntensity() { return logger.debug("TRACE: Material.normalMapIntensity (getter) - Entering."), logger.debug("TRACE: Material.normalMapIntensity (getter) - Exiting."), this._normalMapIntensity } set normalMapIntensity(e) { if (logger.debug("TRACE: Material.normalMapIntensity (setter) - Entering."), this._normalMapIntensity = e, this._enableNormalMap) { if ("normal" === this._normalMapType ? this._material().normalScale ? (this._material().normalScale.x = this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, this._material().normalScale.y = this._material().normalScale.x) : this._material().normalScale = new Vector2(this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity) : "bump" === this._normalMapType && this._normalMapIntensity >= 0 && this._normalMapIntensity <= 10 && (this._material().bumpScale = this._normalMapIntensity), this._material() && (this._material().needsUpdate = !0), this._copies instanceof Array) for (let e of this._copies) "normal" === this._normalMapType ? e.normalScale ? (e.normalScale.x = this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, e.normalScale.y = e.normalScale.x) : e.normalScale = new Vector2(this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity) : "bump" === this._normalMapType && this._normalMapIntensity >= 0 && this._normalMapIntensity <= 10 && (e.bumpScale = this._normalMapIntensity); logger.debug("TRACE: Material.normalMapIntensity (setter) - Exiting.") } else logger.debug("TRACE: Material.normalMapIntensity (setter) - Exiting.") } get normalMapTextureFlipY() { return logger.debug("TRACE: Material.normalMapTextureFlipY (getter) - Entering."), logger.debug("TRACE: Material.normalMapTextureFlipY (getter) - Exiting."), this._normalMapTextureFlipY } set normalMapTextureFlipY(e) { if (logger.debug("TRACE: Material.normalMapTextureFlipY (setter) - Entering."), "boolean" == typeof e) if (this._normalMapTextureFlipY = e, this._enableNormalMap) { if (this._material().normalScale ? (this._material().normalScale.x = this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, this._material().normalScale.y = this._material().normalScale.x) : this._material().normalScale = new Vector2(this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity), this._copies instanceof Array) for (let e of this._copies) e.normalScale ? (e.normalScale.x = this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, e.normalScale.y = e.normalScale.x) : e.normalScale = new Vector2(this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity, this._normalMapTextureFlipY ? -this._normalMapIntensity : this._normalMapIntensity); logger.debug("TRACE: Material.normalMapTextureFlipY (setter) - Exiting.") } else logger.debug("TRACE: Material.normalMapTextureFlipY (setter) - Exiting."); else logger.debug("TRACE: Material.normalMapTextureFlipY (setter) - Exiting.") } get enableDisplacement() { return logger.debug("TRACE: Material.enableDisplacement (getter) - Entering."), logger.debug("TRACE: Material.enableDisplacement (getter) - Exiting."), this._enableDisplacement } set enableDisplacement(e) { if (logger.debug("TRACE: Material.enableDisplacement (setter) - Entering."), "boolean" == typeof e) { if (this._enableDisplacement = e, this._enableDisplacement) this.displacementMap = this._displacementMap; else if (this._material().displacementMap = null, this._copies instanceof Array) for (let e of this._copies) e.displacementMap = null; this._material() && (this._material().needsUpdate = !0), logger.debug("TRACE: Material.enableDisplacement (setter) - Exiting.") } else logger.debug("TRACE: Material.enableDisplacement (setter) - Exiting.") } get displacementMap() { return logger.debug("TRACE: Material.displacementMap (getter) - Entering."), logger.debug("TRACE: Material.displacementMap (getter) - Exiting."), this._displacementMap } set displacementMap({ type: e, source: t }) { if (logger.debug("TRACE: Material.displacementMap (setter) - Entering."), "imagebitmap" === e.toLowerCase() && (t instanceof Texture || util$1.isImage(t) || "" === t)) { if (this._displacementMap.type = "imagebitmap", this._displacementMap._name = t.name, t instanceof Texture && (this._displacementMap.source = t), "" === t && (this._displacementMap.source = void 0), !this._enableDisplacement) return void logger.debug("TRACE: Material.displacementMap (setter) - Exiting."); if (this._material() && (this._displacementMap.source ? this._material().displacementMap && this._material().displacementMap.image !== this._displacementMap.source.textureSource ? (this._material().displacementMap.image = this._displacementMap.source.textureSource, this._material().displacementMap.name = this._displacementMap.source.name, this._material().displacementMap.needsUpdate = !0, this._material().needsUpdate = !0) : this._material().displacementMap || (this._material().displacementMap = new Texture$1(this._displacementMap.source.textureSource), this._material().displacementMap.name = this._displacementMap.source.name, this._material().displacementMap.flipY = !1, this.enableUV && (this.enableUV = !0), this._material().displacementMap.needsUpdate = !0, this._material().needsUpdate = !0) : (this._material().displacementMap = null, this._material().needsUpdate = !0)), this._copies instanceof Array) for (let e of this._copies) e && (this._displacementMap.source ? (e.displacementMap ? (e.displacementMap.image = this._displacementMap.source.textureSource, e.displacementMap.name = this._displacementMap.source.name) : (e.displacementMap = new Texture$1(this._displacementMap.source.textureSource), e.displacementMap.name = this._displacementMap.source.name, e.displacementMap.flipY = !1, this.enableUV && (this.enableUV = !0)), e.displacementMap.needsUpdate = !0) : e.displacementMap = null); logger.debug("TRACE: Material.displacementMap (setter) - Exiting.") } else e.toLowerCase(), logger.debug("TRACE: Material.displacementMap (setter) - Exiting.") } get displacementIntensity() { return logger.debug("TRACE: Material.displacementIntensity (getter) - Entering."), logger.debug("TRACE: Material.displacementIntensity (getter) - Exiting."), this._displacementIntensity } set displacementIntensity(e) { if (logger.debug("TRACE: Material.displacementIntensity (setter) - Entering."), this._displacementIntensity = e, this._material().displacementScale = this._displacementIntensity, this._copies instanceof Array) for (let e of this._copies) e.displacementScale = this._displacementIntensity; logger.debug("TRACE: Material.displacementIntensity (setter) - Exiting.") } get enableOpacity() { return logger.debug("TRACE: Material.enableOpacity (getter) - Entering."), logger.debug("TRACE: Material.enableOpacity (getter) - Exiting."), this._enableOpacity } set enableOpacity(e) { if (logger.debug("TRACE: Material.enableOpacity (setter) - Entering."), "boolean" == typeof e) { if ("water" !== this._type) { if (this._enableOpacity = e, this._enableOpacity ? (this._material().transparent = !0, this._material().opacity = this._opacityIntensity, this.opacityMap = this._opacityMap) : (this._material().transparent = !1, this._material().opacity = 1, this._material().alphaMap = null, this._material().needsUpdate = !0), this._copies instanceof Array) for (let e of this._copies) this._enableOpacity ? (e.transparent = !0, e.opacity = this._opacityIntensity, this.opacityMap = this._opacityMap) : (e.transparent = !1, e.opacity = 1, e.alphaMap = null); logger.debug("TRACE: Material.enableOpacity (setter) - Exiting.") } } else logger.debug("TRACE: Material.enableOpacity (setter) - Exiting.") } get opacityType() { return logger.debug("TRACE: Material.opacityType (getter) - Entering."), logger.debug("TRACE: Material.opacityType (getter) - Exiting."), this._opacityType } set opacityType(e) { if (logger.debug("TRACE: Material.opacityType (setter) - Entering."), "string" == typeof e) { switch (e.toLowerCase()) { case "blend": case "mask": case "refraction": case "refracting": break; default: return void logger.debug("TRACE: Material.opacityType (setter) - Exiting.") }switch (this._opacityType = e, this._opacityType.toLowerCase()) { case "blend": case "mask": case "refraction": case "refracting": break; default: return void logger.debug("TRACE: Material.opacityType (setter) - Exiting.") }logger.debug("TRACE: Material.opacityType (setter) - Exiting.") } else logger.debug("TRACE: Material.opacityType (setter) - Exiting.") } get opacityMap() { return logger.debug("TRACE: Material.opacityMap (getter) - Entering."), logger.debug("TRACE: Material.opacityMap (getter) - Exiting."), this._opacityMap } set opacityMap({ type: e, source: t }) { if (logger.debug("TRACE: Material.opacityMap (setter) - Entering."), "imagebitmap" === e.toLowerCase() && (t instanceof Texture || util$1.isImage(t) || "" === t)) { if (this._opacityMap.type = "imagebitmap", this._opacityMap._name = t.name, t instanceof Texture && (this._opacityMap.source = t), "" === t && (this._opacityMap.source = void 0), !this._enableOpacity) return void logger.debug("TRACE: Material.opacityMap (setter) - Exiting."); if (this._material() && (this._opacityMap.source ? (this._material().transparent = !0, this._material().opacity = this._opacityIntensity, this._material().alphaMap && this._material().alphaMap.image !== this._opacityMap.source.textureSource ? (this._material().alphaMap.image = this._opacityMap.source.textureSource, this._material().alphaMap.name = this._opacityMap.source.name, this._material().alphaMap.needsUpdate = !0, this._material().needsUpdate = !0) : this._material().alphaMap || (this._material().alphaMap = new Texture$1(this._opacityMap.source.textureSource), this._material().alphaMap.name = this._opacityMap.source.name, this._material().alphaMap.flipY = !1, this._material().alphaMap.needsUpdate = !0, this._material().needsUpdate = !0), "number" == typeof this._opacityMap.source._wrapS && this._opacityMap.source._wrapS >= 1e3 && (this._material().alphaMap.wrapS = this._opacityMap.source._wrapS), "number" == typeof this._opacityMap.source._wrapT && this._opacityMap.source._wrapT >= 1e3 && (this._material().alphaMap.wrapT = this._opacityMap.source._wrapT), this.enableUV && (this.enableUV = !0)) : (this._material().alphaMap = null, this._material().needsUpdate = !0)), this._copies instanceof Array) for (let e of this._copies) e && (this._opacityMap.source ? (e.transparent = !0, e.opacity = this._opacityIntensity, e.alphaMap ? (e.alphaMap.image = this._opacityMap.source.textureSource, e.alphaMap.name = this._opacityMap.source.name) : (e.alphaMap = new Texture$1(this._opacityMap.source.textureSource), e.alphaMap.name = this._opacityMap.source.name, e.alphaMap.flipY = !1), "number" == typeof this._opacityMap.source._wrapS && this._opacityMap.source._wrapS >= 1e3 && (e.alphaMap.wrapS = this._opacityMap.source._wrapS), "number" == typeof this._opacityMap.source._wrapT && this._opacityMap.source._wrapT >= 1e3 && (e.alphaMap.wrapT = this._opacityMap.source._wrapT), this.enableUV && (this.enableUV = !0), e.alphaMap.needsUpdate = !0) : e.alphaMap = null, e.needsUpdate = !0); logger.debug("TRACE: Material.opacityMap (setter) - Exiting.") } else e.toLowerCase(), logger.debug("TRACE: Material.opacityMap (setter) - Exiting.") } get opacityIntensity() { return logger.debug("TRACE: Material.opacityIntensity (getter) - Entering."), logger.debug("TRACE: Material.opacityIntensity (getter) - Exiting."), this._opacityIntensity } set opacityIntensity(e) { if (logger.debug("TRACE: Material.opacityIntensity (setter) - Entering."), this._opacityIntensity = e, this._enableOpacity) { if (this._material() && (this._material().transparent = !0, this._material().opacity = this._opacityIntensity), this._copies instanceof Array) for (let e of this._copies) e && (e.transparent = !0, e.opacity = this._opacityIntensity); logger.debug("TRACE: Material.opacityIntensity (setter) - Exiting.") } else logger.debug("TRACE: Material.opacityIntensity (setter) - Exiting.") } get enableEmissive() { return logger.debug("TRACE: Material.enableEmissive (getter) - Entering."), logger.debug("TRACE: Material.enableEmissive (getter) - Exiting."), this._enableEmissive } set enableEmissive(e) { if (logger.debug("TRACE: Material.enableEmissive (setter) - Entering."), "boolean" == typeof e) { if (this._enableEmissive = e, this._enableEmissive) this.emissiveMap = this.emissiveMap, this.emissiveMapColor = this.emissiveMapColor; else if (this._material().emissiveMap = void 0, this._material().emissive && (this._material().emissive.r = 0, this._material().emissive.g = 0, this._material().emissive.b = 0), this._material().emissiveIntensity = 0, this._material().needsUpdate = !0, this._copies instanceof Array) for (let e of this._copies) void 0 === e.emissiveMap ? e.emissiveMap = void 0 : e.emissiveMap.image = void 0, e.emissive && (e.emissive.r = 0, e.emissive.g = 0, e.emissive.b = 0), e.emissiveIntensity = 0; logger.debug("TRACE: Material.enableEmissive (setter) - Exiting.") } else logger.debug("TRACE: Material.enableEmissive (setter) - Exiting.") } get emissiveMapColor() { return this._emissiveMapColor } set emissiveMapColor(e) { if (this._emissiveMapColor = e, this._enableEmissive) { if (this._material() && (this._material().emissive && this._material().emissive.setStyle(this._emissiveMapColor), this._material().emissiveIntensity = this._emissiveIntensity), this._material().needsUpdate = !0, this._copies instanceof Array) for (let e of this._copies) e && (e.emissive && e.emissive.setStyle(this._emissiveMapColor), e.emissiveIntensity = this._emissiveIntensity); logger.debug("TRACE: Material.emissiveMap (setter) - Exiting.") } else logger.debug("TRACE: Material.emissiveMap (setter) - Exiting.") } get emissiveMap() { return logger.debug("TRACE: Material.emissiveMap (getter) - Entering."), logger.debug("TRACE: Material.emissiveMap (getter) - Exiting."), this._emissiveMap.color = this.emissiveMapColor, this._emissiveMap._color = this.emissiveMapColor, this._emissiveMap } set emissiveMap({ type: e, source: t, color: i, reset: r = !1 }) { if (logger.debug("TRACE: Material.emissiveMap (setter) - Entering."), "color" === e.toLowerCase()) return util$1.isCSSColor(i) ? (this.emissiveMap._source ? this.emissiveMap._name = this.emissiveMap._source._name : this.emissiveMap._name = void 0, this.emissiveMapColor = i, void (r && (this._material().emissiveMap = void 0))) : void logger.debug("TRACE: Material.emissiveMap (setter) - Exiting."); if ("imagebitmap" === e.toLowerCase() && (t instanceof Texture || util$1.isImage(t) || void 0 === t || "" === t)) { if (this._emissiveMap._type = "imagebitmap", this._emissiveMap._name = t ? t.name : "", t instanceof Texture && (this._emissiveMap.source = t), "" !== t && void 0 !== t || (this._emissiveMap.source = "", this._material().emissiveMap = void 0), !this._enableEmissive) return void logger.debug("TRACE: Material.emissiveMap (setter) - Exiting."); if (this._material() && (this._emissiveMap.source ? (this._material().emissiveMap ? (this._material().emissiveMap.image = this._emissiveMap.source.textureSource || this._emissiveMap.source, this._material().emissiveMap.name = this._emissiveMap.source.name || this._emissiveMap.name, this._material().emissive && 0 == this._material().emissive.r && 0 == this._material().emissive.g && 0 == this._material().emissive.b && (this._material().emissive.r = 1, this._material().emissive.g = 1, this._material().emissive.b = 1)) : (this._material().emissiveMap = new Texture$1(this._emissiveMap.source.textureSource || this._emissiveMap.source), this._material().emissiveMap.name = this._emissiveMap.source.name || this._emissiveMap.name, this._material().emissiveMap.encoding = 3001, this._material().emissiveMap.flipY = !1, this._material().emissiveMap.format = 1022, this._material().emissiveMap.version = 10, this._material().emissive && 0 == this._material().emissive.r && 0 == this._material().emissive.g && 0 == this._material().emissive.b && (this._material().emissive.r = 1, this._material().emissive.g = 1, this._material().emissive.b = 1)), "number" == typeof this._emissiveMap.source._wrapS && this._emissiveMap.source._wrapS >= 1e3 && (this._material().emissiveMap.wrapS = this._emissiveMap.source._wrapS), "number" == typeof this._emissiveMap.source._wrapT && this._emissiveMap.source._wrapT >= 1e3 && (this._material().emissiveMap.wrapT = this._emissiveMap.source._wrapT), this.enableUV && (this.enableUV = !0), this._material().emissiveIntensity = this._emissiveIntensity, this._material().emissiveMap.needsUpdate = !0) : this._material().emissiveMap = void 0), this._copies instanceof Array) for (let e of this._copies) e && (this._emissiveMap.source ? (e.emissiveMap ? (e.emissiveMap.image = this._emissiveMap.source.textureSource || this._emissiveMap.source, e.emissiveMap.name = this._emissiveMap.source.name || this._emissiveMap.name, e.emissive && (e.emissive.r = 1, e.emissive.g = 1, e.emissive.b = 1)) : (e.emissiveMap = new Texture$1(this._emissiveMap.source.textureSource || this._emissiveMap.source), e.emissiveMap.name = this._emissiveMap.source.name || this._emissiveMap.name, e.emissiveMap.encoding = 3001, e.emissiveMap.flipY = !1, e.emissiveMap.format = 1022, e.emissiveMap.version = 10, e.emissive && 0 == e.emissive.r && 0 == e.emissive.g && 0 == e.emissive.b && (e.emissive.r = 1, e.emissive.g = 1, e.emissive.b = 1)), "number" == typeof this._emissiveMap.source._wrapS && this._emissiveMap.source._wrapS >= 1e3 && (e.emissiveMap.wrapS = this._emissiveMap.source._wrapS), "number" == typeof this._emissiveMap.source._wrapT && this._emissiveMap.source._wrapT >= 1e3 && (e.emissiveMap.wrapT = this._emissiveMap.source._wrapT), this.enableUV && (this.enableUV = !0), e.emissiveIntensity = this._emissiveIntensity, e.emissiveMap.needsUpdate = !0) : e.emissiveMap = void 0); return this.emissiveMapColor = this._emissiveMapColor, void logger.debug("TRACE: Material.emissiveMap (setter) - Exiting.") } e.toLowerCase(), logger.debug("TRACE: Material.emissiveMap (setter) - Exiting.") } get emissiveIntensity() { return logger.debug("TRACE: Material.emissiveIntensity (getter) - Entering."), logger.debug("TRACE: Material.emissiveIntensity (getter) - Exiting."), this._emissiveIntensity } set emissiveIntensity(e) { if (logger.debug("TRACE: Material.emissiveIntensity (setter) - Entering."), this._emissiveIntensity = e, this._material().emissiveIntensity = this._emissiveIntensity, this._copies instanceof Array) for (let e of this._copies) e.emissiveIntensity = this._emissiveIntensity; logger.debug("TRACE: Material.emissiveIntensity (setter) - Exiting.") } get enableClearcoat() { return logger.debug("TRACE: Material.enableClearcoat (getter) - Entering."), logger.debug("TRACE: Material.enableClearcoat (getter) - Exiting."), this._enableClearcoat } set enableClearcoat(e) { if (logger.debug("TRACE: Material.enableClearcoat (setter) - Entering."), "boolean" == typeof e) { if (this._enableClearcoat = e, this._enableClearcoat) this.toPhysicalMaterial(), this.clearcoatMap = this._clearcoatMap, this.clearcoatColor = this._clearcoatColor, this.clearcoatThickness = this._clearcoatThickness, this.clearcoatNormalMap = this._clearcoatNormalMap, this.clearcoatRoughness = this._clearcoatRoughness, this.clearcoatRoughnessMap = this._clearcoatRoughnessMap; else if (this._material().clearcoatMap = void 0, this._material().clearcoat = 0, this._material().sheen = null, this._material().clearcoatNormalMap = void 0, this._material().clearcoatRoughnessMap = void 0, this._material().clearcoatRoughness = 0, this._material().needsUpdate = !0, this._copies instanceof Array) for (let e of this._copies) e.clearcoat = 0, e.clearcoatNormalMap = null, e.clearcoatRoughnessMap = null, e.clearcoatRoughness = 0, e.clearcoatMap = null, e.needsUpdate = !0; logger.debug("TRACE: Material.enableClearcoat (setter) - Exiting.") } else logger.debug("TRACE: Material.enableClearcoat (setter) - Exiting.") } get clearcoatMap() { return logger.debug("TRACE: Material.clearcoatMap (getter) - Entering."), logger.debug("TRACE: Material.clearcoatMap (getter) - Exiting."), this._clearcoatMap.color = this.clearcoatColor, this._clearcoatMap._color = this.clearcoatColor, this._clearcoatMap } set clearcoatMap({ type: e, source: t, color: i, reset: r = !1 }) { if (logger.debug("TRACE: Material.clearcoatMap (setter) - Entering."), "color" === e.toLowerCase() && (this.clearcoatColor = i), "imagebitmap" === e.toLowerCase() && (t instanceof Texture || util$1.isImage(t) || "" === t)) { if (this._clearcoatMap.type = "imagebitmap", this._clearcoatMap._name = t.name, t instanceof Texture && (this._clearcoatMap.source = t), "" === t && (this._clearcoatMap.source = void 0), !this._enableClearcoat) return void logger.debug("TRACE: Material.clearcoatMap (setter) - Exiting."); if (this._enableClearcoat && this.toPhysicalMaterial(), this._material() && (this._clearcoatMap.source ? (this._material().clearcoatMap && this._material().clearcoatMap.image !== (this._clearcoatMap.source.textureSource || this._clearcoatMap.source) ? (this._material().clearcoatMap.image = this._clearcoatMap.source.textureSource || this._clearcoatMap.source, this._material().clearcoatMap.needsUpdate = !0, this._material().needsUpdate = !0) : this._material().clearcoatMap || (this._material().clearcoatMap = new Texture$1(this._clearcoatMap.source.textureSource || this._clearcoatMap.source), this._material().clearcoatMap.flipY = !1, this._material().clearcoatMap.needsUpdate = !0, this._material().needsUpdate = !0), "number" == typeof this._clearcoatMap.source._wrapS && this._clearcoatMap.source._wrapS >= 1e3 && (this._material().clearcoatMap.wrapS = this._clearcoatMap.source._wrapS), "number" == typeof this._clearcoatMap.source._wrapT && this._clearcoatMap.source._wrapT >= 1e3 && (this._material().clearcoatMap.wrapT = this._clearcoatMap.source._wrapT), this.enableUV && (this.enableUV = !0)) : (this._material().clearcoatMap = null, this._material().needsUpdate = !0)), this._copies instanceof Array) for (let e of this._copies) e && (this._clearcoatMap.source ? (e.clearcoatMap ? e.clearcoatMap.image = this._clearcoatMap.source.textureSource || this._clearcoatMap.source : (e.clearcoatMap = new Texture$1(this._clearcoatMap.source.textureSource || this._clearcoatMap.source), e.clearcoatMap.flipY = !1), "number" == typeof this._clearcoatMap.source._wrapS && this._clearcoatMap.source._wrapS >= 1e3 && (e.clearcoatMap.wrapS = this._clearcoatMap.source._wrapS), "number" == typeof this._clearcoatMap.source._wrapT && this._clearcoatMap.source._wrapT >= 1e3 && (e.clearcoatMap.wrapT = this._clearcoatMap.source._wrapT), this.enableUV && (this.enableUV = !0)) : e.clearcoatMap = null, e.needsUpdate = !0); logger.debug("TRACE: Material.clearcoatMap (setter) - Exiting.") } else e.toLowerCase(), logger.debug("TRACE: Material.clearcoatMap (setter) - Exiting.") } get clearcoatColor() { return this._clearcoatColor } set clearcoatColor(e) { if (logger.debug("TRACE: Material.clearcoatColor (getter) - Entering."), logger.debug("TRACE: Material.clearcoatColor (getter) - Exiting."), this._clearcoatColor = e, e) { let t = new Color$1(e); this._material() && this.enableClearcoat && (this._material().sheen = t, this._material().needsUpdate = !0) } else this._material() && this.enableClearcoat && (this._material().sheen = null, this._material().needsUpdate = !0) } get clearcoatThickness() { return logger.debug("TRACE: Material.clearcoatThickness (getter) - Entering."), logger.debug("TRACE: Material.clearcoatThickness (getter) - Exiting."), this._clearcoatThickness } set clearcoatThickness(e) { if (logger.debug("TRACE: Material.clearcoatThickness (setter) - Entering."), "number" == typeof e) { if (this._enableClearcoat && this.toPhysicalMaterial(), this._clearcoatThickness = e, this._enableClearcoat && (this._material().clearcoat = this._clearcoatThickness, this._copies instanceof Array)) for (let e of this._copies) e.clearcoat = this._clearcoatThickness; logger.debug("TRACE: Material.clearcoatThickness (setter) - Exiting.") } else logger.debug("TRACE: Material.clearcoatThickness (setter) - Exiting.") } get clearcoatNormalMap() { return logger.debug("TRACE: Material.clearcoatNormalMap (getter) - Entering."), logger.debug("TRACE: Material.clearcoatNormalMap (getter) - Exiting."), this._clearcoatNormalMap } set clearcoatNormalMap({ type: e, source: t, reset: i = !1 }) { if (logger.debug("TRACE: Material.clearcoatNormalMap (setter) - Entering."), "imagebitmap" === e.toLowerCase() && (t instanceof Texture || util$1.isImage(t) || "" === t)) { if (this._clearcoatNormalMap.type = "imagebitmap", this._clearcoatNormalMap._name = t.name, t instanceof Texture && (this._clearcoatNormalMap.source = t), "" === t && (this._clearcoatNormalMap.source = void 0), this._enableClearcoat && this.toPhysicalMaterial(), !this._enableClearcoat) return void logger.debug("TRACE: Material.clearcoatNormalMap (setter) - Exiting."); if (this._material() && (this._clearcoatNormalMap.source ? (this._material().clearcoatNormalMap && this._material().clearcoatNormalMap.image !== (this._clearcoatNormalMap.source.textureSource || this._clearcoatNormalMap.source) ? (this._material().clearcoatNormalMap.image = this._clearcoatNormalMap.source.textureSource || this._clearcoatNormalMap.source, this._material().clearcoatNormalMap.flipY = !1, this._material().clearcoatNormalMap.needsUpdate = !0, this._material().needsUpdate = !0) : this._material().clearcoatNormalMap || (this._material().clearcoatNormalMap = new Texture$1(this._clearcoatNormalMap.source.textureSource || this._clearcoatNormalMap.source), this._material().clearcoatNormalMap.flipY = !1, this._material().clearcoatNormalMap.needsUpdate = !0, this._material().needsUpdate = !0), "number" == typeof this._clearcoatNormalMap.source._wrapS && this._clearcoatNormalMap.source._wrapS >= 1e3 && (this._material().clearcoatNormalMap.wrapS = this._clearcoatNormalMap.source._wrapS), "number" == typeof this._clearcoatNormalMap.source._wrapT && this._clearcoatNormalMap.source._wrapT >= 1e3 && (this._material().clearcoatNormalMap.wrapT = this._clearcoatNormalMap.source._wrapT), this.enableUV && (this.enableUV = !0)) : (this._material().clearcoatNormalMap = null, this._material().needsUpdate = !0)), this._copies instanceof Array) for (let e of this._copies) e && (this._clearcoatNormalMap.source ? e.clearcoatNormalMap ? (e.clearcoatNormalMap.needsUpdate = !0, e.clearcoatNormalMap.image = this._clearcoatNormalMap.source.textureSource || this._clearcoatNormalMap.source) : (e.clearcoatNormalMap = new Texture$1(this._clearcoatNormalMap.source.textureSource || this._clearcoatNormalMap.source), e.clearcoatNormalMap.flipY = !1) : e.clearcoatNormalMap = null, "number" == typeof this._clearcoatNormalMap.source._wrapS && this._clearcoatNormalMap.source._wrapS >= 1e3 && (e.clearcoatNormalMap.wrapS = this._clearcoatNormalMap.source._wrapS), "number" == typeof this._clearcoatNormalMap.source._wrapT && this._clearcoatNormalMap.source._wrapT >= 1e3 && (e.clearcoatNormalMap.wrapT = this._clearcoatNormalMap.source._wrapT), this.enableUV && (this.enableUV = !0), e.needsUpdate = !0); logger.debug("TRACE: Material.clearcoatNormalMap (setter) - Exiting.") } else e.toLowerCase(), logger.debug("TRACE: Material.clearcoatNormalMap (setter) - Exiting.") } get clearcoatNormalScale() { return logger.debug("TRACE: Material.clearcoatNormalScale (getter) - Entering."), logger.debug("TRACE: Material.clearcoatNormalScale (getter) - Exiting."), this._clearcoatNormalScale } set clearcoatNormalScale(e) { if (logger.debug("TRACE: Material.clearcoatNormalScale (setter) - Entering."), "number" == typeof e) { if (this._enableClearcoat && this.toPhysicalMaterial(), this._clearcoatNormalScale = e, this._enableClearcoat) { if (this._material().clearcoatNormalScale instanceof Vector2 ? this._material().clearcoatNormalScale.set(Math.abs(this._clearcoatNormalScale), this._clearcoatNormalScale) : this._material().clearcoatNormalScale = new Vector2(Math.abs(this._clearcoatNormalScale), this._clearcoatNormalScale), this._copies instanceof Array) for (let e of this._copies) e.clearcoatNormalScale instanceof Vector2 ? e.clearcoatNormalScale.set(Math.abs(this._clearcoatNormalScale), this._clearcoatNormalScale) : e.clearcoatNormalScale = new Vector2(Math.abs(this._clearcoatNormalScale), this._clearcoatNormalScale); logger.debug("TRACE: Material.clearcoatNormalScale (setter) - Exiting.") } } else logger.debug("TRACE: Material.clearcoatNormalScale (setter) - Exiting.") } get clearcoatNormalMapFlipY() { return this._clearcoatNormalMapFlipY } set clearcoatNormalMapFlipY(e) { this._clearcoatNormalMapFlipY = e, this._enableClearcoat && this._material() && this._material().clearcoatNormalMap && (this._material().clearcoatNormalMap.flipY = !1, this._material().clearcoatNormalMap.needsUpdate = !0, this._material().needsUpdate = !0) } get clearcoatRoughness() { return logger.debug("TRACE: Material.clearcoatRoughness (getter) - Entering."), logger.debug("TRACE: Material.clearcoatRoughness (getter) - Exiting."), this._clearcoatRoughness } set clearcoatRoughness(e) { if (logger.debug("TRACE: Material.clearcoatRoughness (setter) - Entering."), "number" == typeof e) { if (this._enableClearcoat && this.toPhysicalMaterial(), this._clearcoatRoughness = e, this._enableClearcoat) { if (this._material().clearcoatRoughness = this._clearcoatRoughness, this._copies instanceof Array) for (let e of this._copies) e.clearcoatRoughness = this._clearcoatRoughness; logger.debug("TRACE: Material.clearcoatRoughness (setter) - Exiting.") } } else logger.debug("TRACE: Material.clearcoatRoughness (setter) - Exiting.") } get clearcoatRoughnessMap() { return logger.debug("TRACE: Material.clearcoatRoughnessMap (getter) - Entering."), logger.debug("TRACE: Material.clearcoatRoughnessMap (getter) - Exiting."), this._clearcoatRoughnessMap } set clearcoatRoughnessMap({ type: e, source: t, reset: i = !1 }) { if (logger.debug("TRACE: Material.clearcoatRoughnessMap (setter) - Entering."), "imagebitmap" === e.toLowerCase() && (t instanceof Texture || util$1.isImage(t) || "" === t)) { if (this._clearcoatRoughnessMap.type = "imagebitmap", this._clearcoatRoughnessMap._name = t.name, t instanceof Texture && (this._clearcoatRoughnessMap.source = t), "" === t && (this._clearcoatRoughnessMap.source = void 0), this._enableClearcoat && this.toPhysicalMaterial(), !this._enableClearcoat) return void logger.debug("TRACE: Material.clearcoatRoughnessMap (setter) - Exiting."); if (this._material() && (this._clearcoatRoughnessMap.source ? (this._material().clearcoatRoughnessMap && this._material().clearcoatRoughnessMap.image !== (this._clearcoatRoughnessMap.source.textureSource || this._clearcoatRoughnessMap.source) ? (this._material().clearcoatRoughnessMap.image = this._clearcoatRoughnessMap.source.textureSource || this._clearcoatRoughnessMap.source, this._material().clearcoatRoughnessMap.needsUpdate = !0, this._material().needsUpdate = !0) : this._material().clearcoatRoughnessMap || (this._material().clearcoatRoughnessMap = new Texture$1(this._clearcoatRoughnessMap.source.textureSource || this._clearcoatRoughnessMap.source), this._material().clearcoatRoughnessMap.flipY = !1, this._material().clearcoatRoughnessMap.needsUpdate = !0, this._material().needsUpdate = !0), "number" == typeof this._clearcoatRoughnessMap.source._wrapS && this._clearcoatRoughnessMap.source._wrapS >= 1e3 && (this._material().clearcoatRoughnessMap.wrapS = this._clearcoatRoughnessMap.source._wrapS), "number" == typeof this._clearcoatRoughnessMap.source._wrapT && this._clearcoatRoughnessMap.source._wrapT >= 1e3 && (this._material().clearcoatRoughnessMap.wrapT = this._clearcoatRoughnessMap.source._wrapT), this.enableUV && (this.enableUV = !0)) : (this._material().clearcoatRoughnessMap = null, this._material().needsUpdate = !0)), this._copies instanceof Array) for (let e of this._copies) e && (this._clearcoatRoughnessMap.source ? (e.clearcoatRoughnessMap ? e.clearcoatRoughnessMap.image = this._clearcoatRoughnessMap.source.textureSource || this._clearcoatRoughnessMap.source : (e.clearcoatRoughnessMap = new Texture$1(this._clearcoatRoughnessMap.source.textureSource || this._clearcoatRoughnessMap.source), e.clearcoatRoughnessMap.flipY = !1), "number" == typeof this._clearcoatRoughnessMap.source._wrapS && this._clearcoatRoughnessMap.source._wrapS >= 1e3 && (e.clearcoatRoughnessMap.wrapS = this._clearcoatRoughnessMap.source._wrapS), "number" == typeof this._clearcoatRoughnessMap.source._wrapT && this._clearcoatRoughnessMap.source._wrapT >= 1e3 && (e.clearcoatRoughnessMap.wrapT = this._clearcoatRoughnessMap.source._wrapT), this.enableUV && (this.enableUV = !0)) : e.clearcoatRoughnessMap = null, e.needsUpdate = !0); logger.debug("TRACE: Material.clearcoatRoughnessMap (setter) - Exiting.") } else e.toLowerCase(), logger.debug("TRACE: Material.clearcoatRoughnessMap (setter) - Exiting.") } get enableAOMap() { return logger.debug("TRACE: Material.enableAOMap (getter) - Entering."), logger.debug("TRACE: Material.enableAOMap (getter) - Exiting."), this._enableAOMap } set enableAOMap(e) { if (logger.debug("TRACE: Material.enableAOMap (setter) - Entering."), "boolean" == typeof e) { if (this._enableAOMap = e, this._enableAOMap) { if (this.aoMap = this._aoMap, this._getRelatedNodes() instanceof Array) for (let e of this._getRelatedNodes()) e.geometry && e.geometry.attributes && e.geometry.attributes.uv && !e.geometry.attributes.uv2 && e.geometry.setAttribute("uv2", new BufferAttribute(e.geometry.attributes.uv.array, 2)) } else if (this._material().aoMap = null, this._material().needsUpdate = !0, this._copies instanceof Array) for (let e of this._copies) e.aoMap = null, e.needsUpdate = !0; logger.debug("TRACE: Material.enableAOMap (setter) - Exiting.") } else logger.debug("TRACE: Material.enableAOMap (setter) - Exiting.") } get aoMap() { return logger.debug("TRACE: Material.aoMap (getter) - Entering."), logger.debug("TRACE: Material.aoMap (getter) - Exiting."), this._aoMap } set aoMap({ type: e, source: t }) { if (logger.debug("TRACE: Material.aoMap (setter) - Entering."), "imagebitmap" === e.toLowerCase() && t instanceof Texture || util$1.isImage(t) || "" === t) { if (this._aoMap.type = "imagebitmap", this._aoMap._name = t.name, this._aoMap.source = t, !this._enableAOMap) return void logger.debug("TRACE: Material.aoMap (setter) - Exiting."); if (this._material()) { if (this._material().aoMap ? "" === this._aoMap.source ? this._material().aoMap = null : (this._material().aoMap.image = this._aoMap.source.textureSource, this._material().aoMap.name = this._aoMap.source.name) : "" === this._aoMap.source ? this._material().aoMap = null : (this._material().aoMap = new Texture$1(this._aoMap.source.textureSource), this._material().aoMap.name = this._aoMap.source.name, this._material().aoMap.flipY = !1), "number" == typeof this._aoMap.source._wrapS && this._aoMap.source._wrapS >= 1e3 && (this._material().aoMap.wrapS = this._aoMap.source._wrapS), "number" == typeof this._aoMap.source._wrapT && this._aoMap.source._wrapT >= 1e3 && (this._material().aoMap.wrapT = this._aoMap.source._wrapT), this.enableUV && (this.enableUV = !0), this._getRelatedNodes() instanceof Array) for (let e of this._getRelatedNodes()) e.geometry && e.geometry.attributes && e.geometry.attributes.uv && !e.geometry.attributes.uv2 && e.geometry.setAttribute("uv2", new BufferAttribute(e.geometry.attributes.uv.array, 2)); this._material().aoMap && (this._material().aoMap.needsUpdate = !0), this._material().needsUpdate = !0 } if (this._copies instanceof Array) for (let e of this._copies) if (e) { if (e.aoMap ? "" === this._aoMap.source ? e.aoMap = null : (e.aoMap.image = this._aoMap.source.textureSource, e.aoMap.name = this._aoMap.source.name) : (e.aoMap = new Texture$1(this._aoMap.source.textureSource), e.aoMap.name = this._aoMap.source.name, e.aoMap.flipY = !1), "number" == typeof this._aoMap.source._wrapS && this._aoMap.source._wrapS >= 1e3 && (e.aoMap.wrapS = this._aoMap.source._wrapS), "number" == typeof this._aoMap.source._wrapT && this._aoMap.source._wrapT >= 1e3 && (e.aoMap.wrapT = this._aoMap.source._wrapT), this.enableUV && (this.enableUV = !0), this._getRelatedNodes() instanceof Array) for (let e of this._getRelatedNodes()) e.geometry && e.geometry.attributes && e.geometry.attributes.uv && !e.geometry.attributes.uv2 && e.geometry.setAttribute("uv2", new BufferAttribute(e.geometry.attributes.uv.array, 2)); e.aoMap && (e.aoMap.needsUpdate = !0), e.needsUpdate = !0 } logger.debug("TRACE: Material.aoMap (setter) - Exiting.") } else e.toLowerCase(), logger.debug("TRACE: Material.aoMap (setter) - Exiting.") } get aoMapIntensity() { return logger.debug("TRACE: Material.aoMapIntensity (getter) - Entering."), logger.debug("TRACE: Material.aoMapIntensity (getter) - Exiting."), this._aoMapIntensity } set aoMapIntensity(e) { if (logger.debug("TRACE: Material.aoMapIntensity (setter) - Entering."), this._aoMapIntensity = e, this._material().aoMapIntensity = this._aoMapIntensity, this._copies instanceof Array) for (let e of this._copies) e.aoMapIntensity = this._aoMapIntensity; logger.debug("TRACE: Material.aoMapIntensity (setter) - Exiting.") } get enableLightMap() { return logger.debug("TRACE: Material.enableLightMap (getter) - Entering."), logger.debug("TRACE: Material.enableLightMap (getter) - Exiting."), this._enableLightMap } set enableLightMap(e) { if (logger.debug("TRACE: Material.enableLightMap (setter) - Entering."), "boolean" == typeof e) { if (this._enableLightMap = e, this._enableLightMap) { if (this.lightMap = this._lightMap, this._getRelatedNodes() instanceof Array) for (let e of this._getRelatedNodes()) e.geometry && e.geometry.attributes && e.geometry.attributes.uv && !e.geometry.attributes.uv2 && e.geometry.setAttribute("uv2", new BufferAttribute(e.geometry.attributes.uv.array, 2)) } else if (this._material().lightMap = null, this._copies instanceof Array) for (let e of this._copies) e.lightMap = null; logger.debug("TRACE: Material.enableLightMap (setter) - Exiting.") } else logger.debug("TRACE: Material.enableLightMap (setter) - Exiting.") } get lightMap() { return logger.debug("TRACE: Material.lightMap (getter) - Entering."), logger.debug("TRACE: Material.lightMap (getter) - Exiting."), this._lightMap } set lightMap({ type: e, source: t }) { if (logger.debug("TRACE: Material.lightMap (setter) - Entering."), "imagebitmap" === e.toLowerCase() && t instanceof Texture || util$1.isImage(t) || "" === t) { if (this._lightMap.type = "imagebitmap", this._lightMap._name = t.name, this._lightMap.source = t, !this._enableLightMap) return void logger.debug("TRACE: Material.lightMap (setter) - Exiting."); if (this._material()) { if (this._material().lightMap ? "" === this._lightMap.source ? this._material().lightMap = null : (this._material().lightMap.image = this._lightMap.source.textureSource, this._material().lightMap.name = this._lightMap.source.name) : (this._material().lightMap = new Texture$1(this._lightMap.source.textureSource), this._material().lightMap.name = this._lightMap.source.name, this._material().lightMap.flipY = !1, this.enableUV && (this.enableUV = !0)), this._getRelatedNodes() instanceof Array) for (let e of this._getRelatedNodes()) e.geometry && e.geometry.attributes && e.geometry.attributes.uv && !e.geometry.attributes.uv2 && e.geometry.setAttribute("uv2", new BufferAttribute(e.geometry.attributes.uv.array, 2)); this._material().lightMap && (this._material().lightMap.needsUpdate = !0) } if (this._copies instanceof Array) for (let e of this._copies) if (e) { if (e.lightMap ? "" === this._lightMap.source ? e.lightMap = null : (e.lightMap.image = this._lightMap.source.textureSource, e.lightMap.name = this._lightMap.source.name) : (e.lightMap = new Texture$1(this._lightMap.source.textureSource), e.lightMap.name = this._lightMap.source.name, e.lightMap.flipY = !1, this.enableUV && (this.enableUV = !0)), this._getRelatedNodes() instanceof Array) for (let e of this._getRelatedNodes()) e.geometry && e.geometry.attributes && e.geometry.attributes.uv && !e.geometry.attributes.uv2 && e.geometry.setAttribute("uv2", new BufferAttribute(e.geometry.attributes.uv.array, 2)); e.lightMap && (e.lightMap.needsUpdate = !0) } logger.debug("TRACE: Material.lightMap (setter) - Exiting.") } else e.toLowerCase(), logger.debug("TRACE: Material.lightMap (setter) - Exiting.") } get lightMapIntensity() { return logger.debug("TRACE: Material.lightMapIntensity (getter) - Entering."), logger.debug("TRACE: Material.lightMapIntensity (getter) - Exiting."), this._lightMapIntensity } set lightMapIntensity(e) { if (logger.debug("TRACE: Material.lightMapIntensity (setter) - Entering."), this._lightMapIntensity = e, this._material().lightMapIntensity = this._lightMapIntensity, this._copies instanceof Array) for (let e of this._copies) e.lightMapIntensity = this._lightMapIntensity; logger.debug("TRACE: Material.lightMapIntensity (setter) - Exiting.") } get side() { return logger.debug("TRACE: Material.side (getter) - Entering."), logger.debug("TRACE: Material.side (getter) - Exiting."), this._side } set side(e) { switch (logger.debug("TRACE: Material.side (setter) - Entering."), this._side = e, this._side) { case 0: this._material().side = FrontSide, this._material().shadowSide = FrontSide; break; case 1: this._material().side = BackSide, this._material().shadowSide = BackSide; break; case 2: this._material().side = DoubleSide, this._material().shadowSide = DoubleSide }if (this._copies instanceof Array) for (let e of this._copies) switch (this._side) { case 0: e.side = FrontSide; break; case 1: e.side = BackSide; break; case 2: e.side = DoubleSide }logger.debug("TRACE: Material.side (setter) - Exiting.") } get depth() { return logger.debug("TRACE: Material.depth (getter) - Entering."), logger.debug("TRACE: Material.depth (getter) - Exiting."), this._depth } set depth(e) { switch (logger.debug("TRACE: Material.depth (setter) - Entering."), this._depth = e, this._depth) { case 0: this._material().depthWrite = !1, this._material().depthTest = !1; break; case 1: this._material().depthWrite = !1, this._material().depthTest = !0; break; case 2: this._material().depthWrite = !0, this._material().depthTest = !0 }if (this._copies instanceof Array) for (let e of this._copies) switch (this._depth) { case 0: e.depthWrite = !1, e.depthTest = !1; break; case 1: e.depthWrite = !1, e.depthTest = !0; break; case 2: e.depthWrite = !0, e.depthTest = !0 }logger.debug("TRACE: Material.depth (setter) - Exiting.") } get waterFlowSpeed() { return logger.debug("TRACE: Material.waterFlowSpeed (getter) - Entering."), logger.debug("TRACE: Material.waterFlowSpeed (getter) - Exiting."), this._waterFlowSpeed } set waterFlowSpeed(e) { if (logger.debug("TRACE: Material.waterFlowSpeed (setter) - Entering."), this._waterFlowSpeed = e, "water" != this._type) return; let t = util$1.findMeshByMaterial(_context.scene, this._material()); t && t.length || _context.materialPreview && _context.materialPreview.scene && (t = util$1.findMeshByMaterial(_context.materialPreview.scene, this._material(), this._copies)); for (let i of t) if (i.getObjectByName(i.name + this._material().name + "_water_")) { let t = _context.animationStore.findMaterialAnimation(i.getObjectByName(i.name + this._material().name + "_water_").material, "WaterAnimationController"); t && (t.speed = e) } logger.debug("TRACE: Material.waterFlowSpeed (setter) - Exiting.") } get waterOffsetY() { return logger.debug("TRACE: Material.waterOffsetY (getter) - Entering."), logger.debug("TRACE: Material.waterOffsetY (getter) - Exiting."), this._waterOffsetY } set waterOffsetY(e) { if (logger.debug("TRACE: Material.waterOffsetY (setter) - Entering."), this._waterOffsetY = e, "water" != this._type) return; let t = util$1.findMeshByMaterial(_context.scene, this._material()); t && t.length || _context.materialPreview && _context.materialPreview.scene && (t = util$1.findMeshByMaterial(_context.materialPreview.scene, this._material(), this._copies)); for (let i of t) { i.position.y = i.userData.y + e; let t = _context.defaultObjectTree.getItemByUUID(i.uuid); t && (t.transformNode = _context.instance.getModelTransformByUUID(i.uuid)) } logger.debug("TRACE: Material.waterOffsetY (setter) - Exiting.") } get waterColor() { return logger.debug("TRACE: Material.waterColor (getter) - Entering."), logger.debug("TRACE: Material.waterColor (getter) - Exiting."), this._waterColor } set waterColor(e) { if (logger.debug("TRACE: Material.waterColor (setter) - Entering."), "water" != this._type) return; this._waterColor = e; let t = util$1.findMeshByMaterial(_context.scene, this._material()); t && t.length || _context.materialPreview && _context.materialPreview.scene && (t = util$1.findMeshByMaterial(_context.materialPreview.scene, this._material(), this._copies)); for (let i of t) { let t = i.getObjectByName(i.name + this._material().name + "_water_"); t && (t.material.uniforms.waterColor.value = new Color$1(e)) } logger.debug("TRACE: Material.waterColor (setter) - Exiting.") } get waterReflectionAutoUpdate() { return logger.debug("TRACE: Material.waterReflectionAutoUpdate (getter) - Entering."), logger.debug("TRACE: Material.waterReflectionAutoUpdate (getter) - Exiting."), this._waterReflectionAutoUpdate } set waterReflectionAutoUpdate(e) { if (logger.debug("TRACE: Material.waterReflectionAutoUpdate (setter) - Entering."), "water" != this._type) return; this._waterReflectionAutoUpdate = e; let t = util$1.findMeshByMaterial(_context.scene, this._material()); t && t.length || _context.materialPreview && _context.materialPreview.scene && (t = util$1.findMeshByMaterial(_context.materialPreview.scene, this._material(), this._copies)); for (let i of t) { let t = i.getObjectByName(i.name + this._material().name + "_water_"); t && (t.reflectionAutoUpdate = e, t.needsUpdate = !0) } logger.debug("TRACE: Material.waterReflectionAutoUpdate (setter) - Exiting.") } get waterReflectionQuality() { return logger.debug("TRACE: Material.waterReflectionQuality (getter) - Entering."), logger.debug("TRACE: Material.waterReflectionQuality (getter) - Exiting."), this._waterReflectionQuality } set waterReflectionQuality(e) { if (logger.debug("TRACE: Material.waterReflectionQuality (setter) - Entering."), "water" != this._type) return; this._waterReflectionQuality = e; let t = util$1.findMeshByMaterial(_context.scene, this._material()); t && t.length || _context.materialPreview && _context.materialPreview.scene && (t = util$1.findMeshByMaterial(_context.materialPreview.scene, this._material(), this._copies)); for (let i of t) { let t = i.getObjectByName(i.name + this._material().name + "_water_"); t && t.getRenderTarget().setSize(e, e) } logger.debug("TRACE: Material.waterReflectionQuality (setter) - Exiting.") } get waterOpacity() { return logger.debug("TRACE: Material.waterOpacity (getter) - Entering."), logger.debug("TRACE: Material.waterOpacity (getter) - Exiting."), this._waterOpacity } set waterOpacity(e) { if (logger.debug("TRACE: Material.waterOpacity (setter) - Entering."), this._waterOpacity = e, "water" != this._type) return; let t = util$1.findMeshByMaterial(_context.scene, this._material()); t && t.length || _context.materialPreview && _context.materialPreview.scene && (t = util$1.findMeshByMaterial(_context.materialPreview.scene, this._material(), this._copies)); for (let i of t) { let t = i.getObjectByName(i.name + this._material().name + "_water_"); t && (t.material.uniforms.alpha.value = e) } logger.debug("TRACE: Material.waterOpacity (setter) - Exiting.") } get waterReflectionRate() { return logger.debug("TRACE: Material.waterReflectionRate (getter) - Entering."), logger.debug("TRACE: Material.waterReflectionRate (getter) - Exiting."), this._waterReflectionRate } set waterReflectionRate(e) { if (logger.debug("TRACE: Material.waterReflectionRate (setter) - Entering."), this._waterReflectionRate = e, "water" != this._type) return; let t = util$1.findMeshByMaterial(_context.scene, this._material()); t && t.length || _context.materialPreview && _context.materialPreview.scene && (t = util$1.findMeshByMaterial(_context.materialPreview.scene, this._material(), this._copies)); for (let i of t) { let t = i.getObjectByName(i.name + this._material().name + "_water_"); t && (t.material.uniforms.reflectionRate.value = e) } logger.debug("TRACE: Material.waterReflectionRate (setter) - Exiting.") } get waterWave() { return logger.debug("TRACE: Material.waterWave (getter) - Entering."), logger.debug("TRACE: Material.waterWave (getter) - Exiting."), this._waterWave } set waterWave(e) { if (logger.debug("TRACE: Material.waterWave (setter) - Entering."), this._waterWave = e, "water" != this._type) return; let t = util$1.findMeshByMaterial(_context.scene, this._material()); t && t.length || _context.materialPreview && _context.materialPreview.scene && (t = util$1.findMeshByMaterial(_context.materialPreview.scene, this._material(), this._copies)); for (let i of t) { let t = i.getObjectByName(i.name + this._material().name + "_water_"); t && (t.material.uniforms.distortionScale.value = e) } logger.debug("TRACE: Material.waterWave (setter) - Exiting.") } get enableSSR() { return logger.debug("TRACE: Material.enableSSR (getter) - Entering."), logger.debug("TRACE: Material.enableSSR (getter) - Exiting."), this._enableSSR } set enableSSR(e) { if (logger.debug("TRACE: Material.enableSSR (setter) - Entering."), "boolean" == typeof e) { if (_context && _context.effectStore && _context.effectStore.visualEffect && _context.effectStore.visualEffect._passes && _context.effectStore.visualEffect._passes.ssrPass && _context.effectStore.visualEffect._passes.ssrPass.ssrEffect) { if (this._enableSSR = e, this._enableSSR) { _context.effectStore.visualEffect._passes.ssrPass.ssrEffect.selects || (_context.effectStore.visualEffect._passes.ssrPass.ssrEffect.selects = []); for (let e = 0; e < this._getRelatedNodes().length; e++)_context.effectStore.visualEffect._passes.ssrPass.ssrEffect.selects.includes(this._getRelatedNodes()[e]) || _context.effectStore.visualEffect._passes.ssrPass.ssrEffect.selects.push(this._getRelatedNodes()[e]) } this._material().disableSSR = !this._enableSSR, logger.debug("TRACE: Material.enableSSR (setter) - Exiting.") } } else logger.debug("TRACE: Material.enableSSR (setter) - Exiting.") } get enableSSRMirror() { return logger.debug("TRACE: Material.enableSSR (getter) - Entering."), logger.debug("TRACE: Material.enableSSR (getter) - Exiting."), this._enableSSR } set enableSSRMirror(e) { if (logger.debug("TRACE: Material.enableSSR (setter) - Entering."), "boolean" == typeof e) { if (this._enableSSR = e, this._enableSSR) { this._enableSSR = !0; let e = null; for (let t = 0; t < _context.envMapIntensity.length; t++)_context.envMapIntensity[t].name === this.material().name && _context.envMapIntensity[t].modelName === this._modelName && (e = _context.envMapIntensity[t]); e ? e.Intensity = this._envMapIntensity : _context.envMapIntensity.push({ name: this.material().name, modelName: this._modelName, Intensity: 1 }), this._getRelatedNodes().forEach((e => { let t, i = _context.instance.defaultObjectTree.getItemByName(this._modelName); for (let r = 0; r < i.children.length && (t = util$1.findModelItemNodeByName(i.children[r], e.name), !t); r++); t && t.enableSSR && _context.instance.addCubeCamera(this._modelName, e, this._name) })) } else { this._enableSSR = !1; for (let e = 0; e < _context.envMapIntensity.length; e++)_context.envMapIntensity[e].name === this.material().name && _context.envMapIntensity[e].modelName === this._modelName && (_context.envMapIntensity[e].Intensity = 1); setTimeout((() => { this._getRelatedNodes().forEach((e => { for (let t = 0; t < _context.ssr.length; t++)if (_context.ssr[t].nodeName === e.name && _context.ssr[t].modelName === this._modelName) { if (!_context.instance.findMaterialInModel(_context.ssr[t].modelName, _context.ssr[t].materialName)._material().envMap) return; _context.instance.findMaterialInModel(_context.ssr[t].modelName, _context.ssr[t].materialName)._material().envMap.dispose(), _context.instance.findMaterialInModel(_context.ssr[t].modelName, _context.ssr[t].materialName)._material().envMap = null, _context.ssr.splice(t, 1), t-- } })) }), 10) } logger.debug("TRACE: Material.enableSSR (setter) - Exiting.") } else logger.debug("TRACE: Material.enableSSR (setter) - Exiting.") } get envMapIntensity() { return logger.debug("TRACE: Material.enableSSR (getter) - Entering."), logger.debug("TRACE: Material.enableSSR (getter) - Exiting."), this._envMapIntensity } set envMapIntensity(e) { } get enableTranslation() { return logger.debug("TRACE: Material.enableTranslation (getter) - Entering."), logger.debug("TRACE: Material.enableTranslation (getter) - Exiting."), this._enableTranslation } set enableTranslation(e) { logger.debug("TRACE: Material.enableTranslation (setter) - Entering."), this._enableTranslation = e, logger.debug("TRACE: Material.enableTranslation (setter) - Exiting.") } get translationSpeedU() { return logger.debug("TRACE: Material.translationSpeedU (getter) - Entering."), logger.debug("TRACE: Material.translationSpeedU (getter) - Exiting."), this._translationSpeedU } set translationSpeedU(e) { logger.debug("TRACE: Material.translationSpeedU (setter) - Entering."), this._translationSpeedU = e, logger.debug("TRACE: Material.translationSpeedU (setter) - Exiting.") } get translationSpeedV() { return logger.debug("TRACE: Material.translationSpeedV (getter) - Entering."), logger.debug("TRACE: Material.translationSpeedV (getter) - Exiting."), this._translationSpeedV } set translationSpeedV(e) { logger.debug("TRACE: Material.translationSpeedV (setter) - Entering."), this._translationSpeedV = e, logger.debug("TRACE: Material.translationSpeedV (setter) - Exiting.") } get enableUV() { return logger.debug("TRACE: Material.enableUV (getter) - Entering."), logger.debug("TRACE: Material.enableUV (getter) - Exiting."), this._enableUV } set enableUV(e) { logger.debug("TRACE: Material.enableUV (setter) - Entering."), this._enableUV = e; let t = ["map", "metalnessMap", "roughnessMap", "normalMap", "bumpMap", "alphaMap", "emissiveMap", "clearcoatMap", "clearcoatNormalMap", "clearcoatRoughnessMap", "aoMap"]; if (this._enableUV) { let e = this._findFirstAvailableMapForUV(); e && (this._material()._uvDefault || (this._material()._uvDefault = { repeat: e.repeat ? e.repeat.clone() : void 0, offset: e.offset ? e.offset.clone() : void 0 }), e.repeat.set(this.repeatU, this.repeatV), e.offset.set(this.offsetU, this.offsetV)), t.forEach((e => { this._material()[e] && this._material()[e].wrapS !== RepeatWrapping && (this._material()[e].wrapS = RepeatWrapping, this._material()[e].wrapT = RepeatWrapping, this._material()[e].needsUpdate = !0) })) } else { let e = this._findFirstAvailableMapForUV(); e && this._material()._uvDefault && (e.repeat.set(this._material()._uvDefault.repeat.x, this._material()._uvDefault.repeat.y), e.offset.set(this._material()._uvDefault.offset.x, this._material()._uvDefault.offset.y)), t.forEach((e => { this._material()[e] && this[`_${e}`] && this[`_${e}`].source && this._material()[e].wrapS !== this[`_${e}`].source._wrapS && (this._material()[e].wrapS = this[`_${e}`].source._wrapS, this._material()[e].wrapT = this[`_${e}`].source._wrapT, this._material()[e].needsUpdate = !0) })) } logger.debug("TRACE: Material.enableUV (setter) - Exiting.") } get repeatU() { return logger.debug("TRACE: Material.repeatU (getter) - Entering."), logger.debug("TRACE: Material.repeatU (getter) - Exiting."), this._repeatU } set repeatU(e) { if (logger.debug("TRACE: Material.repeatU (setter) - Entering."), this._repeatU = e, this._enableUV) { let e = this._findFirstAvailableMapForUV(); e && (e.repeat.x = this._repeatU), this.enableUV && (this.enableUV = !0) } logger.debug("TRACE: Material.repeatU (setter) - Exiting.") } get repeatV() { return logger.debug("TRACE: Material.repeatV (getter) - Entering."), logger.debug("TRACE: Material.repeatV (getter) - Exiting."), this._repeatV } set repeatV(e) { if (logger.debug("TRACE: Material.repeatV (setter) - Entering."), this._repeatV = e, this._enableUV) { let e = this._findFirstAvailableMapForUV(); e && (e.repeat.y = this._repeatV), this.enableUV && (this.enableUV = !0) } logger.debug("TRACE: Material.repeatV (setter) - Exiting.") } get offsetU() { return logger.debug("TRACE: Material.offsetU (getter) - Entering."), logger.debug("TRACE: Material.offsetU (getter) - Exiting."), this._offsetU } set offsetU(e) { if (logger.debug("TRACE: Material.offsetU (setter) - Entering."), this._offsetU = e, this._enableUV) { let e = this._findFirstAvailableMapForUV(); e && (e.offset.x = this.offsetU) } logger.debug("TRACE: Material.offsetU (setter) - Exiting.") } get offsetV() { return logger.debug("TRACE: Material.offsetV (getter) - Entering."), logger.debug("TRACE: Material.offsetV (getter) - Exiting."), this._offsetV } set offsetV(e) { if (logger.debug("TRACE: Material.offsetV (setter) - Entering."), this._offsetV = e, this._enableUV) { let e = this._findFirstAvailableMapForUV(); e && (e.offset.y = this.offsetV) } logger.debug("TRACE: Material.offsetV (setter) - Exiting.") } get relatedNodes() { return logger.debug("TRACE: Material.relatedNodes (getter) - Entering."), logger.debug("TRACE: Material.relatedNodes (getter) - Exiting."), this._getRelatedNodes() } set resourceBasePath(e) { this._resourceBasePath = e } get modelName() { return this._modelName } set modelName(e) { } get polygonOffset() { return this._polygonOffset } set polygonOffset(e) { this._polygonOffset = e, this._material() && (this._material().polygonOffset = e) } get polygonOffsetFactor() { return this._polygonOffsetFactor } set polygonOffsetFactor(e) { this._polygonOffsetFactor = e, this._material() && (this._material().polygonOffsetFactor = e) } get polygonOffsetUnits() { return this._polygonOffsetUnits } set polygonOffsetUnits(e) { this._polygonOffsetUnits = e, this._material() && (this._material().polygonOffsetUnits = e) } url(e) { return `${this._resourceBasePath}///${e}`.replace("/////", "/").replace("////", "/").replace("///", "/") } getSettings() { let e = {}; for (var t in this) t.indexOf("_") > -1 && -1 == t.indexOf("relatedNodes") && (e[t.replace("_", "")] = this[t.replace("_", "")]); return e } _findFirstAvailableMapForUV() { if (this._material()) return this._material().map || this._material().specularMap || this._material().displacementMap || this._material().normalMap || this._material().bumpMap || this._material().roughnessMap || this._material().metalnessMap || this._material().alphaMap || this._material().emissiveMap || this._material().clearcoatMap || this._material().clearcoatNormalMap || this._material().clearcoatRoughnessMap || this._material().aoMap } } Material._toThreeObject = function (e, t) { new MeshPhongMaterial }, Material._fromThreeObject = function (e, t = "") { if (!e) return; let i = new Material({ materialOfThree: e, id: e.uuid, name: e.name, type: "metalness", mapType: "metalness", color: e.color, map: e.map, mapIntensit: e.mapIntensit, metalnessMap: e.metalnessMap, metalnessIntensity: e.metalness, roughnessMap: e.roughnessMap, roughnessIntensity: e.roughness, enableSpecularMap: !!e.envMap, specularMapType: e.envMap ? "custom" : "envmap", specularMap: e.envMap, specularMapIntensity: e.envMapIntensity / ENVMAP_FACTOR, enableNormalMap: !!e.normalMap, normalMapType: "", normalMap: e.normalMap, normalMapFlipY: e.normalMapFlipY, normalMapIntensity: e.normalScale ? e.normalScale.x : 1, enableDisplacement: !!e.displacementMap, displacementMap: e.displacementMap, displacementIntensity: e.displacementScale, enableOpacity: e.transparent || !!e.alphaMap, opacityType: "blend", opacityMap: e.alphaMap, opacityIntensity: e.opacity, opacityInverted: !1, emissive: e.emissive || new Color$1(0, 0, 0), enableEmissive: !!e.emissiveMap || !!e.emissive && (0 !== e.emissive.r || 0 !== e.emissive.g || 0 !== e.emissive.b), emissiveMap: e.emissiveMap, emissiveIntensity: e.emissiveIntensity, enableClearcoat: e instanceof MeshPhysicalMaterial && "" === e.defines.PHYSICAL, clearcoatMap: e.clearcoatMap, sheen: e.sheen, clearcoatThickness: e.clearcoat, clearcoatNormalMap: e.clearcoatNormalMap, clearcoatNormalScale: e.clearcoatNormalScale, clearcoatRoughness: e.clearcoatRoughness, clearcoatRoughnessMap: e.clearcoatRoughnessMap, enableAOMap: !!e.aoMap, aoMap: e.aoMap, aoMapIntensity: e.aoMapIntensity, enableLightMap: !!e.lightMap, lightMap: e.lightMap, lightMapIntensity: e.lightMapIntensity, enableSSR: e.enableSSR, envMapIntensity: e.envMapIntensity, side: e.side, depth: e.depthTest && e.depthWrite ? 2 : e.depthTest || e.depthWrite ? 1 : 0, polygonOffset: e.polygonOffset, polygonOffsetFactor: e.polygonOffsetFactor, polygonOffsetUnits: e.polygonOffsetUnits }); return i._resourceBasePath = t, i }; class MaterialStore { constructor(e) { this._materials = new Object, this._textureStore = e } add(e, t, i, r) { let n = this._materials[e]; if (void 0 !== n) if (n._material().uuid === t.uuid) n.addRelatedNode(i); else { if (i.material instanceof Array) { for (let e = 0; e < i.material.length; e++)if (i.material[e].name === n.name) { i.material[e] = n._material(); break } } else i.material = n._material(); n.addRelatedNode(i) } else this._materials[e] = Material._fromThreeObject(t, _context.instance.resourceBasePath), this._materials[e].addRelatedNode(i), this._materials[e].addModelName(r) } clear() { this._materials = [] } find(e) { return this._materials[e] } getAll() { return this._materials } remove(e) { if (null != this._materials[e]) return delete this._materials[e], !0 } getSettings() { let e = {}; for (let t in this._materials) { let i = {}; for (let e in this._materials[t]) "_id" !== e && "_material" !== e && "_relatedNodes" !== e && "_copies" !== e && "function" != typeof this._materials[t][e] && (this._materials[t][e] instanceof Map$1 ? (i[e.replace("_", "")] = this._materials[t][e], i[e.replace("_", "")]._id && delete i[e.replace("_", "")]._id) : i[e.replace("_", "")] = this._materials[t][e]); e[t] = i } return e } applySettings(e, t, i) { if (e) for (let r in e) { let n = this.find(r); n && (e[r].replacePath ? _context.instance.materialReplace({ path: e[r].replacePath, material: n, onLoad: () => { this.setMaterialParam(e, r, n, t, i) }, onProgress: () => { } }, t, i) : this.setMaterialParam(e, r, n, t, i)) } else logger.error("无效的材质设置。") } setMaterialParam(e, t, i, r, n) { for (let r in e[t]) if (i[r] instanceof Map$1) { for (let i in e[t][r]) e[t][r][i.replace("_", "")] = e[t][r][i]; switch (e[t][r].type) { case "imagebitmap": let n = "undefined" != typeof ImageBitmap && e[t][r].source instanceof ImageBitmap ? e[t][r].source : void 0 !== e[t][r].name ? this._textureStore.find(e[t][r].name) || _context.instance.customTextureStore.find(e[t][r].name) : this._textureStore.find(t + "#" + r); if (("metalnessMap" === r || "roughnessMap" === r) && !n) { let i = "", a = ""; e[t].roughnessMap && (a = e[t].roughnessMap.name || e[t].roughnessMap._name || ""), e[t].metalnessMap && (i = e[t].metalnessMap.name || e[t].metalnessMap._name || ""); let o = _context.instance.getTextures(); n = this._textureStore.find(i + a), n || (n = this._textureStore.find(a + i)), n = o.find((i => i.name.indexOf(e[t][r].name) > -1 && i.name.indexOf("#MetalnessAndRoughness#") > -1)) } if (!n && e[t][r].name && 0 === e[t][r].name.indexOf("[[origin]]")) { _context.instance.customTextureStore.loadTexture({ url: e[t][r].name, name: e[t][r].name, onLoad: () => { let n = "undefined" != typeof ImageBitmap && e[t][r].source instanceof ImageBitmap ? e[t][r].source : void 0 !== e[t][r].name ? this._textureStore.find(e[t][r].name) || _context.instance.customTextureStore.find(e[t][r].name) : this._textureStore.find(t + "#" + r); i[r] = { type: "imagebitmap", source: n, reset: !0 } } }), console.log("可能加载的模型引用了自定义贴图，自定义贴图需要重新load"); break } i[r] = { type: "imagebitmap", source: n, reset: !0 }; break; case "color": e[t][r].reset = !0, i[r] = e[t][r]; break; case "file": default: i[r] = e[t][r] } } else i[r] = e[t][r]; e[t].color && (i.color = e[t].color), _context.instance && _context.instance.setMaterialAnimation({ name: t, enableTranslation: i.enableTranslation, translationSpeedU: util$1.numberOrDefault(i.translationSpeedU, 0), translationSpeedV: util$1.numberOrDefault(i.translationSpeedV, 0), modelName: i._modelName }, r, n) } dispose() { for (const e in this._materials) Object.hasOwnProperty.call(this._materials, e) && util$1.disposeThreeObject(this._materials[e]); this._materials = null, this._textureStore.dispose && this._textureStore.dispose() } } class ArticulationAnimationItem { constructor({ startTime: e, continueTime: t, articulationName: i, startState: r, endState: n, modelId: a }) { this.startTime = Number(e), this.continueTime = Number(t), this.articulationName = i, this.startState = r, this.endState = n; let o = a; this.getModelId = () => o, this.setModelId = e => { o = e }, this.clone = () => new this.constructor({ startTime: this.startTime, continueTime: this.continueTime, articulationName: this.articulationName, startState: this.startState, endState: this.endState, modelId: o }) } get modelId() { return this.getModelId() } set modelId(e) { this.setModelId(e) } } class ArticulationAnimation { constructor(e, t) { this.animationName = e, this.animationType = AnimationTypes.NONE, this.animationSpeed = 1; let i = t; this.isEnable = !1, this.articulationAnimationItems = []; let r = []; this.addAnimationItem = ({ startTime: e, continueTime: t, articulationName: r, startState: n, endState: a }) => { let o = new ArticulationAnimationItem({ startTime: e, continueTime: t, articulationName: r, startState: n, endState: a, modelId: i }); this.articulationAnimationItems.push(o) }, this.play = e => { let t = _context.animationStore.findAnimation(i + this.animationName, ArticulationAnimationGroupController.type); t && (t.reset(), _context.animationStore.remove(t)), t = new ArticulationAnimationGroupController(i + this.animationName, this.animationType, this.animationSpeed, this.articulationAnimationItems, e), _context.animationStore.add(t), this.animationType == AnimationTypes.NONE && r.push(t) }, this.pause = () => { let e = _context.animationStore.findAnimation(i + this.animationName, ArticulationAnimationGroupController.type); e && e.pause() }, this.resume = () => { let e = _context.animationStore.findAnimation(i + this.animationName, ArticulationAnimationGroupController.type); e && e.resume() }, this.reset = () => { let e = _context.animationStore.findAnimation(i + this.animationName, ArticulationAnimationGroupController.type); if (e && (e.reset(), _context.animationStore.remove(e)), this.animationType == AnimationTypes.NONE) { let e = r.findIndex((e => e.animationName == i + this.animationName)); e > -1 && (r[e].reset(), r.splice(e, 1)) } }, this.delete = () => { let e = _context.animationStore.findAnimation(i + this.animationName, ArticulationAnimationGroupController.type); e && (e.reset(), _context.animationStore.remove(e)) }, this.getParentUUId = () => i, this.setParentUUId = e => { i = e }, this.getArticulationAnimationTemps = () => r, this.clone = () => { const e = new this.constructor(this.animationName, i); e.animationType = this.animationType, e.animationSpeed = this.animationSpeed, e.isEnable = this.isEnable; for (const t of this.articulationAnimationItems) e.articulationAnimationItems.push(t.clone()); return e } } get parentUUId() { return this.getParentUUId } set parentUUId(e) { this.setParentUUId(e) } } function ___$insertStyle(e) { if (e && "undefined" != typeof window) { var t = document.createElement("style"); return t.setAttribute("type", "text/css"), t.innerHTML = e, document.head.appendChild(t), e } } function colorToString(e, t) { var i = e.__state.conversionName.toString(), r = Math.round(e.r), n = Math.round(e.g), a = Math.round(e.b), o = e.a, s = Math.round(e.h), l = e.s.toFixed(1), c = e.v.toFixed(1); if (t || "THREE_CHAR_HEX" === i || "SIX_CHAR_HEX" === i) { for (var h = e.hex.toString(16); h.length < 6;)h = "0" + h; return "#" + h } return "CSS_RGB" === i ? "rgb(" + r + "," + n + "," + a + ")" : "CSS_RGBA" === i ? "rgba(" + r + "," + n + "," + a + "," + o + ")" : "HEX" === i ? "0x" + e.hex.toString(16) : "RGB_ARRAY" === i ? "[" + r + "," + n + "," + a + "]" : "RGBA_ARRAY" === i ? "[" + r + "," + n + "," + a + "," + o + "]" : "RGB_OBJ" === i ? "{r:" + r + ",g:" + n + ",b:" + a + "}" : "RGBA_OBJ" === i ? "{r:" + r + ",g:" + n + ",b:" + a + ",a:" + o + "}" : "HSV_OBJ" === i ? "{h:" + s + ",s:" + l + ",v:" + c + "}" : "HSVA_OBJ" === i ? "{h:" + s + ",s:" + l + ",v:" + c + ",a:" + o + "}" : "unknown format" } var ARR_EACH = Array.prototype.forEach, ARR_SLICE = Array.prototype.slice, Common = { BREAK: {}, extend: function (e) { return this.each(ARR_SLICE.call(arguments, 1), (function (t) { (this.isObject(t) ? Object.keys(t) : []).forEach(function (i) { this.isUndefined(t[i]) || (e[i] = t[i]) }.bind(this)) }), this), e }, defaults: function (e) { return this.each(ARR_SLICE.call(arguments, 1), (function (t) { (this.isObject(t) ? Object.keys(t) : []).forEach(function (i) { this.isUndefined(e[i]) && (e[i] = t[i]) }.bind(this)) }), this), e }, compose: function () { var e = ARR_SLICE.call(arguments); return function () { for (var t = ARR_SLICE.call(arguments), i = e.length - 1; i >= 0; i--)t = [e[i].apply(this, t)]; return t[0] } }, each: function (e, t, i) { if (e) if (ARR_EACH && e.forEach && e.forEach === ARR_EACH) e.forEach(t, i); else if (e.length === e.length + 0) { var r, n = void 0; for (n = 0, r = e.length; n < r; n++)if (n in e && t.call(i, e[n], n) === this.BREAK) return } else for (var a in e) if (t.call(i, e[a], a) === this.BREAK) return }, defer: function (e) { setTimeout(e, 0) }, debounce: function (e, t, i) { var r = void 0; return function () { var n = this, a = arguments; function o() { r = null, i || e.apply(n, a) } var s = i || !r; clearTimeout(r), r = setTimeout(o, t), s && e.apply(n, a) } }, toArray: function (e) { return e.toArray ? e.toArray() : ARR_SLICE.call(e) }, isUndefined: function (e) { return void 0 === e }, isNull: function (e) { return null === e }, isNaN: function (e) { function t() { return e.apply(this, arguments) } return t.toString = function () { return e.toString() }, t }((function (e) { return isNaN(e) })), isArray: Array.isArray || function (e) { return e.constructor === Array }, isObject: function (e) { return e === Object(e) }, isNumber: function (e) { return e === e + 0 }, isString: function (e) { return e === e + "" }, isBoolean: function (e) { return !1 === e || !0 === e }, isFunction: function (e) { return e instanceof Function } }, INTERPRETATIONS = [{ litmus: Common.isString, conversions: { THREE_CHAR_HEX: { read: function (e) { var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i); return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString(), 0) } }, write: colorToString }, SIX_CHAR_HEX: { read: function (e) { var t = e.match(/^#([A-F0-9]{6})$/i); return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString(), 0) } }, write: colorToString }, CSS_RGB: { read: function (e) { var t = e.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/); return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]) } }, write: colorToString }, CSS_RGBA: { read: function (e) { var t = e.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/); return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]), a: parseFloat(t[4]) } }, write: colorToString } } }, { litmus: Common.isNumber, conversions: { HEX: { read: function (e) { return { space: "HEX", hex: e, conversionName: "HEX" } }, write: function (e) { return e.hex } } } }, { litmus: Common.isArray, conversions: { RGB_ARRAY: { read: function (e) { return 3 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2] } }, write: function (e) { return [e.r, e.g, e.b] } }, RGBA_ARRAY: { read: function (e) { return 4 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2], a: e[3] } }, write: function (e) { return [e.r, e.g, e.b, e.a] } } } }, { litmus: Common.isObject, conversions: { RGBA_OBJ: { read: function (e) { return !!(Common.isNumber(e.r) && Common.isNumber(e.g) && Common.isNumber(e.b) && Common.isNumber(e.a)) && { space: "RGB", r: e.r, g: e.g, b: e.b, a: e.a } }, write: function (e) { return { r: e.r, g: e.g, b: e.b, a: e.a } } }, RGB_OBJ: { read: function (e) { return !!(Common.isNumber(e.r) && Common.isNumber(e.g) && Common.isNumber(e.b)) && { space: "RGB", r: e.r, g: e.g, b: e.b } }, write: function (e) { return { r: e.r, g: e.g, b: e.b } } }, HSVA_OBJ: { read: function (e) { return !!(Common.isNumber(e.h) && Common.isNumber(e.s) && Common.isNumber(e.v) && Common.isNumber(e.a)) && { space: "HSV", h: e.h, s: e.s, v: e.v, a: e.a } }, write: function (e) { return { h: e.h, s: e.s, v: e.v, a: e.a } } }, HSV_OBJ: { read: function (e) { return !!(Common.isNumber(e.h) && Common.isNumber(e.s) && Common.isNumber(e.v)) && { space: "HSV", h: e.h, s: e.s, v: e.v } }, write: function (e) { return { h: e.h, s: e.s, v: e.v } } } } }], result = void 0, toReturn = void 0, interpret = function () { toReturn = !1; var e = arguments.length > 1 ? Common.toArray(arguments) : arguments[0]; return Common.each(INTERPRETATIONS, (function (t) { if (t.litmus(e)) return Common.each(t.conversions, (function (t, i) { if (result = t.read(e), !1 === toReturn && !1 !== result) return toReturn = result, result.conversionName = i, result.conversion = t, Common.BREAK })), Common.BREAK })), toReturn }, tmpComponent = void 0, ColorMath = { hsv_to_rgb: function (e, t, i) { var r = Math.floor(e / 60) % 6, n = e / 60 - Math.floor(e / 60), a = i * (1 - t), o = i * (1 - n * t), s = i * (1 - (1 - n) * t), l = [[i, s, a], [o, i, a], [a, i, s], [a, o, i], [s, a, i], [i, a, o]][r]; return { r: 255 * l[0], g: 255 * l[1], b: 255 * l[2] } }, rgb_to_hsv: function (e, t, i) { var r = Math.min(e, t, i), n = Math.max(e, t, i), a = n - r, o = void 0; return 0 === n ? { h: NaN, s: 0, v: 0 } : (o = e === n ? (t - i) / a : t === n ? 2 + (i - e) / a : 4 + (e - t) / a, (o /= 6) < 0 && (o += 1), { h: 360 * o, s: a / n, v: n / 255 }) }, rgb_to_hex: function (e, t, i) { var r = this.hex_with_component(0, 2, e); return r = this.hex_with_component(r, 1, t), r = this.hex_with_component(r, 0, i) }, component_from_hex: function (e, t) { return e >> 8 * t & 255 }, hex_with_component: function (e, t, i) { return i << (tmpComponent = 8 * t) | e & ~(255 << tmpComponent) } }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, classCallCheck = function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }, createClass = function () { function e(e, t) { for (var i = 0; i < t.length; i++) { var r = t[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function (t, i, r) { return i && e(t.prototype, i), r && e(t, r), t } }(), get = function e(t, i, r) { null === t && (t = Function.prototype); var n = Object.getOwnPropertyDescriptor(t, i); if (void 0 === n) { var a = Object.getPrototypeOf(t); return null === a ? void 0 : e(a, i, r) } if ("value" in n) return n.value; var o = n.get; return void 0 !== o ? o.call(r) : void 0 }, inherits = function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t) }, possibleConstructorReturn = function (e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }, Color = function () { function e() { if (classCallCheck(this, e), this.__state = interpret.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments"); this.__state.a = this.__state.a || 1 } return createClass(e, [{ key: "toString", value: function () { return colorToString(this) } }, { key: "toHexString", value: function () { return colorToString(this, !0) } }, { key: "toOriginal", value: function () { return this.__state.conversion.write(this) } }]), e }(); function defineRGBComponent(e, t, i) { Object.defineProperty(e, t, { get: function () { return "RGB" === this.__state.space || Color.recalculateRGB(this, t, i), this.__state[t] }, set: function (e) { "RGB" !== this.__state.space && (Color.recalculateRGB(this, t, i), this.__state.space = "RGB"), this.__state[t] = e } }) } function defineHSVComponent(e, t) { Object.defineProperty(e, t, { get: function () { return "HSV" === this.__state.space || Color.recalculateHSV(this), this.__state[t] }, set: function (e) { "HSV" !== this.__state.space && (Color.recalculateHSV(this), this.__state.space = "HSV"), this.__state[t] = e } }) } Color.recalculateRGB = function (e, t, i) { if ("HEX" === e.__state.space) e.__state[t] = ColorMath.component_from_hex(e.__state.hex, i); else { if ("HSV" !== e.__state.space) throw new Error("Corrupted color state"); Common.extend(e.__state, ColorMath.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v)) } }, Color.recalculateHSV = function (e) { var t = ColorMath.rgb_to_hsv(e.r, e.g, e.b); Common.extend(e.__state, { s: t.s, v: t.v }), Common.isNaN(t.h) ? Common.isUndefined(e.__state.h) && (e.__state.h = 0) : e.__state.h = t.h }, Color.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], defineRGBComponent(Color.prototype, "r", 2), defineRGBComponent(Color.prototype, "g", 1), defineRGBComponent(Color.prototype, "b", 0), defineHSVComponent(Color.prototype, "h"), defineHSVComponent(Color.prototype, "s"), defineHSVComponent(Color.prototype, "v"), Object.defineProperty(Color.prototype, "a", { get: function () { return this.__state.a }, set: function (e) { this.__state.a = e } }), Object.defineProperty(Color.prototype, "hex", { get: function () { return "HEX" !== this.__state.space && (this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex }, set: function (e) { this.__state.space = "HEX", this.__state.hex = e } }); var Controller$1 = function () { function e(t, i) { classCallCheck(this, e), this.initialValue = t[i], this.domElement = document.createElement("div"), this.object = t, this.property = i, this.__onChange = void 0, this.__onFinishChange = void 0 } return createClass(e, [{ key: "onChange", value: function (e) { return this.__onChange = e, this } }, { key: "onFinishChange", value: function (e) { return this.__onFinishChange = e, this } }, { key: "setValue", value: function (e) { return this.object[this.property] = e, this.__onChange && this.__onChange.call(this, e), this.updateDisplay(), this } }, { key: "getValue", value: function () { return this.object[this.property] } }, { key: "updateDisplay", value: function () { return this } }, { key: "isModified", value: function () { return this.initialValue !== this.getValue() } }]), e }(), EVENT_MAP = { HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"] }, EVENT_MAP_INV = {}; Common.each(EVENT_MAP, (function (e, t) { Common.each(e, (function (e) { EVENT_MAP_INV[e] = t })) })); var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/; function cssValueToPixels(e) { if ("0" === e || Common.isUndefined(e)) return 0; var t = e.match(CSS_VALUE_PIXELS); return Common.isNull(t) ? 0 : parseFloat(t[1]) } var dom = { makeSelectable: function (e, t) { void 0 !== e && void 0 !== e.style && (e.onselectstart = t ? function () { return !1 } : function () { }, e.style.MozUserSelect = t ? "auto" : "none", e.style.KhtmlUserSelect = t ? "auto" : "none", e.unselectable = t ? "on" : "off") }, makeFullscreen: function (e, t, i) { var r = i, n = t; Common.isUndefined(n) && (n = !0), Common.isUndefined(r) && (r = !0), e.style.position = "absolute", n && (e.style.left = 0, e.style.right = 0), r && (e.style.top = 0, e.style.bottom = 0) }, fakeEvent: function (e, t, i, r) { var n = i || {}, a = EVENT_MAP_INV[t]; if (!a) throw new Error("Event type " + t + " not supported."); var o = document.createEvent(a); switch (a) { case "MouseEvents": var s = n.x || n.clientX || 0, l = n.y || n.clientY || 0; o.initMouseEvent(t, n.bubbles || !1, n.cancelable || !0, window, n.clickCount || 1, 0, 0, s, l, !1, !1, !1, !1, 0, null); break; case "KeyboardEvents": var c = o.initKeyboardEvent || o.initKeyEvent; Common.defaults(n, { cancelable: !0, ctrlKey: !1, altKey: !1, shiftKey: !1, metaKey: !1, keyCode: void 0, charCode: void 0 }), c(t, n.bubbles || !1, n.cancelable, window, n.ctrlKey, n.altKey, n.shiftKey, n.metaKey, n.keyCode, n.charCode); break; default: o.initEvent(t, n.bubbles || !1, n.cancelable || !0) }Common.defaults(o, r), e.dispatchEvent(o) }, bind: function (e, t, i, r) { var n = r || !1; return e.addEventListener ? e.addEventListener(t, i, n) : e.attachEvent && e.attachEvent("on" + t, i), dom }, unbind: function (e, t, i, r) { var n = r || !1; return e.removeEventListener ? e.removeEventListener(t, i, n) : e.detachEvent && e.detachEvent("on" + t, i), dom }, addClass: function (e, t) { if (void 0 === e.className) e.className = t; else if (e.className !== t) { var i = e.className.split(/ +/); -1 === i.indexOf(t) && (i.push(t), e.className = i.join(" ").replace(/^\s+/, "").replace(/\s+$/, "")) } return dom }, removeClass: function (e, t) { if (t) if (e.className === t) e.removeAttribute("class"); else { var i = e.className.split(/ +/), r = i.indexOf(t); -1 !== r && (i.splice(r, 1), e.className = i.join(" ")) } else e.className = void 0; return dom }, hasClass: function (e, t) { return new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1 }, getWidth: function (e) { var t = getComputedStyle(e); return cssValueToPixels(t["border-left-width"]) + cssValueToPixels(t["border-right-width"]) + cssValueToPixels(t["padding-left"]) + cssValueToPixels(t["padding-right"]) + cssValueToPixels(t.width) }, getHeight: function (e) { var t = getComputedStyle(e); return cssValueToPixels(t["border-top-width"]) + cssValueToPixels(t["border-bottom-width"]) + cssValueToPixels(t["padding-top"]) + cssValueToPixels(t["padding-bottom"]) + cssValueToPixels(t.height) }, getOffset: function (e) { var t = e, i = { left: 0, top: 0 }; if (t.offsetParent) do { i.left += t.offsetLeft, i.top += t.offsetTop, t = t.offsetParent } while (t); return i }, isActive: function (e) { return e === document.activeElement && (e.type || e.href) } }, BooleanController = function (e) { function t(e, i) { classCallCheck(this, t); var r = possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), n = r; return r.__prev = r.getValue(), r.__checkbox = document.createElement("input"), r.__checkbox.setAttribute("type", "checkbox"), dom.bind(r.__checkbox, "change", (function () { n.setValue(!n.__prev) }), !1), r.domElement.appendChild(r.__checkbox), r.updateDisplay(), r } return inherits(t, e), createClass(t, [{ key: "setValue", value: function (e) { var i = get(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, e); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), i } }, { key: "updateDisplay", value: function () { return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), get(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(Controller$1), OptionController = function (e) { function t(e, i, r) { classCallCheck(this, t); var n = possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), a = r, o = n; if (n.__select = document.createElement("select"), Common.isArray(a)) { var s = {}; Common.each(a, (function (e) { s[e] = e })), a = s } return Common.each(a, (function (e, t) { var i = document.createElement("option"); i.innerHTML = t, i.setAttribute("value", e), o.__select.appendChild(i) })), n.updateDisplay(), dom.bind(n.__select, "change", (function () { var e = this.options[this.selectedIndex].value; o.setValue(e) })), n.domElement.appendChild(n.__select), n } return inherits(t, e), createClass(t, [{ key: "setValue", value: function (e) { var i = get(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, e); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), i } }, { key: "updateDisplay", value: function () { return dom.isActive(this.__select) ? this : (this.__select.value = this.getValue(), get(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this)) } }]), t }(Controller$1), StringController = function (e) { function t(e, i) { classCallCheck(this, t); var r = possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), n = r; function a() { n.setValue(n.__input.value) } return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), dom.bind(r.__input, "keyup", a), dom.bind(r.__input, "change", a), dom.bind(r.__input, "blur", (function () { n.__onFinishChange && n.__onFinishChange.call(n, n.getValue()) })), dom.bind(r.__input, "keydown", (function (e) { 13 === e.keyCode && this.blur() })), r.updateDisplay(), r.domElement.appendChild(r.__input), r } return inherits(t, e), createClass(t, [{ key: "updateDisplay", value: function () { return dom.isActive(this.__input) || (this.__input.value = this.getValue()), get(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(Controller$1); function numDecimals(e) { var t = e.toString(); return t.indexOf(".") > -1 ? t.length - t.indexOf(".") - 1 : 0 } var NumberController = function (e) { function t(e, i, r) { classCallCheck(this, t); var n = possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), a = r || {}; return n.__min = a.min, n.__max = a.max, n.__step = a.step, Common.isUndefined(n.__step) ? 0 === n.initialValue ? n.__impliedStep = 1 : n.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(n.initialValue)) / Math.LN10)) / 10 : n.__impliedStep = n.__step, n.__precision = numDecimals(n.__impliedStep), n } return inherits(t, e), createClass(t, [{ key: "setValue", value: function (e) { var i = e; return void 0 !== this.__min && i < this.__min ? i = this.__min : void 0 !== this.__max && i > this.__max && (i = this.__max), void 0 !== this.__step && i % this.__step != 0 && (i = Math.round(i / this.__step) * this.__step), get(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, i) } }, { key: "min", value: function (e) { return this.__min = e, this } }, { key: "max", value: function (e) { return this.__max = e, this } }, { key: "step", value: function (e) { return this.__step = e, this.__impliedStep = e, this.__precision = numDecimals(e), this } }]), t }(Controller$1); function roundToDecimal(e, t) { var i = Math.pow(10, t); return Math.round(e * i) / i } var NumberControllerBox = function (e) { function t(e, i, r) { classCallCheck(this, t); var n = possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i, r)); n.__truncationSuspended = !1; var a = n, o = void 0; function s() { a.__onFinishChange && a.__onFinishChange.call(a, a.getValue()) } function l(e) { var t = o - e.clientY; a.setValue(a.getValue() + t * a.__impliedStep), o = e.clientY } function c() { dom.unbind(window, "mousemove", l), dom.unbind(window, "mouseup", c), s() } return n.__input = document.createElement("input"), n.__input.setAttribute("type", "text"), dom.bind(n.__input, "change", (function () { var e = parseFloat(a.__input.value); Common.isNaN(e) || a.setValue(e) })), dom.bind(n.__input, "blur", (function () { s() })), dom.bind(n.__input, "mousedown", (function (e) { dom.bind(window, "mousemove", l), dom.bind(window, "mouseup", c), o = e.clientY })), dom.bind(n.__input, "keydown", (function (e) { 13 === e.keyCode && (a.__truncationSuspended = !0, this.blur(), a.__truncationSuspended = !1, s()) })), n.updateDisplay(), n.domElement.appendChild(n.__input), n } return inherits(t, e), createClass(t, [{ key: "updateDisplay", value: function () { return this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision), get(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(NumberController); function map(e, t, i, r, n) { return r + (e - t) / (i - t) * (n - r) } var NumberControllerSlider = function (e) { function t(e, i, r, n, a) { classCallCheck(this, t); var o = possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i, { min: r, max: n, step: a })), s = o; function l(e) { e.preventDefault(); var t = s.__background.getBoundingClientRect(); return s.setValue(map(e.clientX, t.left, t.right, s.__min, s.__max)), !1 } function c() { dom.unbind(window, "mousemove", l), dom.unbind(window, "mouseup", c), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue()) } function h(e) { var t = e.touches[0].clientX, i = s.__background.getBoundingClientRect(); s.setValue(map(t, i.left, i.right, s.__min, s.__max)) } function u() { dom.unbind(window, "touchmove", h), dom.unbind(window, "touchend", u), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue()) } return o.__background = document.createElement("div"), o.__foreground = document.createElement("div"), dom.bind(o.__background, "mousedown", (function (e) { document.activeElement.blur(), dom.bind(window, "mousemove", l), dom.bind(window, "mouseup", c), l(e) })), dom.bind(o.__background, "touchstart", (function (e) { if (1 !== e.touches.length) return; dom.bind(window, "touchmove", h), dom.bind(window, "touchend", u), h(e) })), dom.addClass(o.__background, "slider"), dom.addClass(o.__foreground, "slider-fg"), o.updateDisplay(), o.__background.appendChild(o.__foreground), o.domElement.appendChild(o.__background), o } return inherits(t, e), createClass(t, [{ key: "updateDisplay", value: function () { var e = (this.getValue() - this.__min) / (this.__max - this.__min); return this.__foreground.style.width = 100 * e + "%", get(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(NumberController), FunctionController = function (e) { function t(e, i, r) { classCallCheck(this, t); var n = possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), a = n; return n.__button = document.createElement("div"), n.__button.innerHTML = void 0 === r ? "Fire" : r, dom.bind(n.__button, "click", (function (e) { return e.preventDefault(), a.fire(), !1 })), dom.addClass(n.__button, "button"), n.domElement.appendChild(n.__button), n } return inherits(t, e), createClass(t, [{ key: "fire", value: function () { this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()) } }]), t }(Controller$1), ColorController = function (e) { function t(e, i) { classCallCheck(this, t); var r = possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)); r.__color = new Color(r.getValue()), r.__temp = new Color(0); var n = r; r.domElement = document.createElement("div"), dom.makeSelectable(r.domElement, !1), r.__selector = document.createElement("div"), r.__selector.className = "selector", r.__saturation_field = document.createElement("div"), r.__saturation_field.className = "saturation-field", r.__field_knob = document.createElement("div"), r.__field_knob.className = "field-knob", r.__field_knob_border = "2px solid ", r.__hue_knob = document.createElement("div"), r.__hue_knob.className = "hue-knob", r.__hue_field = document.createElement("div"), r.__hue_field.className = "hue-field", r.__input = document.createElement("input"), r.__input.type = "text", r.__input_textShadow = "0 1px 1px ", dom.bind(r.__input, "keydown", (function (e) { 13 === e.keyCode && h.call(this) })), dom.bind(r.__input, "blur", h), dom.bind(r.__selector, "mousedown", (function () { dom.addClass(this, "drag").bind(window, "mouseup", (function () { dom.removeClass(n.__selector, "drag") })) })), dom.bind(r.__selector, "touchstart", (function () { dom.addClass(this, "drag").bind(window, "touchend", (function () { dom.removeClass(n.__selector, "drag") })) })); var a = document.createElement("div"); function o(e) { d(e), dom.bind(window, "mousemove", d), dom.bind(window, "touchmove", d), dom.bind(window, "mouseup", l), dom.bind(window, "touchend", l) } function s(e) { p(e), dom.bind(window, "mousemove", p), dom.bind(window, "touchmove", p), dom.bind(window, "mouseup", c), dom.bind(window, "touchend", c) } function l() { dom.unbind(window, "mousemove", d), dom.unbind(window, "touchmove", d), dom.unbind(window, "mouseup", l), dom.unbind(window, "touchend", l), u() } function c() { dom.unbind(window, "mousemove", p), dom.unbind(window, "touchmove", p), dom.unbind(window, "mouseup", c), dom.unbind(window, "touchend", c), u() } function h() { var e = interpret(this.value); !1 !== e ? (n.__color.__state = e, n.setValue(n.__color.toOriginal())) : this.value = n.__color.toString() } function u() { n.__onFinishChange && n.__onFinishChange.call(n, n.__color.toOriginal()) } function d(e) { -1 === e.type.indexOf("touch") && e.preventDefault(); var t = n.__saturation_field.getBoundingClientRect(), i = e.touches && e.touches[0] || e, r = i.clientX, a = i.clientY, o = (r - t.left) / (t.right - t.left), s = 1 - (a - t.top) / (t.bottom - t.top); return s > 1 ? s = 1 : s < 0 && (s = 0), o > 1 ? o = 1 : o < 0 && (o = 0), n.__color.v = s, n.__color.s = o, n.setValue(n.__color.toOriginal()), !1 } function p(e) { -1 === e.type.indexOf("touch") && e.preventDefault(); var t = n.__hue_field.getBoundingClientRect(), i = 1 - ((e.touches && e.touches[0] || e).clientY - t.top) / (t.bottom - t.top); return i > 1 ? i = 1 : i < 0 && (i = 0), n.__color.h = 360 * i, n.setValue(n.__color.toOriginal()), !1 } return Common.extend(r.__selector.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }), Common.extend(r.__field_knob.style, { position: "absolute", width: "12px", height: "12px", border: r.__field_knob_border + (r.__color.v < .5 ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1 }), Common.extend(r.__hue_knob.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }), Common.extend(r.__saturation_field.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }), Common.extend(a.style, { width: "100%", height: "100%", background: "none" }), linearGradient(a, "top", "rgba(0,0,0,0)", "#000"), Common.extend(r.__hue_field.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }), hueGradient(r.__hue_field), Common.extend(r.__input.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: r.__input_textShadow + "rgba(0,0,0,0.7)" }), dom.bind(r.__saturation_field, "mousedown", o), dom.bind(r.__saturation_field, "touchstart", o), dom.bind(r.__field_knob, "mousedown", o), dom.bind(r.__field_knob, "touchstart", o), dom.bind(r.__hue_field, "mousedown", s), dom.bind(r.__hue_field, "touchstart", s), r.__saturation_field.appendChild(a), r.__selector.appendChild(r.__field_knob), r.__selector.appendChild(r.__saturation_field), r.__selector.appendChild(r.__hue_field), r.__hue_field.appendChild(r.__hue_knob), r.domElement.appendChild(r.__input), r.domElement.appendChild(r.__selector), r.updateDisplay(), r } return inherits(t, e), createClass(t, [{ key: "updateDisplay", value: function () { var e = interpret(this.getValue()); if (!1 !== e) { var t = !1; Common.each(Color.COMPONENTS, (function (i) { if (!Common.isUndefined(e[i]) && !Common.isUndefined(this.__color.__state[i]) && e[i] !== this.__color.__state[i]) return t = !0, {} }), this), t && Common.extend(this.__color.__state, e) } Common.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1; var i = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0, r = 255 - i; Common.extend(this.__field_knob.style, { marginLeft: 100 * this.__color.s - 7 + "px", marginTop: 100 * (1 - this.__color.v) - 7 + "px", backgroundColor: this.__temp.toHexString(), border: this.__field_knob_border + "rgb(" + i + "," + i + "," + i + ")" }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, linearGradient(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), Common.extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: "rgb(" + i + "," + i + "," + i + ")", textShadow: this.__input_textShadow + "rgba(" + r + "," + r + "," + r + ",.7)" }) } }]), t }(Controller$1), vendors = ["-moz-", "-o-", "-webkit-", "-ms-", ""]; function linearGradient(e, t, i, r) { e.style.background = "", Common.each(vendors, (function (n) { e.style.cssText += "background: " + n + "linear-gradient(" + t + ", " + i + " 0%, " + r + " 100%); " })) } function hueGradient(e) { e.style.background = "", e.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", e.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", e.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);" } var css = { load: function (e, t) { var i = t || document, r = i.createElement("link"); r.type = "text/css", r.rel = "stylesheet", r.href = e, i.getElementsByTagName("head")[0].appendChild(r) }, inject: function (e, t) { var i = t || document, r = document.createElement("style"); r.type = "text/css", r.innerHTML = e; var n = i.getElementsByTagName("head")[0]; try { n.appendChild(r) } catch (e) { } } }, saveDialogContents = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>', ControllerFactory = function (e, t) { var i = e[t]; return Common.isArray(arguments[2]) || Common.isObject(arguments[2]) ? new OptionController(e, t, arguments[2]) : Common.isNumber(i) ? Common.isNumber(arguments[2]) && Common.isNumber(arguments[3]) ? Common.isNumber(arguments[4]) ? new NumberControllerSlider(e, t, arguments[2], arguments[3], arguments[4]) : new NumberControllerSlider(e, t, arguments[2], arguments[3]) : Common.isNumber(arguments[4]) ? new NumberControllerBox(e, t, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new NumberControllerBox(e, t, { min: arguments[2], max: arguments[3] }) : Common.isString(i) ? new StringController(e, t) : Common.isFunction(i) ? new FunctionController(e, t, "") : Common.isBoolean(i) ? new BooleanController(e, t) : null }; function requestAnimationFrame$1(e) { setTimeout(e, 1e3 / 60) } var requestAnimationFrame$1$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame$1, CenteredDiv = function () { function e() { classCallCheck(this, e), this.backgroundElement = document.createElement("div"), Common.extend(this.backgroundElement.style, { backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear", transition: "opacity 0.2s linear" }), dom.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), Common.extend(this.domElement.style, { position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear", transition: "transform 0.2s ease-out, opacity 0.2s linear" }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement); var t = this; dom.bind(this.backgroundElement, "click", (function () { t.hide() })) } return createClass(e, [{ key: "show", value: function () { var e = this; this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), Common.defer((function () { e.backgroundElement.style.opacity = 1, e.domElement.style.opacity = 1, e.domElement.style.webkitTransform = "scale(1)" })) } }, { key: "hide", value: function () { var e = this, t = function t() { e.domElement.style.display = "none", e.backgroundElement.style.display = "none", dom.unbind(e.domElement, "webkitTransitionEnd", t), dom.unbind(e.domElement, "transitionend", t), dom.unbind(e.domElement, "oTransitionEnd", t) }; dom.bind(this.domElement, "webkitTransitionEnd", t), dom.bind(this.domElement, "transitionend", t), dom.bind(this.domElement, "oTransitionEnd", t), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)" } }, { key: "layout", value: function () { this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + "px" } }]), e }(), styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"); css.inject(styleSheet); var CSS_NAMESPACE = "dg", HIDE_KEY_CODE = 72, CLOSE_BUTTON_HEIGHT = 20, DEFAULT_DEFAULT_PRESET_NAME = "Default", SUPPORTS_LOCAL_STORAGE = function () { try { return !!window.localStorage } catch (e) { return !1 } }(), SAVE_DIALOGUE = void 0, autoPlaceVirgin = !0, autoPlaceContainer = void 0, hide = !1, hideableGuis = [], GUI = function e(t) { var i = this, r = t || {}; this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), dom.addClass(this.domElement, CSS_NAMESPACE), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], r = Common.defaults(r, { closeOnTop: !1, autoPlace: !0, width: e.DEFAULT_WIDTH }), r = Common.defaults(r, { resizable: r.autoPlace, hideable: r.autoPlace }), Common.isUndefined(r.load) ? r.load = { preset: DEFAULT_DEFAULT_PRESET_NAME } : r.preset && (r.load.preset = r.preset), Common.isUndefined(r.parent) && r.hideable && hideableGuis.push(this), r.resizable = Common.isUndefined(r.parent) && r.resizable, r.autoPlace && Common.isUndefined(r.scrollable) && (r.scrollable = !0); var n, a = SUPPORTS_LOCAL_STORAGE && "true" === localStorage.getItem(getLocalStorageHash(this, "isLocal")), o = void 0, s = void 0; if (Object.defineProperties(this, { parent: { get: function () { return r.parent } }, scrollable: { get: function () { return r.scrollable } }, autoPlace: { get: function () { return r.autoPlace } }, closeOnTop: { get: function () { return r.closeOnTop } }, preset: { get: function () { return i.parent ? i.getRoot().preset : r.load.preset }, set: function (e) { i.parent ? i.getRoot().preset = e : r.load.preset = e, setPresetSelectIndex(this), i.revert() } }, width: { get: function () { return r.width }, set: function (e) { r.width = e, setWidth(i, e) } }, name: { get: function () { return r.name }, set: function (e) { r.name = e, s && (s.innerHTML = r.name) } }, closed: { get: function () { return r.closed }, set: function (t) { r.closed = t, r.closed ? dom.addClass(i.__ul, e.CLASS_CLOSED) : dom.removeClass(i.__ul, e.CLASS_CLOSED), this.onResize(), i.__closeButton && (i.__closeButton.innerHTML = t ? e.TEXT_OPEN : e.TEXT_CLOSED) } }, load: { get: function () { return r.load } }, useLocalStorage: { get: function () { return a }, set: function (e) { SUPPORTS_LOCAL_STORAGE && (a = e, e ? dom.bind(window, "unload", o) : dom.unbind(window, "unload", o), localStorage.setItem(getLocalStorageHash(i, "isLocal"), e)) } } }), Common.isUndefined(r.parent)) { if (this.closed = r.closed || !1, dom.addClass(this.domElement, e.CLASS_MAIN), dom.makeSelectable(this.domElement, !1), SUPPORTS_LOCAL_STORAGE && a) { i.useLocalStorage = !0; var l = localStorage.getItem(getLocalStorageHash(this, "gui")); l && (r.load = JSON.parse(l)) } this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = e.TEXT_CLOSED, dom.addClass(this.__closeButton, e.CLASS_CLOSE_BUTTON), r.closeOnTop ? (dom.addClass(this.__closeButton, e.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (dom.addClass(this.__closeButton, e.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), dom.bind(this.__closeButton, "click", (function () { i.closed = !i.closed })) } else { void 0 === r.closed && (r.closed = !0); var c = document.createTextNode(r.name); dom.addClass(c, "controller-name"), s = addRow(i, c); dom.addClass(this.__ul, e.CLASS_CLOSED), dom.addClass(s, "title"), dom.bind(s, "click", (function (e) { return e.preventDefault(), i.closed = !i.closed, !1 })), r.closed || (this.closed = !1) } r.autoPlace && (Common.isUndefined(r.parent) && (autoPlaceVirgin && (autoPlaceContainer = document.createElement("div"), dom.addClass(autoPlaceContainer, CSS_NAMESPACE), dom.addClass(autoPlaceContainer, e.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(autoPlaceContainer), autoPlaceVirgin = !1), autoPlaceContainer.appendChild(this.domElement), dom.addClass(this.domElement, e.CLASS_AUTO_PLACE)), this.parent || setWidth(i, r.width)), this.__resizeHandler = function () { i.onResizeDebounced() }, dom.bind(window, "resize", this.__resizeHandler), dom.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), dom.bind(this.__ul, "transitionend", this.__resizeHandler), dom.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), r.resizable && addResizeHandle(this), o = function () { SUPPORTS_LOCAL_STORAGE && "true" === localStorage.getItem(getLocalStorageHash(i, "isLocal")) && localStorage.setItem(getLocalStorageHash(i, "gui"), JSON.stringify(i.getSaveObject())) }, this.saveToLocalStorageIfPossible = o, r.parent || ((n = i.getRoot()).width += 1, Common.defer((function () { n.width -= 1 }))) }; function addRow(e, t, i) { var r = document.createElement("li"); return t && r.appendChild(t), i ? e.__ul.insertBefore(r, i) : e.__ul.appendChild(r), e.onResize(), r } function removeListeners(e) { dom.unbind(window, "resize", e.__resizeHandler), e.saveToLocalStorageIfPossible && dom.unbind(window, "unload", e.saveToLocalStorageIfPossible) } function markPresetModified(e, t) { var i = e.__preset_select[e.__preset_select.selectedIndex]; i.innerHTML = t ? i.value + "*" : i.value } function augmentController(e, t, i) { if (i.__li = t, i.__gui = e, Common.extend(i, { options: function (t) { if (arguments.length > 1) { var r = i.__li.nextElementSibling; return i.remove(), _add(e, i.object, i.property, { before: r, factoryArgs: [Common.toArray(arguments)] }) } if (Common.isArray(t) || Common.isObject(t)) { var n = i.__li.nextElementSibling; return i.remove(), _add(e, i.object, i.property, { before: n, factoryArgs: [t] }) } }, name: function (e) { return i.__li.firstElementChild.firstElementChild.innerHTML = e, i }, listen: function () { return i.__gui.listen(i), i }, remove: function () { return i.__gui.remove(i), i } }), i instanceof NumberControllerSlider) { var r = new NumberControllerBox(i.object, i.property, { min: i.__min, max: i.__max, step: i.__step }); Common.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], (function (e) { var t = i[e], n = r[e]; i[e] = r[e] = function () { var e = Array.prototype.slice.call(arguments); return n.apply(r, e), t.apply(i, e) } })), dom.addClass(t, "has-slider"), i.domElement.insertBefore(r.domElement, i.domElement.firstElementChild) } else if (i instanceof NumberControllerBox) { var n = function (t) { if (Common.isNumber(i.__min) && Common.isNumber(i.__max)) { var r = i.__li.firstElementChild.firstElementChild.innerHTML, n = i.__gui.__listening.indexOf(i) > -1; i.remove(); var a = _add(e, i.object, i.property, { before: i.__li.nextElementSibling, factoryArgs: [i.__min, i.__max, i.__step] }); return a.name(r), n && a.listen(), a } return t }; i.min = Common.compose(n, i.min), i.max = Common.compose(n, i.max) } else i instanceof BooleanController ? (dom.bind(t, "click", (function () { dom.fakeEvent(i.__checkbox, "click") })), dom.bind(i.__checkbox, "click", (function (e) { e.stopPropagation() }))) : i instanceof FunctionController ? (dom.bind(t, "click", (function () { dom.fakeEvent(i.__button, "click") })), dom.bind(t, "mouseover", (function () { dom.addClass(i.__button, "hover") })), dom.bind(t, "mouseout", (function () { dom.removeClass(i.__button, "hover") }))) : i instanceof ColorController && (dom.addClass(t, "color"), i.updateDisplay = Common.compose((function (e) { return t.style.borderLeftColor = i.__color.toString(), e }), i.updateDisplay), i.updateDisplay()); i.setValue = Common.compose((function (t) { return e.getRoot().__preset_select && i.isModified() && markPresetModified(e.getRoot(), !0), t }), i.setValue) } function recallSavedValue(e, t) { var i = e.getRoot(), r = i.__rememberedObjects.indexOf(t.object); if (-1 !== r) { var n = i.__rememberedObjectIndecesToControllers[r]; if (void 0 === n && (n = {}, i.__rememberedObjectIndecesToControllers[r] = n), n[t.property] = t, i.load && i.load.remembered) { var a = i.load.remembered, o = void 0; if (a[e.preset]) o = a[e.preset]; else { if (!a[DEFAULT_DEFAULT_PRESET_NAME]) return; o = a[DEFAULT_DEFAULT_PRESET_NAME] } if (o[r] && void 0 !== o[r][t.property]) { var s = o[r][t.property]; t.initialValue = s, t.setValue(s) } } } } function _add(e, t, i, r) { if (void 0 === t[i]) throw new Error('Object "' + t + '" has no property "' + i + '"'); var n = void 0; if (r.color) n = new ColorController(t, i); else { var a = [t, i].concat(r.factoryArgs); n = ControllerFactory.apply(e, a) } r.before instanceof Controller$1 && (r.before = r.before.__li), recallSavedValue(e, n), dom.addClass(n.domElement, "c"); var o = document.createElement("span"); dom.addClass(o, "property-name"), o.innerHTML = n.property; var s = document.createElement("div"); s.appendChild(o), s.appendChild(n.domElement); var l = addRow(e, s, r.before); return dom.addClass(l, GUI.CLASS_CONTROLLER_ROW), n instanceof ColorController ? dom.addClass(l, "color") : dom.addClass(l, _typeof(n.getValue())), augmentController(e, l, n), e.__controllers.push(n), n } function getLocalStorageHash(e, t) { return document.location.href + "." + t } function addPresetOption(e, t, i) { var r = document.createElement("option"); r.innerHTML = t, r.value = t, e.__preset_select.appendChild(r), i && (e.__preset_select.selectedIndex = e.__preset_select.length - 1) } function showHideExplain(e, t) { t.style.display = e.useLocalStorage ? "block" : "none" } function addSaveMenu(e) { var t = e.__save_row = document.createElement("li"); dom.addClass(e.domElement, "has-save"), e.__ul.insertBefore(t, e.__ul.firstChild), dom.addClass(t, "save-row"); var i = document.createElement("span"); i.innerHTML = "&nbsp;", dom.addClass(i, "button gears"); var r = document.createElement("span"); r.innerHTML = "Save", dom.addClass(r, "button"), dom.addClass(r, "save"); var n = document.createElement("span"); n.innerHTML = "New", dom.addClass(n, "button"), dom.addClass(n, "save-as"); var a = document.createElement("span"); a.innerHTML = "Revert", dom.addClass(a, "button"), dom.addClass(a, "revert"); var o = e.__preset_select = document.createElement("select"); if (e.load && e.load.remembered ? Common.each(e.load.remembered, (function (t, i) { addPresetOption(e, i, i === e.preset) })) : addPresetOption(e, DEFAULT_DEFAULT_PRESET_NAME, !1), dom.bind(o, "change", (function () { for (var t = 0; t < e.__preset_select.length; t++)e.__preset_select[t].innerHTML = e.__preset_select[t].value; e.preset = this.value })), t.appendChild(o), t.appendChild(i), t.appendChild(r), t.appendChild(n), t.appendChild(a), SUPPORTS_LOCAL_STORAGE) { var s = document.getElementById("dg-local-explain"), l = document.getElementById("dg-local-storage"); document.getElementById("dg-save-locally").style.display = "block", "true" === localStorage.getItem(getLocalStorageHash(e, "isLocal")) && l.setAttribute("checked", "checked"), showHideExplain(e, s), dom.bind(l, "change", (function () { e.useLocalStorage = !e.useLocalStorage, showHideExplain(e, s) })) } var c = document.getElementById("dg-new-constructor"); dom.bind(c, "keydown", (function (e) { !e.metaKey || 67 !== e.which && 67 !== e.keyCode || SAVE_DIALOGUE.hide() })), dom.bind(i, "click", (function () { c.innerHTML = JSON.stringify(e.getSaveObject(), void 0, 2), SAVE_DIALOGUE.show(), c.focus(), c.select() })), dom.bind(r, "click", (function () { e.save() })), dom.bind(n, "click", (function () { var t = prompt("Enter a new preset name."); t && e.saveAs(t) })), dom.bind(a, "click", (function () { e.revert() })) } function addResizeHandle(e) { var t = void 0; function i(i) { return i.preventDefault(), e.width += t - i.clientX, e.onResize(), t = i.clientX, !1 } function r() { dom.removeClass(e.__closeButton, GUI.CLASS_DRAG), dom.unbind(window, "mousemove", i), dom.unbind(window, "mouseup", r) } function n(n) { return n.preventDefault(), t = n.clientX, dom.addClass(e.__closeButton, GUI.CLASS_DRAG), dom.bind(window, "mousemove", i), dom.bind(window, "mouseup", r), !1 } e.__resize_handle = document.createElement("div"), Common.extend(e.__resize_handle.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }), dom.bind(e.__resize_handle, "mousedown", n), dom.bind(e.__closeButton, "mousedown", n), e.domElement.insertBefore(e.__resize_handle, e.domElement.firstElementChild) } function setWidth(e, t) { e.domElement.style.width = t + "px", e.__save_row && e.autoPlace && (e.__save_row.style.width = t + "px"), e.__closeButton && (e.__closeButton.style.width = t + "px") } function getCurrentPreset(e, t) { var i = {}; return Common.each(e.__rememberedObjects, (function (r, n) { var a = {}, o = e.__rememberedObjectIndecesToControllers[n]; Common.each(o, (function (e, i) { a[i] = t ? e.initialValue : e.getValue() })), i[n] = a })), i } function setPresetSelectIndex(e) { for (var t = 0; t < e.__preset_select.length; t++)e.__preset_select[t].value === e.preset && (e.__preset_select.selectedIndex = t) } function updateDisplays(e) { 0 !== e.length && requestAnimationFrame$1$1.call(window, (function () { updateDisplays(e) })), Common.each(e, (function (e) { e.updateDisplay() })) } GUI.toggleHide = function () { hide = !hide, Common.each(hideableGuis, (function (e) { e.domElement.style.display = hide ? "none" : "" })) }, GUI.CLASS_AUTO_PLACE = "a", GUI.CLASS_AUTO_PLACE_CONTAINER = "ac", GUI.CLASS_MAIN = "main", GUI.CLASS_CONTROLLER_ROW = "cr", GUI.CLASS_TOO_TALL = "taller-than-window", GUI.CLASS_CLOSED = "closed", GUI.CLASS_CLOSE_BUTTON = "close-button", GUI.CLASS_CLOSE_TOP = "close-top", GUI.CLASS_CLOSE_BOTTOM = "close-bottom", GUI.CLASS_DRAG = "drag", GUI.DEFAULT_WIDTH = 245, GUI.TEXT_CLOSED = "Close Controls", GUI.TEXT_OPEN = "Open Controls", GUI._keydownHandler = function (e) { "text" === document.activeElement.type || e.which !== HIDE_KEY_CODE && e.keyCode !== HIDE_KEY_CODE || GUI.toggleHide() }, dom.bind(window, "keydown", GUI._keydownHandler, !1), Common.extend(GUI.prototype, { add: function (e, t) { return _add(this, e, t, { factoryArgs: Array.prototype.slice.call(arguments, 2) }) }, addColor: function (e, t) { return _add(this, e, t, { color: !0 }) }, remove: function (e) { this.__ul.removeChild(e.__li), this.__controllers.splice(this.__controllers.indexOf(e), 1); var t = this; Common.defer((function () { t.onResize() })) }, destroy: function () { if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead."); this.autoPlace && autoPlaceContainer.removeChild(this.domElement); var e = this; Common.each(this.__folders, (function (t) { e.removeFolder(t) })), dom.unbind(window, "keydown", GUI._keydownHandler, !1), removeListeners(this) }, addFolder: function (e) { if (void 0 !== this.__folders[e]) throw new Error('You already have a folder in this GUI by the name "' + e + '"'); var t = { name: e, parent: this }; t.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[e] && (t.closed = this.load.folders[e].closed, t.load = this.load.folders[e]); var i = new GUI(t); this.__folders[e] = i; var r = addRow(this, i.domElement); return dom.addClass(r, "folder"), i }, removeFolder: function (e) { this.__ul.removeChild(e.domElement.parentElement), delete this.__folders[e.name], this.load && this.load.folders && this.load.folders[e.name] && delete this.load.folders[e.name], removeListeners(e); var t = this; Common.each(e.__folders, (function (t) { e.removeFolder(t) })), Common.defer((function () { t.onResize() })) }, open: function () { this.closed = !1 }, close: function () { this.closed = !0 }, hide: function () { this.domElement.style.display = "none" }, show: function () { this.domElement.style.display = "" }, onResize: function () { var e = this.getRoot(); if (e.scrollable) { var t = dom.getOffset(e.__ul).top, i = 0; Common.each(e.__ul.childNodes, (function (t) { e.autoPlace && t === e.__save_row || (i += dom.getHeight(t)) })), window.innerHeight - t - CLOSE_BUTTON_HEIGHT < i ? (dom.addClass(e.domElement, GUI.CLASS_TOO_TALL), e.__ul.style.height = window.innerHeight - t - CLOSE_BUTTON_HEIGHT + "px") : (dom.removeClass(e.domElement, GUI.CLASS_TOO_TALL), e.__ul.style.height = "auto") } e.__resize_handle && Common.defer((function () { e.__resize_handle.style.height = e.__ul.offsetHeight + "px" })), e.__closeButton && (e.__closeButton.style.width = e.width + "px") }, onResizeDebounced: Common.debounce((function () { this.onResize() }), 50), remember: function () { if (Common.isUndefined(SAVE_DIALOGUE) && ((SAVE_DIALOGUE = new CenteredDiv).domElement.innerHTML = saveDialogContents), this.parent) throw new Error("You can only call remember on a top level GUI."); var e = this; Common.each(Array.prototype.slice.call(arguments), (function (t) { 0 === e.__rememberedObjects.length && addSaveMenu(e), -1 === e.__rememberedObjects.indexOf(t) && e.__rememberedObjects.push(t) })), this.autoPlace && setWidth(this, this.width) }, getRoot: function () { for (var e = this; e.parent;)e = e.parent; return e }, getSaveObject: function () { var e = this.load; return e.closed = this.closed, this.__rememberedObjects.length > 0 && (e.preset = this.preset, e.remembered || (e.remembered = {}), e.remembered[this.preset] = getCurrentPreset(this)), e.folders = {}, Common.each(this.__folders, (function (t, i) { e.folders[i] = t.getSaveObject() })), e }, save: function () { this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = getCurrentPreset(this), markPresetModified(this, !1), this.saveToLocalStorageIfPossible() }, saveAs: function (e) { this.load.remembered || (this.load.remembered = {}, this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, !0)), this.load.remembered[e] = getCurrentPreset(this), this.preset = e, addPresetOption(this, e, !0), this.saveToLocalStorageIfPossible() }, revert: function (e) { Common.each(this.__controllers, (function (t) { this.getRoot().load.remembered ? recallSavedValue(e || this.getRoot(), t) : t.setValue(t.initialValue), t.__onFinishChange && t.__onFinishChange.call(t, t.getValue()) }), this), Common.each(this.__folders, (function (e) { e.revert(e) })), e || markPresetModified(this.getRoot(), !1) }, listen: function (e) { var t = 0 === this.__listening.length; this.__listening.push(e), t && updateDisplays(this.__listening) }, updateDisplay: function () { Common.each(this.__controllers, (function (e) { e.updateDisplay() })), Common.each(this.__folders, (function (e) { e.updateDisplay() })) } }); var GUI$1 = GUI; const alpha1 = Math.PI / 180; class PointAttributeData { constructor(e) { this.shapeType = "sphere", this.position = new Vector3, this.positionRange = new Vector3, this.positionRadius = 0, this.velocityShape = "cube", this.velocity = new Vector3, this.velocityRange = new Vector3, this.speed = 0, this.speedRange = 0, this.acceleration = new Vector3, this.accelerationRange = new Vector3, this.alive = 0, this.age = 0, this.deathAge = 1, this.angle = 0, this.angleRange = 0, this.angleVelocity = 0, this.angleVelocityRange = 0, this.angleAcceleration = 0, this.angleAccelerationRange = 0, this.size = 0, this.sizeRange = 0, this.sizeTween = null, this.opacity = 1, this.opacityRange = 0, this.opacityTween = null, this.color = new Color$1, this.colorRange = new Color$1, this.colorTween = null, this.dataCombine(e), this.dataSave(), this.createRandomData() } dataSave() { this.defaultPosition = this.position.clone() } dataCombine(e) { Object.assign(this, e) } createRandomData() { if ("cube" == this.shapeType) this.position = this.randomChange(this.position, this.positionRange); else if ("sphere" == this.shapeType) { const e = 2 * Math.random() - 1, t = 2 * Math.PI * Math.random(), i = Math.sqrt(1 - e * e), r = new Vector3(i * Math.cos(t), i * Math.sin(t), e); this.position = (new Vector3).addVectors(this.position, r.multiplyScalar(this.positionRadius)) } if ("cube" == this.velocityShape) this.velocity = this.randomChange(this.velocity, this.velocityRange); else if ("sphere" == this.velocityShape) { const e = (new Vector3).subVectors(this.position, this.defaultPosition), t = this.randomChange(this.speed, this.speedRange); this.velocity = e.normalize().multiplyScalar(t) } this.acceleration = this.randomChange(this.acceleration, this.accelerationRange), this.angle = this.randomChange(this.angle, this.angleRange), this.angleVelocity = this.randomChange(this.angleVelocity, this.angleVelocityRange), this.angleAcceleration = this.randomChange(this.angleAcceleration, this.angleAccelerationRange), this.size = this.randomChange(this.size, this.sizeRange), this.opacity = this.randomChange(this.opacity, this.opacityRange); const e = this.randomChange(this.color, this.colorRange); this.color = (new Color$1).setHSL(e.x, e.y, e.z) } randomChange(e, t) { if (e instanceof Vector3 && t instanceof Vector3) { const i = new Vector3(Math.random() - .5, Math.random() - .5, Math.random() - .5); return (new Vector3).addVectors(e, (new Vector3).multiplyVectors(t, i)) } return e + t * (Math.random() - .5) } update(e) { if (this.position.add(this.velocity.clone().multiplyScalar(e)), this.velocity.add(this.acceleration.clone().multiplyScalar(e)), this.angle += this.angleVelocity * alpha1 * e, this.angleVelocity += this.angleAcceleration * alpha1 * e, this.sizeTween.times.length > 0 && (this.size = this.sizeTween.lerp(this.age)), this.opacityTween.times.length > 0 && (this.opacity = this.opacityTween.lerp(this.age)), this.colorTween.times.length > 0) { const e = this.colorTween.lerp(this.age); this.color = (new Color$1).setHSL(e.x, e.y, e.z) } this.age += e } } var particleFrag = "\n\nuniform sampler2D maps;\nvarying float v_Angle;\nvarying float v_Opacity;\nvarying vec3 v_Color;\nvarying float v_visibleNum;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n    sin(_angle),cos(_angle));\n}\n\nvoid main(){\n    \n    vec4 Colors=vec4(v_Color,v_Opacity);\n    // gl_FragColor=Colors;\n    \n    // gl_FragColor=vec4(1.,1.,1.,v_Opacity);\n    vec2 uvs=vec2(gl_PointCoord.x,gl_PointCoord.y);\n    uvs-=.5;\n    uvs=rotate2d(v_Angle)*uvs;\n    \n    vec4 textures=texture2D(maps,uvs+.5);\n    \n    gl_FragColor=Colors*textures;\n    gl_FragColor.a=min(gl_FragColor.a,v_visibleNum);\n}", particleVert = "\n\nattribute float angle;\nattribute float size;\nattribute float opacity;\nattribute vec3 color;\nattribute float visible;\n\nvarying float v_Angle;\nvarying float v_Opacity;\nvarying vec3 v_Color;\n\n\nvarying vec3 v_startPos;\nattribute vec3 startPos;\nuniform float density;//更改粒子消失比例\nvarying float v_visibleNum;\n\n\n\nfloat random(in vec2 st){\n    return fract(sin(dot(st.xy,\n                vec2(12.9898,78.233)))\n            *43758.5453123);\n        }\n        \n        float noise(in vec2 st){\n            vec2 i=floor(st);\n            vec2 f=fract(st);\n            \n            // Four corners in 2D of a tile\n            float a=random(i);\n            float b=random(i+vec2(1.,0.));\n            float c=random(i+vec2(0.,1.));\n            float d=random(i+vec2(1.,1.));\n            \n            // Smooth Interpolation\n            \n            // Cubic Hermine Curve.  Same as SmoothStep()\n            vec2 u=f*f*(3.-2.*f);\n            // u = smoothstep(0.,1.,f);\n            \n            // Mix 4 coorners percentages\n            return mix(a,b,u.x)+\n            (c-a)*u.y*(1.-u.x)+\n            (d-b)*u.x*u.y;\n        }\n\nvoid main(){\n\n    v_startPos=startPos;\n    vec3 noisemap=vec3(noise(startPos.xz));\n    float visibleNum=smoothstep(density,density+.001,noisemap.r);\n    v_visibleNum=visibleNum;\n    \n    v_Angle=angle;\n    v_Opacity=opacity;\n    if(visible>.5){\n        v_Color=color;\n    }else{\n        v_Color=vec3(0.);\n        v_Opacity=0.;\n    }\n    vec4 ppos=modelViewMatrix*vec4(position,1.);\n    gl_Position=projectionMatrix*ppos;\n    gl_PointSize=size*(300./length(ppos.xyz));\n}"; class mTween { constructor(e, t) { this.times = e || [], this.values = t || [] } lerp(e) { if (0 == this.times.length) return; let t = 0, i = this.times.length; for (; t < i && e > this.times[t];)t++; if (0 == t) return this.values[0]; if (t == i) return this.values[i - 1]; const r = (e - this.times[t - 1]) / (this.times[t] - this.times[t - 1]); return this.values[0] instanceof Vector3 ? this.values[t - 1].clone().lerp(this.values[t], r) : this.values[t - 1] + r * (this.values[t] - this.values[t - 1]) } } class Particles { constructor(e) { this.initData(), this._initOther(), this.setParams(e), this.getMaxOpacity(), this.getMaxSize(), this.createParticle() } initData() { this._pointSec = 100, this.name = null, this.position = new Vector3, this.shapeType = "cube", this.positionRange = new Vector3, this.positionRadius = 0, this.positionRadiusRange = 0, this.velocityShape = "cube", this.velocity = new Vector3, this.velocityRange = new Vector3, this.speed = 0, this.speedRange = 0, this.acceleration = new Vector3, this.accelerationRange = new Vector3, this.age = 0, this._deathAge = 60, this.pointAge = 0, this.pointDeathAge = 1, this.alive = !0, this._loop = !0, this.pointNum = this._pointSec * Math.min(this._deathAge, this.age), this.angle = 0, this.angleRange = 0, this.angleVelocity = 0, this.angleVelocityRange = 0, this.angleAcceleration = 0, this.angleAccelerationRange = 0, this._size = 0, this._sizeRange = 0, this._sizeTween = new mTween, this._opacity = 1, this._opacityRange = 0, this.opacityTween = new mTween, this.color = new Vector3(1, 1, 1), this.colorRange = new Vector3(0, 0, 0), this.colorToRange = !1, this.colorTween = new mTween([0, 1], [new Vector3(1, 1, 1), new Vector3(1, 1, 1)]), this.colorChange = !1, this.textureURL = null, this.textureName = null, this._texture = (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, "texture/particles/star.png"), (e => { e.flipY = !1 })), this._blendMode = "AdditiveBlending" } getMaxOpacity() { if (this.opacityTween.values.length > 0) { let e; for (let t = 0, i = this.opacityTween.values.length; t < i; t++)null == e && (e = this.opacityTween.values[t], this.opacityMaxNum = t), this.opacityTween.values[t] > e && (e = this.opacityTween.values[t], this.opacityMaxNum = t) } } getMaxSize() { if (this._sizeTween.values.length > 0) { let e; for (let t = 0, i = this._sizeTween.values.length; t < i; t++)null == e && (e = this._sizeTween.values[t], this.sizeMaxNum = t), this._sizeTween.values[t] > e && (e = this._sizeTween.values[t], this.sizeMaxNum = t) } } _initOther() { this.panelsVisible = !1, this.parentName = null, this.id = MathUtils.generateUUID(); let e = null; this.setFamily = t => { e = t }, this.getFamily = () => e } get opacity() { return this._opacity } set opacity(e) { this._opacity = e, null != this.opacityMaxNum && (this.opacityTween.values[this.opacityMaxNum] = this._opacity) } get opacityRange() { return this._opacityRange } set opacityRange(e) { this._opacityRange = e } set size(e) { this._size = e, null != this.sizeMaxNum && (this._sizeTween.values[this.sizeMaxNum] = this._size) } get size() { return this._size } set sizeRange(e) { this._sizeRange = e } get sizeRange() { return this._sizeRange } get pointSec() { return this._pointSec } set pointSec(e) { this._pointSec = e, this.mesh && this.particleNumChange(e) } set state(e) { this.alive = e, this.age = 0 } get state() { return this.alive } set loop(e) { this._loop = e, this.alive = !0, this.age = 0 } get loop() { return this._loop } set map(e) { this.textureURL = e, this._texture = (new TextureLoader).load(e, (e => { e.flipY = !1 })), this.material.uniforms.maps.value = this._texture } get map() { return this._texture } set deathAge(e) { this._deathAge = e, this.age = 0, this.alive = !0 } get deathAge() { return this._deathAge } get startColor() { let e = this.getColor(this.color); return 1 == this.colorChange && (e = this.getColor(this.colorTween.values[0])), e } set startColor(e) { this.color = this.toColor(e), this.colorTween.values[0] = this.toColor(e) } get finalColor() { return this.getColor(this.colorTween.values[1]) } set finalColor(e) { this.colorTween.values[1] = this.toColor(e) } get blendMode() { return this._blendMode } set blendMode(e) { this._blendMode = e, this.mesh && (this.mesh.material.blending = THREE[this._blendMode]) } setParent(e) { this.mesh.parent && this.mesh.parent.remove(this.mesh), this.parentName = e.name, e.add(this.mesh) } setParentByUUID(e) { const t = this.getFamily().getObjectByProperty("uuid", e); t ? this.setParent(t) : (console.warn("由于没有找到对应的uuid,该父对象将设置为默认的group"), this.setParent(this.getFamily())) } setParentByName(e) { const t = this.getFamily().getObjectByName(e); t ? this.setParent(t) : (console.warn("由于没有找到对应的name,该父对象将设置为默认的group"), this.setParent(this.getFamily())) } setParams(e) { for (let t in e) t.indexOf("size") > -1 && !t.indexOf("_") > -1 && (e[`_${t}`] = e[t]); Object.assign(this, e), this._pointSec = e.pointSec, this.id = MathUtils.generateUUID(), this.pointNum = this._pointSec * Math.min(this.pointDeathAge, this._deathAge), this.textureURL.indexOf("base64") > -1 || this.textureURL.indexOf("data:") > -1 ? this._texture = (new TextureLoader).load(this.textureURL, (e => { e.flipY = !1 })) : this._texture = (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, this.textureURL), (e => { e.flipY = !1 })), this.colorTween.values.length > 0 && (this.color = this.colorTween.values[0]) } getParams() { return { position: this.position, positionRange: this.positionRange, shapeType: this.shapeType, positionRadius: this.positionRadius, velocityShape: this.velocityShape, velocity: this.velocity, velocityRange: this.velocityRange, speed: this.speed, speedRange: this.speedRange, acceleration: this.acceleration, accelerationRange: this.accelerationRange, age: this.pointAge, deathAge: this.pointDeathAge, ageRandom: this.pointAgeRandom, angle: this.angle, angleRange: this.angleRange, angleVelocity: this.angleVelocity, angleVelocityRange: this.angleVelocityRange, angleAcceleration: this.angleAcceleration, angleAccelerationRange: this.angleAccelerationRange, size: this._size, sizeRange: this._sizeRange, sizeTween: this._sizeTween, opacity: this._opacity, opacityRange: this._opacityRange, opacityTween: this.opacityTween, color: this.color, startColor: this.startColor, finalColor: this.finalColor, colorRange: this.colorRange, colorTween: this.colorTween, _loop: this._loop, _texture: this._texture, pointNum: this.pointNum } } initPointStartData() { let e; return 1 == this.colorToRange ? this.colorRange = new Vector3(1, 1, 1) : this.colorRange = new Vector3(0, 0, 0), this.colorTween.times[1] = this.pointDeathAge, e = 1 == this.colorChange ? this.colorTween : new mTween, this.pointMatrixData = new PointAttributeData({ position: this.position, positionRange: this.positionRange, shapeType: this.shapeType, positionRadius: this.positionRadius, positionRadiusRange: this.positionRadiusRange, velocityShape: this.velocityShape, velocity: this.velocity, velocityRange: this.velocityRange, speed: this.speed, speedRange: this.speedRange, acceleration: this.acceleration, accelerationRange: this.accelerationRange, age: this.pointAge, deathAge: this.pointDeathAge, deathAgeRange: this.pointDeathAge, ageRandom: this.pointAgeRandom, angle: this.angle, angleRange: this.angleRange, angleVelocity: this.angleVelocity, angleVelocityRange: this.angleVelocityRange, angleAcceleration: this.angleAcceleration, angleAccelerationRange: this.angleAccelerationRange, size: this._size, sizeRange: this._sizeRange, sizeTween: this._sizeTween, opacity: this._opacity, opacityRange: this._opacityRange, opacityTween: this.opacityTween, color: this.color, colorRange: this.colorRange, colorTween: e, deathAge: this.pointDeathAge }), this.pointMatrixData } createParticle() { this.geometry = new BufferGeometry, this.pointAnimationData = []; const e = [], t = [], i = [], r = [], n = [], a = []; for (let o = 0; o < this.pointNum; o++)this.pointAnimationData[o] = this.initPointStartData(), e[3 * o] = this.pointAnimationData[o].position.x, e[3 * o + 1] = this.pointAnimationData[o].position.y, e[3 * o + 2] = this.pointAnimationData[o].position.z, t[o] = this.pointAnimationData[o].angle, i[o] = this.pointAnimationData[o].size, r[o] = this.pointAnimationData[o].opacity, n[3 * o] = this.pointAnimationData[o].color.r, n[3 * o + 1] = this.pointAnimationData[o].color.g, n[3 * o + 2] = this.pointAnimationData[o].color.b, a[o] = this.pointAnimationData[o].alive; this.geometry.setAttribute("position", new Float32BufferAttribute(e, 3)), this.geometry.setAttribute("startPos", new Float32BufferAttribute(e, 3)), this.geometry.setAttribute("angle", new Float32BufferAttribute(t, 1)), this.geometry.setAttribute("size", new Float32BufferAttribute(i, 1)), this.geometry.setAttribute("opacity", new Float32BufferAttribute(r, 1)), this.geometry.setAttribute("color", new Float32BufferAttribute(n, 3)), this.geometry.setAttribute("visible", new Float32BufferAttribute(a, 1)), this.material = new ShaderMaterial({ uniforms: { maps: { value: this._texture }, density: { value: 0 } }, vertexShader: particleVert, fragmentShader: particleFrag, transparent: !0, alphaTest: .5, depthWrite: !1, blending: THREE[this._blendMode] }), this.mesh = new Points(this.geometry, this.material), this.mesh.styleType = "particle", this.mesh.system = this } set density(e) { e = 1 - e, this.mesh.material.uniforms.density.value = e } get density() { return 1 - this.mesh.material.uniforms.density.value } particleNumChange(e = 200) { this.state = !1, this._pointSec = e; const t = this._pointSec * Math.min(this.pointDeathAge, this._deathAge); this.pointNum = Math.ceil(t); const i = [], r = [], n = [], a = [], o = [], s = []; for (let e = 0; e < this.pointNum; e++)this.pointAnimationData[e] = this.initPointStartData(), i[3 * e] = this.pointAnimationData[e].position.x, i[3 * e + 1] = this.pointAnimationData[e].position.y, i[3 * e + 2] = this.pointAnimationData[e].position.z, r[e] = this.pointAnimationData[e].angle, n[e] = this.pointAnimationData[e].size, a[e] = this.pointAnimationData[e].opacity, o[3 * e] = this.pointAnimationData[e].color.r, o[3 * e + 1] = this.pointAnimationData[e].color.g, o[3 * e + 2] = this.pointAnimationData[e].color.b, s[e] = this.pointAnimationData[e].alive; this.mesh.geometry.setAttribute("position", new Float32BufferAttribute(i, 3)), this.mesh.geometry.setAttribute("startPos", new Float32BufferAttribute(i, 3)), this.mesh.geometry.setAttribute("angle", new Float32BufferAttribute(r, 1)), this.mesh.geometry.setAttribute("size", new Float32BufferAttribute(n, 1)), this.mesh.geometry.setAttribute("opacity", new Float32BufferAttribute(a, 1)), this.mesh.geometry.setAttribute("color", new Float32BufferAttribute(o, 3)), this.mesh.geometry.setAttribute("visible", new Float32BufferAttribute(s, 1)), this.state = !0 } update(e) { const t = this.geometry.attributes.position.array, i = this.geometry.attributes.angle.array, r = this.geometry.attributes.size.array, n = this.geometry.attributes.opacity.array, a = this.geometry.attributes.color.array, o = this.geometry.attributes.visible.array, s = this.geometry.attributes.startPos.array, l = []; for (let s = 0; s < this.pointNum; s++) { const c = this.pointAnimationData[s]; 1 == c.alive && (c.update(e), c.age > this.pointDeathAge && (c.alive = 0, l.push(s)), t[3 * s] = c.position.x, t[3 * s + 1] = c.position.y, t[3 * s + 2] = c.position.z, i[s] = c.angle, r[s] = c.size, n[s] = c.opacity, a[3 * s] = c.color.r, a[3 * s + 1] = c.color.g, a[3 * s + 2] = c.color.b, o[s] = c.alive) } if (this.geometry.attributes.position.needsUpdate = !0, this.geometry.attributes.angle.needsUpdate = !0, this.geometry.attributes.size.needsUpdate = !0, this.geometry.attributes.opacity.needsUpdate = !0, this.geometry.attributes.color.needsUpdate = !0, this.geometry.attributes.visible.needsUpdate = !0, this.alive) { if (this.age < this.pointDeathAge) { let t = Math.round(this._pointSec * (this.age + 0)), i = Math.round(this._pointSec * (this.age + e)); i > this.pointNum && (i = this.pointNum); for (let e = t; e < i; e++)this.pointAnimationData[e].alive = 1 } for (let e = 0; e < l.length; e++) { const i = l[e]; this.pointAnimationData[i] = this.initPointStartData(), this.pointAnimationData[i].alive = 1, t[3 * i] = this.pointAnimationData[i].position.x, t[3 * i + 1] = this.pointAnimationData[i].position.y, t[3 * i + 2] = this.pointAnimationData[i].position.z, s[3 * i] = this.pointAnimationData[i].position.x, s[3 * i + 1] = this.pointAnimationData[i].position.y, s[3 * i + 2] = this.pointAnimationData[i].position.z } this.geometry.attributes.position.needsUpdate = !0, this.geometry.attributes.startPos.needsUpdate = !0, this.age += e, this.age > this._deathAge && !this.loop && (this.alive = !1) } } showPanel() { let e; this.panels = new GUI$1, e = this.name ? this.name : "粒子动画管理器"; const t = this.panels.addFolder(e); t.open(), t.add(this, "_pointSec", 0, 1e3, 1).name("粒子数量").onChange((e => { this.particleNumChange(e) })), t.add(this, "density", 0, 1, .01).name("粒子密度百分比"); const i = t.addFolder("基础设置"); i.open(), i.add(this, "shapeType", ["sphere", "cube"]).name("初始位置类型").onChange((e => { this.shapeType = e })); const r = i.addFolder("cube类型初始位置"), n = r.addFolder("cube位置初始范围"); n.add(this.position, "x", -500, 500, 1).name("位置X").onChange((e => { this.position.x = e })), n.add(this.position, "y", -500, 500, 1).name("位置Y").onChange((e => { this.position.y = e })), n.add(this.position, "z", -500, 500, 1).name("位置Z").onChange((e => { this.position.z = e })); const a = r.addFolder("cube位置随机范围"); a.add(this.positionRange, "x", -500, 500, 1).name("x").onChange((e => { this.positionRange.x = e })), a.add(this.positionRange, "y", -500, 500, 1).name("y").onChange((e => { this.positionRange.y = e })), a.add(this.positionRange, "z", -500, 500, 1).name("z").onChange((e => { this.positionRange.z = e })); const o = i.addFolder("sphere类型初始位置"); o.add(this, "positionRadius", 0, 100, .1).name("球体发射半径").onChange((e => { this.positionRadius = e })), o.add(this, "positionRadiusRange", 0, 100, .1).name("球体发射半径随机范围").onChange((e => { this.positionRadiusRange = e })), i.add(this, "velocityShape", ["sphere", "cube"]).name("发射方向类型").onChange((e => { this.velocityShape = e })); const s = i.addFolder("发射类型cube速度"); s.add(this.velocity, "x", -50, 50, .1).name("x").onChange((e => { this.velocity.x = e })), s.add(this.velocity, "y", -50, 50, .1).name("y").onChange((e => { this.velocity.y = e })), s.add(this.velocity, "z", -50, 50, .1).name("z").onChange((e => { this.velocity.z = e })); const l = s.addFolder("发射类型cube随机速度范围"); l.add(this.velocityRange, "x", -50, 50, .1).name("x").onChange((e => { this.velocity.x = e })), l.add(this.velocityRange, "y", -50, 50, .1).name("y").onChange((e => { this.velocity.y = e })), l.add(this.velocityRange, "z", -50, 50, .1).name("z").onChange((e => { this.velocity.z = e })); const c = i.addFolder("发射类型sphere速度"); c.add(this, "speed", 0, 100, .1).name("球状发射速度").onChange((e => { this.speed = e })), c.add(this, "speedRange", 0, 100, .1).name("球状发射速度变化范围").onChange((e => { this.speedRange = e })); const h = i.addFolder("加速度"), u = h.addFolder("初始化加速度"); u.add(this.acceleration, "x", -100, 100, .1).name("x").onChange((e => { this.acceleration.x = e })), u.add(this.acceleration, "y", -100, 100, .1).name("y").onChange((e => { this.acceleration.y = e })), u.add(this.acceleration, "z", -100, 100, .1).name("z").onChange((e => { this.acceleration.z = e })); const d = h.addFolder("加速度随机范围"); d.add(this.accelerationRange, "x", -100, 100, .1).name("x").onChange((e => { this.accelerationRange.x = e })), d.add(this.accelerationRange, "y", -100, 100, .1).name("y").onChange((e => { this.accelerationRange.y = e })), d.add(this.accelerationRange, "z", -100, 100, .1).name("z").onChange((e => { this.accelerationRange.z = e })); const p = t.addFolder("时间周期"); p.add(this, "age", 0, 120, .1).name("播放时间").listen().onChange((e => { this.age = e })), p.add(this, "_deathAge", 0, 120, 1).name("生命周期").onChange((e => { this._deathAge = e })), p.add(this, "pointDeathAge", 0, 120, 1).name("内部粒子生命周期").onChange((e => { this.pointDeathAge = e })), p.add(this, "alive").name("持续播放").onChange((e => { this.alive = e })), p.add(this, "_loop").name("是否循环").onChange((e => { this._loop = e })); const f = t.addFolder("粒子状态"), m = f.addFolder("角度状态"); m.add(this, "angle", 0, 360, .1).name("初始化角度").onChange((e => { this.angle = e })), m.add(this, "angleRange", 0, 360, .1).name("初始化角度随机范围").onChange((e => { this.angleRange = e })), m.add(this, "angleVelocity", 0, 360, .1).name("角度旋转速度").onChange((e => { this.angleVelocity = e })), m.add(this, "angleVelocityRange", 0, 360, .1).name("角度旋转速度随机范围").onChange((e => { this.angleVelocityRange = e })), m.add(this, "angleAcceleration", 0, 360, .1).name("角度加速度").onChange((e => { this.angleAcceleration = e })), m.add(this, "angleAccelerationRange", 0, 360, .1).name("角度加速度范围").onChange((e => { this.angleAccelerationRange = e })); const g = f.addFolder("大小状态"); g.add(this, "size", 0, 100, .1).name("大小尺寸").onChange((e => { this._size = e })), g.add(this, "sizeRange", 0, 100, .1).name("大小随机范围").onChange((e => { this._sizeRange = e })); const y = g.addFolder("大小变化动画"); let v = { startTime: this._sizeTween.times[0] || 0, centerTime: this._sizeTween.times[1] || 0, finalTime: this._sizeTween.times[2] || 0, startTws: this._sizeTween.values[0] || 0, centerTws: this._sizeTween.values[1] || 0, finalTws: this._sizeTween.values[2] || 0 }; y.add(v, "startTime", 0, 60, 1).name("起始时间").onChange((e => { this._sizeTween.times[0] = e })), y.add(v, "centerTime", 0, 60, 1).name("时间节点一").onChange((e => { this._sizeTween.times[1] = e })), y.add(v, "finalTime", 0, 60, 1).name("时间节点二").onChange((e => { this._sizeTween.times[2] = e })), y.add(v, "startTws", 0, 100, .1).name("初始状态").onChange((e => { this._sizeTween.values[0] = e })), y.add(v, "centerTws", 0, 100, .1).name("中间状态").onChange((e => { this._sizeTween.values[1] = e })), y.add(v, "finalTws", 0, 100, .1).name("最终状态").onChange((e => { this._sizeTween.values[2] = e })); const _ = { startTime: this.opacityTween.times[0] || 0, centerTime: this.opacityTween.times[1] || 0, finalTime: this.opacityTween.times[2] || 0, startTws: this.opacityTween.values[0] || 0, centerTws: this.opacityTween.values[1] || 0, finalTws: this.opacityTween.values[2] || 0 }, b = f.addFolder("透明度状态"); b.add(this, "opacity", 0, 1, .01).name("透明度").onChange((e => { this._opacity = e })), b.add(this, "opacityRange", 0, 1, .01).name("透明度范围").onChange((e => { this.opacityRange = e })); const x = b.addFolder("透明参数渐变动画"); x.add(_, "startTime", 0, 60, .1).name("初始时间").onChange((e => { this.opacityTween.times[0] = e })), x.add(_, "centerTime", 0, 60, .1).name("状态时间一").onChange((e => { this.opacityTween.times[1] = e })), x.add(_, "finalTime", 0, 60, .1).name("状态时间二").onChange((e => { this.opacityTween.times[2] = e })), x.add(_, "startTws", 0, 1, .01).name("初始透明状态").onChange((e => { this.opacityTween.values[0] = e })), x.add(_, "centerTws", 0, 1, .01).name("透明状态一").onChange((e => { this.opacityTween.values[1] = e })), x.add(_, "finalTws", 0, 1, .01).name("透明状态二").onChange((e => { this.opacityTween.values[2] = e })); const w = f.addFolder("粒子颜色状态"), S = { color: this.getColor(this.color), colorRange: this.getColor(this.colorRange), startTime: this.colorTween.times[0] || 0, centerTime: this.colorTween.times[1] || 0, finalTime: this.colorTween.times[2] || 0, startTW: this.getColor(this.colorTween.values[0]), centerTW: this.getColor(this.colorTween.values[1]), finalTW: this.getColor(this.colorTween.values[2]) }; w.addColor(S, "color").name("初始化颜色").onChange((e => { this.color = this.toColor(e) })), w.addColor(S, "colorRange").name("颜色随机范围").onChange((e => { this.colorRange = this.toColor(e) })); const M = w.addFolder("粒子颜色动画（注:先颜色后时间）"); M.add(S, "startTime", 0, 60, .1).name("初始时间").onChange((e => { this.colorTween.times[0] = e })), M.add(S, "centerTime", 0, 60, .1).name("时间状态一").onChange((e => { this.colorTween.times[1] = e })), M.add(S, "finalTime", 0, 60, .1).name("时间状态二").onChange((e => { this.colorTween.times[2] = e })), M.addColor(S, "startTW").name("初始颜色状态").onChange((e => { this.colorTween.values[0] = this.toColor(e) })), M.addColor(S, "centerTW").name("颜色状态一").onChange((e => { this.colorTween.values[1] = this.toColor(e) })), M.addColor(S, "finalTW").name("颜色状态二").onChange((e => { this.colorTween.values[2] = this.toColor(e) })); const T = { changeTex: () => { this.importImg((e => { const t = (new TextureLoader).load(e, (e => { e.flipY = !1 })); this.textureURL = e, this.map = t })) }, export: () => { this.exportDate(), alert("具体参数请看控制台") }, modelView: "AdditiveBlending" }; t.add(T, "changeTex").name("更换贴图"), t.add(T, "export").name("导出调整参数"), t.add(this, "blendMode", ["AdditiveBlending", "NormalBlending"]).name("混合模式").onChange((e => { this._blendMode = e, this.mesh.material.blending = THREE[this._blendMode] })), this.panelsVisible = !0, document.getElementsByClassName("dg ac")[0].style.zIndex = 1e5 } destroyPanel() { this.panelsVisible = !1, this.panels.destroy() } getColor(e) { if (e) { return `#${(new Color$1).setHSL(e.x, e.y, e.z).getHexString()}` } return `#${(new Color$1).setHSL(0, 0, 0).getHexString()}` } toColor(e) { let t = new Color$1(e).getHSL(); return new Vector3(t.h, t.s, t.l) } importImg(e) { let t = document.createElement("input"); t.type = "file"; const i = () => { if (!t.files) return; const r = t.files[0]; if (r.type.match(/image.*/)) { const n = new FileReader; n.onload = () => { const r = n.result; e && e(r), t.removeEventListener("change", i, !1), t = null }, n.readAsDataURL(r) } }; t.addEventListener("change", i, !1), t.click() } exportDate() { return { pointSec: this._pointSec, name: this.name, id: this.id, position: this.position, shapeType: this.shapeType, positionRange: this.positionRange, positionRadius: this.positionRadius, positionRadiusRange: this.positionRadiusRange, velocityShape: this.velocityShape, velocity: this.velocity, velocityRange: this.velocityRange, speed: this.speed, speedRange: this.speedRange, acceleration: this.acceleration, accelerationRange: this.accelerationRange, _deathAge: this._deathAge, pointDeathAge: this.pointDeathAge, alive: this.alive, _loop: this._loop, pointNum: this.pointNum, angle: this.angle, angleRange: this.angleRange, angleVelocity: this.angleVelocity, angleVelocityRange: this.angleVelocityRange, angleAcceleration: this.angleAcceleration, angleAccelerationRange: this.angleAccelerationRange, size: this._size, sizeRange: this._sizeRange, sizeTween: this._sizeTween, opacity: this._opacity, opacityRange: this._opacityRange, opacityTween: this.opacityTween, color: this.getColor(this.color), colorRange: this.getColor(this.colorRange), colorToRange: this.colorToRange, colorTween: (e => { const t = { times: [], values: [] }; t.times = e.times; for (let i = 0; i < e.values.length; i++) { const r = this.getColor(e.values[i]); t.values[i] = r } return t })(this.colorTween), colorChange: this.colorChange, startColor: this.startColor, finalColor: this.finalColor, textureURL: this.textureURL, textureName: this.textureName, parentName: this.parentName, blendMode: this.blendMode } } dispose() { this.mesh.parent.remove(this.mesh), this.mesh.geometry.dispose(), this.mesh.material.dispose() } } const colorVec3 = e => { const t = {}; return new Color$1(e).getHSL(t), new Vector3(t.h, t.s, t.l) }, fire = function () { return { name: "火焰", shapeType: "sphere", position: new Vector3(0, 0, 0), positionRadius: 2, velocityShape: "cube", velocity: new Vector3(0, 20, 0), sizeTween: new mTween([0, .3, 1], [1, 15, 1]), opacityTween: new mTween([.7, 1], [1, 0]), colorTween: new mTween([.5, 1], [new Vector3(.02, 1, .5), new Vector3(.05, 1, 0)]), colorChange: !0, textureURL: "texture/particles/smoke.png", pointSec: 200 } }, snow = function () { return { name: "雪花", pointNum: 200, shapeType: "cube", position: new Vector3(0, 30, 0), positionRange: new Vector3(50, 0, 50), velocityShape: "cube", velocity: new Vector3(0, -10, 0), velocityRange: new Vector3(5, 2, 5), angle: 0, angleRange: 720, angleVelocity: 0, angleVelocityRange: 60, sizeTween: new mTween([0, .25], [.2, 2]), opacityTween: new mTween([2, 3], [.8, 0]), deathAge: 60, pointDeathAge: 5, textureURL: "texture/particles/snowflake.png", pointSec: 200 } }, water = function () { return { name: "喷泉", shapeType: "cube", positionRange: new Vector3(1, 2, 1), velocity: new Vector3(0, 13, 0), velocityRange: new Vector3(7, 5, 7), acceleration: new Vector3(0, -7, 0), velocityShape: "cube", sizeTween: new mTween([0, .25, 4], [.2, 3, .3]), colorTween: new mTween([0, .5], [new Vector3(.5, .1, .8), new Vector3(.5, .9, .3)]), colorChange: !0, opacityTween: new mTween([0, .2, 3.5], [0, 1, 0]), deathAge: 60, pointDeathAge: 4, textureURL: "texture/particles/snowflake.png" } }, smoke = function () { return { name: "烟雾", position: new Vector3(0, 2, 0), sizeTween: new mTween([0, 1], [0, 8]), positionRange: new Vector3(1, 10, 1), velocity: new Vector3(0, 10, 0), velocityRange: new Vector3(4, 5, 4), acceleration: new Vector3(0, -1, 0), textureURL: "texture/particles/smoke.png", opacityTween: new mTween([0, .3, 2], [0, .5, 0]), pointDeathAge: 2, pointSec: 100 } }, music = function () { return { name: "音符", sizeTween: new mTween([0, 3, 10], [1, 5, 0]), positionRange: new Vector3(10, 0, 10), acceleration: new Vector3(0, -.1, 0), velocity: new Vector3(0, 1, 0), velocityRange: new Vector3(5, -1, 5), shapeType: "cube", velocityShape: "cube", textureURL: "texture/particles/yinfu.png", pointSec: 10, pointDeathAge: 10, angleRange: 360, angleVelocity: 20, colorTween: new mTween([0, 5, 10], [colorVec3("green"), colorVec3("red"), colorVec3("blue")]), colorChange: !0, opacityTween: new mTween([0, 5, 10], [0, 1, .1]), colorToRange: !0 } }, fireFly = function () { return { name: "萤火虫", shapeType: "cube", positionRange: new Vector3(50, 50, 50), velocityShape: "cube", velocityRange: new Vector3(2, 2, 2), textureURL: "texture/particles/spark.png", color: new Vector3(.3, 1, .6), colorRange: colorVec3("blue"), colorToRange: !0, size: 4, sizeRange: 2, pointSec: 20, pointDeathAge: 8 } }, example = { fire: fire, snow: snow, water: water, smoke: smoke, music: music, fireFly: fireFly }, getExample = e => { if (e) return example[e]() }; class ParticleStore { constructor(e) { e && (this.modelItem = e), this.initArrayFunc(), this._initGroups(), this.initData(), this.setParent(this.modelItem.getGroup()), this.panelsVisible = !1, this.needsRemove = !1 } initData() { this.particleGroup = [], this.particleNum = 0, this.particleAnimateData = []; let e = this.modelItem.getGroup(); this.getParent = () => e, this.setParent = t => { this.particleModelGroup.parent && this.particleModelGroup.parent.remove(this.particleModelGroup), e = t, e.add(this.particleModelGroup) }, this.id = MathUtils.generateUUID(), this._state = null } initArrayFunc() { this.arrayRemove = function (e, t) { var i = e.indexOf(t); i > -1 && e.splice(i, 1) } } _initGroups() { this.particleModelGroup = new Group, this.particleModelGroup.name = "粒子管理器组" } set name(e) { this.particleModelGroup.name = e, this._name = e } get name() { return this.particleModelGroup.name } getParticleAnimation(e) { e && e.traverse((e => { if (e.isPoints && "particle" == e.styleType) { let t; null != e.system.name && "" != e.system.name ? t = e.system.name : (t = `粒子动画${this.particleNum}`, this.particleNum++), e.system.name = t, this.particleGroup.push(e.system) } })) } setParentByName(e) { const t = this.modelItem.getGroup().getObjectByName(e); t ? this.setParent(t) : (console.warn("由于没有找到对应的name,该父对象将设置为默认的group"), this.setParent(this.getParent())) } addParticle(e) { let t; "object" == typeof e ? t = e : "string" == typeof e && (t = getExample(e), t._texture = (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, t.textureURL))); const i = new Particles(t), r = this.particleModelGroup; i.setFamily(r), e.parentName ? i.setParentByName(e.parentName) : i.setParent(r), "" != i.name || i.name || (i.name = `粒子动画${this.particleNum}`, this.particleNum++), this.particleGroup.push(i) } getState() { if (this.particleGroup.length > 0) for (let e = 0; e < this.particleGroup.length; e++)console.log(this.particleGroup[e]); else console.warn("当前场景内部没有动画。。。。。。") } update(e) { for (let e = 0; e < this.particleGroup.length; e++)this.particleGroup[e].update(.015) } initGUI() { this.gui = new GUI$1 } set nameFolder(e) { this.parentGUI.domElement.innerText = e } showPanel() { this.initGUI(), this.parentGUI = this.gui.addFolder("动画管理器"); for (let e = 0; e < this.particleGroup.length; e++)this.addPanelList(this.parentGUI, this.particleGroup[e]); this.panelsVisible = !0, document.getElementsByClassName("dg ac")[0].style.zIndex = 1e5 } addPanelList(e, t) { const i = { obs: t, state: t.state, name: t.name, showPanel: !1 }, r = e.addFolder(i.name); r.add(i, "state").name(`${i.name}动画`).onChange((e => { i.obs.state = e })), r.add(i, "showPanel").name(`${i.name}的控制面板`).onChange((e => { e ? i.obs.showPanel() : i.obs.destroyPanel() })), r.add(this, "clearOne").name("删除动画").onChange((t => { this.remove(i.obs), e.removeFolder(r) })) } clearOne(e) { this.arrayRemove(this.particleGroup, e) } remove(e) { 1 == e.panelsVisible && e.destroyPanel(), this.clearOne(e), e.dispose() } removeAll() { this.particleGroup.forEach((e => { this.remove(e) })) } destroyPanel() { this.gui.destroy(), this.panelsVisible = !1 } getParticleStoreSetting() { const e = { particleData: null, name: null }; return e.particleData = this.getSetting(), e.name = this.name, e.parentName = this.getParent() ? this.getParent().name : "", e.position = this.particleModelGroup.position.clone(), e } getSetting() { this.particleAnimateData = []; const e = this.particleGroup.length; for (let t = 0; t < e; t++)this.particleAnimateData.push(this.particleGroup[t].exportDate()); return this.particleAnimateData } applyParticleSettings(e) { e && (e.parentName && this.setParentByName(e.parentName), e.position && this.particleModelGroup.position.set(e.position.x, e.position.y, e.position.z), e.particleData && this.applySetting(e.particleData)) } applySetting(e) { const t = e => { let t = new Color$1(e).getHSL(); return new Vector3(t.h, t.s, t.l) }, i = e => { const i = e; for (let r = 0; r < e.values.length; r++) { const n = t(e.values[r]); i.values[r] = n } return i }; for (let r = 0; r < e.length; r++)if (e[r]) { let n = {}; Object.assign(n, e[r]), n.position = this.JsonToVec3(n.position), n.positionRange = this.JsonToVec3(n.positionRange), n.velocity = this.JsonToVec3(n.velocity), n.velocityRange = this.JsonToVec3(n.velocityRange), n.acceleration = this.JsonToVec3(n.acceleration), n.accelerationRange = this.JsonToVec3(n.accelerationRange), n.sizeTween && (n.sizeTween = this.JsonTomTween(n.sizeTween)), n._sizeTween && (n._sizeTween = this.JsonTomTween(n._sizeTween)), n.opacityTween = this.JsonTomTween(n.opacityTween), n.color = t(n.color), n.colorRange = t(n.colorRange), n.colorTween = i(n.colorTween), n.colorTween = this.JsonTomTween(n.colorTween), this.addParticle(n) } } setParentByUUID(e) { const t = this.modelItem.getGroup().getObjectByProperty("uuid", e); t ? this.setParent(t) : (console.warn("由于没有找到对应的uuid,该父对象将设置为默认的group"), this.setParent(this.getParent())) } dispose() { this.particleModelGroup.traverse((e => { e.geometry && e.geometry.dispose(), e.material && e.material.dispose(), e = null })); const e = this.particleModelGroup.parent; e && e.remove(this.particleModelGroup), this.particleModelGroup = null, this._initGroups(); for (let e = 0; e < this.particleGroup.length; e++)this.particleGroup[e].dispose(); this.particleGroup.splice(0, this.particleGroup.length), this.particleAnimateData.splice(0, this.particleAnimateData.length), this.particleNum = 0 } JsonToVec3(e) { return new Vector3(e.x, e.y, e.z) } JsonTomTween(e) { for (let t = 0; t < e.values.length; t++)"object" == typeof e.values[t] && (e.values[t] = this.JsonToVec3(e.values[t])); return new mTween(e.times, e.values) } set state(e) { this._state = e; for (let t = 0; t < this.particleGroup.length; t++)this.particleGroup[t].state = e } get state() { return this._state } } class ModelItem extends ObjectTreeItem { constructor({ id: e = util$1.guid(), name: t, modelPath: i, modelType: r = "glb", transform: n, children: a = [], isVisible: o, isLock: s, index: l, parent: c, loadModel: h, parentUUID: u }, d, p, f) { super("ModelItem"), this.id = e, this.name = t || this.id, this.modelPath = i, this.modelType = r.toLowerCase(), this.children = a, this.materialStore = new MaterialStore(_context.textureStore, _context.instance), this.particleStoreArray = [], this.type = "ModelItem", this.index = l, this.parent = c, this.articulations = [], this.articulationAnimations = [], this.parentUUID = u; let m = f || null; var g; if (this.addParticleStore = e => { const t = new ParticleStore(this); return t.name = e, _context.animationStore.add(t), this.particleStoreArray.push(t), t }, this.removeParticleStore = e => { const t = function (e, t) { var i = e.indexOf(t); i > -1 && e.splice(i, 1) }; for (let i = 0; i < this.particleStoreArray.length; i++)this.particleStoreArray[i].name == e && (_context.animationStore.remove(this.particleStoreArray[i]), t(this.particleStoreArray, this.particleStoreArray[i])) }, this.getParticleSettings = () => { let e = []; for (let t = 0; t < this.particleStoreArray.length; t++) { const i = this.particleStoreArray[t].getParticleStoreSetting(); e.push(i) } return e }, this.applyParticleSettings = e => { for (let t = 0; t < e.length; t++) { this.addParticleStore(e[t].name).applyParticleSettings(e[t]) } }, this.addArticulation = ({ type: e, name: t, values: i, defaultValue: r }) => { let n = new Articulation({ type: e, name: t, values: i, defaultValue: r }); n.isValid() && (n.getModelNode = () => g, n.getModelItem = () => this, n._type = n.getType(), n._name = n.getName(), n._values = n.getValues(), n._defaultValue = n.getDefaultValue(), this.articulations.push(n)) }, this.deleteArticulation = e => { let t = this.articulations.findIndex((t => t.name == e)); this.articulations[t].deleteArticulation(), this.articulations.splice(t, 1) }, this.addArticulationAnimation = e => { let t = new ArticulationAnimation(e, this.name); this.articulationAnimations.push(t) }, this.playArticulationAnimation = (e, t) => { let i = this.articulationAnimations.find((t => t.animationName === e)); i && i.play(t) }, this.pauseArticulationAnimation = e => { let t = this.articulationAnimations.find((t => t.animationName === e)); t && t.pause() }, this.resumeArticulationAnimation = e => { let t = this.articulationAnimations.find((t => t.animationName === e)); t && t.resume() }, this.resetArticulationAnimation = e => { let t = this.articulationAnimations.find((t => t.animationName === e)); t && t.reset() }, this.deleteArticulationAnimation = e => { let t = this.articulationAnimations.findIndex((t => t.animationName === e)); t > -1 && (this.articulationAnimations[t].delete(), this.articulationAnimations.splice(t, 1)) }, this.materialStore.getModelNode = () => g, this.getGroup = () => g, this.findMaterial = e => this.materialStore.find(e), this.getMaterials = () => this.materialStore.getAll(), this.applyState = () => { if (g && "" !== _context.stateStore.getCurrentState()) { let e = _context.stateStore.findState(_context.stateStore.getCurrentState()); e.settings.models && e.settings.models[this.name] && "boolean" == typeof e.settings.models[this.name].visible && (g.visible = e.settings.models[this.name].visible) } }, this.scale = (e = 1, t = 1, i = 1) => { g && g.scale.set(e, t, i) }, this.translate = (e = 0, t = 0, i = 0) => { g && g.position.set(e, t, i) }, this.rotateX = e => { g && g.rotateX(util$1.degreeToRadian(e)) }, this.rotateY = e => { g && g.rotateY(util$1.degreeToRadian(e)) }, this.rotateZ = e => { g && g.rotateZ(util$1.degreeToRadian(e)) }, this.findNode = (e = "") => util$1.findNodeRecursively(e, g), this.hideNode = (e = "") => { let t = util$1.findNodeRecursively(e, g); t && (t.visible = !1) }, this.showNode = (e = "") => { let t = util$1.findNodeRecursively(e, g); t && (t.visible = !0) }, this.getSettings = () => (g && (this.transform.position = g.position, this.transform.rotation = g.rotation, this.transform.scale = g.scale), { id: this.id, name: this.name, modelPath: this.modelPath, modelType: this.modelType, articulations: this.articulations.map((e => e.getSettings ? e.getSettings() : e)), articulationAnimations: this.articulationAnimations, particleStores: this.getParticleSettings(), children: this.children, materials: this.materialStore.getSettings(), transform: this.transform, type: this.getType(), isVisible: this._getVisible(), isLock: this._getLock(), index: this.index, parent: this.parent }), this._fbxLoad = () => { }, this._glbLoad = () => { }, this.addModel = (e, t, i) => (logger.debug("TRACE: ModelItem.addModel() - Entering.", e), e = e || {}, logger.debug("TRACE: ModelItem.addModel() - Leaving and return a Promise."), new Promise(((r, n) => { if (_context.loaders.gltfLoader || (t && t(0, "No loader initiated."), n(new Error("No loader initiated."))), e.name || (e.name = util$1.guid()), e.modelPath.toLowerCase().indexOf("#disablecache") > -0) { let a = i => { (g = i.scene).name = e.name, e.transform && (e.transform.position && null != e.transform.position.x && g.position.set(e.transform.position.x, e.transform.position.y, e.transform.position.z), e.transform.rotation && null != e.transform.rotation._x && (g.rotation.x = e.transform.rotation._x, g.rotation.y = e.transform.rotation._y, g.rotation.z = e.transform.rotation._z), e.transform.scale && (null != e.transform.scale.x ? g.scale.set(e.transform.scale.x, e.transform.scale.y, e.transform.scale.z) : "number" == typeof e.transform.scale && g.scale.set(e.transform.scale, e.transform.scale, e.transform.scale))), m ? m.add(g) : _context.scene.models.add(g); const n = g.sourceModelKey; if (g.traverse((t => { if (util$1.capableForCastingShadow(t) && (t.castShadow = !0, t.receiveShadow = !0), t.material instanceof Array) for (let i of t.material) { if (i instanceof MeshBasicMaterial) { let e = util$1.MeshBasicMaterialToMeshStandardMaterial(i); e.needsUpdate = !0, t.material[t.material.indexOf(i)] = e, i = e } if (i instanceof MeshStandardMaterial) { i.alphaTest = .05, i.depthWrite = !0, i.depthTest = !0, i.vertexColors = !1, i.needsUpdate = !0; for (let e in i) i[e] instanceof Texture$1 && i[e].image && _context.textureStore.add(i[e].name || `${i.name}#${e}`, i[e], n); this.materialStore.add(i.name, i, t, e.name) } } else { if (t.material instanceof MeshBasicMaterial) { let e = util$1.MeshBasicMaterialToMeshStandardMaterial(t.material); e.needsUpdate = !0, t.material = e } if (t.material instanceof MeshStandardMaterial) { t.material.alphaTest = .05, t.material.depthWrite = !0, t.material.depthTest = !0, t.material.vertexColors = !1, t.material.needsUpdate = !0; for (let e in t.material) t.material[e] instanceof Texture$1 && t.material[e].image && _context.textureStore.add(t.material[e].name || `${t.material.name}#${e}`, t.material[e], n); this.materialStore.add(t.material.name, t.material, t, e.name) } } })), i.animations instanceof Array && i.animations.length > 0) { let e = new AnimationMixer(g); e.clipAction(i.animations[0]).play(), _context.animationMixers.push(e) } this.children = Node._fromThreeObject(g).children, e.isVisible = null == e.isVisible || e.isVisible, e.isVisible ? this.show() : this.hide(), this._setLock(e.isLock), r(), setTimeout((() => { _context.instance.focus(), t && t(1, g) }), 500) }; return void ("fbx" == e.modelType.toLowerCase() ? _context.loaders.fbxLoader.load(e.modelPath.replace("#disablecache", ""), (e => a(e)), i, (e => { t ? t(0, e) : logger.debug(e), n(e) })) : _context.loaders.gltfLoader.load(e.modelPath.replace("#disablecache", ""), (e => a(e)), i, (e => { t ? t(0, e) : logger.debug(e), n(e) }))) } const a = util$1.md5(e.modelPath); _context.cacheStore.load({ path: e.modelPath, type: e.modelType || "glb", onLoad: i => { if ((g = i).sourceModelKey = a, g.name = e.name, e.transform && (e.transform.position && null != e.transform.position.x && g.position.set(e.transform.position.x, e.transform.position.y, e.transform.position.z), e.transform.rotation && null != e.transform.rotation._x && (g.rotation.x = e.transform.rotation._x, g.rotation.y = e.transform.rotation._y, g.rotation.z = e.transform.rotation._z), e.transform.scale && (null != e.transform.scale.x ? g.scale.set(e.transform.scale.x, e.transform.scale.y, e.transform.scale.z) : "number" == typeof e.transform.scale && g.scale.set(e.transform.scale, e.transform.scale, e.transform.scale))), m) m.add(g), "PaintItem" == m.type && m.childrenAdd(this); else { if (!_context.scene) return void util$1.disposeThreeObject(g); _context.scene.models.add(g) } "fbx" == e.modelType ? window._needReplace[this.name] = { modelNode: g, modelItem: this } : (g.traverse((t => { if (util$1.capableForCastingShadow(t) && (t.castShadow = !0, t.receiveShadow = !0), t.material instanceof Array) for (let i of t.material) { if (i instanceof MeshBasicMaterial) { let e = util$1.MeshBasicMaterialToMeshStandardMaterial(i); e.needsUpdate = !0, t.material[t.material.indexOf(i)] = e, i = e } if (i instanceof MeshStandardMaterial) { i.alphaTest = .05, i.depthWrite = !0, i.depthTest = !0, i.vertexColors = !1, i.needsUpdate = !0; for (let e in i) i[e] instanceof Texture$1 && i[e].image && _context.textureStore.add(i[e].name || `${i.name}#${e}`, i[e], a); this.materialStore.add(i.name, i, t, e.name) } } else { if (t.material instanceof MeshBasicMaterial) { let e = util$1.MeshBasicMaterialToMeshStandardMaterial(t.material); e.needsUpdate = !0, t.material = e } if (t.material instanceof MeshStandardMaterial) { t.material.alphaTest = .05, t.material.depthWrite = !0, t.material.depthTest = !0, t.material.vertexColors = !1, t.material.needsUpdate = !0; for (let e in t.material) t.material[e] instanceof Texture$1 && t.material[e].image && _context.textureStore.add(t.material[e].name || `${t.material.name}#${e}`, t.material[e], a); this.materialStore.add(t.material.name, t.material, t, e.name) } } })), this.children = Node._fromThreeObject(g).children), e.isVisible = null == e.isVisible || e.isVisible, e.isVisible ? this.show() : this.hide(), this._setLock(e.isLock), r(), _context.instance.focus(), t && t(1, i, this), _context.paintControls && _context.paintControls.updateWorld() }, onProgress: i, onError: i => { t && t(0, i), logger.debug(i + e.modelPath + "模型加载失败！"), n(i) } }) }))), null != h && h instanceof Object3D) { if (g = h, "fbx" == this.modelType) return void (window._needReplace[this.name] = { modeNode: h, modelItem: this }); const e = g.sourceModelKey; g.traverse((t => { if (util$1.capableForCastingShadow(t) && (t.castShadow = !0, t.receiveShadow = !0), t.material instanceof Array) for (let i of t.material) { if (i instanceof MeshBasicMaterial) { let e = util$1.MeshBasicMaterialToMeshStandardMaterial(i); e.needsUpdate = !0, t.material[t.material.indexOf(i)] = e, i = e } if (i instanceof MeshStandardMaterial) { i.alphaTest = .05, i.depthWrite = !0, i.depthTest = !0, i.vertexColors = !1, i.needsUpdate = !0; for (let t in i) i[t] instanceof Texture$1 && i[t].image && _context.textureStore.add(i[t].name || `${i.name}#${t}`, i[t], e); this.materialStore.add(i.name, i, t, h.name) } } else { if (t.material instanceof MeshBasicMaterial) { let e = util$1.MeshBasicMaterialToMeshStandardMaterial(t.material); e.needsUpdate = !0, t.material = e } if (t.material instanceof MeshStandardMaterial) { t.material.alphaTest = .05, t.material.depthWrite = !0, t.material.depthTest = !0, t.material.vertexColors = !1, t.material.needsUpdate = !0; for (let i in t.material) t.material[i] instanceof Texture$1 && t.material[i].image && _context.textureStore.add(t.material[i].name || `${t.material.name}#${i}`, t.material[i], e); this.materialStore.add(t.material.name, t.material, t, h.name) } } })), this.children = Node._fromThreeObject(g).children } else this.addModel({ name: t, modelPath: i, modelType: r, transform: n, isVisible: o, isLock: s }, d, p); this.updateTransform = e => { e.transform && (e.transform.position && null != e.transform.position.x && g.position.set(e.transform.position.x, e.transform.position.y, e.transform.position.z), e.transform.rotation && null != e.transform.rotation._x && (g.rotation.x = e.transform.rotation._x, g.rotation.y = e.transform.rotation._y, g.rotation.z = e.transform.rotation._z), e.transform.scale && (null != e.transform.scale.x ? g.scale.set(e.transform.scale.x, e.transform.scale.y, e.transform.scale.z) : "number" == typeof e.transform.scale && g.scale.set(e.transform.scale, e.transform.scale, e.transform.scale))) }, this.updateMaterialStore = () => { this.materialStore = new MaterialStore(_context.textureStore, _context.instance); const e = g.sourceModelKey; g.traverse((t => { if (util$1.capableForCastingShadow(t) && (t.castShadow = !0, t.receiveShadow = !0), t.material instanceof Array) for (let i of t.material) { if (i instanceof MeshBasicMaterial) { let e = util$1.MeshBasicMaterialToMeshStandardMaterial(i); e.needsUpdate = !0, t.material[t.material.indexOf(i)] = e, i = e } if (i instanceof MeshStandardMaterial) { i.alphaTest = .05, i.depthWrite = !0, i.depthTest = !0, i.vertexColors = !1, i.needsUpdate = !0; for (let t in i) i[t] instanceof Texture$1 && i[t].image && _context.textureStore.add(i[t].name || `${i.name}#${t}`, i[t], e); this.materialStore.add(i.name, i, t, g.name) } } else { if (t.material instanceof MeshBasicMaterial) { let e = util$1.MeshBasicMaterialToMeshStandardMaterial(t.material); e.needsUpdate = !0, t.material = e } if (t.material instanceof MeshStandardMaterial) { t.material.alphaTest = .05, t.material.depthWrite = !0, t.material.depthTest = !0, t.material.vertexColors = !1, t.material.needsUpdate = !0; for (let i in t.material) t.material[i] instanceof Texture$1 && t.material[i].image && _context.textureStore.add(t.material[i].name || `${t.material.name}#${i}`, t.material[i], e); this.materialStore.add(t.material.name, t.material, t, g.name) } } })) }, this.updateChildren = () => { this.children = Node._fromThreeObject(g).children }, this.updateModel = ({ newModelStyle: e, next: t, onProgress: i, onLoad: r, modelType: n = "glb" } = (params = {})) => { if (!e) return; if (!t) return; let a = new Map, o = new Map, s = new Set, l = new Set, c = new Set, h = new Set; _context.cacheStore.load({ path: e.modelPath, type: n, onLoad: i => { let r = i; r.name = g.name, e.name = g.name, g.traverse((e => { if (e instanceof Water) return; if (e.material) if (e.material instanceof Array) for (let t in e.material) a.set(e.material[t].name, e.material[t]); else a.set(e.material.name, e.material); r.getObjectByName(e.name) || s.add(e) })), r.traverse((e => { if (!(e instanceof Water) && e.material) if (e.material instanceof Array) for (let t in e.material) o.set(e.material[t].name, e.material[t]); else o.set(e.material.name, e.material) })), a.forEach(((e, t) => { o.has(t) || l.add(e) })); let u = JSON.parse(JSON.stringify(this.articulations)); u.forEach && u.forEach(((e, t) => { e.properties.forEach && e.properties.forEach(((e, i) => { s.forEach((i => { let r = e.nodes.indexOf(i.name); r > -1 && (e.nodes.splice(r, 1), c.add(this.articulations[t])) })), e.nodes.length || (e.nodes = ["请选择关节对象"]) })) })), this.articulationAnimations.forEach((e => { e.articulationAnimationItems.forEach((t => { c.forEach((i => { i._name === t.articulationName && h.add(e) })) })) })); let d = Array.from(s).map((e => e.name)), p = Array.from(l).map((e => e.name)), f = Array.from(c).map((e => e._name)), m = Array.from(h).map((e => e.animationName)); t && t({ deleteNodeNameList: d, deleteMaterialNameList: p, deleteJointNameList: f, deleteAnimationNameList: m }, (t => { if (t) { let t = JSON.parse(JSON.stringify(this.getSettings())); if (t.modelPath === e.modelPath) return; t.articulations = u, t.modelPath = e.modelPath, this.modelPath = e.modelPath, this.modelType = n; let i = g.uuid, a = g.parent; a.remove(g), r.uuid = i, a.add(r), g = r, this.updateMaterialStore(), this.updateChildren(), _context.instance.defaultObjectTree.applyObjectSetting(e), _context.instance.defaultObjectTree.applyObjectSetting(t), this.updateTransform(t) } })) }, onProgress: e => { i && i(e) }, onError: e => { r && r(0) } }) }, this.getObjectInfo = () => { let e = { width: 0, height: 0, depth: 0, size: 0, faces: 0, vertices: 0, nodes: 0, materials: 0 }, t = _context.cacheStore._cache.get(md5(this.modelPath)); e.size = (t.size / 1024 / 1024).toFixed(2); let i = new Box3; return this.getGroup && this.getGroup() && i.setFromObject(this.getGroup()), e.width = (i.max.x - i.min.x).toFixed(3), e.height = (i.max.y - i.min.y).toFixed(3), e.depth = (i.max.z - i.min.z).toFixed(3), this.getGroup().traverse((t => { if (t != this.getGroup() && (e.nodes += 1), t.geometry) { let i = null; i = t.geometry.index ? t.geometry.index.count : t.geometry.attributes.position.count, e.vertices += i, e.faces = e.vertices / 3 } })), e.materials = Object.keys(this.materialStore._materials).length, e } } } class BuildingFloorItem extends ObjectTreeItem { constructor({ name: e = "untitled", level: t, parent: i, children: r, isVisible: n, isLock: a, transform: o, loadModel: s, parentUUID: l }, c, h, u) { if (super("BuildingFloorItem"), -1 != e.indexOf("/")) return void logger.warn('创建文件夹中名称不能使用"/"'); let d = c; var p = s || new Group; if (p.name = e, this.name = e, this.type = "BuildingFloorItem", this.level = Number(t), this.parent = i, this.parentUUID = l, this.children = [], this.transform = o || this.transform, p.position.set(this.transform.position.x, this.transform.position.y, this.transform.position.z), p.scale.set(this.transform.scale.x, this.transform.scale.y, this.transform.scale.z), p.rotation.set(this.transform.rotation._x, this.transform.rotation._y, this.transform.rotation._z), s || c.add(p), this.getGroup = () => p, this.getParentGroup = () => d, this.addItem = e => { this.children.push(e) }, this.addNoneFloor = (e, t, i) => { if (!this.children.find((t => t.name === e.name)) || e.loadModel) switch (e.parent = this.name, e.parentUUID = this.getGroup().uuid, e.isNoExcursion || (e = util$1.changeTransformFromBuildind(e, d, p)), e.type) { case "ModelItem": this.addItem(new ModelItem(e, t, (t => { i && i({ name: e.name, parent: this.name, loaded: t.loaded }) }), p)); break; case "IconAsset": this.addItem(new IconItem(e, p, t)) } else logger.warn(`当前位置已经存在名称为“${e.name}”的模型。`) }, this.getItemByName = e => { let t = this.children.find((t => t.name === e)); if (t) return t }, this.getSettings = () => (p && (this.transform.position = p.position, this.transform.rotation = p.rotation, this.transform.scale = p.scale), { name: this.name, children: this.children, transform: this.transform, type: this.type, isVisible: this._getVisible(), isLock: this._getLock(), level: this.level, parent: this.parent, index: this.index }), null != r && r.length > 0) { let e = this; if (null != s && s) { let t = []; r.map((i => { s.children.map((r => { r.name === i.name && (i.loadModel = r, i.isNoExcursion = !0, t.push(new Promise((t => { e.addNoneFloor(i, (e => { t(e) }), u) })))) })) })), Promise.all(t).then((e => { h && h(1) })) } else { let t = []; r.map((i => { i.isNoExcursion = !0, t.push(new Promise((t => { e.addNoneFloor(i, (e => { t(e) }), u) }))) })), Promise.all(t).then((e => { h && h(1) })) } } else h && h(1); n ? this.show() : this.hide(), n ? this.show() : this.hide(), a ? this.lock() : this.unLock() } } class BuildingItem extends ObjectTreeItem { constructor({ name: e = "untitled", index: t, parent: i, children: r, isVisible: n, isLock: a, transform: o, loadModel: s, floor: l, parentUUID: c }, h, u, d) { if (super("BuildingItem"), -1 == e.indexOf("/")) { this.name = e, this.children = []; var p = s || new Group; if (p.name = e, this.type = "BuildingItem", this.parent = i, this.parentUUID = c, this.index = t, this.floor = l, this.transform = o || this.transform, p.position.set(this.transform.position.x, this.transform.position.y, this.transform.position.z), p.scale.set(this.transform.scale.x, this.transform.scale.y, this.transform.scale.z), p.rotation.set(this.transform.rotation._x, this.transform.rotation._y, this.transform.rotation._z), s || h.add(p), this.getGroup = () => p, this.addItem = e => { this.children.push(e), this.children = this.children.sort(this.compare("level", !1)) }, this.compare = (e, t) => (i, r) => { var n = i[e], a = r[e]; return t ? n - a : a - n }, this.addFloor = (e, t, i) => { !p.children.find((t => t.name === e.name)) || e.loadModel ? (e.parent = this.name, e.parentUUID = this.getGroup().uuid, e.isVisible = null == e.isVisible || e.isVisible, e.isLock = null != e.isLock && e.isLock, this.addItem(new BuildingFloorItem(e, p, t, i))) : logger.warn(`当前位置已经存在名称为“${e.name}”的模型。`) }, this.addNoneFloor = (e, t, i) => { if (!p.children.find((t => t.name === e.name)) || e.loadModel) switch (e.parent = this.name, e.parentUUID = this.getGroup().uuid, e.isNoExcursion || (e = util$1.changeTransformFromBuildind(e, p)), e.type) { case "ModelItem": this.addItem(new ModelItem(e, t, (t => { i && i({ name: e.name, parent: this.name, loaded: t.loaded }) }), p)); break; case "IconAsset": this.addItem(new IconItem(e, p, t)) } else logger.warn(`当前位置已经存在名称为“${e.name}”的模型。`) }, this.getItemByName = e => { let t = this.children.find((t => t.name === e)); if (t) return t }, this.getSettings = () => (p && (this.transform.position = p.position, this.transform.rotation = p.rotation, this.transform.scale = p.scale), { name: this.name, children: this.children, transform: this.transform, type: this.type, parent: this.parent, isVisible: this._getVisible(), isLock: this._getLock(), index: this.index, floor: this.floor }), null != r && r.length > 0) { let e = this; if (null != s && s) { let t = []; r.map((i => { s.children.map((r => { r.name === i.name && (i.loadModel = r, "ModelItem" === i.type || "IconAsset" === i.type ? (i.isNoExcursion = !0, t.push(new Promise((t => { e.addNoneFloor(i, (e => { t(e) }), d) })))) : "BuildingFloorItem" === i.type && t.push(new Promise((t => { e.addFloor(i, (e => { t(e) }), d) })))) })) })), Promise.all(t).then((e => { u && u(1) })) } else { let t = []; r.map((i => { "ModelItem" === i.type || "IconAsset" === i.type ? (i.isNoExcursion = !0, t.push(new Promise((t => { e.addNoneFloor(i, (e => { t(e) }), d) })))) : "BuildingFloorItem" === i.type && t.push(new Promise((t => { e.addFloor(i, (e => { t(e) }), d) }))) })), Promise.all(t).then((e => { u && u(1) })) } } else u && u(1, this); n ? this.show() : this.hide(), a ? this.lock() : this.unLock() } else logger.warn('创建文件夹中名称不能使用"/"') } } class FolderItem extends ObjectTreeItem { constructor(e = "untitled", t = {}, i) { if (super("FolderItem"), this.name = e, -1 == e.indexOf("/")) { this.children = [], this.path = t.path ? t.path + "/" + e : "/" + e; var r = new Group; r.name = e, _context.scene.noneModels.add(r), this.type = "FolderItem", this.index = i, this.group = () => r, this.addItem = (e, t) => { this.children.push(e), t && t(1, "文件夹创建成功") }, this.addFolder = (e = "untitled", t, i) => { this.children.find((t => t.isFolder() && t.name === e)) ? logger.warn(`当前位置已经存在名称为“${e}”的文件夹。`) : this.addItem(new FolderItem(e, t, this.children.length), i) }, this.addModel = (e, t, i) => { this.children.find((t => t.isModel() && t.name === e.name)) ? logger.warn(`当前位置已经存在名称为“${e.name}”的模型。`) : ("number" != typeof e.index && (e.index = this.children.length), this.addItem(new ModelItem(e, t, i))) }, this.getSettings = () => ({ name: this.name, path: this.path, children: this.children, transform: this.transform, type: this.getType(), isVisible: this._getVisible(), isLock: this._getLock(), index: this.index }), this.rename = (e, t) => { e && (this.name = e, t && t(1, "模型重命名成功")) } } else logger.warn('创建文件夹中名称不能使用"/"') } } class PaintLayer extends ObjectTreeItem { constructor(e, { name: t, index: i, isVisible: r, isLock: n, transform: a }, o, s, l) { super("PaintLayer"), this.type = e, this.isVisible = r, this.isLock = n, this.transform = a || this.transform, this.name = t, this.index = i, this.children = []; let c = o || new Group; c.name = t, c.type = "PaintGroup", s.add(c), l.addItem(this), c.position.set(this.transform.position.x, this.transform.position.y, this.transform.position.z), c.scale.set(this.transform.scale.x, this.transform.scale.y, this.transform.scale.z), c.rotation.set(this.transform.rotation._x, this.transform.rotation._y, this.transform.rotation._z), this.getGroup = () => c, this.add = e => { c.add(e) }, this.childrenAdd = e => { this.children.push(e) }, this.getType = () => this.type, this.getItemByName = e => this.children.find((t => t.name === e)), this.resetHelper = () => { "GroupItem" === this.type ? this.children.forEach((e => { "ModelAsset" === e.type && e.reset() })) : "PaintItem" === this.type && this.modelInstanced.forEach((e => { e.reset() })) } } } class GroupItem extends PaintLayer { constructor(e, t, i = _context.scene.models, r = _context.defaultObjectTree) { super("GroupItem", e, t, i, r), this.removeChild = e => new Promise((t => { this.remove(e, (e => { let i = 0; this.children.length || (_context.defaultObjectTree.remove(this.name), i = 1), t(i) })) })), this.removeItem = (e, t) => new Promise((i => { let r = this.children.find((t => t.name == e)); "ModelAsset" == r.type || "ModelItem" == r.type ? (r.removeInstance(t), r.points.length ? i(0) : this.removeChild(e).then((e => { i(e) }))) : this.removeChild(e).then((e => { i(e) })), this.children.length || (_context.defaultObjectTree.remove(this.name), i(1)) })), this.getSettings = () => { let e = this.getGroup(); return e && (this.transform.position = e.position, this.transform.rotation = e.rotation, this.transform.scale = e.scale), this.children.forEach((e => { if (e.getMesh && e.getMesh() && e.getMesh().count) { var t = []; if ("ModelAsset" === e.type) for (let r = 0; r < e.getMesh().count; r++) { var i = new Matrix4; e.getMesh().getMatrixAt(r, i), t.push(i) } e.matrix = t } })), { name: this.name, type: this.type, children: this.children, isVisible: this.isVisible, isLock: this.isLock, index: this.index, transform: this.transform } } } } class GisItem extends ObjectTreeItem { constructor(e, t) { if (super("GisItem"), this.type = "GisItem", _context.gisStore.terrainState) return void (t && t({ result: 0, message: "添加失败，场景中已存在一个地形地图！" })); this.gisParam = e; let i = _context.instance.getDatumShiftModel(); if (i || e.place) { if (!e.place) { let t = i.origin ? i.origin[0] : i.lon, r = i.origin ? i.origin[1] : i.lat; e.place = { longitude: t, latitude: r } } this.name = e.name, _context.gisStore && _context.gisStore.initTerrain(e), this.getGroup = () => _context.scene.pgl, this.id = _context.scene.pgl.uuid, this.index = void 0 === e.index ? _context.instance.defaultObjectTree.children.length : e.index, _context.instance.defaultObjectTree.addItem(this), t && t({ result: 1, message: "添加成功！", objectItem: this }), this.dispose = (e = !1) => { _context.gisStore.disposeTerrain() }, this.getSettings = () => ({ id: this.id, name: this.name, type: this.getType(), index: this.index, imagery: this.gisParam.imagery, elevation: this.gisParam.elevation, isLock: this._getLock(), isVisible: this.isVisible, receiveShadow: this.gisParam.receiveShadow }), this.update = (e, t) => { let i = this.getGroup().uuid; if (this.dispose(), _context.gisStore.terrainState) return void (t && t({ result: 0, message: "添加失败，场景中已存在一个地形地图！" })); this.gisParam = e; let r = _context.instance.getDatumShiftModel(); if (r || e.place) { if (!e.place) { let t = r.origin ? r.origin[0] : r.lon, i = r.origin ? r.origin[1] : r.lat; e.place = { longitude: t, latitude: i } } this.name = e.name, _context.gisStore && _context.gisStore.initTerrain(e), this.getGroup().uuid = i } else t && t({ result: 0, message: "添加失败，未设置坐标，请先在坐标编辑设置坐标！" }) }, this.rename = e => { this.name = e, this.getGroup().name = e } } else t && t({ result: 0, message: "添加失败，未设置坐标，请先在坐标编辑设置坐标！" }) } } class PaintItem extends PaintLayer { constructor(e, t, i = _context.scene.models, r = _context.defaultObjectTree) { super("PaintItem", e, t, i, r), this.modelInstanced = [], this.iconInstanced = []; let n = 0; this.childrenRemove = e => { for (let t = this.children.length - 1; t >= 0; t--)this.children[t].name === e && this.children.splice(t, 1) }, this.getInstanced = (e, t) => "ModelAsset" == e ? this.modelInstanced.find((e => e.name == t)) : "IconAsset" == e ? this.iconInstanced.find((e => e.name == t)) : void 0, this.addInstanced = (e, t) => { "ModelAsset" == e ? this.modelInstanced.push(t) : "IconAsset" == e && this.iconInstanced.push(t) }, this.getIndexName = e => { if (!this.children.length) return n = 2, `${e}_1`; if (n) { let t = `${e}_${n}`; return n++, t } let t = this.children[this.children.length - 1].name, i = t.lastIndexOf("_"); return n = Number(t.substr(i + 1)) + 1 || 0, this.getIndexName(e) }, this.updateLast = e => { let t = e.lastIndexOf("_"), i = Number(e.substr(t + 1)) + 1 || 0; i > n && (n = i) }, this.removeItem = e => new Promise((t => { let i = this.children.find((t => t.name == e)); if (i.isInstancedItem) { if ("ModelAsset" == i.type || "ModelItem" == i.type) for (let e = 0; e < this.children.length; e++)this.children[e].isInstancedItem && this.children[e].parent == i.parent && this.children[e].key > i.key && (this.children[e].key = this.children[e].key - 1); this.childrenRemove(e), i.remove(), t(1) } else this.remove(e, (e => { this.children.length || _context.defaultObjectTree.remove(this.name), t(e) })); this.children.length || _context.defaultObjectTree.remove(this.name) })), this.rankNode = (e, t) => { let i = this.children.find((e => e.name == t)), r = i.index, n = JSON.parse(JSON.stringify(this.children)); if (n.sort(((e, t) => e.index - t.index)), "up" == e && r == n[0].index || "down" == e && r == n[n.length - 1].index) return; let a = this._getBrotherNode(e, i.index); a && (i.index = a.index, a.index = r, i.isInstancedItem && i.rankNode(), a.isInstancedItem && a.rankNode()) }, this._getBrotherNode = (e, t) => { if (-1 == t || t == this.children.length + 1) return null; let i = "up" == e ? t - 1 : t + 1, r = this.children.find((e => e.index == i)); if (r) return r; this._getBrotherNode(e, i) }, this.rename = (e, t) => { if (e) { for (let t = 0; t < _context.ssr.length; t++)_context.ssr[t].modelName === this.name && (_context.ssr[t].modelName = e); if (this.name = e, this.getGroup().name = e, this.materialStore) for (let t in this.materialStore._materials) this.materialStore._materials[t]._modelName = e; for (let t = 0; t < this.iconInstanced.length; t++)this.iconInstanced[t].layerName && (this.iconInstanced[t].layerName = e); t && t(1, "重命名成功") } }, this.getSettings = () => { let e = this.getGroup(); e && (this.transform.position = e.position, this.transform.rotation = e.rotation, this.transform.scale = e.scale); let t = []; this.modelInstanced.forEach((e => { let i = { name: e.name, type: "ModelAsset", isVisible: e.isVisible, count: e.count, points: e.points, transform: e.transform, matrix: [], delta: 0, path: e.path, settings: e.settings, newMatrix: e.newMatrix, materials: e.materialStore.getSettings() }; if (e.getMesh && e.getMesh() && e.getMesh().count) { for (let t = 0; t < e.getMesh().count; t++) { var r = new Matrix4; e.getMesh().getMatrixAt(t, r), i.matrix.push(r) } t.push(i) } })); let i = []; return this.children.forEach((e => { e.isInstancedItem || i.push(e.getSettings()) })), { name: this.name, type: this.type, children: i, isVisible: this.isVisible, isLock: this.isLock, index: this.index, transform: this.transform, iconInstanced: this.iconInstanced, modelInstanced: t } } } } var BufferGeometryUtils = { computeTangents: function (e) { e.computeTangents(), console.warn("THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.") }, mergeBufferGeometries: function (e, t) { for (var i = null !== e[0].index, r = new Set(Object.keys(e[0].attributes)), n = new Set(Object.keys(e[0].morphAttributes)), a = {}, o = {}, s = e[0].morphTargetsRelative, l = new BufferGeometry, c = 0, h = 0; h < e.length; ++h) { var u = e[h], d = 0; if (i !== (null !== u.index)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null; for (var p in u.attributes) { if (!r.has(p)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + '. All geometries must have compatible attributes; make sure "' + p + '" attribute exists among all geometries, or in none of them.'), null; void 0 === a[p] && (a[p] = []), a[p].push(u.attributes[p]), d++ } if (d !== r.size) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". Make sure all geometries have the same number of attributes."), null; if (s !== u.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". .morphTargetsRelative must be consistent throughout all geometries."), null; for (var p in u.morphAttributes) { if (!n.has(p)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ".  .morphAttributes must be consistent throughout all geometries."), null; void 0 === o[p] && (o[p] = []), o[p].push(u.morphAttributes[p]) } if (l.userData.mergedUserData = l.userData.mergedUserData || [], l.userData.mergedUserData.push(u.userData), t) { var f; if (i) f = u.index.count; else { if (void 0 === u.attributes.position) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + h + ". The geometry must have either an index or a position attribute"), null; f = u.attributes.position.count } l.addGroup(c, f, h), c += f } } if (i) { var m = 0, g = []; for (h = 0; h < e.length; ++h) { for (var y = e[h].index, v = 0; v < y.count; ++v)g.push(y.getX(v) + m); m += e[h].attributes.position.count } l.setIndex(g) } for (var p in a) { var _ = this.mergeBufferAttributes(a[p]); if (!_) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + p + " attribute."), null; l.setAttribute(p, _) } for (var p in o) { var b = o[p][0].length; if (0 === b) break; l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[p] = []; for (h = 0; h < b; ++h) { var x = []; for (v = 0; v < o[p].length; ++v)x.push(o[p][v][h]); var w = this.mergeBufferAttributes(x); if (!w) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + p + " morphAttribute."), null; l.morphAttributes[p].push(w) } } return l }, mergeBufferAttributes: function (e) { for (var t, i, r, n = 0, a = 0; a < e.length; ++a) { var o = e[a]; if (o.isInterleavedBufferAttribute) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."), null; if (void 0 === t && (t = o.array.constructor), t !== o.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null; if (void 0 === i && (i = o.itemSize), i !== o.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null; if (void 0 === r && (r = o.normalized), r !== o.normalized) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null; n += o.array.length } var s = new t(n), l = 0; for (a = 0; a < e.length; ++a)s.set(e[a].array, l), l += e[a].array.length; return new BufferAttribute(s, i, r) }, interleaveAttributes: function (e) { for (var t, i = 0, r = 0, n = 0, a = e.length; n < a; ++n) { var o = e[n]; if (void 0 === t && (t = o.array.constructor), t !== o.array.constructor) return console.error("AttributeBuffers of different types cannot be interleaved"), null; i += o.array.length, r += o.itemSize } var s = new InterleavedBuffer(new t(i), r), l = 0, c = [], h = ["getX", "getY", "getZ", "getW"], u = ["setX", "setY", "setZ", "setW"], d = 0; for (a = e.length; d < a; d++) { var p = (o = e[d]).itemSize, f = o.count, m = new InterleavedBufferAttribute(s, p, l, o.normalized); c.push(m), l += p; for (var g = 0; g < f; g++)for (var y = 0; y < p; y++)m[u[y]](g, o[h[y]](g)) } return c }, estimateBytesUsed: function (e) { var t = 0; for (var i in e.attributes) { var r = e.getAttribute(i); t += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT } var n = e.getIndex(); return t += n ? n.count * n.itemSize * n.array.BYTES_PER_ELEMENT : 0 }, mergeVertices: function (e, t = 1e-4) { t = Math.max(t, Number.EPSILON); for (var i = {}, r = e.getIndex(), n = e.getAttribute("position"), a = r ? r.count : n.count, o = 0, s = Object.keys(e.attributes), l = {}, c = {}, h = [], u = ["getX", "getY", "getZ", "getW"], d = 0, p = s.length; d < p; d++) { l[_ = s[d]] = [], (S = e.morphAttributes[_]) && (c[_] = new Array(S.length).fill().map((() => []))) } var f = Math.log10(1 / t), m = Math.pow(10, f); for (d = 0; d < a; d++) { var g = r ? r.getX(d) : d, y = "", v = 0; for (p = s.length; v < p; v++)for (var _ = s[v], b = (w = e.getAttribute(_)).itemSize, x = 0; x < b; x++)y += ~~(w[u[x]](g) * m) + ","; if (y in i) h.push(i[y]); else { for (v = 0, p = s.length; v < p; v++) { _ = s[v]; var w = e.getAttribute(_), S = e.morphAttributes[_], M = (b = w.itemSize, l[_]), T = c[_]; for (x = 0; x < b; x++) { var A = u[x]; if (M.push(w[A](g)), S) for (var E = 0, C = S.length; E < C; E++)T[E].push(S[E][A](g)) } } i[y] = o, h.push(o), o++ } } const L = e.clone(); for (d = 0, p = s.length; d < p; d++) { _ = s[d]; var R = e.getAttribute(_); w = new BufferAttribute(new R.array.constructor(l[_]), R.itemSize, R.normalized); if (L.setAttribute(_, w), _ in c) for (v = 0; v < c[_].length; v++) { var D = e.morphAttributes[_][v], P = new BufferAttribute(new D.array.constructor(c[_][v]), D.itemSize, D.normalized); L.morphAttributes[_][v] = P } } return L.setIndex(h), L }, toTrianglesDrawMode: function (e, t) { if (t === TrianglesDrawMode) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e; if (t === TriangleFanDrawMode || t === TriangleStripDrawMode) { var i = e.getIndex(); if (null === i) { var r = [], n = e.getAttribute("position"); if (void 0 === n) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (var a = 0; a < n.count; a++)r.push(a); e.setIndex(r), i = e.getIndex() } var o = i.count - 2, s = []; if (t === TriangleFanDrawMode) for (a = 1; a <= o; a++)s.push(i.getX(0)), s.push(i.getX(a)), s.push(i.getX(a + 1)); else for (a = 0; a < o; a++)a % 2 == 0 ? (s.push(i.getX(a)), s.push(i.getX(a + 1)), s.push(i.getX(a + 2))) : (s.push(i.getX(a + 2)), s.push(i.getX(a + 1)), s.push(i.getX(a))); s.length / 3 !== o && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); var l = e.clone(); return l.setIndex(s), l.clearGroups(), l } return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), e }, computeMorphedAttributes: function (e) { if (!0 !== e.geometry.isBufferGeometry) return console.error("THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."), null; var t = new Vector3, i = new Vector3, r = new Vector3, n = new Vector3, a = new Vector3, o = new Vector3, s = new Vector3, l = new Vector3, c = new Vector3; function h(e, h, u, d, p, f, m, g, y) { t.fromBufferAttribute(u, f), i.fromBufferAttribute(u, m), r.fromBufferAttribute(u, g); var v = e.morphTargetInfluences; if (h.morphTargets && d && v) { s.set(0, 0, 0), l.set(0, 0, 0), c.set(0, 0, 0); for (var _ = 0, b = d.length; _ < b; _++) { var x = v[_], w = d[_]; 0 !== x && (n.fromBufferAttribute(w, f), a.fromBufferAttribute(w, m), o.fromBufferAttribute(w, g), p ? (s.addScaledVector(n, x), l.addScaledVector(a, x), c.addScaledVector(o, x)) : (s.addScaledVector(n.sub(t), x), l.addScaledVector(a.sub(i), x), c.addScaledVector(o.sub(r), x))) } t.add(s), i.add(l), r.add(c) } e.isSkinnedMesh && (e.boneTransform(f, t), e.boneTransform(m, i), e.boneTransform(g, r)), y[3 * f + 0] = t.x, y[3 * f + 1] = t.y, y[3 * f + 2] = t.z, y[3 * m + 0] = i.x, y[3 * m + 1] = i.y, y[3 * m + 2] = i.z, y[3 * g + 0] = r.x, y[3 * g + 1] = r.y, y[3 * g + 2] = r.z } var u, d, p, f, m, g, y, v, _, b = e.geometry, x = e.material, w = b.index, S = b.attributes.position, M = b.morphAttributes.position, T = b.morphTargetsRelative, A = b.attributes.normal, E = b.morphAttributes.position, C = b.groups, L = b.drawRange, R = new Float32Array(S.count * S.itemSize), D = new Float32Array(A.count * A.itemSize); if (null !== w) if (Array.isArray(x)) for (f = 0, g = C.length; f < g; f++)for (_ = x[(v = C[f]).materialIndex], m = Math.max(v.start, L.start), y = Math.min(v.start + v.count, L.start + L.count); m < y; m += 3)h(e, _, S, M, T, u = w.getX(m), d = w.getX(m + 1), p = w.getX(m + 2), R), h(e, _, A, E, T, u, d, p, D); else for (f = Math.max(0, L.start), g = Math.min(w.count, L.start + L.count); f < g; f += 3)h(e, x, S, M, T, u = w.getX(f), d = w.getX(f + 1), p = w.getX(f + 2), R), h(e, x, A, E, T, u, d, p, D); else if (void 0 !== S) if (Array.isArray(x)) for (f = 0, g = C.length; f < g; f++)for (_ = x[(v = C[f]).materialIndex], m = Math.max(v.start, L.start), y = Math.min(v.start + v.count, L.start + L.count); m < y; m += 3)h(e, _, S, M, T, u = m, d = m + 1, p = m + 2, R), h(e, _, A, E, T, u, d, p, D); else for (f = Math.max(0, L.start), g = Math.min(S.count, L.start + L.count); f < g; f += 3)h(e, x, S, M, T, u = f, d = f + 1, p = f + 2, R), h(e, x, A, E, T, u, d, p, D); return { positionAttribute: S, normalAttribute: A, morphedPositionAttribute: new Float32BufferAttribute(R, 3), morphedNormalAttribute: new Float32BufferAttribute(D, 3) } } }; class InstancedHelper extends LineSegments { constructor(e, t = 16776960, i, r, n) { const a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), o = new BufferGeometry; o.setIndex(new BufferAttribute(a, 1)), o.setAttribute("position", new Float32BufferAttribute([1, 2, 1, -1, 2, 1, -1, 0, 1, 1, 0, 1, 1, 2, -1, -1, 2, -1, -1, 0, -1, 1, 0, -1], 3)), super(o, new LineBasicMaterial({ color: t, toneMapped: !1 })), this.box = e, this.type = "InstancedHelper", this.isApplyMatrix = !1, this.defaultSize = new Vector3, e.getSize(this.defaultSize), this.geometry.computeBoundingSphere(), this.layer = i, this.instanced = r, this._lastPostition = new Vector3, this._lastRotation = new Euler, this._lastScale = new Vector3 } updateMatrixWorld(e) { const t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } rotateAxis() { let { key: e } = this.userData, t = this.instanced.getTransform(e), i = new Matrix4; i.compose(t.position, this.quaternion, t.scale), this.instanced.setMatrixAt(e, i); let r = this.instanced.settings[e].name, n = this.layer.getItemByName(r), a = new Euler; a.setFromQuaternion(this.quaternion), n.transform.rotation = { x: a._x, y: a._y, z: a._z } } rotate(e, t) { let { key: i } = this.userData, r = this.instanced.getTransform(i); this.instanced.setTransform(i, e, t, r.scale); let n = new Vector3; this.box.getSize(n), this.box.setFromCenterAndSize(e, n), this.rotation.copy(t) } update(e, t, i) { let { key: r } = this.userData; e = new Vector3(e.x, e.y, e.z), t = new Euler(t.x, t.y, t.z, t.order), i = new Vector3(i.x, i.y, i.z), e.equals(this._lastPostition) && t.equals(this._lastRotation) && i.equals(this._lastScale) || (this._lastPostition = e.clone(), this._lastRotation = t.clone(), this._lastScale = i.clone(), this.instanced.setTransform(r, e, t, i), this.box.setFromCenterAndSize(e, this.defaultSize.clone().multiply(i)), this.rotation.copy(t)) } setPosition(e) { let { key: t } = this.userData, i = new Matrix4, r = new Vector3; this.box.getSize(r), this.box.setFromCenterAndSize(e, r); let n = this.instanced.getTransform(t), a = new Quaternion; a.setFromEuler(n.rotation), i.compose(e, a, n.scale), this.instanced.setMatrixAt(t, i), this.instanced.points[t] = [e.x, e.y, e.z]; let o = this.instanced.settings[t].name; this.layer.getItemByName(o).transform.position = JSON.parse(JSON.stringify(e)), this.instanced.assetObj && (this.instanced.assetObj.points = this.instanced.points) } setQuaternion(e) { this.quaternion.copy(e); let { key: t } = this.userData, i = new Matrix4, r = this.instanced.getTransform(t); i.compose(r.position, e, r.scale), this.instanced.setMatrixAt(t, i) } setScale(e) { if ((e = new Vector3(Math.abs(e.x), Math.abs(e.y), Math.abs(e.z))).equals(this._lastScale)) return; this._lastScale = e.clone(); let { key: t } = this.userData, i = new Matrix4, r = this.instanced.getTransform(t); this.box.setFromCenterAndSize(this.position, this.defaultSize.clone().multiply(e)); let n = new Quaternion; n.setFromEuler(r.rotation), i.compose(r.position, n, e), this.instanced.setMatrixAt(t, i) } } class InstancedObject { constructor({ path: e, gltf: t, name: i, count: r = 1, transform: n, points: a, matrix: o, randomValues: s, newMatrix: l } = {}, c, h, u, d) { if (!(a && a instanceof Array)) return; a.length > INSTANCE_COUNT_MAX && (logger.warn(`实例对象的实例数不能超过 ${INSTANCE_COUNT_MAX}，将忽略超出的 ${a.length - INSTANCE_COUNT_MAX} 个实例。`), a.splice(INSTANCE_COUNT_MAX, a.length - INSTANCE_COUNT_MAX)), r = a.length, this.name = i, this.type = "ModelAsset", this.count = r, this.points = a, this.transform = n, this.matrix = [], this.path = e, this.materialStore = new MaterialStore(_context.textureStore, _context.instance); let p = null, f = [], m = c, g = new Box3, y = new Vector3, v = new Vector3(1, 1, 1), _ = [], b = s; this.newMatrix = l || {}, this.visible = {}, this.settings = []; let x = new Matrix4; x.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); let w = null, S = null; "GroupItem" === c.type ? c.childrenAdd(this) : c.addInstanced("ModelAsset", this), this.setRand = e => { b = e }, this.getCount = () => this.count, this.getHelper = e => _.length > e ? _[e] : null, this.getGroup = () => m, this.addInstanceIsMatrix = e => { if (e) for (let t = 0; t < e.length; t++) { let i = new Matrix4; i.fromArray(e[t].elements); for (let e of f) e.setMatrixAt(t, i.clone()), e.instanceMatrix.needsUpdate = !0; let r = new Box3, n = new Vector3, a = new Euler; if (i.decompose(n, a, v), r.setFromCenterAndSize(n, y.clone().multiply(v)), "PaintItem" === m.type) { let e = new InstancedHelper(r, 16776960, m, this); e.visible = !1, e.userData.key = t, e.name = "helper" + t, e.defaultSize = y.clone(), e.applyMatrix4(i), e.updateMatrix(), m.add(e), _.push(e) } } }, this.removeInstance = (e, t) => { if (!("number" != typeof e || e > this.points)) { if ("PaintItem" === m.type) { delete this.newMatrix[e]; for (let t = e; t < this.points.length - 1; t++) { for (let e of f) { let i = new Matrix4; e.getMatrixAt(t + 1, i), e.setMatrixAt(t, i), e.instanceMatrix.needsUpdate = !0 } this.settings[t + 1].key = this.settings[t + 1].key - 1, _.length > t + 1 && (_[t + 1].userData.key = _[t + 1].userData.key - 1) } for (let e of f) e.count -= 1; _.length > e && (m.getGroup().remove(_[e]), _.splice(e, 1)), this.points.splice(e, 1), this.settings.splice(e, 1); for (const t in this.newMatrix) if (t >= e) { let e = new Matrix4; e = this.newMatrix[t].clone ? this.newMatrix[t].clone() : e.fromArray(this.newMatrix[t].elements), this.newMatrix[t - 1] = e, delete this.newMatrix[t] } } else if ("GroupItem" === m.type) { for (let t = e; t < this.points.length - 1; t++)for (let e of f) { let i = new Matrix4; e.getMatrixAt(t + 1, i), e.setMatrixAt(t, i), e.instanceMatrix.needsUpdate = !0 } for (let e of f) e.count -= 1; this.points.splice(e, 1) } t && t(1) } }, this.addInstance = (e, t) => { if (!(e && e instanceof Array)) return; let i = this.points.length; e.length + this.points.length > INSTANCE_COUNT_MAX && (logger.warn(`实例对象的实例数不能超过 ${INSTANCE_COUNT_MAX}，将忽略超出的 ${e.length + this.points.length - INSTANCE_COUNT_MAX} 个实例。`), this.points.splice(INSTANCE_COUNT_MAX - this.points.length, e.length + this.points.length - INSTANCE_COUNT_MAX)), this.points.push.apply(this.points, e), this.count = this.points.length; for (let e of f) e.count = this.count; for (let e = i; e < this.points.length; e++) { let t = M(this.points[e]), i = (new Vector3).setFromMatrixPosition(t), r = new Box3; for (let i of f) i.setMatrixAt(e, t), i.instanceMatrix.needsUpdate = !0; if ("PaintItem" === m.type) { r.setFromCenterAndSize(i, y.clone().multiply(v)); let n = new InstancedHelper(r, 16776960, m, this); n.userData.key = e, n.visible = !1, n.name = "helper" + e, n.defaultSize = y.clone(), this.transform.rotation && n.rotation.set(0 - this.transform.rotation._x, 0 - this.transform.rotation._y, 0 - this.transform.rotation._z), n.applyMatrix4(t), n.updateMatrix(), m.add(n), _.push(n) } } }, this.getTransform = e => { let t = new Matrix4; this.settings[e].isVisible ? p.getMatrixAt(e, t) : t = this.newMatrix[e].clone(); let i = new Vector3, r = new Quaternion, n = new Vector3; return t.decompose(i, r, n), { position: i, rotation: (new Euler).setFromQuaternion(r), scale: n } }, this.setTransform = (e, t, i, r) => { let n = new Matrix4, a = new Quaternion; a.setFromEuler(i), n.compose(t, a, r), this.setMatrixAt(e, n); let o = this.settings[e].name; m.getItemByName(o).transform = { position: JSON.parse(JSON.stringify(t)), rotation: { x: i._x, y: i._y, z: i._z }, scale: JSON.parse(JSON.stringify(r)) }, this.points[e] = [t.x, t.y, t.z], this.assetObj && (this.assetObj.points = this.points) }, this.setMatrixAt = (e, t, i) => { if (this.settings[e].isVisible || i) for (let i of f) i.setMatrixAt(e, t), i.instanceMatrix.needsUpdate = !0; else this.newMatrix[e] = t.clone() }; let M = (e, t) => { let i = t ? t.getGroup().rotation : new Euler, r = t ? t.getGroup().scale : new Vector3(1, 1, 1), n = new Vector3(e[0] / r.x, e[1] / r.y, e[2] / r.z); n = n.applyEuler(i); let a = new Object3D; a.position.set(n[0], n[1], n[2]), a.position.set(n.x, n.y, n.z); let o = 1; b && b.scaleMax && b.scaleMin && b.scaleFlag && (o = Math.random() * (b.scaleMax - b.scaleMin) + b.scaleMin), a.scale.set(this.transform.scale.x * o, this.transform.scale.y * o, this.transform.scale.z * o), v = a.scale.clone(); let s = 0; b && (s = MathUtils.degToRad(Math.random() * (b.rotateMax - b.rotateMin) + b.rotateMin)), a.rotation.set(this.transform.rotation._x, this.transform.rotation._y + s, this.transform.rotation._z); let l = m.getGroup(); l.updateMatrixWorld(); let c = l.matrixWorld.clone().invert(); return a.applyMatrix4(c), a.updateMatrix(), a.matrix.clone() }, T = e => { const t = e.sourceModelKey; let i = e.geometry.clone(); i.applyMatrix4(e.matrixWorld); let r = e.material; if (r instanceof Array) for (let e of r) { if (e instanceof MeshBasicMaterial) { let t = util$1.MeshBasicMaterialToMeshStandardMaterial(e); r[r.indexOf(e)] = t, e = t } if (e instanceof MeshStandardMaterial) { e.alphaTest = .05, e.depthWrite = !0, e.depthTest = !0, e.vertexColors = !1, e.needsUpdate = !0; for (let i in e) if (e[i] instanceof Texture$1 && e[i].image) { if (!_context.textureStore) { util$1.disposeMaterial(e); break } _context.textureStore.add(e[i].name || `${e.name}#${i}`, e[i], t) } } } else { if (r instanceof MeshBasicMaterial) { r = util$1.MeshBasicMaterialToMeshStandardMaterial(r) } if (r instanceof MeshStandardMaterial) { r.alphaTest = .05, r.depthWrite = !0, r.depthTest = !0, r.vertexColors = !1, r.needsUpdate = !0; for (let e in r) if (r[e] instanceof Texture$1 && r[e].image) { if (!_context.textureStore) { util$1.disposeMaterial(r); break } _context.textureStore.add(r[e].name || `${r.name}#${e}`, r[e], t) } } } if (p = new InstancedMesh(i, r, INSTANCE_COUNT_MAX), p.geometry.computeBoundingBox(), g.expandByObject(e), r instanceof Array) for (let e of r) this.materialStore.add(e.name, e, p, this.name); else this.materialStore.add(r.name, r, p, this.name); p.count = this.count, p.name = `${this.name}#${f.length}`, p.castShadow = !0, p.receiveShadow = !0, p.instanceMatrix.setUsage(DynamicDrawUsage); for (let e = 0; e < this.count; e++) { let t = new Matrix4; 0 === e ? (w || (w = M(this.points[e])), t = w.clone()) : t = M(this.points[e]), p.setMatrixAt(e, t), S = t, p.instanceMatrix.needsUpdate = !0 } m.add(p), f.push(p) }; if (this.getMesh = () => p, this.hide = () => { f.visible = !1 }, this.show = () => { f.visible = !0 }, this.reset = () => { _.forEach((e => { e.visible = !1 })) }, this._hideInstanced = e => { if (this.newMatrix[e]) return; let t = new Matrix4; p.getMatrixAt(e, t); for (const t in this.newMatrix) if (t != e && this.settings[t].isVisible) { let e = this.newMatrix[t]; this.setMatrixAt(t, e.clone(), !0), delete this.newMatrix[t] } this.newMatrix[e] = t.clone(); let i = t.clone(); i.multiplyMatrices(t, x), this.setMatrixAt(e, i, !0) }, this.highlight = (e, t) => { e && t || this.reset(), e && _[e] && (_[e].visible = this.settings[e].isVisible, t || _context.transformControls.attach(_[e])) }, this.setVisible = (e, t) => { if (this.settings[e].isVisible = t, _[e].visible = t, t && this.newMatrix[e]) { let t = new Matrix4; t = this.newMatrix[e].clone ? this.newMatrix[e].clone() : t.fromArray(this.newMatrix[e].elements), this.setMatrixAt(e, t, !0), delete this.newMatrix[e] } else t || this._hideInstanced(e) }, this.lock = (e, t) => { this.settings[e].isLock = t, _[e].visible = !this.settings[e].isLock && this.settings[e].isVisible }, t) { if (t.scene.updateMatrixWorld(!0), o) { if (this.name === t.scene.name) T(t.scene); else { let e = t.scene.children.find((e => e.name.indexOf(this.name) >= 0)); e && T(e) } g.getSize(y), this.addInstanceIsMatrix(o) } h && h(1, this) } else { if (!e) return; let t = this; _context.cacheStore.load({ path: e, type: "glb", onLoad: e => { var i; if (e.updateMatrixWorld(!0), e.traverse((e => { "Mesh" === e.type && T(e) })), g.getSize(y), o) (i = m instanceof GroupItem ? m.getItemByName(this.name) : m.getInstanced("ModelAsset", this.name)) && i.addInstanceIsMatrix && i.addInstanceIsMatrix(o); else if ("PaintItem" === m.type) { let e = new Box3; e.setFromCenterAndSize(new Vector3(t.points[0][0], t.points[0][1], t.points[0][2]), y.clone().multiply(v)); let i = new InstancedHelper(e, 16776960, m, t); i.defaultSize = y.clone(), i.userData.key = 0, i.visible = !1, i.name = "helper0", this.transform.rotation && i.rotation.set(0 - this.transform.rotation._x, 0 - this.transform.rotation._y, 0 - this.transform.rotation._z), S && (i.applyMatrix4(S), i.updateMatrix(), S = void 0), m.add(i), _.push(i) } h && h(1, this) }, onProgress: u, onError: d }) } } } function onBeforeCompile(e) { Object.assign(e.uniforms, this.uniforms), e.fragmentShader = "uniform vec3 outlineColor;\n" + e.fragmentShader, e.fragmentShader = "uniform float outlineThickness;\n" + e.fragmentShader, e.fragmentShader = "uniform vec2 resolution;\n" + e.fragmentShader, e.fragmentShader = "uniform float outline;\n" + e.fragmentShader, e.fragmentShader = e.fragmentShader.replace("#include <map_fragment>", ["#ifdef USE_MAP", " vec4 texelColor = mapTexelToLinear( texture2D( map, vUv ) );", " texelColor = mapTexelToLinear( texelColor );", " if (outline == 0.) {", "\tdiffuseColor = diffuseColor * texelColor;", " } else { ", "\tfloat width = 0.0;", "\tif (resolution.x > resolution.y) {", "\t\twidth = resolution.y;", "\t} else {", "\t\twidth = resolution.x;", "\t}", " \tvec2 texel = vec2( 1.0 / resolution.y, 1.0 / resolution.x );", " \t#define OFFSET_COUNT_FLOAT 32.", " \t#define OFFSET_COUNT 8", " \tfloat aspect = resolution.x / resolution.y;", " \tvec2 offsets[OFFSET_COUNT];", " \toffsets[0] = vec2( 0., 1.);", " \toffsets[1] = vec2( 0., -1.);", " \toffsets[2] = vec2( 1., 0. );", " \toffsets[3] = vec2( -1., 0. );", " \toffsets[4] = vec2( -0.5, 0.5);", " \toffsets[5] = vec2( 0.5, -0.5);", " \toffsets[6] = vec2( 0.5, 0.5);", " \toffsets[7] = vec2( -0.5, -0.5);", " \tfloat a = 0.0;", " \tfloat theta = 0.;", " \tfor( float i = 0.; i < OFFSET_COUNT_FLOAT; i ++ ) {", "\t\ttheta = (6.283185307179586 / OFFSET_COUNT_FLOAT) * i;", " \t\tvec2 samplePoint = vec2(cos(theta) * outlineThickness, sin(theta) * outlineThickness * aspect);", "  \t\tfloat val = texture2D( map, vUv + texel * samplePoint).a;", "  \t\ta = max(a, val);", " \t}", " \tif (texelColor.a > 0.95) {", "\t\tdiffuseColor = diffuseColor * texelColor;", " \t} else {", " \t\ttexelColor = mix( vec4(outlineColor, a), texelColor, texelColor.a );", "\t\tdiffuseColor = vec4(outlineColor.x + 0.5, outlineColor.g + 0.5, outlineColor.b + 0.5, a) * texelColor;", " \t}", " }", "#endif"].join("\n")) } class InstancedGroup { constructor(e, t, i) { let r = e.points, n = e.scales || [], a = 1; if (!(r && r instanceof Array)) return; r.length > INSTANCE_COUNT_MAX && (logger.warn(`实例对象的实例数不能超过 ${INSTANCE_COUNT_MAX}，将忽略超出的 ${r.length - INSTANCE_COUNT_MAX} 个实例。`), r.splice(INSTANCE_COUNT_MAX, r.length - INSTANCE_COUNT_MAX)), a = r.length, this.name = e.name, this.layerName = t.name, this.type = "IconAsset", this.count = a, this.points = r, this.scales = n, this.transform = e.transform, this.assetObj = e, e.randomValues, this.delta = 0; var o = null, s = null, l = null, c = null, h = null, u = null, d = null; this._group = new Group, this.children = [], this.settings = []; var p = null; t.addInstanced("IconAsset", this), this.setRand = e => { }, this.getCount = () => this.children.length, this.getIndexName = () => this.children[this.children.length - 1].name, this.getTransform = () => this.children[this.children.length - 1].transform, this.removeInstance = e => { let t = this.settings.findIndex((t => t.key == e)); this.points.splice(t, 1), this._group.remove(this.children[t]), this.children.splice(t, 1), this.settings.splice(t, 1) }, this.addAllInstance = (i, r, n) => { if (r && i) { this.count = this.points.length; for (let n = 0; n < i.length; n++) { let a = d.clone(), o = i[n], s = { x: 1, y: 1, z: 1 }; r.length > n && (s = r[n]), a.type = "IconGroup", a.name = t.getIndexName(e.name), a.position.set(o[0], o[1], o[2]), a.scale.set(s.x, s.y, s.z), this.children.push(a), this._group.add(a) } } }, this.addInstance = (i, r) => { if (!(i && i instanceof Array)) return; let n = this.points.length; i.length + this.points.length > INSTANCE_COUNT_MAX && (logger.warn(`实例对象的实例数不能超过 ${INSTANCE_COUNT_MAX}，将忽略超出的 ${i.length + this.points.length - INSTANCE_COUNT_MAX} 个实例。`), this.points.splice(INSTANCE_COUNT_MAX - this.points.length, i.length + this.points.length - INSTANCE_COUNT_MAX)), this.points.push.apply(this.points, i); let { x: a, y: o, z: s } = this.transform.scale; this.scales.push.apply(this.scales, [{ x: a, y: o, z: s }]), this.count = this.points.length; for (let i = n; i < this.points.length; i++) { let r = d.clone(), n = this.points[i]; r.type = "IconGroup", r.name = t.getIndexName(e.name), r.position.set(n[0], n[1], n[2]), r.scale.set(this.transform.scale.x, this.transform.scale.y, this.transform.scale.z), this.children.push(r), this._group.add(r) } }; let f = e => { if (null != e.textParam) { var t = e.textParam.canvas, i = new CanvasTexture(t); u = new SpriteMaterial({ map: i, color: 16777215, fog: DRAWABLE_FOG, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, sizeAttenuation: e.param.sizeAttenuation }), (l = new Sprite(u)).scale.set(e.param.sizeAttenuation ? .045 * e.textParam.canvas.width : 405e-6 * e.textParam.canvas.width, e.param.sizeAttenuation ? .045 * e.textParam.canvas.height : 405e-6 * e.textParam.canvas.height, 1); let r = -1; l.center = new Vector2(e.textParam.offsetV * r + .5, e.textParam.offsetH * r + .5), l.type = "IconAsset", l.name = e.name + "文字", l.visible = e.textParam.enableText } }, m = (e, t, i, r, n, a, o) => { let s = document.createElement("canvas"), l = s.getContext("2d"); var c = 4.5 * t, h = ""; i && (h = "bold"); var u = ""; return r && (u = "italic"), l.font = `${u} ${h} ${c}px ${e}`, s.width = 1.8 * (l.measureText(o).width + c), s.height = 3.2 * c, l.fillStyle = n, l.fillRect(0, 0, s.width, s.height), l.font = `${u} ${h} ${2 * c}px ${e}`, l.fillStyle = a, l.textAlign = "center", l.textBaseline = "middle", l.fillText(o, s.width / 2, s.height / 2), s }, g = e => { var t = document.createElement("canvas"); return t.width = e.image.width, t.height = e.image.height, t.getContext("2d").drawImage(e.image, 0, 0, t.width, t.height), t.toDataURL() }; if (this.update = (e, t) => { this.assetObj.param = e.param, this.assetObj.textParam = e.textParam; let i = _context.defaultObjectTree.getItemByName(this.layerName), r = this.settings.map((e => e.name)); if (i.children.forEach((t => { r.includes(t.name) && ("ModelAsset" == e.type ? t.modelPath = e.path : (t.param = e.param, t.textParam = e.textParam)) })), d.clear(), "" != e.param.background) { let t = _context.loaders.textureLoader.load(util$1.url(_context.instance.resourceBasePath, "texture/iconBackground/" + e.param.background + ".png"), (e => { this.backgroundMap = e })); (c = new SpriteMaterial({ map: t, color: new Color$1(e.param.backgroundColor), fog: !1, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, alphaTest: .1, transparent: !0, sizeAttenuation: e.param.sizeAttenuation, polygonOffset: e.param.polygonOffset, polygonOffsetFactor: e.param.polygonOffsetFactor, polygonOffsetUnits: e.param.polygonOffsetUnits })).uniforms = { outlineColor: { value: new Color$1("#ffff00") }, outlineThickness: { value: 65 }, resolution: { value: new Vector2(_context.renderer.domElement.width, _context.renderer.domElement.height) }, outline: { value: 0 } }, c.onBeforeCompile = onBeforeCompile, (p = c.clone()).uniforms = { outlineColor: { value: new Color$1("#ffff00") }, outlineThickness: { value: 65 }, resolution: { value: new Vector2(_context.renderer.domElement.width, _context.renderer.domElement.height) }, outline: { value: 1 } }, p.onBeforeCompile = onBeforeCompile, (o = new Sprite(c.clone())).name = this.assetObj.name + "底图", o.type = "IconBackground", o.scale.set(e.param.sizeAttenuation ? Number(e.param.width) / 25 : Number(e.param.width) / 2500, e.param.sizeAttenuation ? Number(e.param.height) / 25 : Number(e.param.height) / 2500, 1); let i = -1; if (o.center = new Vector2(e.param.offsetV * i + .5, e.param.offsetH * i + .5), "rgba" === e.param.backgroundColor.substring(0, 4)) { let t = e.param.backgroundColor.slice(4); t = t.split(","), t = parseFloat(t[3].replace(/[^0-9.]/gi, "")), o.material.opacity = t } d.add(o) } else (c = new SpriteMaterial).uniforms = { outlineColor: { value: new Color$1("#ffff00") }, outlineThickness: { value: 65 }, resolution: { value: new Vector2(_context.renderer.domElement.width, _context.renderer.domElement.height) }, outline: { value: 0 } }, c.onBeforeCompile = onBeforeCompile, (p = c.clone()).uniforms = { outlineColor: { value: new Color$1("#ffff00") }, outlineThickness: { value: 65 }, resolution: { value: new Vector2(_context.renderer.domElement.width, _context.renderer.domElement.height) }, outline: { value: 1 } }, p.onBeforeCompile = onBeforeCompile, (o = new Sprite(c.clone())).name = this.assetObj.name + "底图", o.type = "IconBackground", o.visible = !1, d.add(o); if (-1 != e.param.path.indexOf("[[origin]]")) var n = e.param.path.replace("[[origin]]", _context.origin); else n = e.param.path; e.map && (n = e.map); let a = _context.loaders.textureLoader.load(n, (e => { this.map = g(e) })); h = new SpriteMaterial({ map: a, color: new Color$1("#ffffff"), fog: !1, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, alphaTest: .1, transparent: !0, sizeAttenuation: e.param.sizeAttenuation, polygonOffset: e.param.polygonOffset, polygonOffsetFactor: e.param.polygonOffsetFactor, polygonOffsetUnits: e.param.polygonOffsetUnits }), (s = new Sprite(h.clone())).name = this.assetObj.name + "图标", s.type = "IconAsset", s.scale.set(e.param.sizeAttenuation ? Number(e.param.width) / 50 : Number(e.param.width) / 5e3, e.param.sizeAttenuation ? Number(e.param.height) / 50 : Number(e.param.height) / 5e3, 1); "" == e.param.background ? s.center = new Vector2(-1 * e.param.offsetV + .5, -1 * e.param.offsetH + .5) : s.center = new Vector2(-2 * e.param.offsetV + .5, -2 * e.param.offsetH + .5), d.add(s), null != e.textParam && e.textParam.enableText ? (e.textParam.canvas = m(e.textParam.fontFamily, e.textParam.fontSize, e.textParam.fontBold, e.textParam.enableItalic, e.textParam.background, e.textParam.color, e.textParam.text), f(e), l.name = this.assetObj.name + "文字") : l = new Group, d.add(l), this.children.forEach(((e, t) => { e.children[0].visible = o.visible, e.children[0].center = o.center.clone(), e.children[1].center = s.center.clone(), l.center && (e.children[2].center = l.center.clone()), e.children[0].material = c.clone(), e.children[0].scale.copy(o.scale), e.children[1].material = h.clone(), e.children[1].scale.copy(s.scale), e.children[2].scale.copy(l.scale), e.children[2].material = u.clone() })) }, this.highlight = (e, t) => { if (t || this.children.forEach((e => { e.children[0].material = c.clone(), e.children[0].material.needsUpdate = !0 })), !e) return; let i = this.children.find((t => t.name == e)); i.children[0].material = p, i.children[0].material.needsUpdate = !0 }, this.cancelHighlight = e => { if (!e) return; let t = this.children.find((t => t.name == e)); t.children[0].material = c.clone(), t.children[0].material.needsUpdate = !0 }, this.setVisible = (e, t) => { let i = this.settings.findIndex((t => t.key == e)), r = this.children.find((t => t.name == e)); r && (r.visible = t), this.settings[i].isVisible = t }, this.lock = (e, t) => { let i = this.settings.findIndex((t => t.key == e)); this.settings[i].isLock = t }, this.toJSON = () => ({ name: this.name, type: this.type, count: this.count, points: this.points, scales: this.scales, transform: this.transform, assetObj: this._getAssetSetting(), settings: this.settings }), this._getAssetSetting = () => { let e = JSON.parse(JSON.stringify(this.assetObj)); return e.map = this.map, e.backgroundMap = this.backgroundMap, e }, ((e, t, i) => { (d = new Group).type = "IconGroup", d.name = t.getIndexName(e.name), d.position.set(this.points[0][0], this.points[0][1], this.points[0][2]); let r = new Vector3(this.transform.scale.x || 1, this.transform.scale.y || 1, this.transform.scale.z || 1); if (e.scales && e.scales.length && (r.x = e.scales[0].x, r.y = e.scales[0].y, r.z = e.scales[0].z), d.scale.copy(r), "" != e.param.background) { let t = _context.loaders.textureLoader.load(util$1.url(_context.instance.resourceBasePath, "texture/iconBackground/" + e.param.background + ".png"), (e => { this.backgroundMap = g(e) })); if ((c = new SpriteMaterial({ map: t, color: new Color$1(e.param.backgroundColor), fog: !1, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, alphaTest: .1, transparent: !0, sizeAttenuation: e.param.sizeAttenuation, polygonOffset: e.param.polygonOffset, polygonOffsetFactor: e.param.polygonOffsetFactor, polygonOffsetUnits: e.param.polygonOffsetUnits })).uniforms = { outlineColor: { value: new Color$1("#ffff00") }, outlineThickness: { value: 65 }, resolution: { value: new Vector2(_context.renderer.domElement.width, _context.renderer.domElement.height) }, outline: { value: 0 } }, e.param.backgroundColor && "rgba" === e.param.backgroundColor.substring(0, 4)) { let t = e.param.backgroundColor.slice(4); t = t.split(","), t = parseFloat(t[3].replace(/[^0-9.]/gi, "")), c.opacity = t } c.onBeforeCompile = onBeforeCompile, (p = c.clone()).uniforms = { outlineColor: { value: new Color$1("#ffff00") }, outlineThickness: { value: 65 }, resolution: { value: new Vector2(_context.renderer.domElement.width, _context.renderer.domElement.height) }, outline: { value: 1 } }, p.onBeforeCompile = onBeforeCompile, (o = new Sprite(c)).name = e.name + "底图", o.type = "IconBackground", o.scale.set(e.param.sizeAttenuation ? Number(e.param.width) / 25 : Number(e.param.width) / 2500, e.param.sizeAttenuation ? Number(e.param.height) / 25 : Number(e.param.height) / 2500, 1); let i = -1; o.center = new Vector2(i * e.param.offsetV + .5, i * e.param.offsetH + .5), d.add(o) } else (c = new SpriteMaterial).uniforms = { outlineColor: { value: new Color$1("#ffff00") }, outlineThickness: { value: 65 }, resolution: { value: new Vector2(_context.renderer.domElement.width, _context.renderer.domElement.height) }, outline: { value: 0 } }, (p = c.clone()).uniforms = { outlineColor: { value: new Color$1("#ffff00") }, outlineThickness: { value: 65 }, resolution: { value: new Vector2(_context.renderer.domElement.width, _context.renderer.domElement.height) }, outline: { value: 1 } }, p.onBeforeCompile = onBeforeCompile, (o = new Sprite(c.clone())).name = e.name + "底图", o.type = "IconBackground", o.visible = !1, d.add(o); if (-1 != e.param.path.indexOf("[[origin]]")) var n = e.param.path.replace("[[origin]]", _context.origin); else n = e.param.path; e.map && (n = e.map); let a = _context.loaders.textureLoader.load(n, (e => { this.map = g(e) })); h = new SpriteMaterial({ map: a, color: new Color$1("#ffffff"), fog: !1, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, alphaTest: .1, transparent: !0, sizeAttenuation: e.param.sizeAttenuation, polygonOffset: e.param.polygonOffset, polygonOffsetFactor: e.param.polygonOffsetFactor, polygonOffsetUnits: e.param.polygonOffsetUnits }), (s = new Sprite(h.clone())).name = e.name + "图标", s.type = "IconAsset", s.scale.set(e.param.sizeAttenuation ? Number(e.param.width) / 50 : Number(e.param.width) / 5e3, e.param.sizeAttenuation ? Number(e.param.height) / 50 : Number(e.param.height) / 5e3, 1); "" == e.param.background ? s.center = new Vector2(-1 * e.param.offsetV + .5, -1 * e.param.offsetH + .5) : s.center = new Vector2(-2 * e.param.offsetV + .5, -2 * e.param.offsetH + .5), d.add(s), null != e.textParam && e.textParam.enableText ? (e.textParam.canvas = m(e.textParam.fontFamily, e.textParam.fontSize, e.textParam.fontBold, e.textParam.enableItalic, e.textParam.background, e.textParam.color, e.textParam.text), f(e), l.name = e.name + "文字", d.add(l)) : d.add(new Group), this.children.push(d), this._group.type = "InstancedGroup", this._group.userData.instancedGroup = this, this._group.add(d), t && t.add(this._group) })(e, t), this.points.length > 1) { let e = this.points.splice(1), i = []; this.scales && (i = this.scales.splice(1)), this.addAllInstance(e, i, t) } i && i(1, this) } } class InstancedItem extends ObjectTreeItem { constructor(e, t, i, r) { super("InstancedItem"), this.type = e.type, this.name = e.name, this.index = r, this.parent = t.name, this.key = i, this.isInstancedItem = !0, this.transform = e.transform, "ModelAsset" == this.type ? (this.modelPath = e.path, this.modelType = (e.modelType || "glb").toLowerCase()) : (this.param = e.param, this.textParam = e.textParam); let n = t, a = null; this.getGroup = () => "IconAsset" === this.type ? n.children.find((e => e.name == this.key)) : "ModelAsset" === this.type ? n.getHelper(this.key) : void 0, this.highlightInstance = e => { n.highlight(this.key, e) }, this.disableHighlight = () => { n.highlight() }, this.cancelHightLight = () => { n.cancelHighlight(this.key) }, this.update = function (e, t) { this.disableHighlight(), "IconAsset" == e.type && (n.update(e, this.key), _context.instance.nextRender((() => { this.highlightInstance() }), 2)) }, this.getSettings = () => ({ name: this.name, type: this.getType(), isVisible: this._getVisible(), isLock: this._getLock(), index: this.index, param: this.param, modelPath: this.modelPath, modelType: this.modelType, map: this.map, backgroundMap: this.backgroundMap, textParam: this.textParam, transform: this.transform, isCustom: this.isCustom, isEditor: this.isEditor, isInstancedItem: this.isInstancedItem, materials: n.materialStore.getSettings() }), this._getVisible = () => this.isVisible, this._setVisible = e => { this.isVisible = e, n.setVisible(this.key, this.isVisible) }, this._getLock = () => this.isLock, this._setLock = e => { this.isLock = e, n.lock(this.key, this.isLock) }, this.rankNode = () => { let e = n.settings.findIndex((e => e.key == this.key)); n.settings[e].index = this.index }, this.remove = () => { n.removeInstance(this.key) }, this.rename = e => { "IconAsset" == this.type && (this.getGroup().name = e), this.name = e; let t = n.settings.findIndex((e => e.key == this.key)); n.settings[t].name = this.name, "IconAsset" == this.type && (n.settings[t].key = this.name, this.key = this.name) }, this.setTransform = e => { this.transform = e; let t = n.settings.findIndex((e => e.key == this.key)); n.points[t] = [e.position.x, e.position.y, e.position.z]; let { x: i, y: r, z: a } = e.scale; n.scales[t] = { x: i, y: r, z: a } }, this.iconHide = () => { if ("IconAsset" == this.type) { let e = this.getGroup(); a = e.visible, e.visible = !1 } }, this.iconShow = () => { if ("IconAsset" == this.type) { this.getGroup().visible = a, a = null } }, this.isVisible = e.isVisible, this.isLock = e.isLock, n.settings.push({ index: this.index, name: this.name, key: this.key, isVisible: this.isVisible, isLock: this.isLock }) } } class MarkerItem extends ObjectTreeItem { constructor({ id: e = util$1.guid(), name: t, modelPath: i, transform: r, isVisible: n } = {}, a, o) { super("MarkerItem"), this.id = e, this.name = t || this.id, this.modelPath = i, this.type = "MarkerItem", this.animations = [], this.scale = (e = 1, t = 1, i = 1) => { _modelNode && _modelNode.scale.set(e, t, i) }, this.translate = (e = 0, t = 0, i = 0) => { _modelNode && _modelNode.position.set(e, t, i) }, this.rotateX = e => { _modelNode && _modelNode.rotateX(util$1.degreeToRadian(e)) }, this.rotateY = e => { _modelNode && _modelNode.rotateY(util$1.degreeToRadian(e)) }, this.rotateZ = e => { _modelNode && _modelNode.rotateZ(util$1.degreeToRadian(e)) }, this.load = (e = { color: "#ffffff", position: [0, 0, 0], size: 100, opacity: 1 }, t, i) => (logger.debug("TRACE: MarkerItem.load() - Entering.", e), e.color = e.color || "#ffffff", e.position = e.position || [0, 0, 0], e.size = "number" == typeof e.size && e.size >= 0 ? e.size : 100, e.opacity = "number" == typeof e.opacity && e.opacity >= 0 && e.opacity <= 1 ? e.opacity : 1, logger.debug("TRACE: MarkerItem.load() - Leaving and return a Promise."), new Promise(((r, n) => { _context.loaders.gltfLoader || (t && t(0, "No loader initiated."), n(new Error("No loader initiated."))), e.name || (e.name = util$1.guid()); var a = e.path; _context.loaders.gltfLoader.load(a, (i => { if (i.scene.traverse((t => { if (t.isMesh) { if (t.userData.transparent = t.material.transparent, t.castShadow = !1, t.receiveShadow = !1, e.opacity < .99 && (t.material.transparent = !0, t.material.opacity = e.opacity), t.material.transparent && t.material.map && (t.material.opacity = e.opacity, t.material.alphaMap = t.material.map.clone(), t.material.emissiveMap = t.material.map.clone(), e.ignoreMap instanceof Array)) { let i = !1; for (let r of e.ignoreMap) r === t.name && (i = !0); i && (t.material.map = null) } t.material.color = new Color$1(e.color), t.material.emissive = new Color$1(e.color), t.material.emissiveIntensity = .5, t.material.depthWrite = _context.drawableDepthTest, t.material.depthTest = _context.drawableDepthTest, t.material.onBeforeCompile = function (e) { let t = ShaderChunk.lights_phong_pars_fragment; t = t.replace("vec3 irradiance = dotNL * directLight.color;", "float colorIntensity = max(max(directLight.color.r,directLight.color.g),directLight.color.b);vec3 irradiance = dotNL * vec3(colorIntensity,colorIntensity,colorIntensity);"), e.fragmentShader = e.fragmentShader.replace("#include <lights_phong_pars_fragment>", t); let i = ShaderChunk.lights_pars_begin; i = i.replace("vec3 irradiance = ambientLightColor;", "float colorIntensity = max(max(ambientLightColor.r,ambientLightColor.g),ambientLightColor.b);vec3 irradiance = vec3(colorIntensity,colorIntensity,colorIntensity);"), i = i.replace("vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );", "vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );float colorIntensity = max(max(irradiance.r,irradiance.g),irradiance.b);irradiance = vec3(colorIntensity,colorIntensity,colorIntensity);"), e.fragmentShader = e.fragmentShader.replace("#include <lights_pars_begin>", i) }, t.material.needsUpdate = !0 } })), e.animations instanceof Array) for (let t of e.animations) switch (t.type) { case "internal": let r, n; switch (t.nodeName && (r = i.scene.getObjectByName(t.nodeName)), r || (r = i.scene), t.animation) { case "rotateY": n = new NodeRotationAnimationController(r, !1, !0, !1, 0, "number" == typeof t.speed ? t.speed : .1, 0), _context.animationStore.add(n), this.animations.push(n); break; case "spread": t.startScale = "number" == typeof t.startScale ? t.startScale : .1, t.stopScale = "number" == typeof t.stopScale ? t.stopScale : 1, t.fadeOutScale = "number" == typeof t.fadeOutScale ? t.fadeOutScale : .7, t.speed = "number" == typeof t.speed ? t.speed : .1, n = new NodeScaleAnimationController(r, t.startScale, t.stopScale, t.fadeOutScale, t.speed, !0), _context.animationStore.add(n), this.animations.push(n); break; case "uvY": if (!r.material) break; t.speed = "number" == typeof t.speed ? t.speed : .2, n = new UVAnimationController(r.material, !1, !0, 0, t.speed), _context.animationStore.add(n), this.animations.push(n); break; case "uvX": if (!r.material) break; t.speed = "number" == typeof t.speed ? t.speed : .2, n = new UVAnimationController(r.material, !0, !1, t.speed, 0), _context.animationStore.add(n), this.animations.push(n) }break; case "imported": const a = new AnimationMixer(i.scene); if (a.name = e.name, !i.animations[e.index || 0]) break; a.clipAction(i.animations[e.index || 0]).setDuration(1).setEffectiveTimeScale("number" == typeof e.timeScale ? e.timeScale : 1).play(), _context.animationMixers.push(a) }i.scene.name = e.name, i.scene.scale.set(e.size, e.size, e.size), i.scene.path = e.path; let n = new Group; n.name = e.name, n.position.set(e.position[0], e.position[1], e.position[2]), n.add(i.scene), r(), t && t(1, n) }), i, (e => { t ? t(0, e) : logger.debug(e), n(e) })) }))), this.destroy = () => { _context.objectStore.remove(this.name), this.animations.forEach((e => { _context.animationStore.remove(_context.animationStore.findNodeAnimation(e.name, e.type)) })), this.animations = [] } } } class Model { constructor({ id: e = util$1.guid(), name: t, url: i, animations: r, children: n = [], isVisible: a, index: o }) { this.id = e, this.name = t || this.id, this.url = i, this.animations = r, this.children = n, this.isVisible = a, this.index = o } findNode(e = "") { if (!this.children || "" === e) return; return this._findNodeRecursively(e, this) } _findNodeRecursively(e, t) { if (t.children && t.children instanceof Array && 0 !== t.children.length) for (let i of t.children) { if (i.name === e) return i; if (i.children instanceof Array && i.children.length > 0) { let t = this._findNodeRecursively(e, i); if (t) return t } } } } var axisTypeChangeEvent = { type: "axisTypeChange" }, mouseDownEvent = { type: "mouseDown" }, mouseUpEvent = { type: "mouseUp", mode: null }; class ModelSelection extends EventDispatcher { constructor() { super("ModelSelection"); let e = "centre", t = new Map, i = new Map, r = new Object3D, n = new Vector3, a = new Euler, o = new Vector3, s = this; this.controlsState = !1, this.onTranslate = void 0, this.onScale = void 0, this.onRotate = void 0; const l = () => { if (s.onTranslate) { const e = Array.from(i.values()).map((e => e.threeObject)); s.onTranslate(e) } }, c = () => { if (s.onRotate) { const e = Array.from(i.values()).map((e => e.threeObject)); s.onScale(e) } }, h = () => { if (s.onRotate) { const e = Array.from(i.values()).map((e => e.threeObject)); s.onRotate(e) } }; let u = e => { let t = e.target.object.position.clone().sub(n); n = e.target.object.position.clone(), i.forEach((e => { let i = t.clone(); i.divide(e.threeObject.parent.getWorldScale(new Vector3)); let r = new Matrix4; r.makeRotationFromQuaternion(e.threeObject.parent.getWorldQuaternion(new Quaternion)).invert(), i.applyMatrix4(r); let n = e.transform.position.clone().add(i); e.threeObject.position.copy(n), e.transform.position = e.threeObject.position.clone(), e.transform.rotation = e.threeObject.rotation.clone(), e.transform.scale = e.threeObject.scale.clone(), e.threeObject instanceof InstancedHelper && e.threeObject.setPosition(n) })), l() }, d = t => { let r = t.target.axis.toLocaleLowerCase(); if ("e" !== r && 0 !== t.target.rotationAngleDelta) { if ("centre" === e) { let e = t.target.object.position.clone(); i.forEach((i => { ((e, t, i, r) => { if (!e || !e.position) return; if (!t) return; if ("x" !== i && "y" !== i && "z" !== i) return; const n = e.getWorldPosition(new Vector3); n.sub(t); const a = { x: new Vector3(1, 0, 0), y: new Vector3(0, 1, 0), z: new Vector3(0, 0, 1) }; n.applyAxisAngle(a[i], r), e.rotateOnWorldAxis(a[i], r); let o = e.parent.getWorldPosition(new Vector3); n.add(t), n.sub(o), n.divide(e.parent.getWorldScale(new Vector3)); let s = new Matrix4; s.makeRotationFromQuaternion(e.parent.getWorldQuaternion(new Quaternion)).invert(), n.applyMatrix4(s), e.position.copy(n) })(i.threeObject, e, r, t.target.rotationAngleDelta), i.threeObject instanceof InstancedHelper && i.threeObject.rotate(i.threeObject.position, i.threeObject.rotation) })) } else "oneself" === e && i.forEach((e => { e.threeObject[`rotate${r.toLocaleUpperCase()}`](t.target.rotationAngleDelta), e.threeObject instanceof InstancedHelper && e.threeObject.rotateAxis() })); h() } }, p = e => { let t = e.target.object.scale; i.forEach((e => { let i = t.clone(), r = new Matrix4; if (r.makeRotationFromQuaternion(e.threeObject.parent.getWorldQuaternion(new Quaternion)).invert(), i.applyMatrix4(r), e.threeObject instanceof InstancedHelper) e.threeObject.setScale(i); else { let t = e.transform.scale; e.threeObject.scale.set(t.x * i.x, t.y * i.y, t.z * i.z) } })), c() }; this.setPropertyTransform = (t = "", n) => { let a; if ("" === t) return a = { success: 0, message: "修改失败" }, a; let o = t.split("."); if (_context.transformControls.dispatchEvent(mouseDownEvent), "oneself" === e) i.forEach(((e, t) => { let i = JSON.parse(JSON.stringify(_context.instance.getModelTransformByUUID(t))); 2 === o.length ? i[o[0]][o[1]] = n : 1 === o.length && (i[o[0]] = n), _context.instance.setModelTransformByUUID(t, i) })), this.enableTransformControl(), a = { success: 1, message: "修改成功" }; else if ("centre" === e) { let e = ["x", "y", "z"]; if ("rotation" === o[0]) if (2 == o.length) { let e = r.rotation[o[1]]; r[`rotate${o[1].toUpperCase()}`](MathUtils.degToRad(n) - e); let t = { target: { axis: o[1], object: r, rotationAngleDelta: MathUtils.degToRad(n) - e } }; d(t) } else 1 == o.length && e.forEach((e => { let t = r.rotation[e]; r[`rotate${e.toUpperCase()}`](MathUtils.degToRad(n[e]) - t); let i = { target: { axis: e, object: r, rotationAngleDelta: MathUtils.degToRad(n[e]) - t } }; d(i) })); else if ("position" === o[0]) if (2 == o.length) { r.position[`set${o[1].toUpperCase()}`](n), u({ target: { object: r } }) } else 1 == o.length && e.forEach((e => { r.position[`set${e.toUpperCase()}`](n[e]), u({ target: { object: r } }) })); else if ("scale" === o[0]) if (2 == o.length) { r.scale[`set${o[1].toUpperCase()}`](n), p({ target: { object: r } }) } else 1 == o.length && e.forEach((e => { r.scale[`set${e.toUpperCase()}`](n[e]), p({ target: { object: r } }) })) } mouseUpEvent.mode = _context.transformControls.mode, _context.transformControls.dispatchEvent(mouseUpEvent) }, this.selectObjectByUUID = (e = [], r = !1) => (i.clear(), t.forEach((e => { e.forEach((e => { if (e.parent && "InstancedGroup" === e.parent.type) { let t = e.parent.parent.uuid, i = _context.defaultObjectTree.getItemByUUID(t); if (i) { let t = i.getItemByName(e.name); t && t.disableHighlight() } } else e.children[0].material.uniforms && (e.children[0].material.uniforms.outline.value = 0) })) })), _context.effectStore.highlightObject(null), e.forEach((e => { let n = { threeObject: null, userObject: null, transform: {} }, a = _context.instance.defaultObjectTree.getItemByUUID(e); if (!0 === r && (a = _context.instance.defaultObjectTree.getItemByName(e)), a && "TileSetItem" !== a.type) { n.userObject = a; let r = a.getGroup(); if (n.threeObject = r, n.transform.position = r.position.clone(), n.transform.rotation = r.rotation.clone(), n.transform.scale = r.scale.clone(), i.set(e, n), "IconAsset" === a.type) a.isInstancedItem ? a.highlightInstance(!0) : r.children[0].material.uniforms.outline.value = 1, t.set(e, [r]); else { let i = []; r.traverse((e => { "IconGroup" === e.type && (e.isInstancedItem ? e.highlightInstance(!0) : e.children[0].material.uniforms.outline.value = 1, i.push(e)) })), i.length > 0 ? (t.set(e, i), _context.effectStore.highlightObject(n.threeObject, !0)) : _context.effectStore.highlightObject(n.threeObject, !0) } } else logger.warn("ModeSelection.selectObjectByUUID(): Invalid input found.") })), this.controlsState && this.enableTransformControl(), this.getSelectionList()), this.setSelectObjectByUUID = e => { i.forEach(((e, t) => { e.transform.scale = e.threeObject.scale.clone(), e.transform.position = e.threeObject.position.clone(), e.transform.rotation = e.threeObject.rotation.clone() })); let r = { threeObject: null, userObject: null, transform: {} }, n = _context.instance.defaultObjectTree.getItemByUUID(e); if (n && "TileSetItem" !== n.type) { r.userObject = n; let a = n.getGroup(); if (r.threeObject = a, r.transform.position = a.position.clone(), r.transform.rotation = a.rotation.clone(), r.transform.scale = a.scale.clone(), i.set(e, r), "IconAsset" === n.type) n.isInstancedItem ? n.highlightInstance(!0) : a.children[0].material.uniforms.outline.value = 1, t.set(e, [a]); else { let i = []; a.traverse((e => { "IconGroup" === e.type && (e.isInstancedItem ? e.highlightInstance(!0) : e.children[0].material.uniforms.outline.value = 1, i.push(e)) })), i.length > 0 ? (t.set(e, i), _context.effectStore.highlightObject(r.threeObject, !0)) : _context.effectStore.highlightObject(r.threeObject, !0) } this.controlsState && this.enableTransformControl() } else logger.warn("ModeSelection.selectObjectByUUID(): Invalid input found."); return this.getSelectionList() }, this.deleteSelectObjectByUUID = e => { if (i.forEach(((e, t) => { e.transform.scale = e.threeObject.scale.clone(), e.transform.position = e.threeObject.position.clone(), e.transform.rotation = e.threeObject.rotation.clone() })), !i.get(e)) return logger.warn("ModeSelection.deleteSelectObjectByUUID(): Invalid input found."), this.getSelectionList(); _context.effectStore.cancleHighlightObject(i.get(e).threeObject); let r = t.get(e); return r && r.forEach((e => { if (e.parent && "InstancedGroup" === e.parent.type) { let t = e.parent.parent.uuid, i = _context.defaultObjectTree.getItemByUUID(t); if (i) { let t = i.getItemByName(e.name); t && t.cancelHightLight() } } else e.children[0].material.uniforms && (e.children[0].material.uniforms.outline.value = 0) })), t.delete(e), i.delete(e), this.controlsState && this.enableTransformControl(), this.getSelectionList() }, this.toggleSelectObjectByUUID = e => (i.get(e) ? this.deleteSelectObjectByUUID(e) : this.setSelectObjectByUUID(e), this.getSelectionList()), this.getSelectionList = () => { let e = []; return i.forEach(((t, i) => { e.push(i) })), e }, this.getProperty = e => { }, this.setProperty = (e, t, r) => { let n = { success: 0, message: "" }; if ("--" == r) return; let a = t.split("."); switch (e) { case "transform": this.setPropertyTransform(t, r); break; case "iconAssetData": i.forEach(((e, t) => { if ("IconAsset" == e.userObject.type) { let t = JSON.parse(JSON.stringify(e.userObject)); a.length > 1 ? t[a[0]][a[1]] = r : 1 == a.length && (t[a[0]] = r), delete t.backgroundMap, delete t.map, e.userObject.update(t) } })), n = { success: 1, message: "修改成功" } }return n }, this.getAllProperties = () => { if (!i.size) return {}; if (1 === i.size) { let e = this.getSelectionList()[0], t = i.get(e), r = {}; return r.position = JSON.parse(JSON.stringify(t.threeObject.position)), r.rotation = JSON.parse(JSON.stringify(t.threeObject.rotation)), r.rotation.x = r.rotation._x, r.rotation.y = r.rotation._y, r.rotation.z = r.rotation._z, r.scale = JSON.parse(JSON.stringify(t.threeObject.scale)), r.rotation.x = r.rotation._x = MathUtils.radToDeg(r.rotation._x), r.rotation.y = r.rotation._y = MathUtils.radToDeg(r.rotation._y), r.rotation.z = r.rotation._z = MathUtils.radToDeg(r.rotation._z), { ...t.userObject, transform: r } } let t = {}; return i.forEach((e => { for (let i in e.userObject) switch (logger.info(`ModeSelection.getAllProperties(): deep clone userObject-propertyName: ${i}`), i) { case "id": case "children": case "materialStore": case "level": case "floor": case "backgroundMap": case "map": case "_nodeSelection": case "getType": t[i] = void 0; break; case "textParam": case "param": if (e.userObject[i].canvas && delete e.userObject[i].canvas, t.hasOwnProperty(i)) for (let r in e.userObject[i]) t[i] && !t[i].hasOwnProperty(r) ? t[i][r] = util$1.clone(e.userObject[i][r]) : t[i][r] = util$1.eq(t[i][r], e.userObject[i][r]) ? t[i][r] : "--"; else t[i] = util$1.clone(JSON.parse(JSON.stringify(e.userObject[i]))); break; case "name": t.hasOwnProperty(i) ? t.label = util$1.eq(t[i], e.userObject[i]) ? t[i] : "--" : (t[i] = util$1.clone(e.userObject[i]), t.label = util$1.clone(e.userObject[i])) } })), "centre" == e ? (t.transform = {}, t.transform.position = JSON.parse(JSON.stringify(r.position)), t.transform.rotation = JSON.parse(JSON.stringify(r.rotation)), t.transform.rotation.x = t.transform.rotation._x, t.transform.rotation.y = t.transform.rotation._y, t.transform.rotation.z = t.transform.rotation._z, t.transform.scale = JSON.parse(JSON.stringify(r.scale)), t.transform.rotation.x = t.transform.rotation._x = MathUtils.radToDeg(t.transform.rotation._x), t.transform.rotation.y = t.transform.rotation._y = MathUtils.radToDeg(t.transform.rotation._y), t.transform.rotation.z = t.transform.rotation._z = MathUtils.radToDeg(t.transform.rotation._z)) : "oneself" == e && (t.transform = {}, i.forEach((e => { let i = {}; for (var r in i.position = JSON.parse(JSON.stringify(e.threeObject.position)), i.rotation = JSON.parse(JSON.stringify(e.threeObject.rotation)), i.rotation.x = i.rotation._x, i.rotation.y = i.rotation._y, i.rotation.z = i.rotation._z, i.scale = JSON.parse(JSON.stringify(e.threeObject.scale)), i.rotation.x = i.rotation._x = MathUtils.radToDeg(i.rotation._x), i.rotation.y = i.rotation._y = MathUtils.radToDeg(i.rotation._y), i.rotation.z = i.rotation._z = MathUtils.radToDeg(i.rotation._z), i) if (t.transform.hasOwnProperty(r)) for (let e in i[r]) t.transform[r] && !t.transform[r].hasOwnProperty(e) ? t.transform[r][e] = util$1.clone(i[r][e]) : t.transform[r][e] = util$1.eq(t.transform[r][e], i[r][e]) ? t.transform[r][e] : "--"; else t.transform[r] = util$1.clone(i[r]) }))), t }, this.getCenterPosition = () => { let e = []; if (i.forEach((t => { let i = t.threeObject.getWorldPosition(new Vector3), r = new Box3; r.expandByObject(t.threeObject), Math.abs(r.min.x) === 1 / 0 ? e.push(i) : (e.push(r.min), e.push(r.max)) })), !e.length) return new Vector3; let t = e[0].clone(), r = e[0].clone(); return e.forEach((e => { t.min(e), r.max(e) })), new Box3(t, r).getCenter(new Vector3) }, this.enableTransformControl = () => { if (this.disableTransformControl(), 1 === i.size) { let e = this.getSelectionList(); return _context.transformControls.attach(i.get(e[0]).threeObject), _context.transformControls.addEventListener("translate", l), _context.transformControls.addEventListener("rotate", h), void _context.transformControls.addEventListener("scale", c) } if (_context.transformControls.removeEventListener("translate", l), _context.transformControls.removeEventListener("rotate", h), _context.transformControls.removeEventListener("scale", c), i.size < 1) return; this.controlsState = !0; let e = this.getCenterPosition(); r.position.copy(e), r.rotation.set(0, 0, 0), r.scale.set(1, 1, 1), n.copy(e), a.copy(r.rotation), o.copy(r.scale), _context.scene.add(r), _context.transformControls.addEventListener("translate", u), _context.transformControls.addEventListener("rotate", d), _context.transformControls.addEventListener("scale", p), _context.transformControls.removeEventListener("translate", l), _context.transformControls.removeEventListener("rotate", h), _context.transformControls.removeEventListener("scale", c), _context.transformControls.attach(r), _context.transformControls.showE = !1 }, this.disableTransformControl = () => { _context.transformControls.removeEventListener("translate", u), _context.transformControls.removeEventListener("rotate", d), _context.transformControls.removeEventListener("scale", p), _context.transformControls.showE = !0, this.controlsState = !1, _context.transformControls.detach() }, this.getSelectedModelMap = () => i, this.getAxisType = () => e, this.setAxisType = t => ("centre" != t && "oneself" != t || (e = t, this.dispatchEvent(axisTypeChangeEvent)), e) } } var traverse_1 = createCommonjsModule((function (e) { var t = e.exports = function (e) { return new i(e) }; function i(e) { this.value = e } function r(e, t, i) { var r = [], o = [], h = !0; return function e(u) { var d = i ? n(u) : u, p = {}, f = !0, m = { node: d, node_: u, path: [].concat(r), parent: o[o.length - 1], parents: o, key: r.slice(-1)[0], isRoot: 0 === r.length, level: r.length, circular: null, update: function (e, t) { m.isRoot || (m.parent.node[m.key] = e), m.node = e, t && (f = !1) }, delete: function (e) { delete m.parent.node[m.key], e && (f = !1) }, remove: function (e) { s(m.parent.node) ? m.parent.node.splice(m.key, 1) : delete m.parent.node[m.key], e && (f = !1) }, keys: null, before: function (e) { p.before = e }, after: function (e) { p.after = e }, pre: function (e) { p.pre = e }, post: function (e) { p.post = e }, stop: function () { h = !1 }, block: function () { f = !1 } }; if (!h) return m; function g() { if ("object" == typeof m.node && null !== m.node) { m.keys && m.node_ === m.node || (m.keys = a(m.node)), m.isLeaf = 0 == m.keys.length; for (var e = 0; e < o.length; e++)if (o[e].node_ === u) { m.circular = o[e]; break } } else m.isLeaf = !0, m.keys = null; m.notLeaf = !m.isLeaf, m.notRoot = !m.isRoot } g(); var y = t.call(m, m.node); return void 0 !== y && m.update && m.update(y), p.before && p.before.call(m, m.node), f ? ("object" != typeof m.node || null === m.node || m.circular || (o.push(m), g(), l(m.keys, (function (t, n) { r.push(t), p.pre && p.pre.call(m, m.node[t], t); var a = e(m.node[t]); i && c.call(m.node, t) && (m.node[t] = a.node), a.isLast = n == m.keys.length - 1, a.isFirst = 0 == n, p.post && p.post.call(m, a), r.pop() })), o.pop()), p.after && p.after.call(m, m.node), m) : m }(e).node } function n(e) { if ("object" == typeof e && null !== e) { var t; if (s(e)) t = []; else if (function (e) { return "[object Date]" === o(e) }(e)) t = new Date(e.getTime ? e.getTime() : e); else if (function (e) { return "[object RegExp]" === o(e) }(e)) t = new RegExp(e); else if (function (e) { return "[object Error]" === o(e) }(e)) t = { message: e.message }; else if (function (e) { return "[object Boolean]" === o(e) }(e)) t = new Boolean(e); else if (function (e) { return "[object Number]" === o(e) }(e)) t = new Number(e); else if (function (e) { return "[object String]" === o(e) }(e)) t = new String(e); else if (Object.create && Object.getPrototypeOf) t = Object.create(Object.getPrototypeOf(e)); else if (e.constructor === Object) t = {}; else { var i = e.constructor && e.constructor.prototype || e.__proto__ || {}, r = function () { }; r.prototype = i, t = new r } return l(a(e), (function (i) { t[i] = e[i] })), t } return e } i.prototype.get = function (e) { for (var t = this.value, i = 0; i < e.length; i++) { var r = e[i]; if (!t || !c.call(t, r)) { t = void 0; break } t = t[r] } return t }, i.prototype.has = function (e) { for (var t = this.value, i = 0; i < e.length; i++) { var r = e[i]; if (!t || !c.call(t, r)) return !1; t = t[r] } return !0 }, i.prototype.set = function (e, t) { for (var i = this.value, r = 0; r < e.length - 1; r++) { var n = e[r]; c.call(i, n) || (i[n] = {}), i = i[n] } return i[e[r]] = t, t }, i.prototype.map = function (e) { return r(this.value, e, !0) }, i.prototype.forEach = function (e) { return this.value = r(this.value, e, !1), this.value }, i.prototype.reduce = function (e, t) { var i = 1 === arguments.length, r = i ? this.value : t; return this.forEach((function (t) { this.isRoot && i || (r = e.call(this, r, t)) })), r }, i.prototype.paths = function () { var e = []; return this.forEach((function (t) { e.push(this.path) })), e }, i.prototype.nodes = function () { var e = []; return this.forEach((function (t) { e.push(this.node) })), e }, i.prototype.clone = function () { var e = [], t = []; return function i(r) { for (var o = 0; o < e.length; o++)if (e[o] === r) return t[o]; if ("object" == typeof r && null !== r) { var s = n(r); return e.push(r), t.push(s), l(a(r), (function (e) { s[e] = i(r[e]) })), e.pop(), t.pop(), s } return r }(this.value) }; var a = Object.keys || function (e) { var t = []; for (var i in e) t.push(i); return t }; function o(e) { return Object.prototype.toString.call(e) } var s = Array.isArray || function (e) { return "[object Array]" === Object.prototype.toString.call(e) }, l = function (e, t) { if (e.forEach) return e.forEach(t); for (var i = 0; i < e.length; i++)t(e[i], i, e) }; l(a(i.prototype), (function (e) { t[e] = function (t) { var r = [].slice.call(arguments, 1), n = new i(t); return n[e].apply(n, r) } })); var c = Object.hasOwnProperty || function (e, t) { return t in e } })); class LoadModelItem extends ObjectTreeItem { constructor(e, t) { super("LoadModelItem"), this.materialStore = new MaterialStore(_context.textureStore, _context.instance), this.type = "ModelItem", this.addModel = (e, t) => { for (let t = e.children.length - 1; t >= 0; t--)_context.scene.models.add(e.children[t]); for (let e = _context.scene.models.children.length - 1; e >= 0; e--)for (let i = t.length - 1; i >= 0; i--)if (t[i].name === _context.scene.models.children[e].userData.name && ("IconAsset" === t[i].type || "GroupItem" === t[i].type || "PaintItem" === t[i].type)) { _context.scene.models.remove(_context.scene.models.children[e]); break } const i = e.sourceModelKey; e.traverse((e => { if (util$1.capableForCastingShadow(e) && (e.castShadow = !0, e.receiveShadow = !0), e.material instanceof MeshBasicMaterial) { let t = util$1.MeshBasicMaterialToMeshStandardMaterial(e.material); e.material = t } if (e.material instanceof MeshStandardMaterial) { e.material.alphaTest = .05, e.material.depthWrite = !0, e.material.depthTest = !0, e.material.vertexColors = !1, e.material.needsUpdate = !0; for (let t in e.material) e.material[t] instanceof Texture$1 && e.material[t].image && _context.textureStore.add(e.material[t].name || `${e.material.name}#${t}`, e.material[t], i) } })) }, this.addModel(e, t) } } class TileSetItem extends ObjectTreeItem { constructor(e, t) { super("TileSetItem"), e = JSON.parse(JSON.stringify(e)); const i = [{ name: "errorTarget", defaultValue: 6 }, { name: "errorThreshold", defaultValue: 1 / 0 }, { name: "cacheSizeMax", defaultValue: 800 }, { name: "cacheSizeMin", defaultValue: 600 }, { name: "workers", defaultValue: 6 }]; for (let t of i) e[t.name] = Number(e[t.name]), isNaN(e[t.name]) && (e[t.name] = t.defaultValue); this.layerId = void 0 === e.id ? "" : e.id, this.url = e.url, this.offset = e.offset, this.rotation = e.rotation, this.errorTarget = e.errorTarget || 6, this.errorThreshold = e.errorThreshold, this.cacheSizeMax = e.cacheSizeMax || 800, this.cacheSizeMin = e.cacheSizeMin || 600, this.format = "B3DM", this.lod = "", this.workers = e.workers || 6, this.transform = e.transform, this.name = e.name, this.type = "TileSetItem", this.isVisible = void 0 === e.isVisible || e.isVisible, this.firstLoad = !0, TilesRenderer.customTransformEnabled = !0; let r = null; this.getGroup = () => r.group; let n = _context.instance.getDatumShiftModel(); if (!TilesRenderer.customTransformOrigin && n && n.type) switch (n.type.toLowerCase()) { case "surface": TilesRenderer.customTransformOrigin = { lon: n.lon, lat: n.lat, alt: n.alt }; break; case "mercator": TilesRenderer.customTransformOrigin = { lon: n.origin[0], lat: n.origin[1], alt: -n.alt } }let a = _context.scene.getObjectByName("__tilesGroup"); a || (a = new Group, a.name = "__tilesGroup", a.rotateX(Math.PI / -2), _context._tilesGroup = a, _context.scene.add(a)), _context.instance._tilesRenderers instanceof Map || (_context.instance._tilesRenderers = new Map); const o = md5(e.url); if (this.urlHash = o, _context.instance._tilesRenderers.has(o)) return logger.warn(`已经存在来自 ${e.url} 的 3DTiles，无法重复添加。`), void (t && t({ result: 0, message: `来自地址 ${e.url} 的 3DTiles 已存在!` })); if (_context.instance.defaultObjectTree.getItemByName(e.name)) return logger.warn(`已经存在名为 ${e.name} 的 3DTiles，无法重复添加。`), void (t && t({ result: 0, message: `名为 ${e.name} 的 3DTiles 已存在!` })); let s = e.url; -1 != s.indexOf("[[origin]]") && (s = s.replace("[[origin]]", _context.origin)), util$1.fetchJSON(s, "get").then((i => { if (!i) return logger.warn(`名为 ${e.name} 的 3DTiles 加载失败，请检查：倾斜摄影地址是否正确，地址是否有安全证书，数据服务器是否允许跨域。`), void (t && t({ result: 0, message: `名为 ${e.name} 的 3DTiles 加载失败，请检查：倾斜摄影地址是否正确，地址是否有安全证书，数据服务器是否允许跨域。` })); r = new TilesRenderer(s, e.offset, e.rotation), r.manager.addHandler(/\.gltf$/, _context.loaders.gltfLoader), r.preprocessURL = e => { let t; return logger.debug(`倾斜摄影url-----${e}`), t = "string" == typeof e ? e.replace(/\+/g, "%2B") : e, logger.debug(`倾斜摄影newUrl-----${t}`), t }, r.urlHash = o, r.group.visible = this.isVisible, r.group.layerId = this.layerId, r.onLoadTileSet = () => { _context.instance._tilesNeedRerender = !0, e.isApi && this.firstLoad && (t && t({ result: 1, message: "成功!" }), this.firstLoad = !1) }, r.onLoadModel = () => { _context.instance._tilesNeedRerender = !0 }, r.fetchOptions.mode = "cors", r.setCamera(_context.camera), r.setResolutionFromRenderer(_context.camera, _context.renderer), r.errorTarget = e.errorTarget ? e.errorTarget : 6, r.errorThreshold = "number" == typeof e.errorThreshold || e.errorThreshold === 1 / 0 ? e.errorThreshold : 1 / 0, 0 === _context.instance._tilesRenderers.size ? (r.lruCache.maxSize = e.cacheSizeMax, r.lruCache.minSize = e.cacheSizeMin, r.lruCache.unloadPercent = .1, r.downloadQueue.maxJobs = e.workers, r.parseQueue.maxJobs = r.downloadQueue.maxJobs) : (r.lruCache = _context.instance._tilesRenderers.get(Array.from(_context.instance._tilesRenderers.keys())[0]).lruCache, r.downloadQueue = _context.instance._tilesRenderers.get(Array.from(_context.instance._tilesRenderers.keys())[0]).downloadQueue, r.parseQueue = _context.instance._tilesRenderers.get(Array.from(_context.instance._tilesRenderers.keys())[0]).parseQueue, r.lruCache.maxSize += e.cacheSizeMax, r.lruCache.minSize += e.cacheSizeMin, r.downloadQueue.maxJobs += e.workers, r.downloadQueue.maxJobs = Math.min(r.downloadQueue.maxJobs, 64), r.parseQueue.maxJobs = r.downloadQueue.maxJobs), _context.instance._tilesRenderers.set(o, r), _context.instance._tilesNeedRerender = !0, r.group.name = e.name, _context._tilesGroup.add(r.group), this.id = r.group.uuid, this.index = void 0 === e.index ? _context.instance.defaultObjectTree.children.length : e.index, _context.instance.defaultObjectTree.addItem(this), void 0 !== e.centerTranslate && r.group.position.set(...e.centerTranslate), void 0 !== e.centerRotation && r.group.rotation.set(e.centerRotation[0] / 180 * Math.PI, e.centerRotation[1] / 180 * Math.PI, e.centerRotation[2] / 180 * Math.PI), e.isApi || t && t({ result: 1, message: "添加成功!", objectItem: this }) })).catch((i => { console.log(i), logger.warn(`名为 ${e.name} 的 3DTiles 加载失败，请检查：倾斜摄影地址是否正确，地址是否有安全证书，数据服务器是否允许跨域。`), t && t({ result: 0, message: ` 名为 ${e.name} 的 3DTiles 加载失败，请检查：倾斜摄影地址是否正确，地址是否有安全证书，数据服务器是否允许跨域。` }) })), this.dispose = (e = !1) => { let t = _context.instance._tilesRenderers.get(this.urlHash); t && (t.lruCache.maxSize -= this.cacheSizeMax, t.lruCache.minSize -= this.cacheSizeMin, t.dispose(), util$1.disposeThreeObject(r.group), r.group.parent.remove(r.group), _context.instance._tilesRenderers.delete(this.urlHash)), 0 !== _context.instance._tilesRenderers.size || e || (_context.instance._tilesNeedRerender = !1, TilesRenderer.customTransformOrigin && (TilesRenderer.customTransformOrigin = void 0)) }, this.getSettings = () => ({ id: this.id, name: this.name, modelPath: "", modelType: "", articulations: [], articulationAnimations: [], children: [], materials: [], transform: this.transform, type: this.getType(), isVisible: this._getVisible(), isLock: this._getLock(), index: this.index, parent: "objectTree", url: this.url, offset: this.offset, rotation: this.rotation, errorTarget: this.errorTarget, errorThreshold: this.errorThreshold, cacheSizeMax: this.cacheSizeMax, cacheSizeMin: this.cacheSizeMin, workers: this.workers, tiles: { format: this.format, url: this.url, cacheSizeMin: this.cacheSizeMin, cacheSizeMax: this.cacheSizeMax, errorTarget: this.errorTarget }, tilesTransform: { position: this.offset, rotation: this.rotation } }), this.update = async (e, t) => { const i = md5(e.url); let n = r.group.uuid; if (e.url !== this.url && _context.instance._tilesRenderers.has(i)) return logger.warn(`已经存在来自 ${e.url} 的 3DTiles，无法重复添加。`), void (t && t({ result: 0, message: `来自地址 ${e.url} 的 3DTiles 已存在!` })); let a = e.url; -1 != a.indexOf("[[origin]]") && (a = a.replace("[[origin]]", _context.origin)), util$1.fetchJSON(a, "get").then((o => { if (!o) return logger.warn(`名为 ${e.name} 的 3DTiles 加载失败，请检查：倾斜摄影地址是否正确，地址是否有安全证书，数据服务器是否允许跨域。`), void (t && t({ result: 0, message: `名为 ${e.name} 的 3DTiles 加载失败，请检查：倾斜摄影地址是否正确，地址是否有安全证书，数据服务器是否允许跨域。` })); this.dispose(!0), e = JSON.parse(JSON.stringify(e)); const s = [{ name: "errorTarget", defaultValue: 6 }, { name: "errorThreshold", defaultValue: 1 / 0 }, { name: "cacheSizeMax", defaultValue: 800 }, { name: "cacheSizeMin", defaultValue: 600 }, { name: "workers", defaultValue: 6 }]; for (let t of s) e[t.name] = Number(e[t.name]), isNaN(e[t.name]) && (e[t.name] = t.defaultValue); this.layerId = void 0 === e.id ? "" : e.id, this.urlHash = i, this.url = e.url || this.url, this.offset = e.offset || this.offset, this.rotation = e.rotation || this.rotation, this.errorTarget = e.errorTarget || this.errorTarget, this.errorThreshold = e.errorThreshold || this.errorThreshold, this.cacheSizeMax = e.cacheSizeMax || this.cacheSizeMax, this.cacheSizeMin = e.cacheSizeMin || this.cacheSizeMin, this.format = "", this.lod = "", this.workers = e.workers || this.workers, this.transform = e.transform || this.transform, this.name = e.name || this.name, this.isVisible = void 0 === e.isVisible || e.isVisible, r = new TilesRenderer(a, e.offset, e.rotation), r.manager.addHandler(/\.gltf$/, _context.loaders.gltfLoader), r.preprocessURL = e => { let t; return logger.debug(`倾斜摄影url-----${e}`), t = "string" == typeof e ? e.replace(/\+/g, "%2B") : e, logger.debug(`倾斜摄影newUrl-----${t}`), t }, r.group.uuid = n, r.urlHash = i, r.group.visible = this.isVisible, r.group.layerId = this.layerId, r.onLoadTileSet = () => { _context.instance._tilesNeedRerender = !0 }, r.onLoadModel = () => { _context.instance._tilesNeedRerender = !0 }, r.fetchOptions.mode = "cors", r.setCamera(_context.camera), r.setResolutionFromRenderer(_context.camera, _context.renderer), r.errorTarget = e.errorTarget, r.errorThreshold = e.errorThreshold, 0 === _context.instance._tilesRenderers.size ? (r.lruCache.maxSize = e.cacheSizeMax, r.lruCache.minSize = e.cacheSizeMin, r.lruCache.unloadPercent = .1, r.downloadQueue.maxJobs = e.workers, r.parseQueue.maxJobs = r.downloadQueue.maxJobs) : (r.lruCache = _context.instance._tilesRenderers.get(Array.from(_context.instance._tilesRenderers.keys())[0]).lruCache, r.downloadQueue = _context.instance._tilesRenderers.get(Array.from(_context.instance._tilesRenderers.keys())[0]).downloadQueue, r.parseQueue = _context.instance._tilesRenderers.get(Array.from(_context.instance._tilesRenderers.keys())[0]).parseQueue, r.lruCache.maxSize += e.cacheSizeMax, r.lruCache.minSize += e.cacheSizeMin, r.downloadQueue.maxJobs += e.workers, r.downloadQueue.maxJobs = Math.min(r.downloadQueue.maxJobs, 64), r.parseQueue.maxJobs = r.downloadQueue.maxJobs), _context.instance._tilesRenderers.set(i, r), _context.instance._tilesNeedRerender = !0, r.group.name = e.name, _context._tilesGroup.add(r.group), this.id = r.group.uuid, t && t({ result: 1, message: "修改成功!" }) })).catch((() => { logger.warn(`名为 ${e.name} 的 3DTiles 加载失败，请检查：倾斜摄影地址是否正确，地址是否有安全证书，数据服务器是否允许跨域。`), t && t({ result: 0, message: `名为 ${e.name} 的 3DTiles 加载失败，请检查：倾斜摄影地址是否正确，地址是否有安全证书，数据服务器是否允许跨域。` }) })) }, this.rename = e => { this.name = e, this.getGroup().name = e } } } const SUGGEST = [{ img: "suggest-one", text: "进入“Windows设置”，选择“系统”项" }, { img: "suggest-two", text: "在“显示”里面找到“图形设置”进行性能首选项设置" }, { img: "suggest-three", text: "点击“浏览”" }, { img: "suggest-four", text: "选择谷歌浏览器的应用程序即安装位置，并添加" }, { img: "suggest-five", text: "添加完成后，点击“选项”" }, { img: "suggest-six", text: "在图形规格中选择“高性能”，并保存。" }]; let numList = []; class PerformanceSuggest { static onUpgradeSuggest() { let e = document.getElementsByTagName("body")[0]; this.body = e; let t = document.createElement("div"); this.SuggestTip = t, t.setAttribute("id", "SuggestTip"), t.className = "SuggestTip", t.innerHTML = '\n          <span class="suggestTip-text">性能优化建议</span>\n        '; let i = ""; for (var r = 0; r <= 10; r++)i = `${i}${10 * r}% {\n        background:linear-gradient(90deg, transparent,rgba(255,0,0,${.5 + .05 * r}),transparent);\n      }`; let n = document.createElement("style"); n.innerText = `@keyframes suggest {\n      ${i}\n    }\n    .SuggestTip {\n      animation: suggest 1s linear infinite alternate;\n    }`, t.appendChild(n); let a = document.createElement("div"); a.innerText = "×", a.className = "SuggestTipCancel", a.style = "border-radius:1px;\n                                  width: 15px;\n                                  height: 15px;\n                                  border:1px solid #FFB973;\n                                  background: #822403;\n                                  color: #FEB772;\n                                  display:flex;\n                                  justify-content: center;\n                                  align-items:center;\n                                  margin-left:8px;\n                                  font-size: 20px;\n                                  cursor: pointer;\n                                  box-sizing:border-box;\n                                  padding: 0 1px 1px 0;\n                                  font-weight: 900;", t.appendChild(a), a.addEventListener("click", this.offUpgradeSuggest); let o = document.createElement("style"); o.innerText = ".SuggestTipCancel:hover { opacity: .7 }", t.appendChild(o), t.style = "background:linear-gradient(90deg, transparent,red,transparent);\n                            font-size: 15px;\n                            color: #FFE599;\n                            display:flex;\n                            justify-content: center;\n                            align-items:center;\n                            position:absolute;\n                            top: 55px;\n                            left: 50%;\n                            transform:translateX(-50%);\n                            width: 267px;\n                            height: 28px;\n                            cursor:pointer;\n                            z-index: 999;\n                            ", _context.instance.container.appendChild(t), t.addEventListener("click", this.onUpgradeSuggestPanel) } static offUpgradeSuggest(e) { let t = PerformanceSuggest; e && e.stopPropagation(), t.SuggestTip && _context.instance.container && _context.instance.container.removeChild(t.SuggestTip), t.SuggestTip = null, e && t.detectFPSTimer && (clearInterval(t.detectFPSTimer), t.detectFPSTimer = null, t.offState = !0) } static getExtension() { let e = document.createElement("canvas").getContext("experimental-webgl"), t = e.getExtension("WEBGL_debug_renderer_info"); return { renderer: e.getParameter(t.UNMASKED_RENDERER_WEBGL), vendor: e.getParameter(t.UNMASKED_VENDOR_WEBGL) } } static onUpgradeSuggestPanel(e) { let t = PerformanceSuggest; if (e && e.stopPropagation(), t.upgradeSuggestPanel) return; let i = document.getElementsByTagName("body")[0]; t.body = i; let r = document.createElement("div"); r.style = "width: 100%;\n                                 height: 100%;\n                                 position:absolute;\n                                 top:0;\n                                 left:0;\n                                 z-index: 9999999;", r.tabIndex = 0, i.addEventListener("keydown", t.keyDownEvent), i.appendChild(r), t.upgradeSuggestPanel = r; let n = document.createElement("div"); n.style = "width: 706px;\n                      height: 566px;\n                      position: absolute;\n                      top: 50%;\n                      left: 50%;\n                      transform:translate(-50%,-50%);\n                      background: #18181b;\n                      border: 1px solid #606374;\n                      display:flex;\n                      flex-direction:column;\n                      ", r.appendChild(n), this.resizeResetPanelStyle = () => { let e = window.document.documentElement.clientWidth, t = window.document.documentElement.clientHeight; if (e < 706 || t < 568) { let i = t / 568, r = e / 706, a = Math.min(r, i); n.style.transform = `scale(${a})translate(-${50 / a}%,-${50 / a}%)` } else n.style.transform = "translate(-50%,-50%)" }, this.resizeResetPanelStyle(), window.addEventListener("resize", this.resizeResetPanelStyle); let a = document.createElement("div"); a.style = "width: 100%;\n                            height: 32px;\n                            background: #333437;\n                            margin-bottom: 1px;\n                            display:flex;\n                            align-items:center;\n                            position:relative", n.appendChild(a); let o = document.createElement("div"); o.innerText = "!", o.style = "box-sizing:border-box;\n                         width: 18px;\n                         height:18px;\n                         border-radius:50%;\n                         border: 2px solid #FF5C26;\n                         margin-left:10px;\n                         display:flex;\n                         align-items:center;\n                         justify-content: center;\n                         color: #FF5C26;\n                         font-weight: 900;\n                         font-size: 12px;", a.appendChild(o); let s = document.createElement("span"); s.innerText = "性能优化建议", s.style = "font-size:14px;\n                       color: #CCCCCC;\n                       margin-left:10px;", a.appendChild(s); let l = document.createElement("span"); l.innerText = "×", l.className = "suggest-cancelIcon", l.style = "position:absolute;\n                        right: 10px;\n                        font-size: 26px;\n                        color:#D7DBE8;\n                        cursor: pointer;\n                        top: -2px;", l.addEventListener("click", t.offUpgradeSuggestPanel), a.appendChild(l); let c = document.createElement("style"); c.innerText = ".suggest-cancelIcon:hover { opacity: .7 }", a.appendChild(c); let h = document.createElement("div"); h.style = "flex:1;\n                       border-top: 1px solid #424653;\n                       background:#2b2c2f;\n                       display:flex;\n                       flex-direction:column;", n.appendChild(h); let u = document.createElement("div"); u.className = "performanceSuggest-body-top-text-box", u.innerHTML = '<p class="performanceSuggest-body-top-text-box-title">您当前场景的平均帧数低于推荐帧数，为获得更好的浏览体验，建议您更换性能较好的PC或者有独立显卡的笔记本电脑：</p>\n                                <p class="performanceSuggest-body-top-text-box-levelOne">如果您使用的是PC，请使用型号为NVIDIA GTX 1660同级别或以上级别的独立显卡。</p>\n                                <p class="performanceSuggest-body-top-text-box-levelOne">如果您使用的是有独立显卡的笔记本电脑，请进行如下设置：</p>', h.appendChild(u); let d = document.createElement("style"); d.innerText = ".performanceSuggest-body-top-text-box {\n                                       padding:20px 35px;\n                                       color:#CCCCCC; \n                                       font-size: 14px;\n                                      }\n                                      .performanceSuggest-body-top-text-box > p {\n                                        line-height: 28px;\n                                      }\n                                     .performanceSuggest-body-top-text-box\n                                      > .performanceSuggest-body-top-text-box-levelOne {\n                                        font-weight: 500;\n                                        padding-left: 18px;\n                                        position: relative;\n                                      }\n                                      .performanceSuggest-body-top-text-box\n                                       > .performanceSuggest-body-top-text-box-levelOne::before {\n                                         content: '';\n                                         display: block;\n                                         width: 5px;\n                                         height: 5px;\n                                         background: #FF5C26;\n                                         border-radius: 50%;\n                                         position: absolute;\n                                         left: 3px;\n                                         top: 50%;\n                                         transform: translateY(-50%);\n                                      }", u.appendChild(d); let p = 0, f = document.createElement("div"); f.className = "suggest-bodyBottomBox", f.style = "display:flex;\n                           justify-content:space-between;\n                           align-items:center;\n                           padding:0 35px 20px 35px;\n                           flex:1;\n                           user-select: none;\n                           position:relative;"; let m = document.createElement("span"); m.innerText = "<", m.style.opacity = "0.2"; let g = document.createElement("div"), y = document.createElement("img"), v = `texture/ui/${SUGGEST[p].img}.png`; y.src = util$1.url(_context.instance.resourceBasePath, v); let _ = document.createElement("p"); _.innerHTML = `${SUGGEST[p].text}${SUGGEST[p].linkText ? `<a target="_blank" href="${SUGGEST[p].linkUrl}" >${SUGGEST[p].linkText}</a>` : ""}`, _.style = "font-size: 16px;\n                            color:#ccc;\n                            text-align:center;", g.appendChild(y), g.appendChild(_); let b = document.createElement("span"); b.innerText = ">"; let x = document.createElement("span"); x.innerText = `${p + 1}/${SUGGEST.length}`, x.style = "position:absolute;\n                          right: 32px;\n                          bottom: 45px;\n                          color: #FF5B26;\n                          font-size: 24px;\n                          transform: scale(1);"; let w = document.createElement("style"); w.innerText = ".suggest-bodyBottomBox > span { font-size: 40px;color:#EEEEEE;transform: scaleY(2.1);cursor:pointer }", m.addEventListener("click", (e => { if (e && e.stopPropagation(), p <= 0) return; p--, m.style.opacity = p <= 0 ? "0.2" : "1", p >= SUGGEST.length - 1 ? b.style.opacity = "0.2" : b.style.opacity = "1", x.innerText = `${p + 1}/${SUGGEST.length}`; let t = `texture/ui/${SUGGEST[p].img}.png`; y.src = util$1.url(_context.instance.resourceBasePath, t), _.innerHTML = `${SUGGEST[p].text}${SUGGEST[p].linkText ? `<a target="_blank" href="${SUGGEST[p].linkUrl}" >${SUGGEST[p].linkText}</a>` : ""}` })), b.addEventListener("click", (e => { if (e && e.stopPropagation(), p >= SUGGEST.length - 1) return; p++, m.style.opacity = p <= 0 ? "0.2" : "1", p >= SUGGEST.length - 1 ? b.style.opacity = "0.2" : b.style.opacity = "1", x.innerText = `${p + 1}/${SUGGEST.length}`; let t = `texture/ui/${SUGGEST[p].img}.png`; y.src = util$1.url(_context.instance.resourceBasePath, t), _.innerHTML = `${SUGGEST[p].text}${SUGGEST[p].linkText ? `<a style="color:#27b1df;" target="_blank" href="${SUGGEST[p].linkUrl}" >${SUGGEST[p].linkText}</a>` : ""}` })), f.appendChild(m), f.appendChild(g), f.appendChild(b), f.appendChild(w), f.appendChild(x), h.appendChild(f); let S = document.createElement("div"); S.style = "width: 100%;\n                         height: 39px;\n                         margin-top:1px;\n                         background: #313235;\n                         position:relative;\n                         display:flex;\n                         justify-content: flex-end;\n                         align-items:center", n.appendChild(S); let M = document.createElement("span"); M.innerText = "确定", M.className = "suggest-button-ok", M.style = "width: 48px;\n                      height: 24px;\n                      background:#1B66F0;\n                      color: #FFFFFF;\n                      font-size: 12px;\n                      display:flex;\n                      justify-content: center;\n                      align-items:center;\n                      margin-right: 10px;\n                      cursor: pointer;\n                      border-radius:2px;", M.addEventListener("click", t.offUpgradeSuggestPanel), S.appendChild(M); let T = document.createElement("style"); T.innerText = ".suggest-button-ok:hover { opacity: .7 }", S.appendChild(T) } static offUpgradeSuggestPanel(e) { let t = PerformanceSuggest; e && e.stopPropagation(), window.removeEventListener("resize", this.resizeResetPanelStyle), t.body.removeChild(t.upgradeSuggestPanel), t.upgradeSuggestPanel = null } static checkSuggestOn() { this.detectFPSTimeout && (clearInterval(this.detectFPSTimeout), this.detectFPSTimeout = null), this.detectFPSTimer && (clearInterval(this.detectFPSTimer), this.detectFPSTimer = null), this.detectFPSTimeout = setTimeout((() => { this.detectFPSTimer = setInterval((() => { if (!_context.instance.getStatistics()) return; if (0 === _context.instance.getStatistics().fps) return; if (numList.push(_context.instance.getStatistics().fps), numList.length > 5 && (numList.reverse(), numList.length = 5, numList.reverse()), numList.length < 5) return; let e = 0; numList.forEach((t => { e += t })); let t = e / numList.length; t < 15 && !this.SuggestTip && (this.onUpgradeSuggest(), numList.length = 0), t >= 15 && this.SuggestTip && (this.offUpgradeSuggest(), numList.length = 0) }), 1e3) }), 1e4) } static keyDownEvent(e) { let t = PerformanceSuggest; 13 == e.keyCode && (t.offUpgradeSuggestPanel(), t.body.removeEventListener("keydown", PerformanceSuggest.keyDownEvent)) } static dispose() { this.detectFPSTimeout && (clearInterval(this.detectFPSTimeout), this.detectFPSTimeout = null), this.detectFPSTimer && (clearInterval(this.detectFPSTimer), this.detectFPSTimer = null), this.offUpgradeSuggest({ e: 1, stopPropagation: () => { } }) } } class ObjectTree extends ObjectTreeItem { constructor(e) { super("ObjectTree"), this.children = [], this._nodeSelection = new NodeSelection(e), this.parentNode = null, this.getGroup = () => _context.scene.models, this.addItem = (e, t) => { this.children.push(e), t && t(1) }, this.addFolder = (e = "untitled", t, i, r, n) => { this.children.find((t => t.isFolder() && t.name === e)) ? logger.warn(`当前位置已经存在名称为“${e}”的文件夹。`) : null != t.children ? this.addItem(this.recursionAddFolderOrModel(t, r, n), i) : this.addItem(new FolderItem(e, {}, "number" == typeof t.index ? t.index : this.children.length), i) }, this.recursionAddFolderOrModel = (e, t, i) => { if ("FolderItem" === e.type) { let r = new FolderItem(e.name, {}, "number" == typeof e.index ? e.index : this.children.length); if (e.children.length > 0) for (let n of e.children) r.children.push(this.recursionAddFolderOrModel(n, t, i)); return r } switch (e.type) { case "ModelItem": return "number" != typeof e.index && (e.index = this.children.length), new ModelItem(e, t, i) } }, this.addModel = (e, t, i, r) => { !this.children.find((t => t.name === e.name)) || e.loadModel ? ("number" != typeof e.index && (e.index = this.children.length), e.parent = "objectTree", e.parentUUID = "objectTreeUUID", new ModelItem(e, ((i, r, n) => { _context.hasUpgradeSuggest && PerformanceSuggest.checkSuggestOn(), i ? (this.addItem(n), t && t(i, r, n)) : t && t(i, r), "fbx" == e.modelType && this._replaceModel(window._needReplace[e.name]), this.applyObjectSetting(e) }), i, r)) : logger.warn(`当前位置已经存在名称为“${e.name}”的模型。`) }, this.addIconAsset = (e, t, i) => { delete e.textParam.canvas; var r = util$1.deepClone(e); r.nameRepetition || (r.name = util$1.getCopyName(r.name, null, this)), "number" != typeof r.index && (r.index = this.children.length), r.parent = "objectTree", r.isVisible = !0, new IconItem(r, t, i) }, this.loadModel = (e, t, i) => { if (!this.children.find((t => t.name === e.name))) return logger.debug("TRACE: ModelItem.addModel() - Entering.", e), e = e || {}, logger.debug("TRACE: ModelItem.addModel() - Leaving and return a Promise."), new Promise(((r, n) => { _context.loaders.gltfLoader || (t && t(0, "No loader initiated."), n(new Error("No loader initiated."))), e.name || (e.name = util$1.guid()), _context.cacheStore.load({ path: e.modelPath, secretKey: e.secretKey, type: "AVWS", onLoad: e => { if ("20220602-NEW-AVWS" === e.children[0].userData.dhExtension.VERSION) { var i = util$1.cloneDeep(e.children[0].userData.dhExtension); _context.instance.applySettings(i), t && t(1, i), r(), setTimeout((() => { _context.instance.focus() }), 500), _context.paintControls && _context.paintControls.updateWorld() } else { let n, a = e.children[0].children; n = e.children[0].userData.dhExtension.objectTree ? e.children[0].userData.dhExtension.objectTree.children : e.children[0].userData.dhExtension.models; for (const e of a) for (const t of n) { if (e.userData.name != t.name) continue; let i = util$1.cloneDeep(t); if (i.loadModel = e, "ModelItem" == t.type && this.addItem(new ModelItem(i)), "IconAsset" == t.type && new IconItem(i, null), "GroupItem" == t.type) { let e = new GroupItem(i); i.children.forEach((t => { switch (t.type) { case "IconAsset": new IconItem(t, e); break; case "ModelAsset": logger.debug(i, t); let r = { name: t.name, gltf: { scene: i.loadModel }, transform: t.transform, points: t.points, matrix: t.matrix }, n = e.children.find((e => e.name === r.name)); n ? n.addInstanceIsMatrix(r.matrix) : new InstancedObject(r, e) } })) } else if ("PaintItem" == t.type) { let e = new PaintItem(i); i.children.map((t => { switch (t.type) { case "IconAsset": new IconItem(t, e); break; case "ModelAsset": case "ModelItem": let r = { name: t.name, type: t.type, modelPath: t.modelPath, modelType: t.modelType, loadModel: i.loadModel.children.find((e => e.name == t.name)), transform: t.transform, isVisible: t.isVisible }; e.childrenAdd(new ModelItem(r)), e.getGroup().add(r.loadModel) } })); let t = i.iconInstanced; for (let i = 0; i < t.length; i++)new InstancedGroup(t[i].assetObj, e, (e => { })); let r = i.modelInstanced; for (let t = 0; t < r.length; t++) { let n = i.loadModel.children.find((e => "Mesh" === e.type && e.name == `${r[t].name}#0`)); n && (n.name = r[t].name, r[t].gltf = { scene: n }), new InstancedObject(r[t], e) } } "BuildingItem" == t.type && _context.instance.defaultObjectTree.addBuilding(i) } i = util$1.cloneDeep(e.children[0].userData.dhExtension); new LoadModelItem(e.children[0], n), t && t(1, i), r(), setTimeout((() => { _context.instance.focus() }), 500), _context.paintControls && _context.paintControls.updateWorld() } }, onProgress: i, onError: e => { t ? t(0, e) : logger.debug(e), n(e) } }) })); logger.warn(`当前位置已经存在名称为“${e.name}”的模型。`) }, this.addBuilding = (e, t, i, r = _context.scene.models) => { this.children.find((t => t.name === e.name)) ? logger.warn(`当前位置已经存在名称为“${e.name}”的模型。`) : ("number" != typeof e.index && (e.index = this.children.length), e.parent = "objectTree", e.parentUUID = "objectTreeUUID", e.isVisible = null == e.isVisible || e.isVisible, e.floor = null != e.floor ? e.floor : null, this.addItem(new BuildingItem(e, r, t, i))) }, this.findItem = e => { if (e) return e = e.split("/"), traverse_1(this.children).get(e) }, this.findItemByName = e => { if ("string" == typeof e && "" !== e) for (let t = 0; t < this.children.length; t++) { let i = this.objectTreeRecursion(this.children[t], e); if (i) return i } }, this.objectTreeRecursion = (e, t) => { if (t && e) if ("ModelItem" === e.type) { if (e.name === t) return e } else { if (!(e.children instanceof Array)) return; for (let i = 0; i < e.children.length; i++) { let r = this.objectTreeRecursion(e.children[i], t); if (r) return r } } }, this.findItemByObject3D = e => { if (!(e instanceof Object3D)) return; let t = e; for (; t.parent && t.parent.name !== _context.scene.models.name;)t = t.parent; return this.getItemByName(t.name) }, this.getParentIds = e => { if (!(e instanceof Object3D)) return; let t = [], i = e; for (; i.parent.name !== _context.scene.models.name;)i = i.parent, t.push(i.uuid); return t }, this.getItemByIndex = e => { if ("number" == typeof e && !(e > this.children.length)) return this.children[e] }, this.findNodeByName = e => { if ("string" == typeof e && "" !== e) for (let t = 0; t < this.children.length; t++) { let i = this.nodeRecursion(this.children[t], e); if (i) return i } }, this.nodeRecursion = (e, t) => { if (t && e) { if (e.name === t) return e; if (e.children.length > 0) for (let i = 0; i < e.children.length; i++) { if (e.children[i].name === t) return e.children[i]; if (e.children[i].children && e.children[i].children.length > 0) { let r = this.nodeRecursion(e.children[i], t); if (r) return r } } } }, this.getAsset = (e, t, i) => { if ("string" == typeof e && "" !== e) if (i) { let r = this.children.find((e => e.name == i)), n = this.iconAssetRecursion(r, e, t); if (n) return n } else for (let i = 0; i < this.children.length; i++) { if ("PaintItem" === this.children[i].type) continue; let r = this.iconAssetRecursion(this.children[i], e, t); if (r) return r } }, this.iconAssetRecursion = (e, t, i) => { if (e) if (e.type === i) { if (e.name === t) return e } else if (e.children && e.children.length > 0) for (let r = 0; r < e.children.length; r++)if (e.children[r].type === i) { if (e.children[r].name === t) return e.children[r] } else if (e.children[r].children && e.children[r].children.length > 0) { let n = this.iconAssetRecursion(e.children[r], t, i); if (n) return n } }, this.rankUp = (e, t, i = this.children) => { for (let r = 0; r < i.length; r++)if (i[r].name === e) { for (let r = 0; r < i.length; r++)if (i[r].name === e) { if (0 === i[r].index) return void (t && t(0, "已是第一名无法上移")); i[r].index -= 1; for (let e = 0; e < i.length; e++)i[e].index === i[r].index && i[e].name != i[r].name && (i[e].index += 1); return void (t && t(1, "成功")) } } else "FolderItem" !== i[r].type && "BuildingItem" !== i.type && "BuildingFloorItem" !== i.type || i[r].children.length > 0 && this.rankUp(e, t, i[r].children) }, this.rankDown = (e, t, i = this.children) => { for (let r = 0; r < i.length; r++)if (i[r].name === e) { for (let r = 0; r < i.length; r++)if (i[r].name === e) { if (i[r].index === i.length - 1) return void (t && t(0, "已是最后一名无法下移")); i[r].index += 1; for (let e = 0; e < i.length; e++)i[e].index === i[r].index && i[e].name != i[r].name && (i[e].index -= 1); return void (t && t(1, "成功")) } } else "FolderItem" !== i[r].type && "BuildingItem" !== i.type && "BuildingFloorItem" !== i.type || i[r].children.length > 0 && this.rankDown(e, t, i[r].children) }, this.traverse = (e, t) => { if (e && "function" == typeof e && this.children && this.children instanceof Array) { t || (t = this.children); for (let i of t) e(i), i.children instanceof Array && this.traverse(e, i.children) } }, this.findMaterialRecursion = (e, t) => { if (e.name === t && "ModelItem" == e.type) return e; if (e.children.length > 0) for (let i = 0; i < e.children.length; i++) { if (e.children[i].name === t && "ModelItem" == e.children[i].type) return e.children[i]; if (e.children[i].children && e.children[i].children.length > 0) { let r = this.findMaterialRecursion(e.children[i], t); if (r) return r } } }, this.findModelFromBuilding = (e = this.children, t, i) => { if (t) for (let n = 0; n < e.length; n++) { let a = null; if ("modelUUID" === i ? a = e[n].getGroup ? e[n].getGroup().uuid : e[n].id : "modelName" === i && (a = e[n].name), t === a) { if ("objectTree" === e[n].parent) return e[n]; if (r = this.findModelFromBuilding(this.children, e[n].parentUUID, "modelUUID")) return r } else if (e[n].children && e[n].children.length > 0) { var r; if (r = this.findModelFromBuilding(e[n].children, t, i)) return r } } }, this.hideItemByName = e => { let t = this.getItemByName(e); t && ("ModelItem" === t.type || "IconAsset" === t.type ? this.modelIsHide(t, !1) : "FolderItem" === t.type && this.folderItemIsHideRecursion(t, !1)) }, this.showItemByName = e => { let t = this.getItemByName(e); t && ("ModelItem" === t.type || "IconAsset" === t.type ? this.modelIsHide(t, !0) : "FolderItem" === t.type && this.folderItemIsHideRecursion(t, !0)) }, this.folderItemIsHideRecursion = (e, t) => { if (e._setVisible(t), !(e.children <= 0)) for (let i = 0; i < e.children.length; i++)"ModelItem" === e.children[i].type ? this.modelIsHide(e.children[i], t) : "FolderItem" !== e.children[i].type && "BuildingItem" !== children.type || this.folderItemIsHideRecursion(e.children[i], t) }, this.modelIsHide = (e, t) => { e._setVisible(t), e.getGroup().visible = t, _context.scene.children.map((i => { "__sysObjectsWater" === i.name && i.children.map((i => { i.userData.modelName === e.name && (i.visible = t) })) })) }, this.renameItem = (e, t, i) => { e && t && ("ModelItem" === this.getItemByName(t).type && (_context.scene.models.getObjectByName(t).name = e), this.getItemByName(t).rename(e, i)) }, this.nodeInObject = e => { if ("string" == typeof e && "" !== e) for (let t = 0; t < this.children.length; t++)return this.nodeInObjectRecursion(this.children[t], e) }, this.nodeInObjectRecursion = (e, t) => { if (t && e) if ("ModelItem" === e.type) { if (e.children.length > 0) for (let i = 0; i < e.children.length; i++)if (this.modelItemRecursion(e.children[i], t)) return e } else if ("FolderItem" === e.type) for (let i = 0; i < e.children.length; i++)return this.nodeInObjectRecursion(e.children[i], t) }, this.modelItemRecursion = (e, t) => { if (e.name === t) return !0; if (e.children.length > 0) for (let i = 0; i < e.children.length; i++)return this.modelItemRecursion(e.children[i], t) }, this.objectTreeRemove = (e, t) => { if (t && e) for (let i = e.length - 1; i >= 0; i--)e[i].name === t ? e.splice(i, 1) : this.objectTreeRemove(e[i], t) }, this.removeAsset = (e, t) => { e && this.removeAssetRecursion(this.children, e, t) }, this.removeAssetRecursion = (e, t, i) => { for (let r = 0; r < e.length; r++)if ("IconAsset" === e[r].type) { if (e[r].name === t) return _context.scene.models.remove(_context.scene.models.getObjectByName(e[r].name)), e.splice(r, 1), void (i && i(1, "删除成功")) } else "BuildingItem" === e[r].type && e[r].children.length > 0 && this.removeAssetRecursion(e[r].children, t, i) }, this.removeItem = (e, t) => { e && this.removeItemRecursion(this.children, e, t) }, this.removeItemRecursion = (e, t, i) => { for (let r = 0; r < e.length; r++)if ("ModelItem" === e[r].type) { if (e[r].name === t) return _context.scene.models.remove(_context.scene.models.getObjectByName(e[r].name)), e.splice(r, 1), void (i && i(1, "删除成功")) } else if ("FolderItem" === e[r].type || "BuildingItem" === e[r].type) { if (e[r].name === t) return _context.scene.models.remove(_context.scene.models.getObjectByName(e[r].name)), e.splice(r, 1), void (i && i(1, "删除成功")); e[r].children.length > 0 && this.removeItemRecursion(e[r].children, t, i) } }, this.getItemByName = e => { if ("string" == typeof e && "" !== e) for (let t = 0; t < this.children.length; t++) { let i = this.itemRecursion(this.children[t], e); if (i) return i } }, this.itemRecursion = (e, t) => { if (t && e) { if (e.name === t) return e; if (("FolderItem" === e.type || "BuildingItem" === e.type || "BuildingFloorItem" === e.type) && e.children.length > 0) for (let i = 0; i < e.children.length; i++) { let r = this.itemRecursion(e.children[i], t); if (r) return r } } }, this.getItemByUUID = e => { if ("string" == typeof e && "" !== e) for (let t = 0; t < this.children.length; t++) { let i = this.getItemByUUIDRecursion(this.children[t], e); if (i) return i } }, this.getItemByUUIDRecursion = (e, t) => { if (t && e) if (e.getGroup) { if (e.getGroup() && e.getGroup().uuid === t) return e; if (e.children && e.children.length > 0) for (let i = 0; i < e.children.length; i++) { let r = this.getItemByUUIDRecursion(e.children[i], t); if (r) return r } } else { if (e.id === t) return e; if (e.children && e.children.length > 0) for (let i = 0; i < e.children.length; i++) { let r = this.getItemByUUIDRecursion(e.children[i], t); if (r) return r } } }, this.getSettings = () => JSON.parse(JSON.stringify({ children: util$1.getSettingsRecursively(this.children) })), this.applySettings = (e, t, i, r = !1) => { e && e.children && e.children.map ? e.children.map((e => { this.applyObjectSetting(e, r) })) : logger.error("无效的模型设置。") }, this.applyObjectSetting = (e, t = !1) => { let i = this, r = i.getItemByName(e.name); if (r) { if (util$1.setNode(e, r, this._nodeSelection, !0), "BuildingItem" === e.type) e.children.forEach((e => { if ("ModelItem" === e.type) { var n = i.findMaterialRecursion(r, e.name); n && n.materialStore && !t && n.materialStore.applySettings(e.materials), n && n.hide && !e.isVisible ? n.hide() : n && n.show && e.isVisible && n.show(), e.particleStores && e.particleStores.length > 0 && !t && n.applyParticleSettings(e.particleStores) } else "BuildingFloorItem" === e.type && e.children.forEach((e => { if ("ModelItem" === e.type) { var n = i.findMaterialRecursion(r, e.name); n && n.materialStore && !t && n.materialStore.applySettings(e.materials), n && n.hide && !e.isVisible ? n.hide() : n && n.show && e.isVisible && n.show(), e.particleStores && e.particleStores.length > 0 && !t && n.applyParticleSettings(e.particleStores) } })) })); else if ("ModelItem" === e.type || "ModelAsset" === e.type) { e.type = "ModelItem", util$1.setArticulation(e, r), i.findMaterialRecursion(r, e.name) && r.materialStore && !t && r.materialStore.applySettings(e.materials), e.particleStores && e.particleStores.length > 0 && !t && r.applyParticleSettings(e.particleStores) } else "PaintItem" === e.type && (e.children.forEach((i => { if ("ModelItem" === i.type) { let n = r.getItemByName(i.name); n && (util$1.setArticulation(i, n), n.materialStore && !t && n.materialStore.applySettings(i.materials, e.name)) } })), e.modelInstanced.forEach((t => { let i = r.getInstanced("ModelAsset", t.name); i && i.materialStore.applySettings(t.materials, e.name, t.name) }))); if (void 0 !== e.isVisible && (e.isVisible ? r.show() : r.hide()), r._setLock(e.isLock), e.animations instanceof Array) for (let t of e.animations) { let r = []; for (let e of t.tracks) { let t; switch (e.type) { case "bool": t = new BooleanKeyframeTrack(e.name, e.times, e.values); break; case "color": t = new ColorKeyframeTrack(e.name, e.times, e.values); break; case "number": t = new NumberKeyframeTrack(e.name, e.times, e.values); break; case "quaternion": t = new QuaternionKeyframeTrack(e.name, e.times, e.values); break; case "string": t = new StringKeyframeTrack(e.name, e.times, e.values); break; case "vector": t = new VectorKeyframeTrack(e.name, e.times, e.values); break; default: t = KeyframeTrack(e.name, e.times, e.values) }r.push(t) } let n = new AnimationClip(t.name, t.duration, r); i._models[e.name].animations.push(n) } void 0 !== e.floor && (r.floor = e.floor), void 0 !== e.isVisible && (e.isVisible ? r.show() : r.hide()) } }, this._replaceModel = e => { e && (e.modelNode.traverse((t => { if (util$1.capableForCastingShadow(t) && (t.castShadow = !0, t.receiveShadow = !0), t.material instanceof Array) for (let i of t.material) { let r = this._replaceMaterial(i); r && (t.material = r, t.material.needsUpdate = !0, e.modelItem.materialStore.add(t.material.name, t.material, t, e.modelNode.name)) } else { let i = this._replaceMaterial(t.material); i && (t.material = i, t.material.needsUpdate = !0, e.modelItem.materialStore.add(t.material.name, t.material, t, e.modelNode.name)) } })), e.modelItem.children = Node._fromThreeObject(e.modelNode).children) }, this._replaceMaterial = e => { if (!e) return; let t = ["name", "alphaMap", "aoMap", "aoMapIntensity", "bumpMap", "bumpScale", "color", "displacementMap", "displacementScale", "displacementBias", "emissive", "emissiveMap", "emissiveIntensity", "envMap", "lightMap", "lightMapIntensity", "map", "normalMap", "normalMapType", "normalScale", "alphaTest", "depthTest", "depthWrite", "opacity", "shadowSide", "side", "transparent", "visible"], i = new MeshStandardMaterial; if (e instanceof MeshPhongMaterial || e instanceof MeshLambertMaterial) { for (let r of t) if (e[r] && (e[r].clone ? i[r] = e[r].clone() : i[r] = e[r], e[r] instanceof Texture$1 || e[r]?.isTexture)) { let t = window._textureMap[e[r].name]; if (!t) continue; let { image: n, mapping: a, wrapS: o, wrapT: s, magFilter: l, minFilter: c, format: h, type: u, anisotropy: d } = t, p = null; p = new CanvasTexture(n, a, o, s, l, c, h, u, d), p.name = t.name, _context.textureStore.add(e[r].name || `${e.name}#${r}`, p), i[r] = p } if (i.emissiveMap && 0 == i.emissive.toJSON() && (i.emissive = new Color$1(1, 1, 1)), !i.envMap && e.specularMap) { let t = window._textureMap[e.specularMap.name]; if (!t) return i; let { image: r, mapping: n, wrapS: a, wrapT: o, magFilter: s, minFilter: l, format: c, type: h, anisotropy: u } = t, d = new CanvasTexture(r, n, a, o, s, l, c, h, u); d.name = t.name, _context.textureStore.add(e.specularMap.name || `${e.name}#envMap`, d), i.envMap = d } let r = e.shininess / 100; return i.roughness = .5 - r < 0 ? 0 : .5 - r, i } } } } class Effect { constructor(e) { this.enabled = !1, this.type = e, this.name = name, this.paused = !1, this.visible = !0, this.tags = [] } createHelper(e, t, i = "#ffff00") { if (this.mesh.getObjectByName("__helper")) this.updateHelper(e, t, i); else { const r = new Box3; r.setFromCenterAndSize(e, t); const n = new Box3Helper(r, new Color$1(i)); n.name = "__helper", n.visible = !1, this.mesh.add(n) } } showHelper() { if (!this.mesh) return; let e = this.mesh.getObjectByName("__helper"); e && (e.visible = !0) } hideHelper() { if (!this.mesh) return; let e = this.mesh.getObjectByName("__helper"); e && (e.visible = !1) } updateHelper(e, t, i) { if (!this.mesh) return; let r = this.mesh.getObjectByName("__helper"); r && (r.box.setFromCenterAndSize(e, t), void 0 !== i && (r.material.color = i)) } } var shaderSource = "\n#ifdef TEXTURE_PRECISION_HIGH\n\n\tuniform mediump sampler2D map;\n\n#else\n\n\tuniform lowp sampler2D map;\n\n#endif\n\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n  vec4 texel = texture2D(map, uv);\n  outputColor = mix(inputColor, texel, texel.a);\n}"; class WatermarkEffect extends Effect$1 { constructor(e = {}) { const t = Object.assign({ blendFunction: BlendFunction.NORMAL, map: null }, e); super("WatermarkEffect", shaderSource, { blendFunction: t.blendFunction, uniforms: new Map([["map", new Uniform(t.map)]]) }) } setMap(e) { this.uniforms.get("map").value = e } } const vertexShader$1 = "\nvarying vec2 vUv;\n\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4(position.xy, 1.0, 1.0);\n}\n", fragmentShader$1 = "\n#ifdef FRAMEBUFFER_PRECISION_HIGH\n\tuniform mediump sampler2D inputBuffer;\n#else\n\tuniform lowp sampler2D inputBuffer;\n#endif\n\nuniform float radius;\nuniform vec2 texelSize;\nuniform vec2 halfTexelSize;\nuniform float kernel;\nuniform float scale;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tfloat d = distance(vec2(0.5, 0.5), vUv) - radius / 2.0;\n\tif (d <= 0.0) {\n\t\tgl_FragColor = texture2D(inputBuffer, vUv);\n\t} else {\n\t\tvec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n\t\tdUv *= (d * 4.0);\n\t\t// Sample top left, top right, bottom left, bottom right texels.\n\t\tvec4 sum = texture2D(inputBuffer, vec2(vUv.x - dUv.x, vUv.y + dUv.y)) \n\t\t\t+ texture2D(inputBuffer, vec2(vUv.x + dUv.x, vUv.y + dUv.y))\n\t\t\t+ texture2D(inputBuffer, vec2(vUv.x + dUv.x, vUv.y - dUv.y))\n\t\t\t+ texture2D(inputBuffer, vec2(vUv.x - dUv.x, vUv.y - dUv.y));\n\t\t// Compute the average.\n\t\tgl_FragColor = sum * 0.25;\n\t\n\t\t#ifdef DITHERING\n\t\n\t\t\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\t\n\t\t#endif\n\t}\n\t\n}\n"; class EdgeBlurMaterial extends ShaderMaterial { constructor(e = new Vector2) { super({ type: "EdgeBlurMaterial", uniforms: { inputBuffer: new Uniform(null), radius: new Uniform(1), texelSize: new Uniform(new Vector2), halfTexelSize: new Uniform(new Vector2), kernel: new Uniform(0), scale: new Uniform(1) }, fragmentShader: fragmentShader$1, vertexShader: vertexShader$1, blending: NoBlending, depthWrite: !1, depthTest: !1 }), this.toneMapped = !1, this.setTexelSize(e.x, e.y), this.kernelSize = KernelSize.LARGE } getKernel() { return kernelPresets[this.kernelSize] } setTexelSize(e, t) { this.uniforms.texelSize.value.set(e, t), this.uniforms.halfTexelSize.value.set(e, t).multiplyScalar(.5) } } const kernelPresets = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])], KernelSize = { VERY_SMALL: 0, SMALL: 1, MEDIUM: 2, LARGE: 3, VERY_LARGE: 4, HUGE: 5 }; class EdgeBlurPass extends Pass { constructor({ radius: e = .8, scale: t = 1, resolutionScale: i = 1, width: r = Resizer.AUTO_SIZE, height: n = Resizer.AUTO_SIZE, kernelSize: a = KernelSize.LARGE } = {}) { super("EdgeBlurPass"), this.renderTargetA = new WebGLRenderTarget(1, 1, { minFilter: LinearFilter, magFilter: LinearFilter, stencilBuffer: !1, depthBuffer: !1 }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B", this.resolution = new Resizer(this, r, n, i), this.edgeBlurMaterial = new EdgeBlurMaterial, this.edgeBlurMaterial.uniforms.radius.value = e, this.edgeBlurMaterial.uniforms.scale.value = t, this.ditheredEdgeBlurMaterial = new EdgeBlurMaterial, this.ditheredEdgeBlurMaterial.dithering = !0, this.dithering = !1, this.kernelSize = a } get width() { return this.resolution.width } set width(e) { this.resolution.width = e } get height() { return this.resolution.height } set height(e) { this.resolution.height = e } get scale() { return this.edgeBlurMaterial.uniforms.scale.value } set scale(e) { this.edgeBlurMaterial.uniforms.scale.value = e, this.ditheredEdgeBlurMaterial.uniforms.scale.value = e } get kernelSize() { return this.edgeBlurMaterial.kernelSize } set kernelSize(e) { this.edgeBlurMaterial.kernelSize = e, this.ditheredEdgeBlurMaterial.kernelSize = e } get radius() { return this.edgeBlurMaterial.uniforms.radius.value } set radius(e) { this.edgeBlurMaterial.uniforms.radius.value = e } render(e, t, i, r, n) { const a = this.scene, o = this.camera, s = this.renderTargetA, l = this.renderTargetB; let c = this.edgeBlurMaterial, h = c.uniforms; const u = c.getKernel(); let d, p, f, m = t; for (this.setFullscreenMaterial(c), p = 0, f = u.length - 1; p < f; ++p)d = 0 == (1 & p) ? s : l, h.kernel.value = u[p], h.inputBuffer.value = m.texture, e.setRenderTarget(d), e.render(a, o), m = d; this.dithering && (c = this.ditheredEdgeBlurMaterial, h = c.uniforms, this.setFullscreenMaterial(c)), h.kernel.value = u[p], h.inputBuffer.value = m.texture, e.setRenderTarget(this.renderToScreen ? null : i), e.render(a, o) } setSize(e, t) { const i = this.resolution; i.base.set(e, t); const r = i.width, n = i.height; this.renderTargetA.setSize(r, n), this.renderTargetB.setSize(r, n), this.edgeBlurMaterial.setTexelSize(1 / r, 1 / n), this.ditheredEdgeBlurMaterial.setTexelSize(1 / r, 1 / n) } initialize(e, t, i) { if (t || i !== UnsignedByteType || (this.renderTargetA.texture.format = RGBFormat, this.renderTargetB.texture.format = RGBFormat), void 0 !== i && (this.renderTargetA.texture.type = i, this.renderTargetB.texture.type = i, i !== UnsignedByteType)) { const e = this.edgeBlurMaterial, t = this.ditheredEdgeBlurMaterial; e.defines.FRAMEBUFFER_PRECISION_HIGH = "1", t.defines.FRAMEBUFFER_PRECISION_HIGH = "1" } } static get AUTO_SIZE() { return Resizer.AUTO_SIZE } } var FireflyShader = { defines: { DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, uniforms: { time: { value: 0 }, speed: { value: 1 }, color: { value: new Color$1(1, 1, 1) }, brightness: { value: 1 }, size: { value: 1 } }, vertexShader: ["precision highp float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float time;", "uniform float speed;", "uniform float size;", "attribute vec3 position;", "attribute vec2 uv;", "attribute vec3 translate;", "varying vec2 vUv;", "varying float vScale;", "void main() {", "vec4 pos=vec4(translate, 1.0 );", "pos.x=pos.x+sin(pos.x+time*speed)*50.0;", "pos.y=pos.y+sin(pos.y+time*speed)*50.0;", "pos.z=pos.z+sin(pos.z+time*speed)*50.0;", "vec4 mvPosition = modelViewMatrix * pos;", "vec3 trTime = vec3(translate.x + time,translate.y + time,translate.z + time);", "float scale = sin( trTime.x * 0.21 * 2.0 );", "vScale = scale;", "scale = scale * 10.0 + 10.0;", "mvPosition.xyz += position*size/10.0;//* scale", "vUv = uv;", "gl_Position = projectionMatrix * mvPosition;", "}"].join("\n"), fragmentShader: ["precision highp float;", "uniform sampler2D map;", "uniform vec3 color;", "uniform float brightness;", "varying vec2 vUv;", "varying float vScale;", "vec3 HUEtoRGB(float H){", "H = mod(H,1.0);", "float R = abs(H * 6.0 - 3.0) - 1.0;", "float G = 2.0 - abs(H * 6.0 - 2.0);", "float B = 2.0 - abs(H * 6.0 - 4.0);", "return clamp(vec3(R,G,B),0.0,1.0);", "}", "vec3 HSLtoRGB(vec3 HSL){", "vec3 RGB = HUEtoRGB(HSL.x);", "float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;", "return (RGB - 0.5) * C + HSL.z;", "}", "void main() {", "vec4 diffuseColor = texture2D( map, vUv );", "gl_FragColor = vec4( diffuseColor.r * color.r, diffuseColor.g * color.g, diffuseColor.b * color.b, brightness * abs(vScale) * diffuseColor.a );", "//gl_FragColor = vec4( 10,0,0, brightness * vScale * diffuseColor.w );", "}"].join("\n") }, HeatmapShader = { uniforms: { map: { value: null }, bgMap: { value: null }, color: { value: new Color$1(1, 1, 1) }, brightness: { value: 1 } }, vertexShader: ["precision highp float;", "varying vec2 vUvv;", "varying vec2 pUv;", "void main() {", "\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );", "   vUvv=uv;", "   pUv=vec2(worldPosition.x,worldPosition.z);", "\tgl_Position = projectionMatrix * mvPosition;", "}"].join("\n"), fragmentShader: ["uniform sampler2D map;", "uniform sampler2D bgMap;", "uniform vec4 color;", "uniform float brightness;", "varying vec2 vUvv;", "varying vec2 pUv;", "void main() {", "\tvec4 dColor = texture2D( map, vUvv);", "   vec2 bguv=pUv;", "   bguv.x*=0.1;", "   bguv.y*=0.1;", "\tvec4 bgColor =texture2D(bgMap,bguv);", "\tvec4 finalColor =mix(dColor,bgColor,bgColor.a);//(dColor+bgColor）*color*brightness;", "\tgl_FragColor =vec4(finalColor.rgb,dColor.a);", "   //gl_FragColor=vec4(vReflectionFactor,vReflectionFactor,vReflectionFactor,1.0);", "}"].join("\n") }; const LensDistortionShader = { defines: { BAND_MODE: 2, CHROMA_SAMPLES: 1 }, uniforms: { tDiffuse: { value: null }, baseIor: { value: .075 }, bandOffset: { value: .003 }, jitterIntensity: { value: 1 }, jitterOffset: { value: 0 } }, vertexShader: "\n\t\tvarying vec2 vUv; \n\t\tvarying vec3 viewDir;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tviewDir = normalize( ( modelViewMatrix * vec4( position, 1.0 ) ).xyz );\n\t\t}\n\t", fragmentShader: "\n\t\tvarying vec2 vUv;\n\t\tvarying vec3 viewDir;\n\t\tuniform float baseIor;\n\t\tuniform float bandOffset;\n\t\tuniform float jitterIntensity;\n\t\tuniform float jitterOffset;\n\t\tuniform sampler2D tDiffuse;\n\n\t\t#include <common>\n\t\tvoid main() {\n\n\t\t\tvec3 normal = vec3( ( 2.0 * vUv - vec2( 1.0 ) ), 1.0 );\n\t\t\tnormal.z = 1.0;\n\t\t\tnormal = normalize( normal );\n\n\t\t\tvec3 color;\n\n\t\t\t// if NO BANDS\n\t\t\t#if BAND_MODE == 0\n\n\t\t\tvec3 refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor );\n\t\t\tcolor = texture2D( tDiffuse, vUv + refracted.xy ).rgb;\n\n\t\t\t// if RGB or RYGCBV BANDS\n\t\t\t#else\n\n\t\t\tfloat index, randValue, offsetValue;\n\t\t\tfloat r, g, b, r_ior, g_ior, b_ior;\n\t\t\tvec3 r_refracted, g_refracted, b_refracted;\n\t\t\tvec4 r_sample, g_sample, b_sample;\n\n\t\t\t#if BAND_MODE == 2\n\t\t\tfloat y, c, v, y_ior, c_ior, v_ior;\n\t\t\tvec3 y_refracted, c_refracted, v_refracted;\n\t\t\tvec4 y_sample, c_sample, v_sample;\n\t\t\t#endif\n\n\t\t\tfor ( int i = 0; i < CHROMA_SAMPLES; i ++ ) {\n\t\t\t\tindex = float( i );\n\t\t\t\trandValue = rand( sin( index + 1. ) * gl_FragCoord.xy + vec2( jitterOffset, - jitterOffset ) ) - 0.5;\n\t\t\t\toffsetValue = index / float( CHROMA_SAMPLES ) + randValue * jitterIntensity;\n\t\t\t\t#if BAND_MODE == 1\n\t\t\t\trandValue *= 2.0;\n\t\t\t\t#endif\n\n\t\t\t\t// Paper describing functions for creating yellow, cyan, and violet bands and reforming\n\t\t\t\t// them into RGB:\n\t\t\t\t// https://web.archive.org/web/20061108181225/http://home.iitk.ac.in/~shankars/reports/dispersionraytrace.pdf\n\t\t\t\tr_ior = 1.0 + bandOffset * ( 0.0 + offsetValue );\n\t\t\t\tg_ior = 1.0 + bandOffset * ( 2.0 + offsetValue );\n\t\t\t\tb_ior = 1.0 + bandOffset * ( 4.0 + offsetValue );\n\n\t\t\t\tr_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / r_ior );\n\t\t\t\tg_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / g_ior );\n\t\t\t\tb_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / b_ior );\n\n\t\t\t\tr_sample = texture2D( tDiffuse, vUv + r_refracted.xy );\n\t\t\t\tg_sample = texture2D( tDiffuse, vUv + g_refracted.xy );\n\t\t\t\tb_sample = texture2D( tDiffuse, vUv + b_refracted.xy );\n\n\t\t\t\t#if BAND_MODE == 2\n\t\t\t\ty_ior = 1.0 + bandOffset * ( 1.0 + offsetValue );\n\t\t\t\tc_ior = 1.0 + bandOffset * ( 3.0 + offsetValue );\n\t\t\t\tv_ior = 1.0 + bandOffset * ( 5.0 + offsetValue );\n\n\t\t\t\ty_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / y_ior );\n\t\t\t\tc_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / c_ior );\n\t\t\t\tv_refracted = refract( vec3( 0.0, 0.0, - 1.0 ), normal, baseIor / v_ior );\n\n\t\t\t\ty_sample = texture2D( tDiffuse, vUv + y_refracted.xy );\n\t\t\t\tc_sample = texture2D( tDiffuse, vUv + c_refracted.xy );\n\t\t\t\tv_sample = texture2D( tDiffuse, vUv + v_refracted.xy );\n\n\t\t\t\tr = r_sample.r / 2.0;\n\t\t\t\ty = ( 2.0 * y_sample.r + 2.0 * y_sample.g - y_sample.b ) / 6.0;\n\t\t\t\tg = g_sample.g / 2.0;\n\t\t\t\tc = ( 2.0 * c_sample.g + 2.0 * c_sample.b - c_sample.r ) / 6.0;\n\t\t\t\tb = b_sample.b / 2.0;\n\t\t\t\tv = ( 2.0 * v_sample.b + 2.0 * v_sample.r - v_sample.g ) / 6.0;\n\n\t\t\t\tcolor.r += r + ( 2.0 * v + 2.0 * y - c ) / 3.0;\n\t\t\t\tcolor.g += g + ( 2.0 * y + 2.0 * c - v ) / 3.0;\n\t\t\t\tcolor.b += b + ( 2.0 * c + 2.0 * v - y ) / 3.0;\n\t\t\t\t#else\n\t\t\t\tcolor.r += r_sample.r;\n\t\t\t\tcolor.g += g_sample.g;\n\t\t\t\tcolor.b += b_sample.b;\n\t\t\t\t#endif\n\t\t\t}\n\t\t\tcolor /= float( CHROMA_SAMPLES );\n\t\t\t#endif\n\t\t\tgl_FragColor = vec4( color, 1.0 );\n\t\t}\n\t" }; var THREE_MeshLine = createCommonjsModule((function (e, t) { (function () { var i = void 0 !== commonjsRequire, r = this.THREE || i && require$$0; if (!r) throw new Error("MeshLine requires three.js"); function n() { r.BufferGeometry.call(this), this.type = "MeshLine", this.positions = [], this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [], this.counters = [], this._points = [], this._geom = null, this.widthCallback = null, this.material = null, this.matrixWorld = new r.Matrix4, Object.defineProperties(this, { geometry: { enumerable: !0, get: function () { return this } }, geom: { enumerable: !0, get: function () { return this._geom }, set: function (e) { this.setGeometry(e, this.widthCallback) } }, points: { enumerable: !0, get: function () { return this._points }, set: function (e) { this.setPoints(e, this.widthCallback) } } }) } function a(e, t) { var i = new r.Matrix4, n = new r.Ray, a = new r.Sphere, o = new r.Vector3, s = this.geometry; if (a.copy(s.boundingSphere), a.applyMatrix4(this.matrixWorld), !1 !== e.ray.intersectSphere(a, o)) { i.copy(this.matrixWorld).invert(), n.copy(e.ray).applyMatrix4(i); var l = new r.Vector3, c = new r.Vector3, h = new r.Vector3, u = this instanceof r.LineSegments ? 2 : 1, d = s.index, p = s.attributes; if (null !== d) for (var f = d.array, m = p.position.array, g = p.width.array, y = 0, v = f.length - 1; y < v; y += u) { var _ = f[y], b = f[y + 1]; l.fromArray(m, 3 * _), c.fromArray(m, 3 * b); var x = null != g[Math.floor(y / 3)] ? g[Math.floor(y / 3)] : 1, w = e.params.Line.threshold + this.material.lineWidth * x / 2, S = w * w; if (!(n.distanceSqToSegment(l, c, o, h) > S)) { o.applyMatrix4(this.matrixWorld); var M = e.ray.origin.distanceTo(o); M < e.near || M > e.far || (t.push({ distance: M, point: h.clone().applyMatrix4(this.matrixWorld), index: y, face: null, faceIndex: null, object: this }), y = v) } } } } function o(e, t, i, r, n) { var a; if (e = e.subarray || e.slice ? e : e.buffer, i = i.subarray || i.slice ? i : i.buffer, e = t ? e.subarray ? e.subarray(t, n && t + n) : e.slice(t, n && t + n) : e, i.set) i.set(e, r); else for (a = 0; a < e.length; a++)i[a + r] = e[a]; return i } function s(e) { r.ShaderMaterial.call(this, { uniforms: Object.assign({}, r.UniformsLib.fog, { lineWidth: { value: 1 }, map: { value: null }, useMap: { value: 0 }, alphaMap: { value: null }, useAlphaMap: { value: 0 }, maskMap: { value: null }, useMaskMap: { value: 0 }, color: { value: new r.Color(16777215) }, opacity: { value: 1 }, resolution: { value: new r.Vector2(1, 1) }, sizeAttenuation: { value: 1 }, dashArray: { value: 0 }, dashOffset: { value: 0 }, dashRatio: { value: .5 }, useDash: { value: 0 }, visibility: { value: 1 }, alphaTest: { value: 0 }, repeat: { value: new r.Vector2(1, 1) }, offset: { value: new r.Vector2(0, 0) }, colorPass: { value: new r.Color(16777215) }, pass: { value: 0 }, passRange: { value: .05 }, faceUp: { value: !1 } }), vertexShader: r.ShaderChunk.meshline_vert, fragmentShader: r.ShaderChunk.meshline_frag }), this.type = "MeshLineMaterial", Object.defineProperties(this, { lineWidth: { enumerable: !0, get: function () { return this.uniforms.lineWidth.value }, set: function (e) { this.uniforms.lineWidth.value = e } }, map: { enumerable: !0, get: function () { return this.uniforms.map.value }, set: function (e) { this.uniforms.map.value = e } }, useMap: { enumerable: !0, get: function () { return this.uniforms.useMap.value }, set: function (e) { this.uniforms.useMap.value = e } }, alphaMap: { enumerable: !0, get: function () { return this.uniforms.alphaMap.value }, set: function (e) { this.uniforms.alphaMap.value = e } }, useAlphaMap: { enumerable: !0, get: function () { return this.uniforms.useAlphaMap.value }, set: function (e) { this.uniforms.useAlphaMap.value = e } }, maskMap: { enumerable: !0, get: function () { return this.uniforms.maskMap.value }, set: function (e) { this.uniforms.maskMap.value = e } }, useMaskMap: { enumerable: !0, get: function () { return this.uniforms.useMaskMap.value }, set: function (e) { this.uniforms.useMaskMap.value = e } }, color: { enumerable: !0, get: function () { return this.uniforms.color.value }, set: function (e) { this.uniforms.color.value = e } }, opacity: { enumerable: !0, get: function () { return this.uniforms.opacity.value }, set: function (e) { this.uniforms.opacity.value = e } }, resolution: { enumerable: !0, get: function () { return this.uniforms.resolution.value }, set: function (e) { this.uniforms.resolution.value.copy(e) } }, sizeAttenuation: { enumerable: !0, get: function () { return this.uniforms.sizeAttenuation.value }, set: function (e) { this.uniforms.sizeAttenuation.value = e } }, dashArray: { enumerable: !0, get: function () { return this.uniforms.dashArray.value }, set: function (e) { this.uniforms.dashArray.value = e, this.useDash = 0 !== e ? 1 : 0 } }, dashOffset: { enumerable: !0, get: function () { return this.uniforms.dashOffset.value }, set: function (e) { this.uniforms.dashOffset.value = e } }, dashRatio: { enumerable: !0, get: function () { return this.uniforms.dashRatio.value }, set: function (e) { this.uniforms.dashRatio.value = e } }, useDash: { enumerable: !0, get: function () { return this.uniforms.useDash.value }, set: function (e) { this.uniforms.useDash.value = e } }, visibility: { enumerable: !0, get: function () { return this.uniforms.visibility.value }, set: function (e) { this.uniforms.visibility.value = e } }, alphaTest: { enumerable: !0, get: function () { return this.uniforms.alphaTest.value }, set: function (e) { this.uniforms.alphaTest.value = e } }, repeat: { enumerable: !0, get: function () { return this.uniforms.repeat.value }, set: function (e) { this.uniforms.repeat.value.copy(e) } }, offset: { enumerable: !0, get: function () { return this.uniforms.offset.value }, set: function (e) { this.uniforms.offset.value.copy(e) } }, colorPass: { enumerable: !0, get: function () { return this.uniforms.colorPass.value }, set: function (e) { this.uniforms.colorPass.value.copy(e) } }, pass: { enumerable: !0, get: function () { return this.uniforms.pass.value }, set: function (e) { this.uniforms.pass.value = e } }, passRange: { enumerable: !0, get: function () { return this.uniforms.passRange.value }, set: function (e) { this.uniforms.passRange.value = e } }, faceUp: { enumerable: !0, get: function () { return this.uniforms.faceUp.value }, set: function (e) { this.uniforms.faceUp.value = e } } }), this.setValues(e) } n.prototype = Object.create(r.BufferGeometry.prototype), n.prototype.constructor = n, n.prototype.isMeshLine = !0, n.prototype.setMatrixWorld = function (e) { this.matrixWorld = e }, n.prototype.setGeometry = function (e, t) { this._geometry = e, e instanceof r.BufferGeometry ? this.setPoints(e.getAttribute("position").array, t) : this.setPoints(e, t) }, n.prototype.setPoints = function (e, t) { if (e instanceof Float32Array || e instanceof Array) { if (this._points = e, this.widthCallback = t, this.positions = [], this.counters = [], e.length && e[0] instanceof r.Vector3) for (var i = 0; i < e.length; i++) { var n = e[i], a = i / e.length; this.positions.push(n.x, n.y, n.z), this.positions.push(n.x, n.y, n.z), this.counters.push(a), this.counters.push(a) } else for (i = 0; i < e.length; i += 3) { a = i / e.length; this.positions.push(e[i], e[i + 1], e[i + 2]), this.positions.push(e[i], e[i + 1], e[i + 2]), this.counters.push(a), this.counters.push(a) } this.process() } else logger.error("ERROR: The BufferArray of points is not instancied correctly.") }, n.prototype.raycast = a, n.prototype.compareV3 = function (e, t) { var i = 6 * e, r = 6 * t; return this.positions[i] === this.positions[r] && this.positions[i + 1] === this.positions[r + 1] && this.positions[i + 2] === this.positions[r + 2] }, n.prototype.copyV3 = function (e) { var t = 6 * e; return [this.positions[t], this.positions[t + 1], this.positions[t + 2]] }, n.prototype.process = function () { var e, t, i = this.positions.length / 6; this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [], t = this.compareV3(0, i - 1) ? this.copyV3(i - 2) : this.copyV3(0), this.previous.push(t[0], t[1], t[2]), this.previous.push(t[0], t[1], t[2]); for (var n = 0; n < i; n++) { if (this.side.push(1), this.side.push(-1), e = this.widthCallback ? this.widthCallback(n / (i - 1)) : 1, this.width.push(e), this.width.push(e), this.uvs.push(n / (i - 1), 0), this.uvs.push(n / (i - 1), 1), n < i - 1) { t = this.copyV3(n), this.previous.push(t[0], t[1], t[2]), this.previous.push(t[0], t[1], t[2]); var a = 2 * n; this.indices_array.push(a, a + 1, a + 2), this.indices_array.push(a + 2, a + 1, a + 3) } n > 0 && (t = this.copyV3(n), this.next.push(t[0], t[1], t[2]), this.next.push(t[0], t[1], t[2])) } if (t = this.compareV3(i - 1, 0) ? this.copyV3(1) : this.copyV3(i - 1), this.next.push(t[0], t[1], t[2]), this.next.push(t[0], t[1], t[2]), null !== this.material && !0 === this.material.faceUp) { const e = 2 * Math.PI; for (let t = 0; t < this.positions.length; t += 3) { const i = new r.Vector2(this.positions[t], this.positions[t + 2]), n = new r.Vector2(this.previous[t], this.previous[t + 2]), a = new r.Vector2(this.next[t], this.next[t + 2]); let o = null, s = 0; if (a.equals(i)) o = i.clone().sub(n).normalize(); else if (n.equals(i)) o = a.clone().sub(i).normalize(); else { const t = i.clone().sub(n).normalize(), r = a.clone().sub(i).normalize(); o = t.clone().add(r).normalize(); const l = (Math.atan2(t.y, t.x) + e) % e; s = (Math.atan2(r.y, r.x) + e) % e - l } const l = o.clone(); o.x = -l.y, o.y = l.x; const c = this.side[Math.floor(t / 3)]; o.multiplyScalar(c); let h = this.material.lineWidth / 2; 0 !== s && (h /= Math.cos(s / 2)), o.multiplyScalar(Math.abs(h)), this.positions[t] += o.x, this.positions[t + 2] += o.y } } this._attributes && this._attributes.position.count === this.positions.length ? (this._attributes.position.copyArray(new Float32Array(this.positions)), this._attributes.position.needsUpdate = !0, this._attributes.previous.copyArray(new Float32Array(this.previous)), this._attributes.previous.needsUpdate = !0, this._attributes.next.copyArray(new Float32Array(this.next)), this._attributes.next.needsUpdate = !0, this._attributes.side.copyArray(new Float32Array(this.side)), this._attributes.side.needsUpdate = !0, this._attributes.width.copyArray(new Float32Array(this.width)), this._attributes.width.needsUpdate = !0, this._attributes.uv.copyArray(new Float32Array(this.uvs)), this._attributes.uv.needsUpdate = !0, this._attributes.index.copyArray(new Uint16Array(this.indices_array)), this._attributes.index.needsUpdate = !0) : this._attributes = { position: new r.BufferAttribute(new Float32Array(this.positions), 3), previous: new r.BufferAttribute(new Float32Array(this.previous), 3), next: new r.BufferAttribute(new Float32Array(this.next), 3), side: new r.BufferAttribute(new Float32Array(this.side), 1), width: new r.BufferAttribute(new Float32Array(this.width), 1), uv: new r.BufferAttribute(new Float32Array(this.uvs), 2), index: new r.BufferAttribute(new Uint16Array(this.indices_array), 1), counters: new r.BufferAttribute(new Float32Array(this.counters), 1) }, this.setAttribute("position", this._attributes.position), this.setAttribute("previous", this._attributes.previous), this.setAttribute("next", this._attributes.next), this.setAttribute("side", this._attributes.side), this.setAttribute("width", this._attributes.width), this.setAttribute("uv", this._attributes.uv), this.setAttribute("counters", this._attributes.counters), this.setIndex(this._attributes.index), this.computeBoundingSphere(), this.computeBoundingBox() }, n.prototype.advance = function (e) { var t = this._attributes.position.array, i = this._attributes.previous.array, r = this._attributes.next.array, n = t.length; o(t, 0, i, 0, n), o(t, 6, t, 0, n - 6), t[n - 6] = e.x, t[n - 5] = e.y, t[n - 4] = e.z, t[n - 3] = e.x, t[n - 2] = e.y, t[n - 1] = e.z, o(t, 6, r, 0, n - 6), r[n - 6] = e.x, r[n - 5] = e.y, r[n - 4] = e.z, r[n - 3] = e.x, r[n - 2] = e.y, r[n - 1] = e.z, this._attributes.position.needsUpdate = !0, this._attributes.previous.needsUpdate = !0, this._attributes.next.needsUpdate = !0 }, r.ShaderChunk.meshline_vert = ["", r.ShaderChunk.logdepthbuf_pars_vertex, r.ShaderChunk.fog_pars_vertex, "", "attribute vec3 previous;", "attribute vec3 next;", "attribute float side;", "attribute float width;", "attribute float counters;", "", "uniform vec2 resolution;", "uniform float lineWidth;", "uniform vec3 color;", "uniform vec3 colorPass;", "uniform float opacity;", "uniform float sizeAttenuation;", "uniform bool faceUp;", "", "varying vec2 vUV;", "varying vec4 vColor;", "varying vec4 vColorPass;", "varying float vCounters;", "", "vec2 fix( vec4 i, float aspect ) {", "", "    vec2 res = i.xy / i.w;", "    res.x *= aspect;", "\t   vCounters = counters;", "    return res;", "", "}", "", "void main() {", "", "    float aspect = resolution.x / resolution.y;", "", "    vColor = vec4( color, opacity );", "    vColorPass = vec4( colorPass, opacity );", "    vUV = uv;", "    vec4 finalPosition;", "    mat4 m = projectionMatrix * modelViewMatrix;", "", "    if (faceUp) {", "        vec4 positionP = vec4( position, 1.0 );", "        finalPosition = m * positionP;", "    } else {", "        finalPosition = m * vec4( position, 1.0 );", "        vec4 prevPos = m * vec4( previous, 1.0 );", "        vec4 nextPos = m * vec4( next, 1.0 );", "", "        vec2 currentP = fix( finalPosition, aspect );", "        vec2 prevP = fix( prevPos, aspect );", "        vec2 nextP = fix( nextPos, aspect );", "", "        float w = lineWidth * width;", "", "        vec2 dir;", "        if( nextP == currentP ) dir = normalize( currentP - prevP );", "        else if( prevP == currentP ) dir = normalize( nextP - currentP );", "        else {", "            vec2 dir1 = normalize( currentP - prevP );", "            vec2 dir2 = normalize( nextP - currentP );", "            dir = normalize( dir1 + dir2 );", "", "            vec2 perp = vec2( -dir1.y, dir1.x );", "            vec2 miter = vec2( -dir.y, dir.x );", "            //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );", "", "        }", "", "        vec4 normal = vec4( -dir.y, dir.x, 0., 1. );", "        normal.xy *= .5 * w;", "        normal *= projectionMatrix;", "        if( sizeAttenuation == 0. ) {", "            normal.xy *= finalPosition.w;", "            normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;", "        }", "        finalPosition.xy += normal.xy * side;", "    }", "    gl_Position = finalPosition;", "", r.ShaderChunk.logdepthbuf_vertex, r.ShaderChunk.fog_vertex && "    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", r.ShaderChunk.fog_vertex, "}"].join("\n"), r.ShaderChunk.meshline_frag = ["", r.ShaderChunk.fog_pars_fragment, r.ShaderChunk.logdepthbuf_pars_fragment, "", "uniform sampler2D map;", "uniform sampler2D alphaMap;", "uniform sampler2D maskMap;", "uniform float useMap;", "uniform float useAlphaMap;", "uniform float useMaskMap;", "uniform float useDash;", "uniform float dashArray;", "uniform float dashOffset;", "uniform float dashRatio;", "uniform float visibility;", "uniform float alphaTest;", "uniform vec2 repeat;", "uniform vec2 offset;", "uniform float pass;", "uniform float passRange;", "", "varying vec2 vUV;", "varying vec4 vColor;", "varying vec4 vColorPass;", "varying float vCounters;", "", "void main() {", "", r.ShaderChunk.logdepthbuf_fragment, "", "    vec4 c;", "    if (vUV.x < pass - passRange) {", "        c = vColorPass;", "    } else if (vUV.x > pass + passRange){", "        c = vColor;", "    } else {", "        c = mix(vColorPass, vColor, (vUV.x - (pass - passRange)) / (passRange * 2.0));", "    }", "    vec2 vUV2 = vUV + offset;", "    if( useMap == 1. ) c *= texture2D( map, vUV2 * repeat );", "    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV2 * repeat ).a;", "    if( useMaskMap == 1. ) {", "        vec4 mask = texture2D( maskMap, vUV2 * repeat );", "        c.a *= (( mask.r + mask.g + mask.b ) / 3.0 );", "    }", "    if( c.a < alphaTest ) discard;", "    if( useDash == 1. ){", "        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));", "    }", "    gl_FragColor = c;", "    gl_FragColor.a *= step(vCounters, visibility);", "", r.ShaderChunk.fog_fragment, "}"].join("\n"), s.prototype = Object.create(r.ShaderMaterial.prototype), s.prototype.constructor = s, s.prototype.isMeshLineMaterial = !0, s.prototype.copy = function (e) { return r.ShaderMaterial.prototype.copy.call(this, e), this.lineWidth = e.lineWidth, this.map = e.map, this.useMap = e.useMap, this.alphaMap = e.alphaMap, this.useAlphaMap = e.useAlphaMap, this.maskMap = e.maskMap, this.useMaskMap = e.useMaskMap, this.color.copy(e.color), this.opacity = e.opacity, this.resolution.copy(e.resolution), this.sizeAttenuation = e.sizeAttenuation, this.dashArray.copy(e.dashArray), this.dashOffset.copy(e.dashOffset), this.dashRatio.copy(e.dashRatio), this.useDash = e.useDash, this.visibility = e.visibility, this.alphaTest = e.alphaTest, this.repeat.copy(e.repeat), this.offset.copy(e.offset), this.colorPass.copy(e.colorPass), this.pass = e.pass, this.passRange = e.passRange, this }, e.exports && (t = e.exports = { MeshLine: n, MeshLineMaterial: s, MeshLineRaycast: a }), t.MeshLine = n, t.MeshLineMaterial = s, t.MeshLineRaycast = a }).call(commonjsGlobal) })), RainlineShader = { defines: { DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, uniforms: { time: { value: 0 }, speed: { value: 1 }, color: { value: new Color$1(1, 1, 1) }, brightness: { value: 1 }, width: { value: 1 }, height: { value: 1 } }, vertexShader: ["precision highp float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float time;", "uniform float speed;", "uniform float width;", "uniform float height;", "attribute vec3 position;", "attribute vec2 uv;", "attribute vec3 translate;", "varying vec2 vUv;", "varying float vScale;", "void main() {", "vec4 pos=vec4(translate, 1.0 );", "pos.y+=position.y*height;", "vec4 mvPosition =  modelViewMatrix * pos;", "vec3 trTime = vec3(translate.x - time,translate.y - time,translate.z - time);", "float scale =  (trTime.x+trTime.y+trTime.z)*0.33*speed;", "vScale = scale;", "mvPosition.xyz += vec3(position.x*width,0,position.z*width);//* scale", "vUv = uv;", "gl_Position = projectionMatrix *mvPosition;", "}"].join("\n"), fragmentShader: ["precision highp float;", "uniform sampler2D map;", "uniform vec3 color;", "uniform float brightness;", "uniform float opacity;", "varying vec2 vUv;", "varying float vScale;", "vec3 HUEtoRGB(float H){", "H = mod(H,1.0);", "float R = abs(H * 6.0 - 3.0) - 1.0;", "float G = 2.0 - abs(H * 6.0 - 2.0);", "float B = 2.0 - abs(H * 6.0 - 4.0);", "return clamp(vec3(R,G,B),0.0,1.0);", "}", "vec3 HSLtoRGB(vec3 HSL){", "vec3 RGB = HUEtoRGB(HSL.x);", "float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;", "return (RGB - 0.5) * C + HSL.z;", "}", "void main() {", "vec2 uv=vUv;", "//uv.y+=vScale;", "uv.y=uv.y+mod(vScale,20.0)*0.1-1.0;", "vec4 diffuseColor = texture2D( map, uv );", "float alpha=diffuseColor.w;", "if(uv.y>=1.0||uv.y<=0.0){", "alpha=0.0;", "}", "gl_FragColor = vec4( diffuseColor.xyz * color *brightness , alpha*opacity );", "}"].join("\n") }; const SharpenShader = { uniforms: { tDiffuse: { type: "t", value: null }, width: { type: "f", value: 0 }, height: { type: "f", value: 0 }, kernel: { type: "fv1", value: [-1, -1, -1, -1, 9, -1, -1, -1, -1] }, intensity: { type: "f", value: .1 } }, vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader: ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "uniform float width;", "uniform float height;", "uniform float kernel[9];", "uniform float intensity;", "void main(void)", "{", "float step_w = intensity/width;", "float step_h = intensity/height;", "vec2 offset[9];", "offset[0] = vec2(-step_w, -step_h);", "offset[1] = vec2(0.0, -step_h);", "offset[2] = vec2(step_w, -step_h);", "offset[3] = vec2(-step_w, 0.0);", "offset[4] = vec2(0.0, 0.0);", "offset[5] = vec2(step_w, 0.0);", "offset[6] = vec2(-step_w, step_h);", "offset[7] = vec2(0.0, step_h);", "offset[8] = vec2(step_w, step_h);", "vec3 sum = vec3(0.0);", "for( int i=0; i<9; i++ )", "sum += texture2D(tDiffuse, vUv + offset[i]).rgb * kernel[i];", "gl_FragColor = vec4(sum,1.0);", "}"].join("\n") }, vertexShader = "\nvarying vec2 vUv;\n\nvoid mainSupport(const in vec2 uv) {\n\n  vUv = uv;\n\n}\n", fragmentShader = "\nvarying vec2 vUv;\n\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\nuniform sampler2D tNormal;\nuniform sampler2D tMetalness;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraInverseProjectionMatrix;\nuniform float maxDistance;\nuniform float thickness;\nuniform float opacity;\nuniform float resolutionScale;\n\nfloat pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {\n  return length(cross(x0 - x1, x0 - x2)) / length(x2 - x1);\n}\n\nfloat pointPlaneDistance(vec3 point, vec3 planePoint, vec3 planeNormal) {\n  float a = planeNormal.x, b = planeNormal.y, c = planeNormal.z;\n  float x0 = point.x, y0 = point.y, z0 = point.z;\n  float x = planePoint.x, y = planePoint.y, z = planePoint.z;\n  float d = -(a * x + b * y + c * z);\n  float distance = (a * x0 + b * y0 + c * z0 + d) / sqrt(a * a + b * b + c * c);\n  return distance;\n}\n\nfloat getDepth(vec2 uv) {\n  return unpackRGBAToDepth(texture2D(tDepth, uv));\n}\n\nfloat getViewZ(const in float depth){\n  return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n}\n\nvec3 getViewPosition(const in vec2 uv, const in float depth, const in float clipW){\n  vec4 clipPosition = vec4((vec3(uv,depth) - .5) * 2., 1.);\n  clipPosition *= clipW;\n  return (cameraInverseProjectionMatrix * clipPosition).xyz;\n}\n\nvec3 getViewNormal(const in vec2 uv){\n    return unpackRGBToNormal(texture2D(tNormal, uv).xyz);\n}\n\nvec2 viewPositionToXY(vec3 viewPosition){\n    vec2 xy;\n    vec4 clip = cameraProjectionMatrix * vec4(viewPosition, 1);\n    xy = clip.xy;\n    float clipW = clip.w;\n    xy /= clipW;\n    xy = (xy + 1.) / 2.;\n    xy *= resolution;\n    return xy;\n}\n\nvoid mainImage(const in vec4 inputColor, const in vec2 uv, const in float depth, out vec4 outputColor) {\n\n  // outputColor = texture2D(tMetalness, uv);\n  // return;\n\n  vec4 normalValue = vec4(unpackRGBToNormal(texture2D(tNormal, uv).xyz), 1.0);\n  float snowRatio = normalValue.g - normalValue.r - normalValue.b;\n  if (snowRatio < 0.0) {\n    snowRatio = 0.0;\n  }\n  // normalValue = cameraInverseProjectionMatrix * normalValue;\n  // outputColor = normalValue;\n  // return;\n\n  float metalness = texture2D(tMetalness, uv).r;\n  if (metalness == 0.) {\n    outputColor = inputColor;\n    return;\n  }\n\n  vec4 reflectColor;\n  float depthValue = getDepth(uv);\n  float viewZ = getViewZ(depthValue);\n\n    if(-viewZ >= cameraFar) {\n    outputColor = inputColor;\n    return;\n  }\n  \n  float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n  vec3 viewPosition = getViewPosition(vUv, depthValue, clipW);\n\n  vec2 d0 = gl_FragCoord.xy;\n  vec2 d1;\n\n  vec3 viewNormal = getViewNormal(vUv);\n    \n#ifdef PERSPECTIVE_CAMERA\n  vec3 viewIncidentDir = normalize(viewPosition);\n  vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);\n#else\n  vec3 viewIncidentDir = vec3(0, 0, -1);\n  vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);\n#endif\n    \n  float maxReflectRayLen = maxDistance / dot(-viewIncidentDir, viewNormal);\n    \n  vec3 d1viewPosition = viewPosition + viewReflectDir * maxReflectRayLen;\n\n#ifdef PERSPECTIVE_CAMERA\n  if(d1viewPosition.z > -cameraNear){\n    float t = (-cameraNear-viewPosition.z) / viewReflectDir.z;\n    d1viewPosition = viewPosition + viewReflectDir * t;\n  }\n#endif\n\n  d1 = viewPositionToXY(d1viewPosition);\n\n  float totalLen = length(d1 - d0);\n  float xLen = d1.x - d0.x;\n  float yLen = d1.y - d0.y;\n  float totalStep = max(abs(xLen), abs(yLen));\n  float xSpan = xLen / totalStep;\n  float ySpan = yLen / totalStep;\n\n  for(float i = 0.0; i < float(768); i++){\n    if(i >= totalStep) {\n      break;\n    }\n    vec2 xy = vec2(d0.x + i * xSpan, d0.y + i * ySpan);\n    if(xy.x < 0. || xy.x > resolution.x || xy.y < 0. || xy.y > resolution.y) {\n      break;\n    }\n    float s = length(xy - d0) / totalLen;\n    vec2 uv = xy / resolution;\n    float d = getDepth(uv);\n    float vZ = getViewZ(d);\n    if(-vZ >= cameraFar) {\n      continue;\n    }\n    float cW = cameraProjectionMatrix[2][3] * vZ + cameraProjectionMatrix[3][3];\n    vec3 vP = getViewPosition(uv, d, cW);\n        \n#ifdef PERSPECTIVE_CAMERA\n    float recipVPZ = 1. / viewPosition.z;\n    float viewReflectRayZ = 1. / (recipVPZ + s * (1. / d1viewPosition.z - recipVPZ));\n#else\n    float viewReflectRayZ = viewPosition.z + s * (d1viewPosition.z - viewPosition.z);\n#endif\n    \n    if(viewReflectRayZ <= vZ) {\n\n      bool hit;\n\n      float away=pointToLineDistance(vP, viewPosition, d1viewPosition);\n\n      float minThickness;\n      vec2 xyNeighbor = xy;\n      xyNeighbor.x += 1.;\n      vec2 uvNeighbor = xyNeighbor / resolution;\n      vec3 vPNeighbor = getViewPosition(uvNeighbor, d, cW);\n      minThickness = vPNeighbor.x - vP.x;\n      minThickness *= 3.;\n      float tk = max(minThickness, thickness);\n\n      hit = away <= tk;\n      \n      if(hit) {\n        vec3 vN = getViewNormal(uv);\n        \n        if(dot(viewReflectDir,vN) >= 0.) {\n          continue;\n        }\n        \n        float distance = pointPlaneDistance(vP, viewPosition, viewNormal);\n        \n        if(distance > maxDistance) {\n          break;\n        }\n        \n        float op = opacity;\n\n\n        float ratio = 1.0 - (distance / maxDistance);\n        float attenuation = ratio * ratio;\n        op = opacity * attenuation;\n\n\n\n        float fresnelCoe = (dot(viewIncidentDir, viewReflectDir) + 1.) / 2.;\n\t\t\t\top *= fresnelCoe;\n\n        reflectColor = texture2D(tDiffuse, uv);\n        reflectColor.a = op;\n        break;\n      }\n    }\n  }\n\n  outputColor = mix(inputColor, reflectColor, reflectColor.a);\n  // outputColor = mix(outputColor, vec4(1.0, 1.0, 1.0, 1.0), snowRatio);\n\n}\n"; class SSREffect extends Effect$1 { constructor(e, { blendFunction: t = BlendFunction.NORMAL, normalBuffer: i = null, depthBuffer: r = null, selects: n = null, width: a = Resizer.AUTO_SIZE, height: o = Resizer.AUTO_SIZE, scene: s, opacity: l = .5, groundReflector: c } = {}) { super("SSREffect", fragmentShader, { blendFunction: t, attributes: EffectAttribute.DEPTH, uniforms: new Map([["tDiffuse", new Uniform(null)], ["tNormal", new Uniform(i)], ["tDepth", new Uniform(r)], ["tMetalness", new Uniform(null)], ["cameraNear", new Uniform(e.near)], ["cameraFar", new Uniform(e.far)], ["cameraProjectionMatrix", new Uniform(e.projectionMatrix)], ["cameraInverseProjectionMatrix", new Uniform(e.projectionMatrixInverse)], ["maxDistance", new Uniform(10)], ["thickness", new Uniform(.1)], ["opacity", new Uniform(l)], ["resolutionScale", new Uniform(1)]]), vertexShader: vertexShader }), this.groundReflector = c, this.scene3D = s, this._selects = n, this.selective = Array.isArray(this._selects), Object.defineProperty(this, "selects", { get() { return this._selects }, set(e) { this._selects !== e && (this._selects = e, Array.isArray(e) ? (this.selective = !0, this.defines.SELECTIVE = !0, this.needsUpdate = !0) : (this.selective = !1, this.defines.SELECTIVE = !1, this.needsUpdate = !0)) } }), this.camera = e, this.originalClearColor = new Color$1, this.metalnessOnMaterial = new MeshBasicMaterial({ color: "white" }), this.metalnessOffMaterial = new MeshBasicMaterial({ color: "black" }), this.metalnessRenderTarget = new WebGLRenderTarget(a, o, { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat }), this.uniforms.get("tMetalness").value = this.metalnessRenderTarget.texture } update(e, t, i) { this.uniforms.get("tDiffuse").value = t.texture, this.selective && this.renderMetalness(e, this.metalnessOnMaterial, this.metalnessRenderTarget, 0, 0) } initialize(e, t, i) { } renderMetalness(e, t, i, r, n) { e.getClearColor(this.originalClearColor); const a = e.getClearAlpha(), o = e.autoClear; e.setRenderTarget(i), e.autoClear = !1, r = t.clearColor || r, n = t.clearAlpha || n, null != r && (e.setClearColor(r), e.setClearAlpha(n || 0), e.clear()), this.scene3D.traverseVisible((e => { if (e.isMesh) if (e.material instanceof Array ? (e._SSRPassBackupMaterial = [], e._SSRPassBackupMaterial.push(...e.material)) : e._SSRPassBackupMaterial = e.material, this._selects.includes(e)) if (e.material instanceof Array) for (let t in e.material) e.material[t].disableSSR ? e.material[t] = this.metalnessOffMaterial : e.material[t] = this.metalnessOnMaterial; else e.material.disableSSR ? e.material = this.metalnessOffMaterial : e.material = this.metalnessOnMaterial; else e.material = this.metalnessOffMaterial })), e.render(this.scene3D, this.camera), this.scene3D.traverseVisible((e => { e.isMesh && (e._SSRPassBackupMaterial instanceof Array ? (e.material = [], e.material.push(...e._SSRPassBackupMaterial)) : e.material = e._SSRPassBackupMaterial) })), e.autoClear = o, e.setClearColor(this.originalClearColor), e.setClearAlpha(a) } } class Firefly extends Effect { constructor(e) { super("Firefly"), this.option = e, this.name = e.name, this.mesh = null, this.visible = !0; var t = new PlaneGeometry(10, 10), i = new InstancedBufferGeometry; i.index = t.index, i.attributes = t.attributes; for (var r = new Float32Array(3 * this.option.density), n = 0; n < this.option.density; n++) { let e = Math.random() * this.option.radius * 2 - this.option.radius, t = Math.random() * this.option.radius * 2 - this.option.radius, i = Math.random() * (this.option.endHeight - this.option.beginHeight) + this.option.beginHeight; r[3 * n] = e, r[3 * n + 1] = i, r[3 * n + 2] = t } i.setAttribute("translate", new InstancedBufferAttribute(r, 3)); var a = new RawShaderMaterial({ uniforms: { map: { value: (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, "texture/effects/firefly.png")) }, time: { value: 0 }, speed: { value: this.option.speed / 100 }, color: { value: new Color$1(this.option.color) }, brightness: { value: this.option.brightness }, size: { value: this.option.size }, radius: { value: (this.option.endHeight - this.option.beginHeight) / 10 } }, vertexShader: FireflyShader.vertexShader, fragmentShader: FireflyShader.fragmentShader, blending: NormalBlending, transparent: !0, alphaTest: .2 }); this.mesh = new Mesh(i, a), this.mesh.position.set(Number(this.option.position.x) + Number(this.option.offset.x), Number(this.option.position.y) + Number(this.option.offset.y), Number(this.option.position.z) + Number(this.option.offset.z)), this.mesh.name = this.option.name, _context.scene.spaceEffects.add(this.mesh); let o = _context.animationStore.findLayerAnimation(this.option.name, FireflyAnimationController.type); if (o && _context.animationStore.remove(o), o = new FireflyAnimationController(a), o.name = this.option.name, _context.animationStore.add(o), null != this.option.enableAutoHidebyDistance && (this.mesh.activeVisible = !0, this.mesh.enableAutoHidebyDistance = this.option.enableAutoHidebyDistance, this.mesh.minDistance = this.option.minDistance, this.mesh.maxDistance = this.option.maxDistance, _context.animationStore.addDistance(this.option.name, DistanceController, _context.camera, this.mesh)), null == e.visible ? (this.visible = !0, this.mesh.activeVisible = !0, this.mesh.visible = !0, this.option.visible = !0) : (e.visible, this.visible = e.visible, this.mesh.activeVisible = e.visible, this.mesh.visible = e.visible, this.option.visible = e.visible), "function" == typeof this.createHelper) { let e = (this.option.endHeight + this.option.beginHeight) / 2, t = this.option.endHeight - this.option.beginHeight; this.createHelper(new Vector3(0, e, 0), new Vector3(2 * this.option.radius, t, 2 * this.option.radius)) } } update(e) { for (let t in e) null != this.option[t] ? this.option[t] !== e[t] && (this.option[t] = e[t]) : logger.warn(t + "属性不存在"); let t = new PlaneGeometry(10, 10), i = new InstancedBufferGeometry; i.index = t.index, i.attributes = t.attributes; let r = new Float32Array(3 * this.option.density); for (let e = 0; e < this.option.density; e++) { let t = Math.random() * this.option.radius * 2 - this.option.radius, i = Math.random() * this.option.radius * 2 - this.option.radius, n = Math.random() * (this.option.endHeight - this.option.beginHeight) + this.option.beginHeight; r[3 * e] = t, r[3 * e + 1] = n, r[3 * e + 2] = i } i.setAttribute("translate", new InstancedBufferAttribute(r, 3)); let n = new RawShaderMaterial({ uniforms: { map: { value: (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, "texture/effects/firefly.png")) }, time: { value: 0 }, speed: { value: this.option.speed / 100 }, color: { value: new Color$1(this.option.color) }, brightness: { value: this.option.brightness }, size: { value: this.option.size } }, vertexShader: FireflyShader.vertexShader, fragmentShader: FireflyShader.fragmentShader, transparent: !0, alphaTest: .2 }), a = _context.animationStore.findLayerAnimation(e.name, FireflyAnimationController.type); if (a && _context.animationStore.remove(a), a = new FireflyAnimationController(n), a.name = e.name, _context.animationStore.add(a), null != this.option.enableAutoHidebyDistance && (this.mesh.enableAutoHidebyDistance = this.option.enableAutoHidebyDistance, this.mesh.minDistance = this.option.minDistance, this.mesh.maxDistance = this.option.maxDistance, _context.animationStore.addDistance(this.option.name, DistanceController, _context.camera, this.mesh)), this.mesh.position.x = Number(this.option.position.x) + Number(this.option.offset.x), this.mesh.position.y = Number(this.option.position.y) + Number(this.option.offset.y), this.mesh.position.z = Number(this.option.position.z) + Number(this.option.offset.z), this.mesh.geometry.dispose && this.mesh.geometry.dispose(), this.mesh.geometry = i, this.mesh.material = n, "function" == typeof this.updateHelper) { let e = (this.option.endHeight + this.option.beginHeight) / 2, t = this.option.endHeight - this.option.beginHeight; this.updateHelper(new Vector3(0, e, 0), new Vector3(2 * this.option.radius, t, 2 * this.option.radius)) } } hide() { this.visible = !1, this.mesh.visible = !1, this.mesh.activeVisible = !1, this.option.visible = !1 } show() { this.visible = !0, this.mesh.visible = !0, this.mesh.activeVisible = !0, this.option.visible = !0 } remove() { let e = _context.animationStore.findLayerAnimation(this.option.name, FireflyAnimationController.type), t = _context.animationStore.findLayerAnimation(this.option.name, "DistanceController"); e && _context.animationStore.remove(e), t && _context.animationStore.remove(t), _context.scene.spaceEffects.remove(this.mesh), delete this.mesh } } class Rainline extends Effect { constructor(e) { super("Rainline"), this.option = e, this.name = e.name, this.mesh = null, this.visible = !0; var t = new PlaneGeometry(1, 1), i = new InstancedBufferGeometry; i.index = t.index, i.attributes = t.attributes; for (var r = new Float32Array(3 * this.option.density), n = 0; n < this.option.density; n++) { let e = Math.random() * this.option.radius * 2 - this.option.radius, t = Math.random() * this.option.radius * 2 - this.option.radius, i = .5 * this.option.endHeight; r[3 * n] = e, r[3 * n + 1] = i, r[3 * n + 2] = t } i.setAttribute("translate", new InstancedBufferAttribute(r, 3)); var a = new RawShaderMaterial({ uniforms: { map: { value: (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, "texture/effects/rainline.png")) }, time: { value: 0 }, speed: { value: this.option.speed }, color: { value: new Color$1(this.option.color) }, brightness: { value: this.option.brightness }, opacity: { value: this.option.opacity }, width: { value: this.option.lineWidth }, height: { value: this.option.endHeight - this.option.beginHeight } }, vertexShader: RainlineShader.vertexShader, fragmentShader: RainlineShader.fragmentShader, depthTest: !0, depthWrite: !0, transparent: !0, alphaTest: .2 }); this.mesh = new Mesh(i, a), this.mesh.position.set(Number(this.option.position.x) + Number(this.option.offset.x), Number(this.option.position.y) + Number(this.option.offset.y), Number(this.option.position.z) + Number(this.option.offset.z)), this.mesh.name = this.option.name, this.mesh.renderOrder = 101, _context.scene.spaceEffects.add(this.mesh); let o = _context.animationStore.findLayerAnimation(this.option.name, RainlineAnimationController.type); if (o && _context.animationStore.remove(o), o = new RainlineAnimationController(a), o.name = this.option.name, _context.animationStore.add(o), null != this.option.enableAutoHidebyDistance && (this.mesh.activeVisible = !0, this.mesh.enableAutoHidebyDistance = this.option.enableAutoHidebyDistance, this.mesh.minDistance = this.option.minDistance, this.mesh.maxDistance = this.option.maxDistance, _context.animationStore.addDistance(this.option.name, DistanceController, _context.camera, this.mesh)), null == e.visible ? (this.visible = !0, this.option.visible = !0) : (e.visible, this.visible = e.visible, this.mesh.activeVisible = e.visible, this.mesh.visible = e.visible, this.option.visible = e.visible), "function" == typeof this.createHelper) { let e = (this.option.endHeight + this.option.beginHeight) / 2, t = this.mesh.material.uniforms.height.value; this.createHelper(new Vector3(0, e, 0), new Vector3(2 * this.option.radius, t, 2 * this.option.radius)) } } update(e) { for (let t in e) null != this.option[t] ? this.option[t] !== e[t] && (this.option[t] = e[t]) : logger.warn(t + "属性不存在"); let t = new PlaneGeometry(1, 1), i = new InstancedBufferGeometry; i.index = t.index, i.attributes = t.attributes; let r = new Float32Array(3 * this.option.density); for (let e = 0; e < this.option.density; e++) { let t = Math.random() * this.option.radius * 2 - this.option.radius, i = Math.random() * this.option.radius * 2 - this.option.radius, n = .5 * (this.option.endHeight - this.option.beginHeight + this.option.beginHeight); r[3 * e] = t, r[3 * e + 1] = n, r[3 * e + 2] = i } i.setAttribute("translate", new InstancedBufferAttribute(r, 3)); let n = new RawShaderMaterial({ uniforms: { map: { value: (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, "texture/effects/rainline.png")) }, time: { value: 0 }, speed: { value: this.option.speed }, color: { value: new Color$1(this.option.color) }, brightness: { value: this.option.brightness }, opacity: { value: this.option.opacity }, width: { value: this.option.lineWidth }, height: { value: this.option.endHeight - this.option.beginHeight } }, vertexShader: RainlineShader.vertexShader, fragmentShader: RainlineShader.fragmentShader, blending: NormalBlending, depthTest: !0, depthWrite: !0, transparent: !0, alphaTest: .2 }), a = _context.animationStore.findLayerAnimation(e.name, RainlineAnimationController.type); if (a && _context.animationStore.remove(a), a = new RainlineAnimationController(n), a.name = e.name, _context.animationStore.add(a), null != this.option.enableAutoHidebyDistance && (this.mesh.enableAutoHidebyDistance = this.option.enableAutoHidebyDistance, this.mesh.minDistance = this.option.minDistance, this.mesh.maxDistance = this.option.maxDistance, _context.animationStore.addDistance(this.option.name, DistanceController, _context.camera, this.mesh)), this.mesh.position.x = Number(this.option.position.x) + Number(this.option.offset.x), this.mesh.position.y = Number(this.option.position.y) + Number(this.option.offset.y), this.mesh.position.z = Number(this.option.position.z) + Number(this.option.offset.z), this.mesh.geometry.dispose && this.mesh.geometry.dispose(), this.mesh.geometry = i, this.mesh.material = n, "function" == typeof this.updateHelper) { let e = (this.option.endHeight + this.option.beginHeight) / 2, t = this.mesh.material.uniforms.height.value; this.updateHelper(new Vector3(0, e, 0), new Vector3(2 * this.option.radius, t, 2 * this.option.radius)) } } hide() { this.visible = !1, this.mesh.visible = !1, this.mesh.activeVisible = !1, this.option.visible = !1 } show() { this.visible = !0, this.mesh.visible = !0, this.mesh.activeVisible = !0, this.option.visible = !0 } remove() { let e = _context.animationStore.findLayerAnimation(this.option.name, RainlineAnimationController.type), t = _context.animationStore.findLayerAnimation(this.option.name, "DistanceController"); e && _context.animationStore.remove(e), t && _context.animationStore.remove(t), _context.scene.spaceEffects.remove(this.mesh), delete this.mesh } } class Fireworks extends Effect { constructor(e) { super("Fireworks"), this.mesh = new Group, this.mesh.position.set(e.centerPos.x, e.centerPos.y, e.centerPos.z), this.mesh.name = e.name, this.option = e, this.name = e.name, this.visible = !0, this.mapTex = (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, "texture/effects/firefly.png")), this.addFireworks(e, e.radius), _context.scene.spaceEffects.add(this.mesh); let t = _context.animationStore.findLayerAnimation(e.name, FireworksAnimationController.type); if (t && _context.animationStore.remove(t), t = new FireworksAnimationController(this.mesh, e), t.name = e.name, _context.animationStore.add(t), null != e.enableAutoHidebyDistance && (this.mesh.activeVisible = !0, this.mesh.enableAutoHidebyDistance = e.enableAutoHidebyDistance, this.mesh.minDistance = e.minDistance, this.mesh.maxDistance = e.maxDistance, _context.animationStore.addDistance(e.name, DistanceController, _context.camera, this.mesh)), null == e.visible ? (this.visible = !0, this.option.visible = !0) : (e.visible, this.visible = e.visible, this.mesh.activeVisible = e.visible, this.mesh.visible = e.visible, this.option.visible = e.visible), "function" == typeof this.createHelper) { let e = this.option.topHeight + this.option.bottomHeight, t = this.option.topHeight - this.option.bottomHeight + this.option.centerPos.y + this.option.offset.y; this.createHelper(new Vector3(0, e, 0), new Vector3(2 * (this.option.range + this.option.size + this.option.radius + this.option.topHeight + this.option.bottomHeight), 2 * t, 2 * (this.option.range + this.option.size + this.option.radius + this.option.topHeight + this.option.bottomHeight))) } } addFireworks(e, t) { for (let i = 0; i < t; i++) { let t = new Group; t.pos = {}; let i = e.centerPos.x + Number(e.offset.x) + 2 * e.range * Math.random() - e.range, r = Number(e.offset.y) + e.bottomHeight + (e.topHeight - e.bottomHeight) * Math.random(), n = e.centerPos.z + Number(e.offset.z) + 2 * e.range * Math.random() - e.range; t.pos.x = i, t.pos.y = r, t.pos.z = n, t.position.x = i, t.position.y = r, t.position.z = n, t.speed = e.speed + e.speedR * Math.random(), t.lifetime = e.lifetime + e.lifetimeR * Math.random(), t.leaveTime = 0, t.currentTime = 0; let a = new SpriteMaterial({ opacity: 0, color: new Color$1(e.color), transparent: !0, map: this.mapTex }); a.blending = NormalBlending; for (let i = 0; i < 100; i++) { let i = new Sprite(a); i.scale.set(e.size, e.size, e.size), i.position.set(t.pos.x, t.pos.y, t.pos.z), i.dir = new Vector3(2 * Math.random() - 1, 2 * Math.random() - 1, 2 * Math.random() - 1).normalize(), t.add(i) } this.mesh.add(t) } } update(e) { this.mesh.position.set(e.centerPos.x, e.centerPos.y, e.centerPos.z), this.mesh.name = e.name; for (let t in e) null != this.option[t] ? this.option[t] !== e[t] && (this.option[t] = e[t]) : logger.warn(t + "属性不存在"); if (this.mesh.children.length > this.option.radius) for (var t = this.mesh.children.length - 1; this.mesh.children.length > this.option.radius + 1; t--)"Box3Helper" !== this.mesh.children[t].type && this.mesh.children.splice(t, 1); else if (this.mesh.children.length < this.option.radius + 1) { let e = this.option.radius - this.mesh.children.length + 1; this.addFireworks(this.option, e) } for (t = 0; t < this.mesh.children.length; t++) { if ("Box3Helper" === this.mesh.children[t].type) continue; this.mesh.children[t].pos = {}; let r = this.option.centerPos.x + Number(this.option.offset.x) + 2 * this.option.range * Math.random() - this.option.range, n = Number(e.offset.y) + this.option.bottomHeight + (this.option.topHeight - this.option.bottomHeight) * Math.random(), a = this.option.centerPos.z + Number(this.option.offset.z) + 2 * this.option.range * Math.random() - this.option.range; this.mesh.children[t].pos.x = r, this.mesh.children[t].pos.y = n, this.mesh.children[t].pos.z = a, this.mesh.children[t].position.x = r, this.mesh.children[t].position.y = n, this.mesh.children[t].position.z = a, this.mesh.children[t].speed = this.option.speed + this.option.speedR * Math.random(), this.mesh.children[t].lifetime = this.option.lifetime + this.option.lifetimeR * Math.random(), this.mesh.children[t].color = this.option.color; let o = util$1.colorToRGBAObject(this.option.color); for (var i = 0; i < this.mesh.children[t].children.length; i++)this.mesh.children[t].children[i].material.color.r = o.r, this.mesh.children[t].children[i].material.color.g = o.g, this.mesh.children[t].children[i].material.color.b = o.b, this.mesh.children[t].children[i].scale.set(this.option.size, this.option.size, this.option.size) } let r = _context.animationStore.findLayerAnimation(this.option.name, FireworksAnimationController.type); if (r && _context.animationStore.remove(r), r = new FireworksAnimationController(this.mesh, this.option), r.name = this.option.name, _context.animationStore.add(r), null != this.option.enableAutoHidebyDistance && (this.mesh.enableAutoHidebyDistance = this.option.enableAutoHidebyDistance, this.mesh.minDistance = this.option.minDistance, this.mesh.maxDistance = this.option.maxDistance, _context.animationStore.addDistance(this.option.name, DistanceController, _context.camera, this.mesh)), "function" == typeof this.createHelper) { let e = this.option.topHeight + this.option.bottomHeight, t = this.option.topHeight - this.option.bottomHeight + this.option.centerPos.y + this.option.offset.y; this.updateHelper(new Vector3(0, e, 0), new Vector3(2 * (this.option.range + this.option.size + this.option.radius + this.option.topHeight + this.option.bottomHeight), 2 * t, 2 * (this.option.range + this.option.size + this.option.radius + this.option.topHeight + this.option.bottomHeight))) } } hide() { this.visible = !1, this.mesh.visible = !1, this.mesh.activeVisible = !1, this.option.visible = !1 } show() { this.visible = !0, this.mesh.visible = !0, this.mesh.activeVisible = !0, this.option.visible = !0 } remove() { let e = _context.animationStore.findLayerAnimation(this.mesh.name, FireworksAnimationController.type), t = _context.animationStore.findLayerAnimation(this.option.name, "DistanceController"); e && _context.animationStore.remove(e), t && _context.animationStore.remove(t), _context.scene.spaceEffects.remove(this.mesh), delete this.mesh } } class Rain extends Effect { constructor(e) { super("Rain"), this.name = e.name, this.mesh = new Group, this.mesh.name = e.name, this.mesh.renderOrder = 102, this.visible = !0, this.option = e; for (var t = new BufferGeometry, i = [], r = [], n = (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, "texture/effects/rain.png")), a = 0; a < e.density; a++) { var o = 2e3 * (Math.random() - .5), s = 1e3 * (Math.random() - .5), l = 2e3 * (Math.random() - .5); i.push(o, s, l) } t.setAttribute("position", new Float32BufferAttribute(i, 3)); var c = [[[1, .2, .5], n, e.size], [[1, .2, .2], n, e.size], [[.95, .1, .5], n, e.size]]; for (a = 0; a < c.length; a++) { c[a][0]; n = c[a][1]; var h = c[a][2]; r[a] = new PointsMaterial({ size: h, map: n, blending: NormalBlending, depthWrite: !1, transparent: !0, color: new Color$1("#ffffff") }); var u = new Points(t, r[a]); u.visible = !0, u.rotation.x = 6 * Math.random(), u.rotation.y = 6 * Math.random(), u.rotation.z = 6 * Math.random(), u.position.y = 500 * Math.random() - 250, this.mesh.add(u) } this.mesh.rotation.z = MathUtils.degToRad(this.option.direction), this.mesh.position.x = e.offset.x, this.mesh.position.y = e.offset.y, this.mesh.position.z = e.offset.z, _context.scene.spaceEffects.add(this.mesh); let d = _context.animationStore.findLayerAnimation(e.name, RainAnimationController.type); d && _context.animationStore.remove(d), d = new RainAnimationController(this.mesh, e.followCamera), d.name = e.name, _context.animationStore.add(d), null != e.enableAutoHidebyDistance && (this.mesh.activeVisible = !0, this.mesh.enableAutoHidebyDistance = e.enableAutoHidebyDistance, this.mesh.minDistance = e.minDistance, this.mesh.maxDistance = e.maxDistance, _context.animationStore.addDistance(e.name, DistanceController, _context.camera, this.mesh)), null == e.visible ? (this.visible = !0, this.option.visible = !0) : (e.visible, this.visible = e.visible, this.mesh.activeVisible = e.visible, this.mesh.visible = e.visible, this.option.visible = e.visible) } update(e) { for (let t in e) null != this.option[t] ? this.option[t] !== e[t] && (this.option[t] = e[t]) : logger.warn(t + "属性不存在"); for (var t = new BufferGeometry, i = [], r = (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, "texture/effects/rain.png")), n = 0; n < this.option.density; n++) { var a = 2e3 * Math.random() - 1e3, o = 1e3 * Math.random(), s = 2e3 * Math.random() - 1e3; i.push(a, o, s) } t.setAttribute("position", new Float32BufferAttribute(i, 3)); r = (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, "texture/effects/rain.png")); var l = this.option.size, c = new PointsMaterial({ size: l, map: r, blending: NormalBlending, depthWrite: !1, transparent: !0, color: new Color$1("#ffffff") }); for (n = 0; n < this.mesh.children.length; n++)this.mesh.children[n].geometry.dispose && this.mesh.children[n].geometry.dispose(), this.mesh.children[n].geometry = t, this.mesh.children[n].material = c; this.mesh.rotation.z = MathUtils.degToRad(this.option.direction), this.mesh.position.x = this.option.offset.x, this.mesh.position.y = this.option.offset.y, this.mesh.position.z = this.option.offset.z; let h = _context.animationStore.findLayerAnimation(this.option.name, RainAnimationController.type); h && _context.animationStore.remove(h), h = new RainAnimationController(this.mesh), h.name = this.option.name, _context.animationStore.add(h), null != this.option.enableAutoHidebyDistance && (this.mesh.enableAutoHidebyDistance = this.option.enableAutoHidebyDistance, this.mesh.minDistance = this.option.minDistance, this.mesh.maxDistance = this.option.maxDistance, _context.animationStore.addDistance(this.option.name, DistanceController, _context.camera, this.mesh)) } hide() { this.visible = !1, this.mesh.visible = !1, this.mesh.activeVisible = !1, this.option.visible = !1 } show() { this.visible = !0, this.mesh.visible = !0, this.mesh.activeVisible = !0, this.option.visible = !0 } remove() { let e = _context.animationStore.findLayerAnimation(this.option.name, RainAnimationController.type), t = _context.animationStore.findLayerAnimation(this.option.name, "DistanceController"); e && _context.animationStore.remove(e), t && _context.animationStore.remove(t), _context.scene.spaceEffects.remove(this.mesh), delete this.mesh } } class Snow extends Effect { constructor(e) { super("Snow"), this.name = e.name, this.mesh = new Group, this.mesh.name = e.name, this.mesh.renderOrder = 103, this.visible = !0, this.option = e; for (var t = new BufferGeometry, i = [], r = [], n = (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, "texture/effects/snow.png")), a = 0; a < e.density; a++) { var o = 2e3 * (Math.random() - .5), s = 1e3 * (Math.random() - .5), l = 2e3 * (Math.random() - .5); i.push(o, s, l) } t.setAttribute("position", new Float32BufferAttribute(i, 3)); var c = [[[1, .2, .5], n, e.size], [[1, .2, .2], n, e.size], [[.95, .1, .5], n, e.size]]; for (a = 0; a < c.length; a++) { c[a][0]; n = c[a][1]; var h = c[a][2]; r[a] = new PointsMaterial({ size: h, map: n, blending: NormalBlending, depthWrite: !1, transparent: !0, color: new Color$1("#ffffff") }); var u = new Points(t, r[a]); u.visible = !0, u.rotation.x = 6 * Math.random(), u.rotation.y = 6 * Math.random(), u.rotation.z = 6 * Math.random(), u.position.y = 500 * Math.random() - 250, this.mesh.add(u) } this.mesh.rotation.z = MathUtils.degToRad(this.option.direction), this.mesh.position.x = e.offset.x, this.mesh.position.y = e.offset.y, this.mesh.position.z = e.offset.z, _context.scene.spaceEffects.add(this.mesh); let d = _context.animationStore.findLayerAnimation(e.name, SnowAnimationController.type); d && _context.animationStore.remove(d), d = new SnowAnimationController(this.mesh, e.followCamera), d.name = e.name, _context.animationStore.add(d), null != e.enableAutoHidebyDistance && (this.mesh.activeVisible = !0, this.mesh.enableAutoHidebyDistance = e.enableAutoHidebyDistance, this.mesh.minDistance = e.minDistance, this.mesh.maxDistance = e.maxDistance, _context.animationStore.addDistance(e.name, DistanceController, _context.camera, this.mesh)), null == e.visible ? (this.visible = !0, this.option.visible = !0) : (e.visible, this.visible = e.visible, this.mesh.activeVisible = e.visible, this.mesh.visible = e.visible, this.option.visible = e.visible) } update(e) { for (let t in e) null != this.option[t] ? this.option[t] !== e[t] && (this.option[t] = e[t]) : logger.warn(t + "属性不存在"); for (var t = new BufferGeometry, i = [], r = 0; r < this.option.density; r++) { var n = 2e3 * Math.random() - 1e3, a = 1e3 * Math.random(), o = 2e3 * Math.random() - 1e3; i.push(n, a, o) } t.setAttribute("position", new Float32BufferAttribute(i, 3)); var s = (new TextureLoader).load(util$1.url(_context.instance.resourceBasePath, "texture/effects/snow.png")), l = this.option.size, c = new PointsMaterial({ size: l, map: s, blending: NormalBlending, depthWrite: !1, transparent: !0, color: new Color$1("#ffffff") }); for (r = 0; r < this.mesh.children.length; r++)this.mesh.children[r].geometry.dispose && this.mesh.children[r].geometry.dispose(), this.mesh.children[r].geometry = t, this.mesh.children[r].material = c; this.mesh.rotation.z = MathUtils.degToRad(this.option.direction), this.mesh.position.x = this.option.offset.x, this.mesh.position.y = this.option.offset.y, this.mesh.position.z = this.option.offset.z; let h = _context.animationStore.findLayerAnimation(this.option.name, SnowAnimationController.type); h && _context.animationStore.remove(h), h = new SnowAnimationController(this.mesh), h.name = this.option.name, _context.animationStore.add(h), null != this.option.enableAutoHidebyDistance && (this.mesh.enableAutoHidebyDistance = this.option.enableAutoHidebyDistance, this.mesh.minDistance = this.option.minDistance, this.mesh.maxDistance = this.option.maxDistance, _context.animationStore.addDistance(this.option.name, DistanceController, _context.camera, this.mesh)) } hide() { this.visible = !1, this.mesh.visible = !1, this.mesh.activeVisible = !1, this.option.visible = !1 } show() { this.visible = !0, this.mesh.visible = !0, this.mesh.activeVisible = !0, this.option.visible = !0 } remove() { let e = _context.animationStore.findLayerAnimation(this.mesh.name, SnowAnimationController.type), t = _context.animationStore.findLayerAnimation(this.option.name, "DistanceController"); e && _context.animationStore.remove(e), t && _context.animationStore.remove(t), _context.scene.spaceEffects.remove(this.mesh), delete this.mesh } } class SpaceEffect { constructor() { this._enabled = void 0, this._effects = [], _context.scene.spaceEffects = new Group("__spaceEffects"), _context.scene.spaceEffects.name = "__spaceEffects", _context.scene.add(_context.scene.spaceEffects) } get enabled() { return this._enabled } set enabled(e) { util$1.isBoolean(e) } addEffect(e) { if (void 0 !== this.findEffect(e.name) && this.findEffect(e.name)) logger.warn("name为" + e.name + "的特效已存在"); else if ("firefly" == e.type) { let t = new Firefly(e); this._effects.push(t) } else if ("rainline" == e.type) { let t = new Rainline(e); this._effects.push(t) } else if ("fireworks" == e.type) { let t = new Fireworks(e); this._effects.push(t) } else if ("rain" == e.type) { let t = new Rain(e); this._effects.push(t) } else if ("snow" == e.type) { let t = new Snow(e); this._effects.push(t) } } findEffect(e) { return this._effects.find((t => e === t.name)) } updateEffect(e, t) { void 0 !== this.findEffect(e) && this.findEffect(e) ? this.findEffect(e).update(t) : logger.warn("name为" + e + "的特效不存在") } removeEffect(e) { for (let t = 0; t < this._effects.length; t++)if (e === this._effects[t].name) { util$1.disposeThreeObject(this._effects[t].mesh), this._effects[t].remove(), this._effects.splice(t, 1); break } } renameEffect(e, t) { if (void 0 !== this.findEffect(t) && this.findEffect(t)) if (this.findEffect(e)) logger.warn("name为" + e + "的特效已存在"); else { let i = this.findEffect(t); i.name = e, i.mesh.name = e, i.option.name = e } else logger.warn("name为" + t + "的特效不存在") } hideEffect(e) { void 0 !== this.findEffect(e) && this.findEffect(e) ? this.findEffect(e).hide() : logger.warn("name为" + e + "的特效不存在") } showEffect(e) { void 0 !== this.findEffect(e) && this.findEffect(e) ? this.findEffect(e).show() : logger.warn("name为" + e + "的特效不存在") } hideHelpers() { for (let e = 0; e < this._effects.length; e++)this._effects[e] && "function" == typeof this._effects[e].hideHelper && this._effects[e].hideHelper() } getSettings() { let e = []; for (let t = 0; t < this._effects.length; t++)e.push(JSON.parse(JSON.stringify(this._effects[t]))); return e.map((e => { delete e.mesh })), e } applySettings(e) { if (this._effects && this._effects.length > 0) for (let e = this._effects.length - 1; e >= 0; e--)this.removeEffect(this._effects[e].name); !e || !e.length > 0 || e.map((e => { if ("firefly" === e.option.type) { let t = new Firefly(e.option); this._effects.push(t) } else if ("rainline" === e.option.type) { let t = new Rainline(e.option); this._effects.push(t) } else if ("fireworks" === e.option.type) { let t = new Fireworks(e.option); this._effects.push(t) } else if ("rain" == e.option.type) { let t = new Rain(e.option); this._effects.push(t) } else if ("snow" == e.option.type) { let t = new Snow(e.option); this._effects.push(t) } })) } } class Statistics { constructor() { let e = Date.now(), t = e, i = 0, r = 0; this.start = () => { e = Date.now() }, this.stop = () => { i++; var e = Date.now(); return e >= t + 1e3 && (r = Math.round(1e3 * i / (e - t)), t = e, i = 0), e }, this.update = () => { e = this.stop() }, this.getRendererInfo = e => ({ fps: r, geometries: e.info.memory.geometries, textures: e.info.memory.textures, calls: e.info.render.calls, faces: Math.floor((e.info.render.triangles - 18) / 3) < 0 ? 0 : Math.floor((e.info.render.triangles - 18) / 3), vertices: e.info.render.triangles - 18 < 0 ? 0 : e.info.render.triangles - 18 }) } } class View { constructor({ id: e = util$1.guid(), name: t = "" } = {}, i) { this._id = e, this._name = t, this._camera = { positionX: 0, positionY: 0, positionZ: 0, azimuth: 0, inclination: 0, inclinationMin: 0, inclinationMax: 90, fov: 45, distance: 1500, distanceMin: 350, distanceMax: 2e3, viewDistanceMin: 350, viewDistanceMax: 2e3, viewLimitRadius: 1e8, autoRotate: !1, autoRotateSpeed: 60, duration: 1.5, autoRotateDirection: "CW" }, this._boundary = { enabled: !1 }, this._cameraPath = { enabled: !1 }, this._context = i } get camera() { return this._camera } set camera(e) { this._camera = e, this._context } getSettings() { return this._camera.positionX = this._context.orbitControl.object.position.x, this._camera.positionY = this._context.orbitControl.object.position.y, this._camera.positionZ = this._context.orbitControl.object.position.z, this._camera.azimuth = this._context.orbitControl.getAzimuthalAngle() / Math.PI * 180, this._camera.inclination = this._context.orbitControl.getPolarAngle() / (Math.PI / 2) * 90 - 90, this._camera.inclinationMin = this._context.minInclination, this._camera.inclinationMax = this._context.maxInclination, this._camera.fov = this._context.orbitControl.object.fov, this._camera.distance = Math.abs(this._context.orbitControl.object.position.clone().sub(this._context.orbitControl.target).length()), this._camera.distanceMin = this._context.orbitControl.minDistance, this._camera.distanceMax = this._context.orbitControl.maxDistance, this._camera.viewDistanceMin = this._context.orbitControl.object.near, this._camera.viewDistanceMax = this._context.orbitControl.object.far, this._camera.targetX = this._context.orbitControl.target.x, this._camera.targetY = this._context.orbitControl.target.y, this._camera.targetZ = this._context.orbitControl.target.z, this._camera.inclinationAngleMin = this._context.orbitControl.minPolarAngle / Math.PI * 180 - 90, this._camera.inclinationAngleMax = this._context.orbitControl.maxPolarAngle / Math.PI * 180 - 90, this._camera.viewLimitRadius = this._camera.viewLimitRadius, this._camera.autoRotate = this._camera.autoRotate, this._camera.duration = this._camera.duration, this._camera.autoRotateSpeed = this._camera.autoRotateSpeed, this._camera.autoRotateDirection = this._camera.autoRotateDirection, { camera: this._camera } } applySettings(e, t, i) { if (logger.debug(e), !e) return void logger.error("无效的视野设置。"); this._camera = { ...this._camera, ...e.camera }; let r = this._context.orbitControl.object, n = this._camera.distanceMax, a = this._camera.distanceMin; r.fov = util$1.numberOrDefault(this._camera.fov, r.fov), r.near = util$1.numberOrDefault(this._camera.viewDistanceMin, r.near), r.far = util$1.numberOrDefault(this._camera.viewDistanceMax, r.far), this._context.orbitControl.minDistance = 0, this._context.orbitControl.maxDistance = 1e6, null != e.camera.inclinationAngleMin && (this._context.orbitControl.minPolarAngle = (e.camera.inclinationAngleMin + 90) / 180 * Math.PI), null != e.camera.inclinationAngleMax && (this._context.orbitControl.maxPolarAngle = (e.camera.inclinationAngleMax + 90) / 180 * Math.PI), r.updateProjectionMatrix(), this._context.orbitControl.defaultTargetPosition = new Vector3(this._camera.targetX, this._camera.targetY, this._camera.targetZ), this._context.orbitControl.viewLimitRadius = this._camera.viewLimitRadius, _context.instance.cameraFlyTo(new Vector3(this._camera.targetX, this._camera.targetY, this._camera.targetZ), this._camera.azimuth, this._camera.inclination, this._camera.distance, i ? 0 : this._camera.duration || 0, !0, (() => { this._context.minInclination = util$1.numberOrDefault(this._camera.inclinationMin, this._context.minInclination), this._context.maxInclination = util$1.numberOrDefault(this._camera.inclinationMax, this._context.maxInclination), this._context.orbitControl.minDistance = util$1.numberOrDefault(a, this._context.minDistance), this._context.orbitControl.maxDistance = util$1.numberOrDefault(n, this._context.maxDistance), t && t(1) })) } } View._fromThreeObject = function (e) { if (!e) return new View; return new View }; class VisualEffect { constructor() { this.cachedPasses = -1, this._enabled = void 0, this._size = new Vector2(0, 0), _context.renderer.getSize(this._size), this._passes = {}, this._enableSSR = !1, this._ssrIntensity = 1, this._ssrQuality = 1, this._ssrOpacity = 1, this._ssrThickness = 1, this._ssrMaxDistance = 10, this._enableSSAO = !1, this._ssaoRadius = 5, this._ssaoIntensity = 1, this._ssaoQuality = .5, this._ssaoKernelRadius = 5, this._ssaoMinDistance = 0, this._ssaoMaxDistance = 10, this._enableGrain = !1, this._grainIntensity = .2, this._enableEdgeBlur = !1, this._edgeBlurRadius = .2, this._edgeBlurIntensity = 1, this._enableDOF = !1, this._dofDistanceForground = 10, this._dofDistanceBackground = 100, this._dofQuality = .5, this._dofFocus = "manual", this._dofFocusTarget = new Vector3(0, 0, 0), this._dofFocusDistance = 0, this._dofFocalDistance = .5, this._enableSharpen = !1, this._sharpenIntensity = .1, this._enableChromaticAberration = !1, this._chromaticAberrationIntensity = .2, this._enableBloom = !1, this._bloomThreshold = 1, this._bloomBrightness = 1, this._bloomRadius = 1, this._enableToneMapping = !1, this._toneMappingExposure = 1, this._toneMappingBrightness = 0, this._toneMappingContrast = 0, this._toneMappingHue = 0, this._toneMappingSaturation = 0, this._enableColorBalance = !1, this._colorBalanceHue = 1, this._colorBalanceR = 1, this._colorBalanceG = 1, this._colorBalanceB = 1, this._enableFog = !1, this._fogDistance = 100, this._fogIntensity = 1, this._fogDistanceNear = 10, this._fogDistanceFar = 200, this._fogColor = void 0, this._fogColor0 = void 0, this._fogColorFromSkybox = void 0, this._fogAutoColor = !0, this._enableAntialias = !1, this._antialiasType = "SMAA", this._antialiasSampleCount = 8, this._antialiasColorDiff = !0, this._antialiasPixelReject = !0, this._enableLUT = !1, this._lutIntensity = 1, this._lutSelected = "Arabica 12", this._lutCustom = "", this._lutCustomName = "", this._enableWatermark = !0, this._watermark = ""; const e = new WatermarkEffect; let t = new OutlineEffect(_context.scene, _context.camera, { blendFunction: BlendFunction.SCREEN, edgeStrength: 32, pulseSpeed: 0, visibleEdgeColor: 16772608, hiddenEdgeColor: 14522624, height: 540, blur: !1, xRay: !0 }); this._passes.outlinePass = new EffectPass(_context.camera, t), this._passes.outlinePass.name = "OutlinePass", this._passes.outlinePass.outlineEffect = t; let i = new OutlineEffect(_context.scene, _context.camera, { blendFunction: BlendFunction.SCREEN, edgeStrength: 32, pulseSpeed: 0, height: 1080, blur: !1, xRay: !0 }); i.blur = !0, i.blurPass.kernelSize = 1, this._passes.articulationOutlinePass = new EffectPass(_context.camera, i), this._passes.articulationOutlinePass.name = "ArticulationOutlineEffect", this._passes.articulationOutlinePass.articulationOutlineEffect = i, this._lutMap = { "Arabica 12": null, "Chemical 168": null, "Clayton 33": null, "Django 25": null, "Faded 47": null, "Fusion 88": null, "Hyla 68": null, "Lenox 340": null, "Lucky 64": null, "Paladin 1875": null, "Pasadena 21": null, "Pitaya 15": null, "Sprocket 231": null, "Teigen 28": null, "Zeke 39": null }, this._passes.normalPass = new NormalPass(_context.scene.models, _context.camera), this._passes.normalPass.name = "NormalPass", this._passes.depthDownsamplingPass = new DepthDownsamplingPass({ normalBuffer: this._passes.normalPass.texture, resolutionScale: .5 }), this._passes.depthDownsamplingPass.name = "DepthDownsamplingPass"; const r = _context.renderer.capabilities.isWebGL2 ? this._passes.depthDownsamplingPass.texture : null; let n = new SSAOEffect(_context.camera, this._passes.normalPass.texture, { blendFunction: BlendFunction.MULTIPLY, distanceScaling: !1, depthAwareUpsampling: !0, normalDepthBuffer: r, samples: 9, rings: 7, distanceThreshold: 100 / (_context.camera.far - _context.camera.near), distanceFalloff: 25 / (_context.camera.far - _context.camera.near), rangeThreshold: 1 / (_context.camera.far - _context.camera.near), rangeFalloff: .3 / (_context.camera.far - _context.camera.near), luminanceInfluence: .7, minRadiusScale: .33, radius: .1, intensity: 1, bias: .025, fade: .01, color: new Color$1(0), resolutionScale: .5 }); n.blendMode.opacity.value = 0; const a = new NoiseEffect({ blendFunction: BlendFunction.COLOR_DODGE }); a.blendMode.opacity.value = 0; const o = new DepthOfFieldEffect(_context.camera, { blendFunction: BlendFunction.SKIP, focusDistance: 0, focalLength: .048, bokehScale: 2, height: 720 }); o.blurPass.kernelSize = 5, o.circleOfConfusionMaterial.uniforms.focusDistance.value = 0, o.circleOfConfusionMaterial.uniforms.focalLength.value = .048; const s = new DepthEffect({ blendFunction: BlendFunction.SKIP }), l = new TextureEffect({ blendFunction: BlendFunction.SKIP, texture: o.renderTargetCoC.texture }); let c = new ShaderMaterial(SharpenShader); c.uniforms.width.value = this._size.width, c.uniforms.height.value = this._size.height, c.uniforms.intensity.value = 1, this._passes.sharpenPass = new ShaderPass(c, "tDiffuse"), this._passes.sharpenPass.name = "SharpenPass", this._passes.sharpenPass.sharpenMaterial = c, this._passes.sharpenPass.enabled = !1; let h = new ShaderMaterial(LensDistortionShader); h.shaderType = "LensDistortionShader", h.defines.BAND_MODE = 2, h.defines.CHROMA_SAMPLES = 16, h.uniforms.baseIor.value = 1, h.uniforms.bandOffset.value = 0, h.uniforms.jitterIntensity.value = .5, this._passes.distortPass = new ShaderPass(h, "tDiffuse"), this._passes.distortPass.name = "ChromaticAberrationPass", this._passes.distortPass.distortMaterial = h; let u = new BloomEffect({ blendFunction: BlendFunction.SCREEN, kernelSize: KernelSize$1.MEDIUM, luminanceThreshold: .4, luminanceSmoothing: .1, height: 480 }); u.blendMode.opacity.value = 0, this._enableFog = !1, this._fogDistance = 100, this._fogIntensity = 1, this._fogDistanceNear = 10, this._fogDistanceFar = 200, this._fogColor = void 0, this._fogColor0 = void 0, this._fogColorFromSkybox = void 0, this._fogAutoColor = !0; new SMAAImageLoader(_context.defaultLoadingManager).load((([e, t]) => { const i = new SMAAEffect(e, t, SMAAPreset.ULTRA, EdgeDetectionMode.COLOR); i.edgeDetectionMaterial.setLocalContrastAdaptationFactor(2.5), i.edgeDetectionMaterial.setEdgeDetectionThreshold(.02), i.edgeDetectionMaterial.setPredicationMode(PredicationMode.DEPTH), i.edgeDetectionMaterial.setPredicationThreshold(.02), i.edgeDetectionMaterial.setPredicationScale(1), i.blendMode.opacity.value = 0, this._passes.smaaPass = new EffectPass(_context.camera, i), this._passes.smaaPass.name = "SMAAPass", this._passes.smaaPass.smaaEffect = i, this._passes.smaaPass.renderToScreen = !0, this._passes.smaaPass.encodeOutput = !0, this.addPass(this._passes.smaaPass) })); let d = new BrightnessContrastEffect({ blendFunction: BlendFunction.NORMAL }), p = new HueSaturationEffect({ blendFunction: BlendFunction.NORMAL }); d.uniforms.get("brightness").value = 0, d.uniforms.get("contrast").value = 0, p.setHue(0), p.uniforms.get("saturation").value = 0, this._passes.colorGradingPass = new EffectPass(_context.camera, d, p), this._passes.colorGradingPass.name = "ColorGradingPass", this._passes.colorGradingPass.brightnessContrastEffect = d, this._passes.colorGradingPass.hueSaturationEffect = p, this._passes.ssaoPass = new EffectPass(_context.camera, n), this._passes.ssaoPass.name = "SSAOPass", this._passes.ssaoPass.ssaoEffect = n, this._passes.bloomPass = new EffectPass(_context.camera, u), this._passes.bloomPass.name = "BloomPass", this._passes.bloomPass.bloomEffect = u, this._passes.ssrDepthPass = new DepthPass(_context.scene.models, _context.camera), this._passes.ssrDepthPass.name = "SSRDepthPass"; const f = new SSREffect(_context.camera, { depthBuffer: this._passes.ssrDepthPass.texture, normalBuffer: this._passes.normalPass.texture, width: window.innerWidth, height: window.innerHeight, scene: _context.scene.models, opacity: 1 }); this._passes.ssrPass = new EffectPass(_context.camera, f), this._passes.ssrPass.name = "SSRPass", this._passes.ssrPass.ssrEffect = f, this._passes.ssrDepthPass.enabled = !1, this._passes.ssrPass.enabled = !1, this._passes.dofPass = new EffectPass(_context.camera, o, l, s), this._passes.dofPass.name = "DOFPass", this._passes.dofPass.depthOfFieldEffect = o, this._passes.dofPass.cocTextureEffect = l, this._passes.dofPass.depthEffect = s, this._passes.watermarkPass = new EffectPass(_context.camera, e), this._passes.watermarkPass.name = "WatermarkPass", this._passes.watermarkPass.watermarkEffect = e, _context.composer.addPass(this._passes.watermarkPass), this._passes.grainPass = new EffectPass(_context.camera, a), this._passes.grainPass.name = "GrainPass", _context.composer.addPass(this._passes.outlinePass), _context.composer.addPass(this._passes.articulationOutlinePass), _context.BlendFunction = BlendFunction, this._passes.edgeBlurPass = new EdgeBlurPass, this._passes.edgeBlurPass.name = "EdgeBlurPass", this._passes.edgeBlurPass.enabled = !1, this.addPass = e => { if (this.findActivePassPosition(e.name) > -1) return; let t = this.findPassPosition(e.name); if (t < 1) return; let i = 0; for (let e = t - 1; e > 0; e--) { let t = this.findActivePassPosition(VisualEffect.PASS_ORDER[e]); if (-1 !== t) { i = t; break } } _context.composer.addPass(e, i + 1), this.setRenderToScreen(), this.findActivePassPosition("CacheBufferPass") > -1 ? this.cachedPasses = this.findActivePassPosition("CacheBufferPass") : this.cachedPasses = -1 }, this.removePass = e => { e && (_context.composer.removePass(e), this.setRenderToScreen(), this.findActivePassPosition("CacheBufferPass") > -1 ? this.cachedPasses = this.findActivePassPosition("CacheBufferPass") : this.cachedPasses = -1) }, this.setRenderToScreen = () => { for (let e of _context.composer.passes) e.renderToScreen = !1; _context.composer.passes[_context.composer.passes.length - 1].renderToScreen = !0 }, this.findPassPosition = e => { if (!e) return -1; let t = -1; for (let i = 0; i < VisualEffect.PASS_ORDER.length; i++)VisualEffect.PASS_ORDER[i] === e && (t = i); return t }, this.findActivePassPosition = e => { if (!e) return -1; let t = -1; for (let i = 0; i < _context.composer.passes.length; i++)_context.composer.passes[i].name === e && (t = i); return t } } get enabled() { return this._enabled } set enabled(e) { util$1.isBoolean(e) && (this.enableWatermark = this.enableSSR = this.enableSSAO = this.enableGrain = this.enableDOF = this.enableSharpness = this.enableChromaticAberration = this.enableBloom = this.enableToneMapping = this.enableColorBalance = this.enableFog = this.enableAntialias = this._enabled = e, _context.sceneBufferCacheExpired = !0) } get enableWatermark() { return this._enableWatermark } set enableWatermark(e) { if (!util$1.isBoolean(e)) return; let t = this._enableWatermark = e, i = this._passes.watermarkPass.watermarkEffect, r = t ? BlendFunction.NORMAL : BlendFunction.SKIP; i.blendMode.setBlendFunction(r), _context.sceneBufferCacheExpired = !0 } get watermark() { return this._watermark } set watermark(e) { _context.loaders.textureLoader.load(e, (t => { this._passes.watermarkPass.watermarkEffect.setMap(t), this._watermark = e })), _context.sceneBufferCacheExpired = !0 } get enableSSR() { return this._enableSSR } set enableSSR(e) { util$1.isBoolean(e) && (this._enableSSR = e, this._passes.ssrDepthPass.enabled = this._enableSSR, this._passes.ssrPass.enabled = this._enableSSR, this._enableSSAO || this._enableSSR ? this.addPass(this._passes.normalPass) : this.removePass(this._passes.normalPass), this._enableSSR ? (this.addPass(this._passes.ssrDepthPass), this.addPass(this._passes.ssrPass)) : (this.removePass(this._passes.ssrDepthPass), this.removePass(this._passes.ssrPass)), _context.sceneBufferCacheExpired = !0) } get ssrOpacity() { return this._ssrOpacity } set ssrOpacity(e) { "number" != typeof e || e < 0 || e > 1 || (this._ssrOpacity = e, this._passes.ssrPass.ssrEffect.uniforms.get("opacity").value = this._ssrOpacity, _context.sceneBufferCacheExpired = !0) } get ssrThickness() { return this._ssrThickness } set ssrThickness(e) { "number" != typeof e || e < 0 || (this._ssrThickness = e, this._passes.ssrPass.ssrEffect.uniforms.get("thickness").value = this._ssrThickness, _context.sceneBufferCacheExpired = !0) } get ssrMaxDistance() { return this._ssrMaxDistance } set ssrMaxDistance(e) { "number" != typeof e || e < 0 || (this._ssrMaxDistance = e, this._passes.ssrPass.ssrEffect.uniforms.get("maxDistance").value = this._ssrMaxDistance, _context.sceneBufferCacheExpired = !0) } get ssrIntensity() { return this._ssrIntensity } set ssrIntensity(e) { "number" != typeof e || e < 0 || e > 1 || (this._ssrIntensity = e, this._passes.ssrPass.ssrEffect.uniforms.get("opacity").value = this._ssrIntensity, _context.sceneBufferCacheExpired = !0) } get ssrQuality() { return this._ssrQuality } set ssrQuality(e) { "number" != typeof e || e < 0 || (this._ssrQuality = e, this._passes.ssrPass.ssrEffect.uniforms.get("maxDistance").value = this._ssrQuality, _context.sceneBufferCacheExpired = !0) } get enableSSAO() { return this._enableSSAO } set enableSSAO(e) { if (!util$1.isBoolean(e)) return; this._passes.ssaoPass.ssaoEffect.blendMode.setBlendFunction((this._enableSSAO = e) ? BlendFunction.MULTIPLY : BlendFunction.SKIP); let t = 9; this._ssaoQuality <= .5 && this._ssaoQuality >= 0 ? t = this._ssaoQuality / .5 * 8 + 1 : this._ssaoQuality > .5 && this._ssaoQuality <= 1 && (t = (this._ssaoQuality - .5) / .5 * 91 + 9), this._passes.ssaoPass.ssaoEffect.samples = t, this._passes.ssaoPass.ssaoEffect.blendMode.opacity.value = this._ssaoIntensity; let i = this._ssaoMaxDistance / (_context.camera.far - _context.camera.near), r = i / 4; this._passes.ssaoPass.ssaoEffect.setDistanceCutoff(i, r), this._enableSSAO || this._enableSSR ? this.addPass(this._passes.normalPass) : this.removePass(this._passes.normalPass), this._enableSSAO ? (_context.renderer.capabilities.isWebGL2 && this.addPass(this._passes.depthDownsamplingPass), this.addPass(this._passes.ssaoPass)) : (_context.renderer.capabilities.isWebGL2 && this.removePass(this._passes.depthDownsamplingPass), this.removePass(this._passes.ssaoPass)), _context.sceneBufferCacheExpired = !0 } get ssaoKernelRadius() { return this._ssaoKernelRadius } set ssaoKernelRadius(e) { if ("number" != typeof e) return; this._passes.ssaoPass.ssaoEffect.blendMode.setBlendFunction((this._enableSSAO = this.enableSSAO) ? BlendFunction.MULTIPLY : BlendFunction.SKIP), this._ssaoKernelRadius = Math.max(e, 0); let t = this._ssaoKernelRadius / (_context.camera.far - _context.camera.near), i = t / 3; this._passes.ssaoPass.ssaoEffect.setProximityCutoff(t, i), _context.sceneBufferCacheExpired = !0 } get ssaoMinDistance() { return this._ssaoMinDistance } set ssaoMinDistance(e) { this._passes.ssaoPass.ssaoEffect.blendMode.setBlendFunction((this._enableSSAO = this.enableSSAO) ? BlendFunction.MULTIPLY : BlendFunction.SKIP), this._ssaoMinDistance = e, _context.sceneBufferCacheExpired = !0 } get ssaoMaxDistance() { return this._ssaoMaxDistance } set ssaoMaxDistance(e) { if ("number" != typeof e) return; this._passes.ssaoPass.ssaoEffect.blendMode.setBlendFunction((this._enableSSAO = this.enableSSAO) ? BlendFunction.MULTIPLY : BlendFunction.SKIP), this._ssaoMaxDistance = Math.max(e, 0); let t = this._ssaoMaxDistance / (_context.camera.far - _context.camera.near), i = t / 4; this._passes.ssaoPass.ssaoEffect.setDistanceCutoff(t, i), _context.sceneBufferCacheExpired = !0 } get ssaoRadius() { return this._ssaoRadius } set ssaoRadius(e) { this._passes.ssaoPass.ssaoEffect.blendMode.setBlendFunction((this._enableSSAO = this.enableSSAO) ? BlendFunction.MULTIPLY : BlendFunction.SKIP), this._ssaoRadius = e, _context.sceneBufferCacheExpired = !0 } get ssaoIntensity() { return this._ssaoIntensity } set ssaoIntensity(e) { "number" == typeof e && (this._passes.ssaoPass.ssaoEffect.blendMode.setBlendFunction((this._enableSSAO = this.enableSSAO) ? BlendFunction.MULTIPLY : BlendFunction.SKIP), this._ssaoIntensity = Math.min(Math.max(e, 0), 5), this._passes.ssaoPass.ssaoEffect.blendMode.opacity.value = this._ssaoIntensity, _context.sceneBufferCacheExpired = !0) } get ssaoQuality() { return this._ssaoQuality } set ssaoQuality(e) { this._passes.ssaoPass.ssaoEffect.blendMode.setBlendFunction((this._enableSSAO = this.enableSSAO) ? BlendFunction.MULTIPLY : BlendFunction.SKIP), this._ssaoQuality = e; let t = 9; this._ssaoQuality <= .5 && this._ssaoQuality >= 0 ? t = this._ssaoQuality / .5 * 8 + 1 : this._ssaoQuality > .5 && this._ssaoQuality <= 1 && (t = (this._ssaoQuality - .5) / .5 * 91 + 9), this._passes.ssaoPass.ssaoEffect.samples = t, _context.sceneBufferCacheExpired = !0 } get enableGrain() { return this._enableGrain } set enableGrain(e) { util$1.isBoolean(e) && (this._passes.grainPass.enabled = this._enableGrain = e, this.grainIntensity = this._grainIntensity, this._passes.grainPass.enabled ? this.addPass(this._passes.grainPass) : this.removePass(this._passes.grainPass), _context.sceneBufferCacheExpired = !0) } get grainIntensity() { return this._grainIntensity } set grainIntensity(e) { this._passes.grainPass.enabled = this._enableGrain; let t = util$1.numberOrDefault(e, this._grainIntensity); this._grainIntensity = t, this._passes.grainPass.effects[0].blendMode.opacity.value = this._grainIntensity / 2, _context.sceneBufferCacheExpired = !0 } get enableEdgeBlur() { return this._enableEdgeBlur } set enableEdgeBlur(e) { util$1.isBoolean(e) && (this._enableEdgeBlur = e, this._passes.edgeBlurPass.enabled = e, this._enableEdgeBlur ? this.addPass(this._passes.edgeBlurPass) : this.removePass(this._passes.edgeBlurPass), _context.sceneBufferCacheExpired = !0) } get edgeBlurRadius() { return this._edgeBlurRadius } set edgeBlurRadius(e) { "number" == typeof e && (e < 0 && (e = 0), e > 1 && (e = 1), this._edgeBlurRadius = e, this._passes.edgeBlurPass && (this._passes.edgeBlurPass.radius = 1 - e), _context.sceneBufferCacheExpired = !0) } get edgeBlurIntensity() { return this._edgeBlurIntensity } set edgeBlurIntensity(e) { "number" == typeof e && (e < 0 && (e = 0), e > 1 && (e = 1), this._edgeBlurIntensity = e, this._passes.edgeBlurPass && (this._passes.edgeBlurPass.scale = e), _context.sceneBufferCacheExpired = !0) } get enableDOF() { return this._enableDOF } set enableDOF(e) { util$1.isBoolean(e) && (this._passes.dofPass.depthOfFieldEffect.blendMode.setBlendFunction((this._enableDOF = e) ? BlendFunction.NORMAL : BlendFunction.SKIP), this._enableDOF ? this.addPass(this._passes.dofPass) : this.removePass(this._passes.dofPass), _context.sceneBufferCacheExpired = !0) } get dofQuality() { return this._dofQuality } set dofQuality(e) { "number" == typeof e && (e < 0 && (e = 0), e > 1 && (e = 1), this._dofQuality = e, this._passes.dofPass && this._passes.dofPass.depthOfFieldEffect && (this._passes.dofPass.depthOfFieldEffect.bokehScale = 5 * this._dofQuality), _context.sceneBufferCacheExpired = !0) } get dofFocus() { return this._dofFocus } set dofFocus(e) { "string" == typeof e && "auto" === e && "manual" === e && (this._dofFocus = e, _context.sceneBufferCacheExpired = !0) } get dofFocusTarget() { return this._dofFocusTarget } set dofFocusTarget(e) { } get dofFocusDistance() { return this._dofFocusDistance } set dofFocusDistance(e) { "number" == typeof e && (this._dofFocusDistance = e, this._passes.dofPass.depthOfFieldEffect.circleOfConfusionMaterial.uniforms.focusDistance.value = e, _context.sceneBufferCacheExpired = !0) } get dofFocalDistance() { return this._dofFocalDistance } set dofFocalDistance(e) { "number" == typeof e && (this._dofFocalDistance = e, this._passes.dofPass && this._passes.dofPass.depthOfFieldEffect && (this._passes.dofPass.depthOfFieldEffect.circleOfConfusionMaterial.uniforms.focalLength.value = Math.pow(Math.E, 10 * this._dofFocalDistance) / (_context.camera.far - _context.camera.near), _context.sceneBufferCacheExpired = !0)) } get enableSharpen() { return this._enableSharpen } set enableSharpen(e) { util$1.isBoolean(e) && (this._passes.sharpenPass.enabled = this._enableSharpen = e, this._enableSharpen ? this.addPass(this._passes.sharpenPass) : this.removePass(this._passes.sharpenPass), _context.sceneBufferCacheExpired = !0) } get sharpenIntensity() { return this._sharpenIntensity } set sharpenIntensity(e) { let t = util$1.numberOrDefault(e, this._sharpenIntensity); this._sharpenIntensity = t, this._passes.sharpenPass.sharpenMaterial.uniforms.intensity.value = this._sharpenIntensity, _context.sceneBufferCacheExpired = !0 } get enableChromaticAberration() { return this._enableChromaticAberration } set enableChromaticAberration(e) { util$1.isBoolean(e) && (this._passes.distortPass.distortMaterial.uniforms.bandOffset.value = (this._enableChromaticAberration = e) ? .005 * this._chromaticAberrationIntensity : 0, this._passes.distortPass.enabled = this._enableChromaticAberration, this._enableChromaticAberration ? this.addPass(this._passes.distortPass) : this.removePass(this._passes.distortPass), _context.sceneBufferCacheExpired = !0) } get chromaticAberrationIntensity() { return this._chromaticAberrationIntensity } set chromaticAberrationIntensity(e) { !util$1.isNumber(e) || e < 0 || (this._chromaticAberrationIntensity = e, this._enableChromaticAberration && (this._passes.distortPass.distortMaterial.uniforms.bandOffset.value = .005 * this._chromaticAberrationIntensity), _context.sceneBufferCacheExpired = !0) } get enableBloom() { return this._enableBloom } set enableBloom(e) { util$1.isBoolean(e) && (this._passes.bloomPass.effects[0].blendMode.opacity.value = (this._enableBloom = e) ? 1 : 0, this._enableBloom ? this.addPass(this._passes.bloomPass) : this.removePass(this._passes.bloomPass), _context.sceneBufferCacheExpired = !0) } get bloomThreshold() { return this._bloomThreshold } set bloomThreshold(e) { this._bloomThreshold = e, this._passes.bloomPass.effects[0].luminanceMaterial.uniforms.threshold.value = this._bloomThreshold = e, _context.sceneBufferCacheExpired = !0 } get bloomBrightness() { return this._bloomBrightness } set bloomBrightness(e) { this._passes.bloomPass && (this._passes.bloomPass.effects[0].intensity = this._bloomBrightness = e, _context.sceneBufferCacheExpired = !0) } get bloomRadius() { return this._bloomRadius } set bloomRadius(e) { this._passes.bloomPass.effects[0].kernelSize = Math.round(5 * (this._bloomRadius = e)), _context.sceneBufferCacheExpired = !0 } get enableToneMapping() { return this._enableToneMapping } set enableToneMapping(e) { util$1.isBoolean(e) && this._passes.colorGradingPass && this._passes.colorGradingPass.brightnessContrastEffect && this._passes.colorGradingPass.hueSaturationEffect && (this._enableToneMapping = e, this._enableToneMapping ? this.addPass(this._passes.colorGradingPass) : this.removePass(this._passes.colorGradingPass), _context.sceneBufferCacheExpired = !0) } get toneMappingExposure() { return this._toneMappingExposure } set toneMappingExposure(e) { this.enableToneMapping = this._enableToneMapping, this._toneMappingExposure = e, _context.sceneBufferCacheExpired = !0 } get toneMappingBrightness() { return this._toneMappingBrightness } set toneMappingBrightness(e) { this.enableToneMapping = this._enableToneMapping, this._passes.colorGradingPass && this._passes.colorGradingPass.brightnessContrastEffect && ("number" != typeof e || e < -1 || e > 1 || (this._passes.colorGradingPass.brightnessContrastEffect.uniforms.get("brightness").value = this._toneMappingBrightness = e, _context.sceneBufferCacheExpired = !0)) } get toneMappingContrast() { return this._toneMappingContrast } set toneMappingContrast(e) { this.enableToneMapping = this._enableToneMapping, this._passes.colorGradingPass && this._passes.colorGradingPass.brightnessContrastEffect && ("number" != typeof e || e < -1 || e > 1 || (e > .99 && (e = .99), this._passes.colorGradingPass.brightnessContrastEffect.uniforms.get("contrast").value = this._toneMappingContrast = e, _context.sceneBufferCacheExpired = !0)) } get toneMappingHue() { return this._toneMappingHue } set toneMappingHue(e) { this.enableToneMapping = this._enableToneMapping, this._passes.colorGradingPass && this._passes.colorGradingPass.hueSaturationEffect && ("number" != typeof e || e < -180 || e > 180 || (this._passes.colorGradingPass.hueSaturationEffect.setHue(MathUtils.degToRad(this._toneMappingHue = e)), _context.sceneBufferCacheExpired = !0)) } get toneMappingSaturation() { return this._toneMappingSaturation } set toneMappingSaturation(e) { this.enableToneMapping = this._enableToneMapping, this._passes.colorGradingPass && this._passes.colorGradingPass.hueSaturationEffect && ("number" != typeof e || e < -1 || e > 1 || (this._passes.colorGradingPass.hueSaturationEffect.uniforms.get("saturation").value = this._toneMappingSaturation = e, _context.sceneBufferCacheExpired = !0)) } get enableFog() { return this._enableFog } set enableFog(e) { util$1.isBoolean(e) && (this._enableFog = e, this._setFog()) } get fogDistanceNear() { return this._fogDistanceNear } set fogDistanceNear(e) { "number" != typeof e || e < 0 || (this._fogDistanceNear = e, this._setFog()) } get fogDistanceFar() { return this._fogDistanceFar } set fogDistanceFar(e) { "number" != typeof e || e < 0 || (this._fogDistanceFar = e, this._setFog()) } get fogAutoColor() { return this._fogAutoColor } set fogAutoColor(e) { util$1.isBoolean(e) && (this._fogAutoColor = e, this._setFog()) } get fogColor() { return this._fogColor } set fogColor(e) { util$1.isCSSColor(e) && (this._fogColor = e, this._setFog()) } _setFog() { switch (_context.scene.fog = null, util$1.isCSSColor(this._fogColor) || util$1.isCSSColor(this._fogColor0) || (this._fogColor = "#cccccc"), this._enableFog ? this._fogAutoColor ? _context.scene.fog = new Fog(this._fogColorFromSkybox, this._fogDistanceNear, this._fogDistanceFar) : _context.scene.fog = new Fog(this._fogColor, this._fogDistanceNear, this._fogDistanceFar) : this._fogAutoColor ? _context.scene.fog = new Fog(this._fogColorFromSkybox, 5e8, 500000001) : _context.scene.fog = new Fog(this._fogColor, 5e8, 500000001), _context.renderer.outputEncoding) { case sRGBEncoding: _context.scene.fog.color.convertSRGBToLinear(); break; case GammaEncoding: _context.scene.fog.color.convertGammaToLinear() }_context.sceneBufferCacheExpired = !0 } get enableAntialias() { return this._enableAntialias } set enableAntialias(e) { this._passes.smaaPass && util$1.isBoolean(e) && (this._passes.smaaPass.effects[0].blendMode.opacity.value = (this._enableAntialias = e) ? 1 : 0, _context.sceneBufferCacheExpired = !0) } get antialiasType() { return this._antialiasType } set antialiasType(e) { this._antialiasType = e } get antialiasSampleCount() { return this._antialiasSampleCount } set antialiasSampleCount(e) { this._antialiasSampleCount = e, this._setAntialias() } get antialiasColorDiff() { return this._antialiasColorDiff } set antialiasColorDiff(e) { this._antialiasColorDiff = e, this._setAntialias() } get antialiasPixelReject() { return this._antialiasPixelReject } set antialiasPixelReject(e) { this._antialiasPixelReject = e, this._setAntialias() } _setAntialias() { } get enableLUT() { return this._enableLUT } set enableLUT(e) { let t = this._enableLUT; this._enableLUT = e, this._passes.lutPass && (t != e && (_context.instance.crossfadeFreeze(), _context.instance.crossfade(1e3)), this._passes.lutPass.enabled = this._enableLUT, _context.sceneBufferCacheExpired = !0) } get availableLUTs() { let e = []; for (let t in this._lutMap) e.push(t); return e } get lutIntensity() { return this._lutIntensity } set lutIntensity(e) { if (!util$1.isNumber(e)) return; e < 0 && (e = 0), e > 1 && (e = 1); let t = this._lutIntensity; this._lutIntensity = e, this._passes.lutPass && (t != e && _context.instance.crossfadeFreeze(), this._passes.lutPass.effects[0].blendMode.opacity.value = this._lutIntensity, t != e && _context.instance.crossfade(1e3)), _context.sceneBufferCacheExpired = !0 } get lutSelected() { return this._lutSelected } set lutSelected(e) { if ("CUSTOM" === e) { if (!this._lutCustom) return; this._addLUTCube(this._lutCustom, "CUSTOM") } else e.indexOf(".CUBE") > 0 && (e = e.replace(".CUBE", "")), this._lutMap.hasOwnProperty(e) || (e = "Arabica 12"), this._addLUTCube(util$1.url(_context.instance.resourceBasePath, `texture/luts/${e}.CUBE`), e); _context.sceneBufferCacheExpired = !0 } get lutCustom() { return this._lutCustom } set lutCustom(e) { if (this._lutCustom = e, "" !== e) try { this._addLUTCube(e, "CUSTOM") } catch (t) { e = "" } "CUSTOM" === this._lutSelected && "" === e && (this._passes.lutPass && (this._passes.lutPass.enabled = !1, this._passes.lutPass = null), delete this._lutMap.CUSTOM), _context.sceneBufferCacheExpired = !0 } get lutCustomName() { return this.lutCustomName } set lutCustomName(e) { this._lutCustomName = e } nextLUT() { if (!this._enableLUT) return; if ("Zeke 39" === this.lutSelected) return this.lutSelected = "Arabica 12", "Arabica 12"; let e = ""; for (let t in this._lutMap) { if ("" !== e) { this.lutSelected = t; break } this._lutMap[t] === this._passes.lutPass.effects[0].getLUT() && (e = t) } return _context.sceneBufferCacheExpired = !0, this.lutSelected } _addLUTCube(e, t) { if (this._lutSelected = t, this._lutMap[t] && this._lutMap[t].image && "string" != typeof this._lutMap[t].image && this._passes.lutPass) this._passes.lutPass.effects[0].setLUT(this._lutMap[t]); else if (this._passes.lutPass) try { new LUTCubeLoader(_context.defaultLoadingManager).load(e, (e => { if (_context.instance.crossfadeFreeze(), !this._passes.lutPass) return; const i = LookupTexture3D.from(e); this._passes.lutPass.effects[0].setLUT(i), this._lutMap[t] = i, _context.instance.crossfade(1e3) })) } catch (e) { logger.warn("无效的 3D LUT 文件。"), _context.instance.crossfade(1e3) } else new LUTCubeLoader(_context.defaultLoadingManager).load(e, (e => { _context.instance.crossfadeFreeze(); try { const i = LookupTexture3D.from(e); let r = _context.renderer.capabilities.isWebGL2 ? new LUTEffect(i) : new LUTEffect(i.convertToUint8().toDataTexture()); this._passes.lutPass ? this._lutSelected === t && this._passes.lutPass.effects[0].setLUT(this._lutMap[t]) : this._lutSelected === t && (this._passes.lutPass = new EffectPass(_context.camera, r), this._passes.lutPass.name = "LUTPass", this._passes.lutPass.enabled = this._enableLUT, this._passes.lutPass.effects[0].blendMode.opacity.value = this._lutIntensity, this.addPass(this._passes.lutPass), this._lutMap[t] = i), _context.instance.crossfade(1e3) } catch (e) { logger.warn("无效的 3D LUT 文件。", e), _context.instance.crossfade(1e3) } }), (e => { }), (e => { logger.warn("无效的 3D LUT 文件。", e), _context.instance.crossfade(1e3) })) } _updateDOFCameraProjection(e) { this._updateCameraProjection(e) } _updateCameraProjection(e) { e && "number" == typeof e.far && "number" == typeof e.near && (this._passes.dofPass && this._passes.dofPass.depthOfFieldEffect && (this._passes.dofPass.depthOfFieldEffect.circleOfConfusionMaterial.adoptCameraSettings(e), this.dofFocalDistance = this._dofFocalDistance), this._passes.ssaoPass && this._passes.ssaoPass.ssaoEffect && (this._passes.ssaoPass.ssaoEffect.ssaoMaterial.adoptCameraSettings(e), this.ssaoKernelRadius = this._ssaoKernelRadius, this.ssaoMaxDistance = this._ssaoMaxDistance), _context.sceneBufferCacheExpired = !0) } getSettings() { let e = {}; for (let t in this) "_composer" !== t && "_context" !== t && "_scene" !== t && "_renderer" !== t && "_camera" !== t && "_cameraControl" !== t && "_context" !== t && "_enabled" !== t && "_size" !== t && "_passes" !== t && "function" != typeof this[t] && (e[t.replace("_", "")] = this[t]); return e } applySettings(e) { if (e) { for (let t in e) if (this[t] = e[t], "lutMap" === t) for (let i in e[t]) for (let r in this._lutMap) r === i && (this._lutMap[r] || (this._lutMap[r] = e[t][i])) } else logger.error("无效的场景特效设置。") } } VisualEffect.PASS_ORDER = ["RenderPass", "DepthDownsamplingPass", "NormalPass", "SSAOPass", "BloomPass", "SSRDepthPass", "SSRPass", "DOFPass", "WatermarkPass", "LUTPass", "ChromaticAberrationPass", "SharpenPass", "ColorGradingPass", "OutlinePass", "ArticulationOutlineEffect", "EdgeBlurPass", "CacheBufferPass", "GrainPass", "SMAAPass"]; var LightProbeGenerator = { fromCubeTexture: function (e) { for (var t, i, r, n = 0, a = new Vector3, o = new Vector3, s = new Color$1, l = [0, 0, 0, 0, 0, 0, 0, 0, 0], c = new SphericalHarmonics3, h = c.coefficients, u = 0; u < 6; u++) { var d = e.image[u], p = d.width, f = d.height, m = document.createElement("canvas"); m.width = p, m.height = f; var g = m.getContext("2d"); g.drawImage(d, 0, 0, p, f); for (var y = g.getImageData(0, 0, p, f), v = y.data, _ = y.width, b = 2 / _, x = 0, w = v.length; x < w; x += 4) { s.setRGB(v[x] / 255, v[x + 1] / 255, v[x + 2] / 255), convertColorToLinear(s, e.encoding); var S = x / 4, M = (S % _ + .5) * b - 1, T = 1 - (Math.floor(S / _) + .5) * b; switch (u) { case 0: a.set(-1, T, -M); break; case 1: a.set(1, T, M); break; case 2: a.set(-M, 1, -T); break; case 3: a.set(-M, -1, T); break; case 4: a.set(-M, T, 1); break; case 5: a.set(M, T, -1) }i = a.lengthSq(), n += r = 4 / (Math.sqrt(i) * i), o.copy(a).normalize(), SphericalHarmonics3.getBasisAt(o, l); for (var A = 0; A < 9; A++)h[A].x += l[A] * s.r * r, h[A].y += l[A] * s.g * r, h[A].z += l[A] * s.b * r } } t = 4 * Math.PI / n; for (A = 0; A < 9; A++)h[A].x *= t, h[A].y *= t, h[A].z *= t; return new LightProbe(c) }, fromCubeRenderTarget: function (e, t) { for (var i, r, n, a = 0, o = new Vector3, s = new Vector3, l = new Color$1, c = [0, 0, 0, 0, 0, 0, 0, 0, 0], h = new SphericalHarmonics3, u = h.coefficients, d = 0; d < 6; d++) { var p = t.width, f = new Uint8Array(p * p * 4); e.readRenderTargetPixels(t, 0, 0, p, p, f, d); for (var m = 2 / p, g = 0, y = f.length; g < y; g += 4) { l.setRGB(f[g] / 255, f[g + 1] / 255, f[g + 2] / 255), convertColorToLinear(l, t.texture.encoding); var v = g / 4, _ = (v % p + .5) * m - 1, b = 1 - (Math.floor(v / p) + .5) * m; switch (d) { case 0: o.set(1, b, -_); break; case 1: o.set(-1, b, _); break; case 2: o.set(_, 1, -b); break; case 3: o.set(_, -1, b); break; case 4: o.set(_, b, 1); break; case 5: o.set(-_, b, -1) }r = o.lengthSq(), a += n = 4 / (Math.sqrt(r) * r), s.copy(o).normalize(), SphericalHarmonics3.getBasisAt(s, c); for (var x = 0; x < 9; x++)u[x].x += c[x] * l.r * n, u[x].y += c[x] * l.g * n, u[x].z += c[x] * l.b * n } } i = 4 * Math.PI / a; for (x = 0; x < 9; x++)u[x].x *= i, u[x].y *= i, u[x].z *= i; return new LightProbe(h) } }, convertColorToLinear = function (e, t) { switch (t) { case sRGBEncoding: e.convertSRGBToLinear(); break; case LinearEncoding: break; default: console.warn("WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.") }return e }, OrbitControls = function (e, t, i = !0) { var r, n, a, o, s, l; void 0 === t && logger.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), t === document && logger.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.targetLimit = { limitHeight: [-1 / 0, 1 / 0], center: [0, 0], radius: 1 / 0 }, this.object = e, this.domElement = t, this.enabled = !0, this.target = new Vector3, this.minDistance = 3, this.maxDistance = this.object.far, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = i, this.zoomSpeed = 1, this.enableRotate = i, this.rotateSpeed = 1, this.enablePan = i, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }, this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN }, this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.keyOperate = null, this.getPolarAngle = function () { return g.phi }, this.getAzimuthalAngle = function () { return g.theta }, this.listenToKeyEvents = function (e) { e.addEventListener("keydown", ee), this._domElementKeyEvents = e }, this.setDistanceToTarget = function (e) { (new Date).getTime() / 1e3 - _context.renderer.lastResize > 1 && (c.target.sub(c.object.position), c.target.setLength(e), c.target.add(c.object.position)) }, this.saveState = function () { c.target0.copy(c.target), c.position0.copy(c.object.position), c.zoom0 = c.object.zoom }, this.reset = function () { c.target.copy(c.target0), c.object.position.copy(c.position0), c.object.zoom = c.zoom0, c.object.updateProjectionMatrix(), c.dispatchEvent(h), c.update(), f = p.NONE }, this.update = (r = new Vector3, n = (new Quaternion).setFromUnitVectors(e.up, new Vector3(0, 1, 0)), a = n.clone().invert(), o = new Vector3, s = new Quaternion, l = 2 * Math.PI, function (e) { var t = c.object.position; r.copy(t).sub(c.target), r.applyQuaternion(n), g.setFromVector3(r), e > 1 && logger.warn("orbitControls update delta > 1", e), c.autoRotate && f === p.NONE && D(function (e) { return e ? 2 * Math.PI / 60 / 60 * c.autoRotateSpeed * e / .0167 : 2 * Math.PI / 60 / 60 * c.autoRotateSpeed }(e)), c.enableDamping && (e < 4 || void 0 === e) ? (g.theta += y.theta * c.dampingFactor, g.phi += y.phi * c.dampingFactor) : (g.theta += y.theta, g.phi += y.phi); var i = c.minAzimuthAngle, u = c.maxAzimuthAngle; return isFinite(i) && isFinite(u) && (i < -Math.PI ? i += l : i > Math.PI && (i -= l), u < -Math.PI ? u += l : u > Math.PI && (u -= l), g.theta = i <= u ? Math.max(i, Math.min(u, g.theta)) : g.theta > (i + u) / 2 ? Math.max(i, g.theta) : Math.min(u, g.theta)), g.phi = Math.max(c.minPolarAngle, Math.min(c.maxPolarAngle, g.phi)), g.makeSafe(), g.radius *= v, g.radius = Math.max(c.minDistance, Math.min(c.maxDistance, g.radius)), !0 === c.enableDamping && (e < 4 || void 0 === e) ? c.target.addScaledVector(_, c.dampingFactor) : c.target.add(_), function () { if (c.targetLimit.radius !== 1 / 0) { const e = c.targetLimit.center, t = new Vector3(e[0], 0, e[1]), i = c.target, r = new Vector3(i.x, 0, i.z); Math.abs(t.distanceTo(r)) > c.targetLimit.radius && (r.sub(t).setLength(r.length() - c.targetLimit.radius), c.target.sub(r)) } c.targetLimit.limitHeight[0] !== -1 / 0 && c.target.y < c.targetLimit.limitHeight[0] && (c.target.y = c.targetLimit.limitHeight[0]), c.targetLimit.limitHeight[1] !== 1 / 0 && c.target.y > c.targetLimit.limitHeight[1] && (c.target.y = c.targetLimit.limitHeight[1]) }(), r.setFromSpherical(g), r.applyQuaternion(a), t.copy(c.target).add(r), c.object.lookAt(c.target), !0 === c.enableDamping && (e < 4 || void 0 === e) ? (y.theta *= 1 - c.dampingFactor, y.phi *= 1 - c.dampingFactor, _.multiplyScalar(1 - c.dampingFactor)) : (y.set(0, 0, 0), _.set(0, 0, 0)), v = 1, !!(b || o.distanceToSquared(c.object.position) > m || 8 * (1 - s.dot(c.object.quaternion)) > m) && (c.dispatchEvent(h), o.copy(c.object.position), s.copy(c.object.quaternion), b = !1, !0) }), this.dispose = function () { c.domElement.removeEventListener("contextmenu", ne), c.domElement.removeEventListener("pointerdown", X), c.domElement.removeEventListener("wheel", Q), c.domElement.removeEventListener("touchstart", te), c.domElement.removeEventListener("touchend", re), c.domElement.removeEventListener("touchmove", ie), c.domElement.ownerDocument.removeEventListener("pointermove", Z), c.domElement.ownerDocument.removeEventListener("pointerup", q), null !== c._domElementKeyEvents && c._domElementKeyEvents.removeEventListener("keydown", ee) }; var c = this, h = { type: "change" }, u = { type: "start" }, d = { type: "end" }, p = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }, f = p.NONE, m = 1e-6, g = new Spherical, y = new Spherical, v = 1, _ = new Vector3, b = !1, x = new Vector2, w = new Vector2, S = new Vector2, M = new Vector2, T = new Vector2, A = new Vector2, E = new Vector2, C = new Vector2, L = new Vector2; function R() { return Math.pow(.95, c.zoomSpeed) } function D(e) { y.theta -= e } function P(e) { y.phi -= e } var O, I = (O = new Vector3, function (e, t) { O.setFromMatrixColumn(t, 0), O.multiplyScalar(-e), _.add(O) }), k = function () { var e = new Vector3; return function (t, i) { !0 === c.screenSpacePanning ? e.setFromMatrixColumn(i, 1) : (e.setFromMatrixColumn(i, 0), e.crossVectors(c.object.up, e)), e.multiplyScalar(t), _.add(e) } }(), B = function () { var e = new Vector3; return function (t, i) { var r = c.domElement; if (c.object.isPerspectiveCamera) { var n = c.object.position; e.copy(n).sub(c.target); var a = e.length(); a *= Math.tan(c.object.fov / 2 * Math.PI / 180), I(2 * t * a / r.clientHeight, c.object.matrix), k(2 * i * a / r.clientHeight, c.object.matrix); let o = c.target.clone(); if (o.add(_), c.defaultTargetPosition && 0 != c.viewLimitRadius && c.viewLimitRadius) { o.distanceTo(c.defaultTargetPosition) > c.viewLimitRadius && _.set(0, 0, 0) } } else c.object.isOrthographicCamera ? (I(t * (c.object.right - c.object.left) / c.object.zoom / r.clientWidth, c.object.matrix), k(i * (c.object.top - c.object.bottom) / c.object.zoom / r.clientHeight, c.object.matrix)) : (logger.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), c.enablePan = !1); c.dispatchEvent({ type: "pan" }) } }(); function N(e) { if (c.object.isPerspectiveCamera) v /= e; else if (c.object.isOrthographicCamera) { if ("scene" === c.zoomCenter) { let t = c.object.position.clone(), i = c.object.zoom; c.object.zoom = Math.max(c.minZoom, Math.min(c.maxZoom, c.object.zoom * e)), t.multiplyScalar(i / c.object.zoom); const r = c.zoomAxis || "y"; "y" === r && (c.object.position.set(t.x, c.object.position.y, t.z), c.target.set(t.x, 0, t.z)), "z" === r && (c.object.position.set(t.x, t.y, c.object.position.z), c.target.set(t.x, t.y, 0)), c.update() } else c.object.zoom = Math.max(c.minZoom, Math.min(c.maxZoom, c.object.zoom * e)); c.object.updateProjectionMatrix(), b = !0 } else logger.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), c.enableZoom = !1 } function F(e) { if (c.object.isPerspectiveCamera) v *= e; else if (c.object.isOrthographicCamera) { if ("scene" === c.zoomCenter) { let t = c.object.position.clone(), i = c.object.zoom; c.object.zoom = Math.max(c.minZoom, Math.min(c.maxZoom, c.object.zoom / e)), t.multiplyScalar(i / c.object.zoom); const r = c.zoomAxis || "y"; "y" === r && (c.object.position.set(t.x, c.object.position.y, t.z), c.target.set(t.x, 0, t.z)), "z" === r && (c.object.position.set(t.x, t.y, c.object.position.z), c.target.set(t.x, t.y, 0)), c.update() } else c.object.zoom = Math.max(c.minZoom, Math.min(c.maxZoom, c.object.zoom / e)); c.object.updateProjectionMatrix(), b = !0 } else logger.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), c.enableZoom = !1 } function U(e) { x.set(e.clientX, e.clientY) } function z(e) { E.set(e.clientX, e.clientY) } function G(e) { M.set(e.clientX, e.clientY) } function H(e) { if (1 == e.touches.length) x.set(e.touches[0].pageX, e.touches[0].pageY); else { var t = .5 * (e.touches[0].pageX + e.touches[1].pageX), i = .5 * (e.touches[0].pageY + e.touches[1].pageY); x.set(t, i) } } function V(e) { if (1 == e.touches.length) M.set(e.touches[0].pageX, e.touches[0].pageY); else { var t = .5 * (e.touches[0].pageX + e.touches[1].pageX), i = .5 * (e.touches[0].pageY + e.touches[1].pageY); M.set(t, i) } } function j(e) { var t = e.touches[0].pageX - e.touches[1].pageX, i = e.touches[0].pageY - e.touches[1].pageY, r = Math.sqrt(t * t + i * i); E.set(0, r) } function W(e) { if (1 == e.touches.length) w.set(e.touches[0].pageX, e.touches[0].pageY); else { var t = .5 * (e.touches[0].pageX + e.touches[1].pageX), i = .5 * (e.touches[0].pageY + e.touches[1].pageY); w.set(t, i) } S.subVectors(w, x).multiplyScalar(c.rotateSpeed); var r = c.domElement; D(2 * Math.PI * S.x / r.clientHeight), P(2 * Math.PI * S.y / r.clientHeight), x.copy(w) } function $(e) { if (1 == e.touches.length) T.set(e.touches[0].pageX, e.touches[0].pageY); else { var t = .5 * (e.touches[0].pageX + e.touches[1].pageX), i = .5 * (e.touches[0].pageY + e.touches[1].pageY); T.set(t, i) } A.subVectors(T, M).multiplyScalar(c.panSpeed), B(A.x, A.y), M.copy(T) } function Y(e) { var t = e.touches[0].pageX - e.touches[1].pageX, i = e.touches[0].pageY - e.touches[1].pageY, r = Math.sqrt(t * t + i * i); C.set(0, r), L.set(0, Math.pow(C.y / E.y, c.zoomSpeed)), N(L.y), E.copy(C) } function X(e) { if (!1 !== c.enabled) switch (e.pointerType) { case "mouse": case "pen": switch (c.keyOperate) { case "translation": 0 === e.button && J(e); break; case "rotate": 0 === e.button && K(e); break; case "zoom": 0 === e.button && function (e) { if (e.preventDefault(), c.domElement.focus ? c.domElement.focus() : window.focus(), !1 === c.enableZoom) return; z(e), (f = p.DOLLY) !== p.NONE && (c.domElement.ownerDocument.addEventListener("pointermove", Z), c.domElement.ownerDocument.addEventListener("pointerup", q), c.dispatchEvent(u)) }(e); break; case "paint": 2 === e.button && K(e), 1 === e.button && J(e); break; default: !function (e) { var t; switch (e.preventDefault(), c.domElement.focus ? c.domElement.focus() : window.focus(), e.button) { case 0: t = c.mouseButtons.LEFT; break; case 1: t = c.mouseButtons.MIDDLE; break; case 2: t = c.mouseButtons.RIGHT; break; default: t = -1 }switch (t) { case MOUSE.DOLLY: if (!1 === c.enableZoom) return; z(e), f = p.DOLLY; break; case MOUSE.ROTATE: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === c.enablePan) return; G(e), f = p.PAN } else { if (!1 === c.enableRotate) return; U(e), f = p.ROTATE } break; case MOUSE.PAN: if (e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === c.enableRotate) return; U(e), f = p.ROTATE } else { if (!1 === c.enablePan) return; G(e), f = p.PAN } break; default: f = p.NONE }f !== p.NONE && (c.domElement.ownerDocument.addEventListener("pointermove", Z), c.domElement.ownerDocument.addEventListener("pointerup", q), c.dispatchEvent(u)); "function" == typeof c.onPanStart && c.onPanStart(e) }(e) } } } function Z(e) { if (!1 !== c.enabled) switch (e.pointerType) { case "mouse": case "pen": !function (e) { if (!1 === c.enabled) return; switch (e.preventDefault(), f) { case p.ROTATE: if (!1 === c.enableRotate) return; !function (e) { w.set(e.clientX, e.clientY), S.subVectors(w, x).multiplyScalar(c.rotateSpeed); var t = c.domElement; D(2 * Math.PI * S.x / t.clientHeight), P(2 * Math.PI * S.y / t.clientHeight), x.copy(w), c.update() }(e); break; case p.DOLLY: if (!1 === c.enableZoom) return; !function (e) { C.set(e.clientX, e.clientY), L.subVectors(C, E), L.y > 0 ? N(R()) : L.y < 0 && F(R()), E.copy(C), c.update() }(e); break; case p.PAN: if (!1 === c.enablePan) return; !function (e) { T.set(e.clientX, e.clientY), A.subVectors(T, M).multiplyScalar(c.panSpeed), B(A.x, A.y), M.copy(T), c.update() }(e) } }(e) } } function q(e) { switch (e.pointerType) { case "mouse": case "pen": !function (e) { if (c.domElement.ownerDocument.removeEventListener("pointermove", Z), c.domElement.ownerDocument.removeEventListener("pointerup", q), !1 === c.enabled) return; c.dispatchEvent(d), f = p.NONE, "function" == typeof c.onPanEnd && c.onPanEnd(e) }(e) } } function J(e) { if (e.preventDefault(), c.domElement.focus ? c.domElement.focus() : window.focus(), e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === c.enableRotate) return; U(e), f = p.ROTATE } else { if (!1 === c.enablePan) return; G(e), f = p.PAN } f !== p.NONE && (c.domElement.ownerDocument.addEventListener("pointermove", Z), c.domElement.ownerDocument.addEventListener("pointerup", q), c.dispatchEvent(u)) } function K(e) { if (e.preventDefault(), c.domElement.focus ? c.domElement.focus() : window.focus(), e.ctrlKey || e.metaKey || e.shiftKey) { if (!1 === c.enablePan) return; G(e), f = p.PAN } else { if (!1 === c.enableRotate) return; U(e), f = p.ROTATE } f !== p.NONE && (c.domElement.ownerDocument.addEventListener("pointermove", Z), c.domElement.ownerDocument.addEventListener("pointerup", q), c.dispatchEvent(u)) } function Q(e) { !1 === c.enabled || !1 === c.enableZoom || f !== p.NONE && f !== p.ROTATE || (e.preventDefault(), e.stopPropagation(), c.dispatchEvent(u), function (e) { e.deltaY < 0 ? F(R()) : e.deltaY > 0 && N(R()), c.update() }(e), c.dispatchEvent(d)) } function ee(e) { !1 !== c.enabled && !1 !== c.enablePan && function (e) { var t = !1; switch (e.keyCode) { case c.keys.UP: B(0, c.keyPanSpeed), t = !0; break; case c.keys.BOTTOM: B(0, -c.keyPanSpeed), t = !0; break; case c.keys.LEFT: B(c.keyPanSpeed, 0), t = !0; break; case c.keys.RIGHT: B(-c.keyPanSpeed, 0), t = !0 }t && (e.preventDefault(), c.update()) }(e) } function te(e) { if (!1 !== c.enabled) { switch (e.preventDefault(), e.touches.length) { case 1: switch (c.touches.ONE) { case TOUCH.ROTATE: if (!1 === c.enableRotate) return; H(e), f = p.TOUCH_ROTATE; break; case TOUCH.PAN: if (!1 === c.enablePan) return; V(e), f = p.TOUCH_PAN; break; default: f = p.NONE }break; case 2: switch (c.touches.TWO) { case TOUCH.DOLLY_PAN: if (!1 === c.enableZoom && !1 === c.enablePan) return; !function (e) { c.enableZoom && j(e), c.enablePan && V(e) }(e), f = p.TOUCH_DOLLY_PAN; break; case TOUCH.DOLLY_ROTATE: if (!1 === c.enableZoom && !1 === c.enableRotate) return; !function (e) { c.enableZoom && j(e), c.enableRotate && H(e) }(e), f = p.TOUCH_DOLLY_ROTATE; break; default: f = p.NONE }break; default: f = p.NONE }f !== p.NONE && c.dispatchEvent(u) } } function ie(e) { if (!1 !== c.enabled) switch (e.preventDefault(), e.stopPropagation(), f) { case p.TOUCH_ROTATE: if (!1 === c.enableRotate) return; W(e), c.update(); break; case p.TOUCH_PAN: if (!1 === c.enablePan) return; $(e), c.update(); break; case p.TOUCH_DOLLY_PAN: if (!1 === c.enableZoom && !1 === c.enablePan) return; !function (e) { c.enableZoom && Y(e), c.enablePan && $(e) }(e), c.update(); break; case p.TOUCH_DOLLY_ROTATE: if (!1 === c.enableZoom && !1 === c.enableRotate) return; !function (e) { c.enableZoom && Y(e), c.enableRotate && W(e) }(e), c.update(); break; default: f = p.NONE } } function re(e) { !1 !== c.enabled && (c.dispatchEvent(d), f = p.NONE) } function ne(e) { !1 !== c.enabled && e.preventDefault() } c.domElement.addEventListener("contextmenu", ne), c.domElement.addEventListener("pointerdown", X), c.domElement.addEventListener("wheel", Q), c.domElement.addEventListener("touchstart", te), c.domElement.addEventListener("touchend", re), c.domElement.addEventListener("touchmove", ie) }; OrbitControls.prototype = Object.create(EventDispatcher.prototype), OrbitControls.prototype.constructor = OrbitControls; var MapControls = function (e, t) { OrbitControls.call(this, e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = MOUSE.PAN, this.mouseButtons.RIGHT = MOUSE.ROTATE, this.touches.ONE = TOUCH.PAN, this.touches.TWO = TOUCH.DOLLY_ROTATE }; MapControls.prototype = Object.create(EventDispatcher.prototype), MapControls.prototype.constructor = MapControls; class PreviewMaterial { constructor(e, t, i, r) { this.container = e, _context.materialPreview = {}, _context.materialPreview.renderer = new WebGLRenderer({ antialias: !0, alpha: !0 }), _context.materialPreview.scene = new Scene, _context.materialPreview.scene.background = new Color$1(3026737); const n = new AmbientLight(16777215, 1); _context.materialPreview.scene.add(n); let a = new DirectionalLight(16777215, 1), o = new DirectionalLight(16777215, .8), s = new DirectionalLight(16777215, .6); a.position.set(10, 7, 10), o.position.set(-10, 2, 10), s.position.set(0, 0, -10), a.target.position.set(0, 0, 0), o.target.position.set(0, 0, 0), s.target.position.set(0, 0, 0), _context.materialPreview.scene.add(a), _context.materialPreview.scene.add(o), _context.materialPreview.scene.add(s), _context.materialPreview.camera = new PerspectiveCamera(50, e.getBoundingClientRect().width / e.getBoundingClientRect().height, .1, 1e3), _context.materialPreview.camera.position.set(0, 0, 3), _context.materialPreview.renderer.setSize(e.getBoundingClientRect().width, e.getBoundingClientRect().height), _context.materialPreview.orbitControls = new OrbitControls(_context.materialPreview.camera, _context.materialPreview.renderer.domElement), _context.materialPreview.orbitControls.enablePan = !1, e.appendChild(_context.materialPreview.renderer.domElement), this.scene = _context.materialPreview.scene, this.path = t, this.showType = null, this.models = new Group, this.scene.add(this.models), _context.instance.preloadResource(t, "avwa", (() => { let e = _context.cacheStore.find(t); if (e) { let t = null, i = null, r = new Map; e.resource.traverse((e => { if (e.material && !t && (t = e.material.clone()), e.material) for (let t in e.material) e.material[t] instanceof Texture$1 && e.material[t].image && r.set(e.material[t].name || `${e.material.name}#${t}`, Texture._fromThreeObject(e.material[t])); e.userData && e.userData.dhAsset && !i && (i = e.userData.dhAsset) })); let n = Material._fromThreeObject(t); this.materialInstance && (this.materialInstance.type = "metalness"), this.materialInstance = n, n.resourceBasePath = _context.instance.resourceBasePath, this.createSphere(t), this.createCylinder(t), this.createBox(t), this.createPlane(t), util$1.setMaterialParam(i.materials[t.name], n, r), _context.materialPreview.hasRenderer = !0 } i && i() }), (e => { r && r(e) })) } update(e, t, i) { _context.materialPreview.hasRenderer = !1, _context.instance.preloadResource(e, "avwa", (() => { let i = _context.cacheStore.find(e); if (i) { let e = null, t = null, r = new Map; i.resource.traverse((i => { if (i.material && !e && (e = i.material.clone()), i.material) for (let e in i.material) i.material[e] instanceof Texture$1 && i.material[e].image && r.set(i.material[e].name || `${i.material.name}#${e}`, Texture._fromThreeObject(i.material[e])); i.userData && i.userData.dhAsset && !t && (t = i.userData.dhAsset) })); let n = Material._fromThreeObject(e); this.materialInstance && (this.materialInstance.type = "metalness"), this.materialInstance = n, n.resourceBasePath = _context.instance.resourceBasePath, this.materialInstance && (this.materialInstance.type = "metalness"), this.updateMaterial(e, "sphere"), this.updateMaterial(e, "cylinder"), this.updateMaterial(e, "box"), this.updateMaterial(e, "plane"), util$1.setMaterialParam(t.materials[e.name], n, r), _context.materialPreview.hasRenderer = !0 } t && t() }), (e => { i && i(e) })) } updateMaterial(e, t) { this[t] ? (util$1.disposeMaterial(this[t].material), this[t].material = e, this[t].material.needsUpdate = !0) : this[`create${t.replace(t[0], t[0].toLowerCase())}`](e) } createSphere(e) { let t = new Mesh(new SphereGeometry(1, 40, 40), e); t.name = "sphere", this.sphere = t, this.showType = "sphere", this.models.add(t) } createCylinder(e) { let t = new Mesh(new CylinderGeometry(.8, .8, 1.6, 40, 40), e); t.name = "cylinder", this.cylinder = t, t.visible = !1, this.models.add(t) } createBox(e) { let t = new Mesh(new BoxGeometry(1.4, 1.4, 1.4, 10, 10, 10), e); t.name = "box", this.box = t, t.visible = !1, this.models.add(t) } createPlane(e) { let t = new Mesh(new PlaneGeometry(1.4, 1.4, 10, 10), e); t.name = "plane", this.plane = t, t.visible = !1, this.models.add(t) } showGeometry(e) { this[this.showType].visible = !1, this[e].visible = !0, this.showType = e } dispose() { for (this.materialInstance && (this.materialInstance.type = "metalness"), util$1.disposeMaterial(this.materialInstance.material()), this.materialInstance = null, _context.materialPreview.hasRenderer = !1, util$1.disposeThreeObject(this.models), this.models.remove(this.sphere), this.models.remove(this.cylinder), this.models.remove(this.plane), this.models.remove(this.box), _context.materialPreview.scene.traverse((function (e) { if (e.isMesh) if (_objectCount--, e.geometry.dispose(), e.material instanceof Array) for (let t of e.material) t.dispose(); else e.material.dispose(); e.isSprite && e.material.dispose() })); _context.materialPreview.scene.children.length;)_context.materialPreview.scene.remove(_context.materialPreview.scene.children[0]); _context.materialPreview.renderer.domElement && this.container.removeChild(_context.materialPreview.renderer.domElement), _context.materialPreview.scene = null, _context.materialPreview.camera = null, _context.materialPreview.renderer.dispose(), _context.materialPreview.renderer.forceContextLoss(), _context.materialPreview.renderer.content = null; let e = _context.materialPreview.renderer.domElement.getContext("webgl"); e && e.getExtension("WEBGL_lose_context").loseContext(), _context.materialPreview.renderer = null, _context.materialPreview.orbitControls = null, _context.materialPreview = null } setResolution(e, t) { "number" != typeof e || e < WIDTH_MIN || e > WIDTH_MAX || "number" != typeof t || t < HEIGHT_MIN || t > HEIGHT_MAX || _context.materialPreview.hasRenderer && (_context.materialPreview.camera.aspect = 1 * e / t, _context.materialPreview.camera.updateProjectionMatrix(), _context.materialPreview.renderer.setSize(e, t, !0)) } } class GlobeCalibrateControls { constructor(e) { let t, i, r = "", n = e => { "both" === r && e && "rotate" === e.target.mode && e.target.dragging && (1 !== e.target.rotationAxis.x && 1 !== e.target.rotationAxis.y && 1 !== e.target.rotationAxis.z || t.rotateOnWorldAxis(e.target.rotationAxis, e.target.rotationAngleDelta)), "function" == typeof this.callback && this.callback(this.getCalibrateDatum()) }, a = !1, o = .5, s = e => { e.preventDefault(), e.stopPropagation(); let i = 1; switch (e.deltaY < 0 ? i = 1 / .95 : e.deltaY > 0 && (i = .95), r) { case "ref": t.scale.multiplyScalar(i); break; case "model": _context.scene.models.scale.multiplyScalar(i); break; case "both": _context.scene.models.scale.multiplyScalar(i), t.scale.multiplyScalar(i) }_context.sceneBufferCacheExpired = !0, n() }; this.getOpacity = () => o, this.setOpacity = e => { o = Math.min(Math.max(e, 0), 1), t && t.material && (t.material.opacity = e) }, this.enable = (e, r) => { if (e = e && "ecef" === e.type ? e : _context.datumShiftModel, this.callback = r, t || (t = (() => { const e = new MeshBasicMaterial({ map: _context.loaders.textureLoader.load(util$1.url(_context.instance.resourceBasePath, "texture/planets/earth_atmos_4096.jpg")), transparent: !0, opacity: o, depthTest: !1 }), i = 6378.137, r = new SphereGeometry(i, 512, 256); return r.scale(1, 6356.752 / i, 1), t = new Mesh(r, e), t.name = "Planet", t.castShadow = !0, t.receiveShadow = !0, t })(), _context.scene.sysObjects.add(t)), i = { position: _context.scene.models.position.clone(), rotation: _context.scene.models.rotation.clone(), scale: _context.scene.models.scale.clone() }, e && "ecef" === e.type) { t.position.set(0, 0, 0), _context.scene.models.position.set(-e.offset.x, -e.offset.y, -e.offset.z), t.scale.set(1, 1, 1), _context.scene.models.scale.set(.001 / e.scaleX, .001 / e.scaleY, .001 / e.scaleZ), t.rotation.set(0, 0, 0); const i = new Matrix4; i.makeRotationFromEuler(new Euler(MathUtils.degToRad(e.rotation.x), MathUtils.degToRad(e.rotation.y), MathUtils.degToRad(e.rotation.z))), i.invert(), _context.scene.models.rotation.setFromRotationMatrix(i) } t.visible = !0, _context.transformControls.scaleEqualProportion0 = _context.transformControls.scaleEqualProportion, _context.transformControls.scaleEqualProportion = !0, _context.transformControls.addEventListener("objectChange", n), _context.instance.switchCameraMode(1, "-z", { fitX: !0, boundingSphere: !0 }), _context.orthoCameraControls.zoomAxis = "z", _context.orthoCameraControls.enablePan0 = _context.orthoCameraControls.enablePan, _context.orthoCameraControls.enableScale0 = _context.orthoCameraControls.enableScale, _context.orthoCameraControls.enableZoom0 = _context.orthoCameraControls.enableZoom, this.changeMode("both"), a = !0 }, this.disable = () => { _context.renderer.domElement.removeEventListener("wheel", s), this.callback = void 0, _context.instance.disableTransform(), t.visible = !1, _context.transformControls.scaleEqualProportion = _context.transformControls.scaleEqualProportion0 || !1, _context.instance.switchCameraMode(0), _context.orthoCameraControls.enablePan = _context.orthoCameraControls.enablePan0, _context.orthoCameraControls.enableScale = _context.orthoCameraControls.enableScale0, _context.orthoCameraControls.enableZoom = _context.orthoCameraControls.enableZoom0, i.position && i.rotation && i.scale && (_context.scene.models.position.copy(i.position), _context.scene.models.rotation.copy(i.rotation), _context.scene.models.scale.copy(i.scale), i = {}), a = !1 }, this.getCalibrateDatum = () => { const e = t.scale.x, i = t.matrix.clone(), r = _context.scene.models.position.clone(), n = _context.scene.models.scale.x, a = _context.scene.models.matrix.clone(); i.invert(), a.premultiply(i); const o = new Euler, s = new Matrix4; s.extractRotation(a), s.invert(), o.setFromRotationMatrix(s); const l = r.clone(); return l.divideScalar(-n), l.applyMatrix4(s), { type: "ecef", scaleX: e / (1e3 * n), scaleY: e / (1e3 * n), scaleZ: e / (1e3 * n), offset: l.clone(), rotation: { x: MathUtils.radToDeg(o.x), y: MathUtils.radToDeg(o.y), z: MathUtils.radToDeg(o.z) } } }, this.setCalibrateDatum = e => { if (!a || !e || "ecef" !== e.type) return; t.position.set(0, 0, 0), _context.scene.models.position.set(-e.offset.x, -e.offset.y, -e.offset.z), t.scale.set(1, 1, 1), _context.scene.models.scale.set(.001 / e.scaleX, .001 / e.scaleY, .001 / e.scaleZ), t.rotation.set(0, 0, 0); const i = new Matrix4; i.makeRotationFromEuler(new Euler(MathUtils.degToRad(e.rotation.x), MathUtils.degToRad(e.rotation.y), MathUtils.degToRad(e.rotation.z))), i.invert(), _context.scene.models.rotation.setFromRotationMatrix(i) }, this.changeMode = (e = "both") => { switch (e.toLowerCase()) { case "ref": _context.instance.enableTransformByUUID(t.uuid), _context.instance.snapOff(), this.changeTransform("rotate"), _context.transformControls.showX = !0, _context.transformControls.showY = !0, _context.transformControls.showZ = !1, _context.transformControls.showE = !1, _context.orthoCameraControls.enablePan = !1, _context.orthoCameraControls.enableRotate = !1, _context.orthoCameraControls.enableZoom = !1, _context.renderer.domElement.removeEventListener("wheel", s), _context.renderer.domElement.addEventListener("wheel", s), r = "ref"; break; case "model": _context.instance.enableTransformByUUID(_context.scene.models.uuid), _context.instance.snapOff(), this.changeTransform("rotate"), _context.transformControls.showX = !0, _context.transformControls.showY = !0, _context.transformControls.showZ = !0, _context.transformControls.showE = !1, _context.orthoCameraControls.enablePan = !1, _context.orthoCameraControls.enableRotate = !1, _context.orthoCameraControls.enableZoom = !1, _context.renderer.domElement.removeEventListener("wheel", s), _context.renderer.domElement.addEventListener("wheel", s), r = "model"; break; case "both": default: _context.instance.enableTransformByUUID(_context.scene.models.uuid), _context.instance.snapOff(), this.changeTransform("rotate"), _context.transformControls.showX = !0, _context.transformControls.showY = !0, _context.transformControls.showZ = !1, _context.transformControls.showE = !1, _context.orthoCameraControls.enablePan = !1, _context.orthoCameraControls.enableRotate = !1, _context.orthoCameraControls.enableZoom = !0, r = "both" } }, this.changeTransform = (e = "scale") => { switch (e.toLowerCase()) { case "translate": if ("model" !== r) return; _context.instance.setTransformMode("translate"), _context.transformControls.showX = !0, _context.transformControls.showY = !0, _context.transformControls.showZ = !0, _context.transformControls.showE = !0, _context.transformControls.scaleEqualProportion = !0; break; case "scale": _context.instance.setTransformMode("scale"), _context.transformControls.showX = !0, _context.transformControls.showY = !0, _context.transformControls.showZ = !0, _context.transformControls.showE = !0, _context.transformControls.scaleEqualProportion = !0; break; case "rotate": _context.instance.setTransformMode("rotate"), _context.transformControls.showX = !1, _context.transformControls.showY = !0, _context.transformControls.showZ = !1, _context.transformControls.showE = !1, _context.transformControls.scaleEqualProportion = !1 } }, this.changeGlobeStyle = e => { } } } class PaintControls { constructor() { let e, t, i, r, n, a, o = !1, s = !1, l = 0, c = "roam", h = !1, u = !1; const d = []; let p = null, f = !1, m = !1, g = null, y = null, v = null; this.size = 1; let _ = !1, b = 1, x = -1, w = []; this.setSize = e => { "number" == typeof e && e > 0 && (this.size = e, i.scale.set(e, .1 * e, e)) }, this.handleKeys = e => { 219 === e.keyCode && this.setSize(this.size / 1.1), 221 === e.keyCode && this.setSize(1.1 * this.size) }, this.init = () => { const n = new CylinderGeometry(1, 1, 1, 32); r = new MeshLambertMaterial({ color: 16711935, opacity: .5, transparent: !0 }), i = new Mesh(n, r), i.scale.set(5, .5, 5), i.visible = !1, _context.scene.sysObjects.add(i), t = new Raycaster, e = new Vector2, document.addEventListener("pointermove", this.onPointerMove), document.addEventListener("pointerdown", this.onPointerDown), document.addEventListener("pointerup", this.onPointerUp), document.addEventListener("keydown", this.onDocumentKeyDown), document.addEventListener("keyup", this.onDocumentKeyUp) }, this.destroy = () => { document.removeEventListener("pointermove", this.onPointerMove), document.removeEventListener("pointerdown", this.onPointerDown), document.removeEventListener("pointerup", this.onPointerUp), document.removeEventListener("keydown", this.onDocumentKeyDown), document.removeEventListener("keyup", this.onDocumentKeyUp), document.removeEventListener("keydown", this.handleKeys), d.forEach((e => { util$1.disposeThreeObject(e) })), d.length = 0 }, this.getRand = function (e) { return this.obj = e, this.init() }, this.getRand.prototype.sum = function (e) { var t = this.obj, i = 0; return t.forEach && t.forEach((t => { i += t[e] })), i }, this.getRand.prototype.init = function () { var e = null, t = this.obj, i = this.sum("intensity"); for (var r in t) { if (parseFloat(Math.random() * i) <= t[r].intensity) { e = t[r]; break } i -= t[r].intensity } return e }, this._paint = ({ x: e, y: t, z: i }, r, a) => { if (!o || !(this.assets instanceof Array && this.assets.length > 0)) return; let s = {}; if (s = new this.getRand(this.assets), "paint" === c.toLowerCase() || "brush" === c.toLowerCase()) { let n = Math.random() * Math.PI * 2, o = Math.random() * this.size, s = new Vector3(Math.cos(n) * o, 0, Math.sin(n) * o); if (r && s.applyQuaternion(r), e += s.x, t += s.y, i += s.z, a) { a instanceof InstancedMesh && (a = a.parent); let t = (new Box3).setFromObject(a); t && t.min && t.max && "__pgl" !== a.name && (e = t.min.x > e ? t.min.x : e, e = t.max.x < e ? t.max.x : e, i = t.min.z > i ? t.min.z : i, i = t.max.z < i ? t.max.z : i) } } if (s.transform ? 0 == s.transform.scale.x && (s.transform.scale = { x: 1, y: 1, z: 1 }) : s.transform = { position: { x: 0, y: 0, z: 0 }, rotation: { _x: 0, _y: 0, _z: 0, _order: "XYZ" }, scale: { x: 1, y: 1, z: 1 } }, "number" == typeof s.intensity && s.intensity < 0 && (s.intensity = 0), 0 === s.intensity) return; if (l * s.probability < 2) return; l = 0; let h = [[e, t, i]], u = JSON.parse(JSON.stringify(s)); switch (u.isVisible = !0, u.transform.position.x = h[0][0], u.transform.position.y = h[0][1], u.transform.position.z = h[0][2], u.path = u.param.path, u.index = v.children.length + 1, s.type) { case "ModelAsset": if ("clone" == n) { u.name = v.getIndexName(u.name), u.modelPath = u.param.path; let e = s.randomValues, t = 1; e && e.scaleMax && e.scaleMin && e.scaleFlag && (t = Math.random() * (e.scaleMax - e.scaleMin) + e.scaleMin), u.transform.scale = { x: u.transform.scale.x * t, y: u.transform.scale.y * t, z: u.transform.scale.z * t }; let i = 0; e && (i = MathUtils.degToRad(Math.random() * (e.rotateMax - e.rotateMin) + e.rotateMin)); let r = new Euler(u.transform.rotation._x, u.transform.rotation._y + i, u.transform.rotation._z); u.transform.rotation = r; let n = new ModelItem(u, null, null, v), a = v.getGroup(), o = n.getGroup(); a.updateMatrixWorld(); let l = a.matrixWorld.clone().invert(); o.applyMatrix(l), o.updateMatrix(), setTimeout((() => { util$1.setArticulation(u, n), n.materialStore && n.materialStore.applySettings(u.materials, v.name) }), 500), "plot" === c.toLowerCase() && g && g({ name: v ? v.name : null }) } else { let e = null; if (u.points = h, e = "GroupItem" == v.type ? v.getItemByName(s.name) : v.getInstanced("ModelAsset", s.name), e) { if (s.drawRequested = void 0, e.setRand(u.randomValues), e.addInstance(h, v), "GroupItem" != v.type) { let t = JSON.parse(JSON.stringify(u)); t.name = v.getIndexName(u.name), v.childrenAdd(new InstancedItem(t, e, e.getCount() - 1, v.children.length + 1)), "plot" === c.toLowerCase() && g && g({ name: v ? v.name : null }) } } else { if (1 == s.drawRequested) break; s.drawRequested = !0, new InstancedObject(u, v, ((e, t) => { if ("GroupItem" == v.type); else { let e = JSON.parse(JSON.stringify(u)); e.name = v.getIndexName(u.name), v.childrenAdd(new InstancedItem(e, t, t.getCount() - 1, v.children.length + 1)) } t.materialStore.applySettings(u.materials, v.name, t.name), s.drawRequested = void 0, "plot" === c.toLowerCase() && g && g({ name: v ? v.name : null }) })) } } break; case "IconAsset": if ("instanced" == n) { let e = v.getInstanced("IconAsset", s.name); if (e) { e.addInstance(h, v); let t = JSON.parse(JSON.stringify(u)); t.name = e.getIndexName(), v.childrenAdd(new InstancedItem(t, e, t.name, v.children.length + 1)) } else u.points = h, u.transform.scale ? u.scales = [JSON.parse(JSON.stringify(u.transform.scale))] : u.scales = [{ x: 1, y: 1, z: 1 }], new InstancedGroup(u, v, ((e, t) => { let i = JSON.parse(JSON.stringify(u)); i.name = t.getIndexName(), v.childrenAdd(new InstancedItem(i, t, i.name, v.children.length + 1)) })); "plot" === c.toLowerCase() && g && g({ name: v ? v.name : null }) } else u.name = v.getIndexName(u.name), new IconItem(u, v), "plot" === c.toLowerCase() && g && g({ name: v ? v.name : null }) } }, this._clickItem = e => { let t = e.object.parent, i = t.name; if ("PaintItem" === v.type) { if ("PaintGroup" === t.type) { i = e.object.name; let t = i.indexOf("#"); i = i.substr(0, t); let r = v.getInstanced("ModelAsset", i).settings.find((t => t.key == e.instanceId)); i = r.name } let r = v.children.find((e => e.name === i)); g && g({ name: v.name, object: t, objectItem: r }, r.type) } else if ("GroupItem" === v.type) { let r = ""; if ("PaintGroup" === t.type) { i = e.object.name; let t = i.indexOf("#"); i = i.substr(0, t), r = "ModelAsset" } else r = "IconAsset"; let n = v.children.find((e => e.name === i)); "PaintGroup" === t.type && (t = n.getHelper(e.instanceId)), g && g({ name: v.name, object: t, objectItem: { type: "ModelAsset", name: e.object.name, transform: { position: e.object.position, rotation: e.object.rotation, scale: e.object.scale } } }, r) } }, this._castLayer = () => { let e = []; return v && (assetObject.getGroup().children.map((t => { "IconGroup" === t.type ? t.children.map((t => { e.push(t) })) : "InstancedGroup" === t.type ? t.children.map((t => { t.children.map((t => { e.push(t) })) })) : e.push(t) })), assetObject.children.map((t => { "ModelItem" === t.type && t.getGroup().children.map((t => { e.push(t) })) }))), t.intersectObjects(e) }, this._erase = () => { let e = t.intersectObjects(d); if (e.length > 0) { let t, i = []; if (e = e.filter((e => { let t = e.object.parent; if ("PaintGroup" !== t.type) { if (!i.includes(t.name)) return i.push(e.object.parent.name), !0 } else if (!i.includes(e.instanceId)) return i.push(e.instanceId), !0 })), w = w.concat(e), b > 1) { if (-1 == x && (x = Math.round(Math.random() * b + .1) - 1), !(w.length >= b)) return; t = w[x], w = [], x = -1 } else t = e[0]; let r = t.object.parent, n = r.name; if ("PaintItem" === v.type) { if ("PaintGroup" === r.type) { n = t.object.name; let e = n.indexOf("#"); n = n.substr(0, e), n = v.getInstanced("ModelAsset", n).settings.find((e => e.key == t.instanceId)).name } v.removeItem(n).then((e => { this.updateWorld(), g && g(e, "删除成功") })) } else if ("GroupItem" === v.type) if ("PaintGroup" === r.type) { n = t.object.name; let e = n.indexOf("#"); n = n.substr(0, e), v.removeItem(n, t.instanceId).then((e => { this.updateWorld(), e && g && g(e, "删除成功") })) } else v.removeItem(n).then((e => { this.updateWorld(), e && g && g(e, "删除成功") })) } }, this.onPointerMove = r => { if (!o || r.target !== _context.renderer.domElement) return; if (a && (a = clearInterval(a), a = void 0), m) return; h = !0, l++, e.set(r.offsetX / _context.renderer.domElement.clientWidth * 2 - 1, -r.offsetY / _context.renderer.domElement.clientHeight * 2 + 1), t.setFromCamera(e, _context.camera), u && f && this._erase(); const n = t.intersectObjects(d); if (_context.scene.getObjectByName("__pgl") && _context.pgl.terrain) { let e = _context.pgl.terrain.pickTerrain({ x: r.offsetX, y: r.offsetY }); if (e && e.hit) { for (let t = 0; t < n.length; t++)if (n[t].distance > e.distance) { n.splice(t, 0, e); break } (0 === n.length || e.distance > n[n.length - 1].distance) && n.push(e) } } if (n.length > 0) { const e = n[0]; let t = new Vector3; e.face && (t = e.face.normal.clone()); let r = new Quaternion; e.object.matrixWorld.decompose({ x: 0, y: 0, z: 0 }, r, { x: 0, y: 0, z: 0 }), t.applyQuaternion(r), t.normalize(), i.position.copy(e.point).add(t.clone().multiplyScalar(i.scale.y / 2)); let a = util$1.calcQuaternionFromNormal(t); if (i.setRotationFromQuaternion(a), u) { if ("paint" !== c.toLowerCase() && "brush" !== c.toLowerCase()) return; if (0 === this.assets.length) return; this._createDrawGroup(), this._paint(e.point, a, e.object) } } }, this.onPointerUp = i => { if (o && i.target === _context.renderer.domElement && 0 === i.button) if (h && g && g({ name: v ? v.name : null }), u = !1, h = !1, a && (a = clearInterval(a), a = void 0), e.set(i.offsetX / _context.renderer.domElement.clientWidth * 2 - 1, -i.offsetY / _context.renderer.domElement.clientHeight * 2 + 1), t.setFromCamera(e, _context.camera), s); else if (f) this._erase(); else if (u) y && y({ type: "progress", total: 1, loaded: 1 }); else if ("plot" === c.toLowerCase()) { if (0 === this.assets.length) return; const e = t.intersectObjects(d); if (_context.scene.getObjectByName("__pgl") && _context.pgl.terrain) { let t = _context.pgl.terrain.pickTerrain({ x: i.offsetX, y: i.offsetY }); if (t && t.hit) { for (let i = 0; i < e.length; i++)if (e[i].distance > t.distance) { e.splice(i, 0, t); break } (0 === e.length || t.distance > e[e.length - 1].distance) && e.push(t) } } e.length > 0 && (this._createDrawGroup(), this._paint(e[0].point, null, e[0].object)) } else if ("click" === c.toLowerCase()) { const e = t.intersectObjects(d); e.length > 0 && this._clickItem(e[0]) } }, this.onPointerDown = e => { if (!o || e.target !== _context.renderer.domElement || 0 !== e.button) return; if (u = !0, h = !1, "paint" !== c.toLowerCase() && "brush" !== c.toLowerCase()) return; const i = t.intersectObjects(d); i.length > 0 && (a || (a = setInterval((() => { this._paint(i[0].point, null, i[0].object) }), 500))) }, this.onDocumentKeyDown = e => { switch (e.keyCode) { case 16: s = !0 } }, this.onDocumentKeyUp = e => { switch (e.keyCode) { case 16: s = !1 } }, this._createDrawGroup = () => { if (!v) { let e = { name: util$1.getCopyName("Layer", null, _context.defaultObjectTree), index: _context.instance.defaultObjectTree.children.length, isVisible: !0 }; v = new PaintItem(e) } }, this.setLayerName = e => { p = e, v = _context.defaultObjectTree.getItemByName(p), this.updateWorld() }, this.setMode = (e = "roam", t = "clone", a, s, l, h, u, d, x) => { v = null, _ = h, b = 1 / l; let w = c; v = _context.defaultObjectTree.getItemByName(p); let S = []; for (let e of s) { if (!e.param || !e.param.path) continue; let t = ""; switch (e.type.toLowerCase()) { case "iconasset": case "iconitem": t = "texture"; break; case "modelasset": default: t = "glb" }S.push(new Promise((i => { _context.instance.preloadResource(e.param.path, t, (e => { i(e), logger.debug("finish") }), d) }))) } if (Promise.all(S).then((e => { x && x(e) })), s.length > 0) { s.forEach((e => { if (this.assets) { this.assets.find((t => t.name === e.name)) || this.assets.push(e) } else this.assets = [], this.assets.push(e) })); for (let e = 0; e < this.assets.length; e++) { if (this.assets[e].gltfIsAdd = !1, s.find((t => this.assets[e].name === t.name))) for (let e = 0; e < s.length; e++)s[e].name === this.assets[e].name && (this.assets[e].randomValues = s[e].randomValues, this.assets[e].intensity = s[e].intensity, this.assets[e].param = s[e].param, this.assets[e].probability = s[e].probability, this.assets[e].type = s[e].type, s[e].textParam && (this.assets[e].textParam = s[e].textParam)); else this.assets.splice(e, 1), e-- } } else this.assets = []; if (this.setSize(a), c = e, n = t, w !== c) { switch (c) { case "roam": o = !1, f = !1, m = !1, i.visible = !1, "editor" === _context.pointerMode ? _context.orbitControls.keyOperate = "paint" : _context.orbitControls.keyOperate = null, _context.pointerDisabled = !1, document.removeEventListener("keydown", this.handleKeys); break; case "plot": case "paint": o = !0, f = !1, m = !1, i.visible = !0, _context.orbitControls.keyOperate = "paint", r.color = new Color$1("#ffb300"), _context.pointerDisabled = !0, document.addEventListener("keydown", this.handleKeys); break; case "remove": o = !0, f = !0, m = !1, i.visible = !1, _context.orbitControls.keyOperate = "paint", _context.pointerDisabled = !0, document.removeEventListener("keydown", this.handleKeys); break; case "click": o = !0, f = !1, m = !0, i.visible = !1, _context.orbitControls.keyOperate = "paint", _context.pointerDisabled = !0, document.removeEventListener("keydown", this.handleKeys); break; default: c = w }this.updateWorld(), u && (g = u), d && (y = d) } else this.updateWorld() }, this.updateWorld = () => { "click" !== c && "remove" !== c || !p ? (d.length = 0, _context.scene.children.map(((e, t) => { "__tilesGroup" === e.name && e.children[0] ? d.push(e.children[0]) : "__models" === e.name && e.traverseVisible((function (e) { if (_) d.push(e); else if (e.isMesh && "PaintGroup" !== e.type && "PaintGroup" !== e.parent.type) { if ("Group" === e.parent.type && "PaintGroup" === e.parent.parent.type) return; d.push(e) } })) }))) : (d.length = 0, v && (v.getGroup().children.map((e => { "IconGroup" === e.type ? e.children.map((e => { d.push(e) })) : "InstancedGroup" === e.type ? e.children.map((e => { e.children.map((e => { d.push(e) })) })) : "InstancedHelper" !== e.type && d.push(e) })), v.children.map((e => { "ModelItem" === e.type && e.getGroup().children.map((e => { d.push(e) })) })))) }, this.setData = e => { for (let t of this.assets) { let i = _context.instancedObjectStore.findInstancedObject(t.name); i ? i.addInstance(points) : _context.instancedObjectStore.add(new InstancedObject({ name: t.name, modelPath: t.modelPath, transform: t.transform, points: e })) } } } } var TargetCameraControls = function (e) { this.orbitControl = e, this.enabled = !0, this.target = new Vector3, this.targetObject = void 0, this.viewDistance = 100, this.minDistance = 1, this.maxDistance = 1e4, this.inclination = -45, this.maxInclination = 90, this.minInclination = -90, this.azimuth = 0, this.autoRotateEnable = !1, this.autoRotateSpeed = .1, this.enableKeys = !0, this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }, this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.PAN, RIGHT: MOUSE.DOLLY }, this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }, this.startPos = new Vector3(0, 0, 0), this.startInclination = 0, this.startAzimuth = 0, this.targetPos = new Vector3(0, 0, 0), this.targetInclination = 0, this.targetAzimuth = 0, this.currentTime = 0, this.durationTime = 0, this.startDistance = 0, this.targetDistance = 0, this.target0 = this.target.clone(), this.position0 = this.orbitControl.object.position.clone(), this.zoom0 = this.orbitControl.object.zoom, this.enablePan = !0, this.enableRotate = !0, this.enableZoom = !0, this.callback = void 0; var t = !1, i = this; Object.defineProperty(i, "isZoomTo", { get: function () { return t } }); function r(e, t, i, r) { var n = t - e; return e + (n /= i) * r } this.zoomTo = function (e, r, n, a, o, s, l, c) { r = (r + 180) % 360 - 180; let h = i.orbitControl.getAzimuthalAngle() / Math.PI * 180; r - h > 180 && (r -= 360), r - h < -180 && (r += 360), i.targetPos = e, i.targetAzimuth = r, i.targetInclination = n, i.durationTime = o, i.enablePan = s, i.targetDistance = a; var u = i.orbitControl.object.position.clone().divideScalar(-1), d = i.orbitControl.target.clone().add(u).length(), p = 180 * i.orbitControl.getAzimuthalAngle() / Math.PI, f = 180 * i.orbitControl.getPolarAngle() / Math.PI; if (i.startDistance = d, i.currentTime = 0, i.startPos = i.orbitControl.target.clone(), i.startInclination = f - 90, i.startAzimuth = p, t = !0, this.callback) { const e = this.callback; this.callback = l, void 0 === c && (c = !0), e({ isInterrupt: c }) } else this.callback = l }, this.update = function (e) { if (t) { if (i.durationTime - i.currentTime > 1e-6) { var n = r(i.startPos.x, i.targetPos.x, i.durationTime, i.currentTime), a = r(i.startPos.y, i.targetPos.y, i.durationTime, i.currentTime), o = r(i.startPos.z, i.targetPos.z, i.durationTime, i.currentTime); i.target = new Vector3(n, a, o), i.inclination = r(i.startInclination, i.targetInclination, i.durationTime, i.currentTime), i.azimuth = r(i.startAzimuth, i.targetAzimuth, i.durationTime, i.currentTime), i.viewDistance = r(i.startDistance, i.targetDistance, i.durationTime, i.currentTime), i.currentTime += e, s() } else if (t = !1, i.target = i.targetPos, i.inclination = i.targetInclination, i.azimuth = i.targetAzimuth, i.viewDistance = i.targetDistance, s(), this.callback) { util$1.markObjectsNeedsUpdate(); const e = this.callback; this.callback = void 0, e() } function s() { var t = new Vector3(0, 0, i.viewDistance), r = new Matrix4; r.identity(), r.makeRotationX(i.inclination * Math.PI / 180); var n = new Matrix4; n.identity(), n.makeRotationY(i.azimuth * Math.PI / 180); var a = new Matrix4; a.identity(), a.makeRotationZ(0), n.multiply(r), n.multiply(a), t.applyMatrix4(n); var o = t.add(i.target); i.orbitControl.object.position.set(o.x, o.y, o.z), i.orbitControl.target.set(i.target.x, i.target.y, i.target.z), i.orbitControl.update(e) } } i.autoRotateEnable && (i.azimuth += i.autoRotateSpeed * e) }, this.dispose = function () { }, this.update() }; TargetCameraControls.prototype = Object.create(EventDispatcher.prototype), TargetCameraControls.prototype.constructor = TargetCameraControls; var TransformControls = function (e, t) { void 0 === t && (logger.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), Object3D.call(this), this.visible = !1, this.domElement = t, this.scaleEqualProportion = !1; var i = new TransformControlsGizmo; this.add(i); var r = new TransformControlsPlane; this.add(r); var n = this; V("camera", e), V("object", void 0), V("enabled", !0), V("axis", null), V("mode", "translate"), V("translationSnap", null), V("rotationSnap", null), V("scaleSnap", null), V("space", "world"), V("size", 1), V("dragging", !1), V("showX", !0), V("showY", !0), V("showZ", !0), V("showE", !0); var a = { type: "change" }, o = { type: "mouseDown" }, s = { type: "mouseUp", mode: n.mode }, l = { type: "objectChange" }, c = { type: "translate" }, h = { type: "rotate" }, u = { type: "scale" }, d = new Raycaster; function p(e, t, i) { for (var r = t.intersectObject(e, !0), n = 0; n < r.length; n++)if (r[n].object.visible || i) return r[n]; return !1 } var f = new Vector3, m = new Vector3, g = new Quaternion, y = { X: new Vector3(1, 0, 0), Y: new Vector3(0, 1, 0), Z: new Vector3(0, 0, 1) }, v = new Vector3, _ = new Vector3, b = new Vector3, x = new Vector3, w = new Vector3, S = new Vector3, M = 0, T = new Vector3, A = new Quaternion, E = new Vector3, C = new Vector3, L = new Quaternion, R = new Quaternion, D = new Vector3, P = new Vector3, O = new Quaternion, I = new Vector3, k = new Vector3, B = new Quaternion, N = new Quaternion, F = new Vector3, U = new Vector3, z = new Vector3, G = new Quaternion, H = new Vector3; function V(e, t) { var o = t; Object.defineProperty(n, e, { get: function () { return void 0 !== o ? o : t }, set: function (t) { o !== t && (o = t, r[e] = t, i[e] = t, n.dispatchEvent({ type: e + "-changed", value: t }), n.dispatchEvent(a)) } }), n[e] = t, r[e] = t, i[e] = t } function j(e) { if (n.domElement.ownerDocument.pointerLockElement) return { x: 0, y: 0, button: e.button }; var i = e.changedTouches ? e.changedTouches[0] : e, r = t.getBoundingClientRect(); return { x: (i.clientX - r.left) / r.width * 2 - 1, y: -(i.clientY - r.top) / r.height * 2 + 1, button: e.button } } function W(e) { if (n.enabled) switch (e.pointerType) { case "mouse": case "pen": n.pointerHover(j(e)) } } function $(e) { n.enabled && (n.domElement.style.touchAction = "none", n.domElement.ownerDocument.addEventListener("pointermove", Y), n.pointerHover(j(e)), n.pointerDown(j(e))) } function Y(e) { n.enabled && n.pointerMove(j(e)) } function X(e) { n.enabled && (n.domElement.style.touchAction = "", n.domElement.ownerDocument.removeEventListener("pointermove", Y), n.pointerUp(j(e))) } V("worldPosition", k), V("worldPositionStart", P), V("worldQuaternion", B), V("worldQuaternionStart", O), V("cameraPosition", T), V("cameraQuaternion", A), V("pointStart", v), V("pointEnd", _), V("rotationAxis", x), V("rotationAngle", M), V("eye", U), t.addEventListener("pointerdown", $), t.addEventListener("pointermove", W), n.domElement.ownerDocument.addEventListener("pointerup", X), this.dispose = function () { t.removeEventListener("pointerdown", $), t.removeEventListener("pointermove", W), n.domElement.ownerDocument.removeEventListener("pointermove", Y), n.domElement.ownerDocument.removeEventListener("pointerup", X), this.traverse((function (e) { e.geometry && e.geometry.dispose(), e.material && e.material.dispose() })) }, this.attach = function (e) { return this.object = e, this.visible = !0, this }, this.detach = function () { return this.object = void 0, this.visible = !1, this.axis = null, this }, this.updateMatrixWorld = function () { void 0 !== this.object && (this.object.updateMatrixWorld(), null === this.object.parent ? logger.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(C, L, D), this.object.matrixWorld.decompose(k, B, F), R.copy(L).invert(), N.copy(B).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(T, A, E), U.copy(T).sub(k).normalize(), Object3D.prototype.updateMatrixWorld.call(this) }, this.pointerHover = function (e) { if (void 0 !== this.object && !0 !== this.dragging) { d.setFromCamera(e, this.camera); var t = p(i.picker[this.mode], d); this.axis = t ? t.object.name : null } }, this.pointerDown = function (e) { if (void 0 !== this.object && !0 !== this.dragging && 0 === e.button && null !== this.axis) { d.setFromCamera(e, this.camera); var t = p(r, d, !0); if (t) { var i = this.space; if ("scale" === this.mode ? i = "local" : "E" !== this.axis && "XYZE" !== this.axis && "XYZ" !== this.axis || (i = "world"), "local" === i && "rotate" === this.mode) { var n = this.rotationSnap; "X" === this.axis && n && (this.object.rotation.x = Math.round(this.object.rotation.x / n) * n), "Y" === this.axis && n && (this.object.rotation.y = Math.round(this.object.rotation.y / n) * n), "Z" === this.axis && n && (this.object.rotation.z = Math.round(this.object.rotation.z / n) * n) } this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(); let e = this.object.position, r = this.object.quaternion, a = this.object.scale; if (this.object.matrixWorld.decompose(P, O, I), z.copy(e), G.copy(r), H.copy(a), this.object instanceof InstancedHelper) { let { key: e } = this.object.userData, t = this.object.instanced.getTransform(e), i = new Quaternion; i.setFromEuler(t.rotation), z.copy(t.position), G.copy(i), H.copy(t.scale), P = t.position.clone(), O = i.clone(), I = t.scale.clone() } v.copy(t.point).sub(P) } this.dragging = !0, this.rotationAngle = 0, o.mode = this.mode, this.dispatchEvent(o) } }, this.pointerMove = function (e) { var t = this.axis, i = this.mode, o = this.object, s = this.space; if ("scale" === i ? s = "local" : "E" !== t && "XYZE" !== t && "XYZ" !== t || (s = "world"), void 0 !== o && null !== t && !1 !== this.dragging && -1 === e.button) { d.setFromCamera(e, this.camera); var T = p(r, d, !0); if (T) { if (_.copy(T.point).sub(P), "translate" === i) { if (b.copy(_).sub(v), "local" === s && "XYZ" !== t && b.applyQuaternion(N), -1 === t.indexOf("X") && (b.x = 0), -1 === t.indexOf("Y") && (b.y = 0), -1 === t.indexOf("Z") && (b.z = 0), "local" === s && "XYZ" !== t ? b.applyQuaternion(G).divide(D) : b.applyQuaternion(R).divide(D), o.position.copy(b).add(z), this.translationSnap && ("local" === s && (o.position.applyQuaternion(g.copy(G).invert()), -1 !== t.search("X") && (o.position.x = Math.round(o.position.x / this.translationSnap) * this.translationSnap), -1 !== t.search("Y") && (o.position.y = Math.round(o.position.y / this.translationSnap) * this.translationSnap), -1 !== t.search("Z") && (o.position.z = Math.round(o.position.z / this.translationSnap) * this.translationSnap), o.position.applyQuaternion(G)), "world" === s && (o.parent && o.position.add(f.setFromMatrixPosition(o.parent.matrixWorld)), -1 !== t.search("X") && (o.position.x = Math.round(o.position.x / this.translationSnap) * this.translationSnap), -1 !== t.search("Y") && (o.position.y = Math.round(o.position.y / this.translationSnap) * this.translationSnap), -1 !== t.search("Z") && (o.position.z = Math.round(o.position.z / this.translationSnap) * this.translationSnap), o.parent && o.position.sub(f.setFromMatrixPosition(o.parent.matrixWorld)))), o instanceof InstancedHelper) o.setPosition(o.position); else if ("IconGroup" === o.type && o.parent && "InstancedGroup" === o.parent.type) { let e = _context.defaultObjectTree.getItemByUUID(o.uuid); if (e && "IconAsset" === e.type && e.isInstancedItem) { let t = JSON.parse(JSON.stringify(e.transform)); t.position = JSON.parse(JSON.stringify(o.position)), e.setTransform(t) } } c.object = o, n.dispatchEvent(c) } else if ("scale" === i) { if (-1 !== t.search("XYZ") || this.scaleEqualProportion) { var A = _.length() / v.length(); _.dot(v) < 0 && (A *= -1), m.set(A, A, A) } else f.copy(v), m.copy(_), f.applyQuaternion(N), m.applyQuaternion(N), m.divide(f), -1 === t.search("X") && (m.x = 1), -1 === t.search("Y") && (m.y = 1), -1 === t.search("Z") && (m.z = 1); let e = H.clone().multiply(m); if (this.scaleSnap && (-1 !== t.search("X") && (e.x = Math.round(e.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t.search("Y") && (e.y = Math.round(e.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), -1 !== t.search("Z") && (e.z = Math.round(e.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap)), o instanceof InstancedHelper) o.setScale(e); else if ("IconGroup" === o.type && o.parent && "InstancedGroup" === o.parent.type) { let e = _context.defaultObjectTree.getItemByUUID(o.uuid); if (e && "IconAsset" === e.type && e.isInstancedItem) { let t = JSON.parse(JSON.stringify(e.transform)); t.position = JSON.parse(JSON.stringify(o.position)), e.setTransform(t) } } else o.scale.copy(e); u.object = o, n.dispatchEvent(u) } else if ("rotate" === i) { b.copy(_).sub(v); var E = 20 / k.distanceTo(f.setFromMatrixPosition(this.camera.matrixWorld)); "E" === t ? (x.copy(U), M = _.angleTo(v), w.copy(v).normalize(), S.copy(_).normalize(), M *= S.cross(w).dot(U) < 0 ? 1 : -1) : "XYZE" === t ? (x.copy(b).cross(U).normalize(), M = b.dot(f.copy(x).cross(this.eye)) * E) : "X" !== t && "Y" !== t && "Z" !== t || (x.copy(y[t]), f.copy(y[t]), "local" === s && f.applyQuaternion(B), M = b.dot(f.cross(U).normalize()) * E), this.rotationSnap && (M = Math.round(M / this.rotationSnap) * this.rotationSnap), this.rotationAngleDelta = M - this.rotationAngle, this.rotationAngle = M; let e = new Quaternion; "local" === s && "E" !== t && "XYZE" !== t ? e.copy(G).multiply(g.setFromAxisAngle(x, M)).normalize() : (x.applyQuaternion(R), e.copy(g.setFromAxisAngle(x, M)).multiply(G).normalize()), o instanceof InstancedHelper ? o.setQuaternion(e) : o.quaternion.copy(e), h.object = o, n.dispatchEvent(h) } this.dispatchEvent(a), this.dispatchEvent(l) } } }, this.pointerUp = function (e) { 0 === e.button && (this.dragging && null !== this.axis && (s.mode = this.mode, this.dispatchEvent(s)), this.dragging = !1, this.axis = null) }, this.getMode = function () { return n.mode }, this.setMode = function (e) { n.mode = e }, this.setTranslationSnap = function (e) { n.translationSnap = e }, this.setRotationSnap = function (e) { n.rotationSnap = e }, this.setScaleSnap = function (e) { n.scaleSnap = e }, this.setSize = function (e) { n.size = e }, this.setSpace = function (e) { n.space = e }, this.update = function () { logger.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.") } }; TransformControls.prototype = Object.assign(Object.create(Object3D.prototype), { constructor: TransformControls, isTransformControls: !0 }); var TransformControlsGizmo = function () { Object3D.call(this), this.type = "TransformControlsGizmo"; var e = new MeshBasicMaterial({ depthTest: !1, depthWrite: !1, transparent: !0, side: DoubleSide, fog: !1, toneMapped: !1 }), t = new LineBasicMaterial({ depthTest: !1, depthWrite: !1, transparent: !0, linewidth: 1, fog: !1, toneMapped: !1 }), i = e.clone(); i.opacity = .15; var r = e.clone(); r.opacity = .33; var n = e.clone(); n.color.set(16711680); var a = e.clone(); a.color.set(65280); var o = e.clone(); o.color.set(255); var s = e.clone(); s.opacity = .25; var l = s.clone(); l.color.set(16776960); var c = s.clone(); c.color.set(65535); var h = s.clone(); h.color.set(16711935), e.clone().color.set(16776960); var u = t.clone(); u.color.set(16711680); var d = t.clone(); d.color.set(65280); var p = t.clone(); p.color.set(255); var f = t.clone(); f.color.set(65535); var m = t.clone(); m.color.set(16711935); var g = t.clone(); g.color.set(16776960); var y = t.clone(); y.color.set(7895160); var v = g.clone(); v.opacity = .25; var _ = new CylinderGeometry(0, .05, .2, 12, 1, !1), b = new BoxGeometry(.125, .125, .125), x = new BufferGeometry; x.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3)); var w = function (e, t) { for (var i = new BufferGeometry, r = [], n = 0; n <= 64 * t; ++n)r.push(0, Math.cos(n / 32 * Math.PI) * e, Math.sin(n / 32 * Math.PI) * e); return i.setAttribute("position", new Float32BufferAttribute(r, 3)), i }, S = { X: [[new Mesh(_, n), [1, 0, 0], [0, 0, -Math.PI / 2], null, "fwd"], [new Mesh(_, n), [1, 0, 0], [0, 0, Math.PI / 2], null, "bwd"], [new Line(x, u)]], Y: [[new Mesh(_, a), [0, 1, 0], null, null, "fwd"], [new Mesh(_, a), [0, 1, 0], [Math.PI, 0, 0], null, "bwd"], [new Line(x, d), null, [0, 0, Math.PI / 2]]], Z: [[new Mesh(_, o), [0, 0, 1], [Math.PI / 2, 0, 0], null, "fwd"], [new Mesh(_, o), [0, 0, 1], [-Math.PI / 2, 0, 0], null, "bwd"], [new Line(x, p), null, [0, -Math.PI / 2, 0]]], XYZ: [[new Mesh(new OctahedronGeometry(.1, 0), s.clone()), [0, 0, 0], [0, 0, 0]]], XY: [[new Mesh(new PlaneGeometry(.295, .295), l.clone()), [.15, .15, 0]], [new Line(x, g), [.18, .3, 0], null, [.125, 1, 1]], [new Line(x, g), [.3, .18, 0], [0, 0, Math.PI / 2], [.125, 1, 1]]], YZ: [[new Mesh(new PlaneGeometry(.295, .295), c.clone()), [0, .15, .15], [0, Math.PI / 2, 0]], [new Line(x, f), [0, .18, .3], [0, 0, Math.PI / 2], [.125, 1, 1]], [new Line(x, f), [0, .3, .18], [0, -Math.PI / 2, 0], [.125, 1, 1]]], XZ: [[new Mesh(new PlaneGeometry(.295, .295), h.clone()), [.15, 0, .15], [-Math.PI / 2, 0, 0]], [new Line(x, m), [.18, 0, .3], null, [.125, 1, 1]], [new Line(x, m), [.3, 0, .18], [0, -Math.PI / 2, 0], [.125, 1, 1]]] }, M = { X: [[new Mesh(new CylinderGeometry(.2, 0, 1, 4, 1, !1), i), [.6, 0, 0], [0, 0, -Math.PI / 2]]], Y: [[new Mesh(new CylinderGeometry(.2, 0, 1, 4, 1, !1), i), [0, .6, 0]]], Z: [[new Mesh(new CylinderGeometry(.2, 0, 1, 4, 1, !1), i), [0, 0, .6], [Math.PI / 2, 0, 0]]], XYZ: [[new Mesh(new OctahedronGeometry(.2, 0), i)]], XY: [[new Mesh(new PlaneGeometry(.4, .4), i), [.2, .2, 0]]], YZ: [[new Mesh(new PlaneGeometry(.4, .4), i), [0, .2, .2], [0, Math.PI / 2, 0]]], XZ: [[new Mesh(new PlaneGeometry(.4, .4), i), [.2, 0, .2], [-Math.PI / 2, 0, 0]]] }, T = { START: [[new Mesh(new OctahedronGeometry(.01, 2), r), null, null, null, "helper"]], END: [[new Mesh(new OctahedronGeometry(.01, 2), r), null, null, null, "helper"]], DELTA: [[new Line(function () { var e = new BufferGeometry; return e.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3)), e }(), r), null, null, null, "helper"]], X: [[new Line(x, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new Line(x, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new Line(x, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] }, A = { X: [[new Line(w(1, .5), u)], [new Mesh(new OctahedronGeometry(.04, 0), n), [0, 0, .99], null, [1, 3, 1]]], Y: [[new Line(w(1, .5), d), null, [0, 0, -Math.PI / 2]], [new Mesh(new OctahedronGeometry(.04, 0), a), [0, 0, .99], null, [3, 1, 1]]], Z: [[new Line(w(1, .5), p), null, [0, Math.PI / 2, 0]], [new Mesh(new OctahedronGeometry(.04, 0), o), [.99, 0, 0], null, [1, 3, 1]]], E: [[new Line(w(1.25, 1), v), null, [0, Math.PI / 2, 0]], [new Mesh(new CylinderGeometry(.03, 0, .15, 4, 1, !1), v), [1.17, 0, 0], [0, 0, -Math.PI / 2], [1, 1, .001]], [new Mesh(new CylinderGeometry(.03, 0, .15, 4, 1, !1), v), [-1.17, 0, 0], [0, 0, Math.PI / 2], [1, 1, .001]], [new Mesh(new CylinderGeometry(.03, 0, .15, 4, 1, !1), v), [0, -1.17, 0], [Math.PI, 0, 0], [1, 1, .001]], [new Mesh(new CylinderGeometry(.03, 0, .15, 4, 1, !1), v), [0, 1.17, 0], [0, 0, 0], [1, 1, .001]]], XYZE: [[new Line(w(1, 1), y), null, [0, Math.PI / 2, 0]]] }, E = { AXIS: [[new Line(x, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]] }, C = { X: [[new Mesh(new TorusGeometry(1, .1, 4, 24), i), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]], Y: [[new Mesh(new TorusGeometry(1, .1, 4, 24), i), [0, 0, 0], [Math.PI / 2, 0, 0]]], Z: [[new Mesh(new TorusGeometry(1, .1, 4, 24), i), [0, 0, 0], [0, 0, -Math.PI / 2]]], E: [[new Mesh(new TorusGeometry(1.25, .1, 2, 24), i)]], XYZE: [[new Mesh(new SphereGeometry(.7, 10, 8), i)]] }, L = { X: [[new Mesh(b, n), [.8, 0, 0], [0, 0, -Math.PI / 2]], [new Line(x, u), null, null, [.8, 1, 1]]], Y: [[new Mesh(b, a), [0, .8, 0]], [new Line(x, d), null, [0, 0, Math.PI / 2], [.8, 1, 1]]], Z: [[new Mesh(b, o), [0, 0, .8], [Math.PI / 2, 0, 0]], [new Line(x, p), null, [0, -Math.PI / 2, 0], [.8, 1, 1]]], XY: [[new Mesh(b, l), [.85, .85, 0], null, [2, 2, .2]], [new Line(x, g), [.855, .98, 0], null, [.125, 1, 1]], [new Line(x, g), [.98, .855, 0], [0, 0, Math.PI / 2], [.125, 1, 1]]], YZ: [[new Mesh(b, c), [0, .85, .85], null, [.2, 2, 2]], [new Line(x, f), [0, .855, .98], [0, 0, Math.PI / 2], [.125, 1, 1]], [new Line(x, f), [0, .98, .855], [0, -Math.PI / 2, 0], [.125, 1, 1]]], XZ: [[new Mesh(b, h), [.85, 0, .85], null, [2, .2, 2]], [new Line(x, m), [.855, 0, .98], null, [.125, 1, 1]], [new Line(x, m), [.98, 0, .855], [0, -Math.PI / 2, 0], [.125, 1, 1]]], XYZX: [[new Mesh(new BoxGeometry(.125, .125, .125), s.clone()), [1.1, 0, 0]]], XYZY: [[new Mesh(new BoxGeometry(.125, .125, .125), s.clone()), [0, 1.1, 0]]], XYZZ: [[new Mesh(new BoxGeometry(.125, .125, .125), s.clone()), [0, 0, 1.1]]] }, R = { X: [[new Mesh(new CylinderGeometry(.2, 0, .8, 4, 1, !1), i), [.5, 0, 0], [0, 0, -Math.PI / 2]]], Y: [[new Mesh(new CylinderGeometry(.2, 0, .8, 4, 1, !1), i), [0, .5, 0]]], Z: [[new Mesh(new CylinderGeometry(.2, 0, .8, 4, 1, !1), i), [0, 0, .5], [Math.PI / 2, 0, 0]]], XY: [[new Mesh(b, i), [.85, .85, 0], null, [3, 3, .2]]], YZ: [[new Mesh(b, i), [0, .85, .85], null, [.2, 3, 3]]], XZ: [[new Mesh(b, i), [.85, 0, .85], null, [3, .2, 3]]], XYZX: [[new Mesh(new BoxGeometry(.2, .2, .2), i), [1.1, 0, 0]]], XYZY: [[new Mesh(new BoxGeometry(.2, .2, .2), i), [0, 1.1, 0]]], XYZZ: [[new Mesh(new BoxGeometry(.2, .2, .2), i), [0, 0, 1.1]]] }, D = { X: [[new Line(x, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]], Y: [[new Line(x, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]], Z: [[new Line(x, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]] }, P = function (e) { var t = new Object3D; for (var i in e) for (var r = e[i].length; r--;) { var n = e[i][r][0].clone(), a = e[i][r][1], o = e[i][r][2], s = e[i][r][3], l = e[i][r][4]; n.name = i, n.tag = l, a && n.position.set(a[0], a[1], a[2]), o && n.rotation.set(o[0], o[1], o[2]), s && n.scale.set(s[0], s[1], s[2]), n.updateMatrix(); var c = n.geometry.clone(); c.applyMatrix4(n.matrix), n.geometry = c, n.renderOrder = 1 / 0, n.position.set(0, 0, 0), n.rotation.set(0, 0, 0), n.scale.set(1, 1, 1), t.add(n) } return t }, O = new Vector3(0, 0, 0), I = new Euler, k = new Vector3(0, 1, 0), B = new Vector3(0, 0, 0), N = new Matrix4, F = new Quaternion, U = new Quaternion, z = new Quaternion, G = new Vector3(1, 0, 0), H = new Vector3(0, 1, 0), V = new Vector3(0, 0, 1); this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = P(S)), this.add(this.gizmo.rotate = P(A)), this.add(this.gizmo.scale = P(L)), this.add(this.picker.translate = P(M)), this.add(this.picker.rotate = P(C)), this.add(this.picker.scale = P(R)), this.add(this.helper.translate = P(T)), this.add(this.helper.rotate = P(E)), this.add(this.helper.scale = P(D)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1, this.updateMatrixWorld = function () { this.space; var e = "local" === ("scale" === this.mode ? "local" : this.space) ? this.worldQuaternion : z; this.gizmo.translate.visible = "translate" === this.mode, this.gizmo.rotate.visible = "rotate" === this.mode, this.gizmo.scale.visible = "scale" === this.mode, this.helper.translate.visible = "translate" === this.mode, this.helper.rotate.visible = "rotate" === this.mode, this.helper.scale.visible = "scale" === this.mode; var t = []; t = (t = (t = t.concat(this.picker[this.mode].children)).concat(this.gizmo[this.mode].children)).concat(this.helper[this.mode].children); for (var i = 0; i < t.length; i++) { var r, n = t[i]; if (n.visible = !0, n.rotation.set(0, 0, 0), n.position.copy(this.worldPosition), r = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), n.scale.set(1, 1, 1).multiplyScalar(r * this.size / 7), "helper" !== n.tag) { if (n.quaternion.copy(e), "translate" === this.mode || "scale" === this.mode) { var a = .99; "X" !== n.name && "XYZX" !== n.name || Math.abs(k.copy(G).applyQuaternion(e).dot(this.eye)) > a && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), "Y" !== n.name && "XYZY" !== n.name || Math.abs(k.copy(H).applyQuaternion(e).dot(this.eye)) > a && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), "Z" !== n.name && "XYZZ" !== n.name || Math.abs(k.copy(V).applyQuaternion(e).dot(this.eye)) > a && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), "XY" === n.name && Math.abs(k.copy(V).applyQuaternion(e).dot(this.eye)) < .2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), "YZ" === n.name && Math.abs(k.copy(G).applyQuaternion(e).dot(this.eye)) < .2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), "XZ" === n.name && Math.abs(k.copy(H).applyQuaternion(e).dot(this.eye)) < .2 && (n.scale.set(1e-10, 1e-10, 1e-10), n.visible = !1), -1 !== n.name.search("X") && (k.copy(G).applyQuaternion(e).dot(this.eye) < 0 ? "fwd" === n.tag ? n.visible = !1 : n.scale.x *= -1 : "bwd" === n.tag && (n.visible = !1)), -1 !== n.name.search("Y") && (k.copy(H).applyQuaternion(e).dot(this.eye) < 0 ? "fwd" === n.tag ? n.visible = !1 : n.scale.y *= -1 : "bwd" === n.tag && (n.visible = !1)), -1 !== n.name.search("Z") && (k.copy(V).applyQuaternion(e).dot(this.eye) < 0 ? "fwd" === n.tag ? n.visible = !1 : n.scale.z *= -1 : "bwd" === n.tag && (n.visible = !1)) } else "rotate" === this.mode && (U.copy(e), k.copy(this.eye).applyQuaternion(F.copy(e).invert()), -1 !== n.name.search("E") && n.quaternion.setFromRotationMatrix(N.lookAt(this.eye, B, H)), "X" === n.name && (F.setFromAxisAngle(G, Math.atan2(-k.y, k.z)), F.multiplyQuaternions(U, F), n.quaternion.copy(F)), "Y" === n.name && (F.setFromAxisAngle(H, Math.atan2(k.x, k.z)), F.multiplyQuaternions(U, F), n.quaternion.copy(F)), "Z" === n.name && (F.setFromAxisAngle(V, Math.atan2(k.y, k.x)), F.multiplyQuaternions(U, F), n.quaternion.copy(F))); n.visible = n.visible && (-1 === n.name.indexOf("X") || this.showX), n.visible = n.visible && (-1 === n.name.indexOf("Y") || this.showY), n.visible = n.visible && (-1 === n.name.indexOf("Z") || this.showZ), n.visible = n.visible && (-1 === n.name.indexOf("E") || this.showE), n.material.color && (n.material._opacity = n.material._opacity || n.material.opacity, n.material._color = n.material._color || n.material.color.clone(), n.material.color.copy(n.material._color), n.material.opacity = n.material._opacity, this.enabled ? this.axis && (n.name === this.axis || this.axis.split("").some((function (e) { return n.name === e })) ? (n.material.opacity = 1, n.material.color.lerp(new Color$1(1, 1, 1), .5)) : (n.material.opacity *= .25, n.material.color.lerp(new Color$1(1, 1, 1), .5))) : (n.material.opacity *= .5, n.material.color.lerp(new Color$1(1, 1, 1), .5))) } else n.visible = !1, "AXIS" === n.name ? (n.position.copy(this.worldPositionStart), n.visible = !!this.axis, "X" === this.axis && (F.setFromEuler(I.set(0, 0, 0)), n.quaternion.copy(e).multiply(F), Math.abs(k.copy(G).applyQuaternion(e).dot(this.eye)) > .9 && (n.visible = !1)), "Y" === this.axis && (F.setFromEuler(I.set(0, 0, Math.PI / 2)), n.quaternion.copy(e).multiply(F), Math.abs(k.copy(H).applyQuaternion(e).dot(this.eye)) > .9 && (n.visible = !1)), "Z" === this.axis && (F.setFromEuler(I.set(0, Math.PI / 2, 0)), n.quaternion.copy(e).multiply(F), Math.abs(k.copy(V).applyQuaternion(e).dot(this.eye)) > .9 && (n.visible = !1)), "XYZE" === this.axis && (F.setFromEuler(I.set(0, Math.PI / 2, 0)), k.copy(this.rotationAxis), n.quaternion.setFromRotationMatrix(N.lookAt(B, k, H)), n.quaternion.multiply(F), n.visible = this.dragging), "E" === this.axis && (n.visible = !1)) : "START" === n.name ? (n.position.copy(this.worldPositionStart), n.visible = this.dragging) : "END" === n.name ? (n.position.copy(this.worldPosition), n.visible = this.dragging) : "DELTA" === n.name ? (n.position.copy(this.worldPositionStart), n.quaternion.copy(this.worldQuaternionStart), O.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), O.applyQuaternion(this.worldQuaternionStart.clone().invert()), n.scale.copy(O), n.visible = this.dragging) : (n.quaternion.copy(e), this.dragging ? n.position.copy(this.worldPositionStart) : n.position.copy(this.worldPosition), this.axis && (n.visible = -1 !== this.axis.search(n.name))) } Object3D.prototype.updateMatrixWorld.call(this) } }; TransformControlsGizmo.prototype = Object.assign(Object.create(Object3D.prototype), { constructor: TransformControlsGizmo, isTransformControlsGizmo: !0 }); var TransformControlsPlane = function () { Mesh.call(this, new PlaneGeometry(1e5, 1e5, 2, 2), new MeshBasicMaterial({ visible: !1, wireframe: !0, side: DoubleSide, transparent: !0, opacity: .1, toneMapped: !1 })), this.type = "TransformControlsPlane"; var e = new Vector3(1, 0, 0), t = new Vector3(0, 1, 0), i = new Vector3(0, 0, 1), r = new Vector3, n = new Vector3, a = new Vector3, o = new Matrix4, s = new Quaternion; this.updateMatrixWorld = function () { var l = this.space; switch (this.position.copy(this.worldPosition), "scale" === this.mode && (l = "local"), e.set(1, 0, 0).applyQuaternion("local" === l ? this.worldQuaternion : s), t.set(0, 1, 0).applyQuaternion("local" === l ? this.worldQuaternion : s), i.set(0, 0, 1).applyQuaternion("local" === l ? this.worldQuaternion : s), a.copy(t), this.mode) { case "translate": case "scale": switch (this.axis) { case "X": a.copy(this.eye).cross(e), n.copy(e).cross(a); break; case "Y": a.copy(this.eye).cross(t), n.copy(t).cross(a); break; case "Z": a.copy(this.eye).cross(i), n.copy(i).cross(a); break; case "XY": n.copy(i); break; case "YZ": n.copy(e); break; case "XZ": a.copy(i), n.copy(t); break; case "XYZ": case "E": n.set(0, 0, 0) }break; case "rotate": default: n.set(0, 0, 0) }0 === n.length() ? this.quaternion.copy(this.cameraQuaternion) : (o.lookAt(r.set(0, 0, 0), n, a), this.quaternion.setFromRotationMatrix(o)), Object3D.prototype.updateMatrixWorld.call(this) } }; function SelectControls() { const { instance: e, orbitControls: t, renderer: i, objectStore: r, scene: n, defaultObjectTree: a } = _context, o = new Triangle, s = new Triangle, l = new Box3, c = "__SELECT_DIV_ID__", h = { callback: void 0 }, u = new Frustum, d = {}, p = new Vector2; function f(e) { t.enabled = !1, h.callback = e, i.domElement.addEventListener("pointerdown", m), i.domElement.addEventListener("pointerup", g) } function m(e) { i.domElement === e.target && (e.preventDefault && e.preventDefault(), 0 === e.button && (p.x = e.offsetX, p.y = e.offsetY, i.domElement.addEventListener("pointermove", y))) } function g(t) { if (i.domElement !== t.target) return; t.preventDefault && t.preventDefault(), i.domElement.removeEventListener("pointermove", y); const r = document.getElementById(c); if (!r) return; i.domElement.parentNode.removeChild(r); const n = p.x > t.offsetX ? t.offsetX : p.x, a = p.x < t.offsetX ? t.offsetX : p.x, o = p.y > t.offsetY ? t.offsetY : p.y, s = p.y < t.offsetY ? t.offsetY : p.y, l = new Vector3, f = e.convertScreenToWorld({ x: n, y: o }, l); d.p1Near = l, d.p1Far = f; const m = new Vector3, g = e.convertScreenToWorld({ x: n, y: s }, m); d.p2Near = m, d.p2Far = g; const _ = new Vector3, b = e.convertScreenToWorld({ x: a, y: s }, _); d.p3Near = _, d.p3Far = b; const x = new Vector3, w = e.convertScreenToWorld({ x: a, y: o }, x); d.p4Near = x, d.p4Far = w; const S = (new Plane).setFromCoplanarPoints(l, x, m), M = (new Plane).setFromCoplanarPoints(f, b, w), T = (new Plane).setFromCoplanarPoints(l, g, f), A = (new Plane).setFromCoplanarPoints(x, w, b), E = (new Plane).setFromCoplanarPoints(w, l, f), C = (new Plane).setFromCoplanarPoints(_, g, m); u.set(S, M, T, A, E, C), h.callback && h.callback(v) } function y(e) { if (i.domElement !== e.target) return; e.preventDefault && e.preventDefault(); let t = document.getElementById(c); t || (t = document.createElement("div"), t.setAttribute("id", c), t.style.position = "absolute", t.style.backgroundColor = "rgba(0,0,0,0)", t.style.border = "2px red solid", t.style.pointerEvents = "none", i.domElement.parentNode.appendChild(t)), t.style.width = `${Math.abs(e.offsetX - p.x)}px`, t.style.height = `${Math.abs(e.offsetY - p.y)}px`, t.style.left = `${e.offsetX > p.x ? p.x : e.offsetX}px`, t.style.top = `${e.offsetY > p.y ? p.y : e.offsetY}px` } function v(e) { if (!e.geometry) return !1; if (!e.geometry.isBufferGeometry) return !1; if (!u.intersectsObject(e)) return !1; const t = e.geometry.attributes.position.array; let i = []; if (e.geometry.index) i = e.geometry.index.array; else for (let e = 0, r = t.length / 3; e < r; e++)i.push(e); for (let r = 0, n = i.length; r < n; r += 3) { const n = i[r], a = new Vector3(t[n], t[n + 1], t[n + 2]); if (a.applyMatrix4(e.matrixWorld), u.containsPoint(a)) return !0; const s = i[r + 1], l = new Vector3(t[s], t[s + 1], t[s + 2]); if (l.applyMatrix4(e.matrixWorld), u.containsPoint(l)) return !0; const c = i[r + 2], h = new Vector3(t[c], t[c + 1], t[c + 2]); if (h.applyMatrix4(e.matrixWorld), u.containsPoint(h)) return !0; if (o.set(a, l, h), o.containsPoint(d.p1Near)) return !0; if (o.containsPoint(d.p1Far)) return !0; if (o.containsPoint(d.p2Near)) return !0; if (o.containsPoint(d.p2Far)) return !0; if (o.containsPoint(d.p3Near)) return !0; if (o.containsPoint(d.p3Far)) return !0; if (o.containsPoint(d.p4Near)) return !0; if (o.containsPoint(d.p4Far)) return !0 } return !1 } const _ = "__SELECT_CIRCLE_ID__", b = { callback: void 0 }, x = new Vector3; let w, S, M; function T(e) { t.enabled = !1, b.callback = e, i.domElement.addEventListener("pointerdown", A), i.domElement.addEventListener("pointerup", E) } function A(t) { if (i.domElement !== t.target) return; if (t.preventDefault && t.preventDefault(), 0 !== t.button) return; let r = e.pickScreenToWorld({ x: t.offsetX, y: t.offsetY }); if (!1 === r.flag) return; r = e.convertWorldToSceneLocal(r), x.set(r.x, r.y, r.z); const n = []; for (let e = 0; e <= 360; e++) { const t = Math.PI / 180 * e, i = 1 * Math.cos(t), r = 1 * Math.sin(t); n.push(x.x + i), n.push(-(x.z - r)) } e.addArea(_, { point: n, depth: 500, areaType: "gradient01", color: "#ff0000", fillColor: "#ff0000", alpha: 1, fillArea: "segment01", fillType: "none", enableAutoHidebyDistance: !1, offset: !0, lonOffset: 0, latOffset: 0, altOffset: 0, alt: x.y, isShow: !0 }, void 0, (function (e) { M = e })), i.domElement.addEventListener("pointermove", C) } function E(e) { if (i.domElement !== e.target) return; e.preventDefault && e.preventDefault(), i.domElement.removeEventListener("pointermove", C); if (!r.find(_)) return; r.remove(_), P.length = 0; const t = new Vector3(x.x, 0, x.z), n = new Vector3(t.x + S, 0, t.z); for (let e = 1; e <= 360; e++) { const i = Math.PI / 180 * e; let r = S * Math.cos(i), a = S * Math.sin(i); r = t.x + r, a = t.z + a, P.push(n.clone()), P.push(t.clone()), P.push(n.set(r, 0, a).clone()) } D.setFromPoints(P), D.min.y = -1 / 0, D.max.y = 1 / 0, b.callback && b.callback(B) } function C(t) { i.domElement === t.target && (void 0 !== w && clearTimeout(w), w = setTimeout((function () { t.preventDefault && t.preventDefault(); let i = e.pickScreenToWorld({ x: t.offsetX, y: t.offsetY }); if (!1 === i.flag) return; i = e.convertWorldToSceneLocal(i); const r = x.clone(); r.y = 0; const n = x.clone(); if (n.set(i.x, 0, i.z), S = r.distanceTo(n), void 0 === M) return; M.scale.set(S, 1, S), w = void 0 }), 10)) } const L = "__SELECT_POLYGON_ID__", R = { callback: void 0 }, D = new Box3, P = [], O = []; function I(e) { t.enabled = !1, R.callback = e, i.domElement.addEventListener("pointerdown", k) } function k(t) { if (i.domElement !== t.target) return; if (t.preventDefault && t.preventDefault(), 2 == t.button) { if (!r.find(L)) return; r.remove(L); const e = []; for (const t of O) t.y = 0, e.push(t); O.length = 0, P.length = 0; const t = util$1.getIndices(e); for (const i of t) P.push(e[i]); return D.setFromPoints(P), D.min.y = -1 / 0, D.max.y = 1 / 0, void (R.callback && R.callback(B)) } if (0 !== t.button) return; let n = e.pickScreenToWorld({ x: t.offsetX, y: t.offsetY }); !1 !== n.flag && (n = e.convertWorldToSceneLocal(n), O.push(new Vector3(n.x, n.y, n.z)), e.addPath(L, { points: O, color: "#ff0000", colorPass: "#ff0000", pass: 0, passRange: 0, pathType: "segment06", width: 100, alpha: 1, isShow: !0 })) } function B(e) { if (!e.geometry) return !1; if (!e.geometry.isBufferGeometry) return !1; if (null === e.geometry.boundingBox && e.geometry.computeBoundingBox(), l.copy(e.geometry.boundingBox).applyMatrix4(e.matrixWorld), !D.intersectsBox(l)) return !1; const t = e.geometry.attributes.position.array; let i = []; if (e.geometry.index) i = e.geometry.index.array; else for (let e = 0, r = t.length / 3; e < r; e++)i.push(e); for (let r = 0, n = P.length; r < n; r += 3) { const n = P[r], a = P[r + 1], l = P[r + 2]; o.set(n, a, l); for (let r = 0, c = i.length; r < c; r += 3) { const c = i[r], h = new Vector3(t[c], t[c + 1], t[c + 2]); if (h.applyMatrix4(e.matrixWorld), h.y = 0, o.containsPoint(h)) return !0; const u = i[r + 1], d = new Vector3(t[u], t[u + 1], t[u + 2]); if (d.applyMatrix4(e.matrixWorld), d.y = 0, o.containsPoint(d)) return !0; const p = i[r + 2], f = new Vector3(t[p], t[p + 1], t[p + 2]); if (f.applyMatrix4(e.matrixWorld), f.y = 0, o.containsPoint(f)) return !0; if (s.set(h, d, f), s.containsPoint(n)) return !0; if (s.containsPoint(a)) return !0; if (s.containsPoint(l)) return !0 } } } function N() { i.domElement.removeEventListener("pointerdown", m), i.domElement.removeEventListener("pointermove", y), i.domElement.removeEventListener("pointerup", g), h.callback = void 0; const e = document.getElementById(c); e && i.domElement.parentNode.removeChild(e), i.domElement.removeEventListener("pointerdown", A), i.domElement.removeEventListener("pointermove", C), i.domElement.removeEventListener("pointerup", E), b.callback = void 0; r.find(_) && r.remove(_), i.domElement.removeEventListener("pointerdown", k), R.callback = void 0, P.length = 0, O.length = 0; r.find(L) && r.remove(L), t.enabled = !0 } this.startSelect = function (e) { N(); const { type: t } = e; function i(t) { const { modelType: i, events: r } = e, o = "model" === i ? "ModelItem" : "BuildingItem", s = []; for (const e of n.models.children) { const i = a.findItemByObject3D(e); if (!i) continue; if (0 == i.visible) continue; if (!i.getType || i.getType() !== o) continue; let r = !1; e.traverse((function (e) { r || e.isMesh && (r = t(e)) })), r && s.push(i) } const l = { type: i, data: [] }; _context.effectStore.highlightObject(); for (const e of s) _context.effectStore.highlightObject(e.getGroup(), !0), l.data.push({ id: e.name }); r && r(l) } "rect" === t && f(i), "circle" === t && T(i), "polygon" === t && I(i) }, this.endSelect = function () { _context.effectStore.highlightObject(), N() }, this.startSelectDrawable = function (e, t) { N(); const { type: i } = e; function n(e) { const i = []; r.forEach((function (t) { let r = !1; if (t.traverse((function (e) { r || (r = e.userData.inView) })), !1 === r) return; let n = !1; t.traverse((function (t) { if (!n) { if (t.isInstancedMesh) { const r = new Mesh; r.copy(t); const a = new Matrix4, o = t.instanceMatrix.array; for (let s = 0, l = t.instanceMatrix.count; s < l; s++)a.fromArray(o, s * t.instanceMatrix.itemSize), r.matrixWorld = a, n = e(r), n && (i.push({ isInstancedMesh: !0, name: t.name, index: s }), n = !1) } (t.isMesh || t.isSprite) && (n = e(t)) } })), n && i.push(t) })), t && t(i) } "rect" === i && f(n), "circle" === i && T(n), "polygon" === i && I(n) }, this.endSelectDrawable = N } TransformControlsPlane.prototype = Object.assign(Object.create(Mesh.prototype), { constructor: TransformControlsPlane, isTransformControlsPlane: !0 }); let ModelSelectEvent = { type: "modelSelect" }, NodeSelectEvent = { type: "nodeSelect" }; class SelectionControls extends EventDispatcher { constructor() { super("SelectionControls"); let e = {}, t = {}, i = "selection_div", r = ["ModelItem", "BuildingItem", "BuildingFloorItem", "IconAsset", "GroupItem", "PaintItem", "BuildingFloorHome"]; this.fromBuildingSelection = null, this.fromModelSelection = null, this._clearSelectDiv = () => { let e = document.getElementById(i); e && _context.renderer.domElement.parentNode.removeChild(e) }, this._createSelectDiv = () => { this._clearSelectDiv(); let r = document.createElement("div"); r.setAttribute("id", i), r.style = `position: absolute;\n                width: ${Math.abs(t.x - e.x)}px; \n                height:${Math.abs(t.y - e.y)}px; \n                left: ${t.x > e.x ? e.x : t.x}px; \n                top: ${t.y > e.y ? e.y : t.y}px;\n                background-color: rgba(0,0,0,0);\n                border: 2px red solid;\n                pointer-events: none`, _context.renderer.domElement.parentNode.appendChild(r) }, this._onMouseMove = i => { window.navigator.platform.toLocaleLowerCase().indexOf("mac") > -1 && !i.metaKey || (-1 !== window.navigator.platform.toLocaleLowerCase().indexOf("mac") || i.ctrlKey) && i.target === _context.renderer.domElement && (Math.abs(e.x - i.offsetX) > 3 || Math.abs(e.y - i.offsetY) > 3) && (i.preventDefault(), t.x = i.offsetX, t.y = i.offsetY, this._createSelectDiv()) }, this._onMouseDown = t => { 0 === t.button && (window.navigator.platform.toLocaleLowerCase().indexOf("mac") > -1 && !t.metaKey || (-1 !== window.navigator.platform.toLocaleLowerCase().indexOf("mac") || t.ctrlKey) && _context.renderer && t.target === _context.renderer.domElement && (_context.transformControls.enabled = !1, _context.transformControls.pointerUp({ button: 0 }), t.preventDefault(), document.addEventListener("pointermove", this._onMouseMove), e.x = t.offsetX, e.y = t.offsetY)) }, this._onMouseUp = i => { 0 === i.button && (_context.transformControls.enabled = !0, document.removeEventListener("pointermove", this._onMouseMove), this._clearSelectDiv(), window.navigator.platform.toLocaleLowerCase().indexOf("mac") > -1 && !i.metaKey || (-1 !== window.navigator.platform.toLocaleLowerCase().indexOf("mac") || i.ctrlKey) && _context.renderer && i.target === _context.renderer.domElement && (e.x === i.offsetX && e.y === i.offsetY || void 0 === e.x && void 0 === e.y || (i.preventDefault(), t.x = i.offsetX, t.y = i.offsetY, this._getSelectionObject(i), e = {}, t = {}))) }, this._convertWorldToScreen = e => { var t = new Vector3(e.x, e.y, e.z).project(_context.camera), i = _context.renderer.domElement.parentNode.clientWidth / 2, r = _context.renderer.domElement.parentNode.clientHeight / 2; return { x: Math.round(t.x * i + i), y: Math.round(-t.y * r + r) } }, this._inPolygon = (e, t) => { let i, r = 0, n = t[0], a = t.length; for (let o = 1; o <= a; o++) { if (i = t[o % a], e.y > (n.y > i.y ? i.y : n.y) && e.y <= (n.y < i.y ? i.y : n.y) && e.x <= (n.x > i.x ? n.x : i.x) && n.y != i.y) { let t = (e.y - n.y) * (i.x - n.x) / (i.y - n.y) + n.x; (n.x == i.x || e.x <= t) && r++ } n = i } return r % 2 != 0 }, this.getIsSelectionObject = i => { let n = _context.defaultObjectTree.getItemByUUID(i.uuid); if (n && n.getType && r.indexOf(n.getType()) > -1 && !0 === i.visible && !n.isLock) { i.updateWorldMatrix(); let r = (new Box3).setFromObject(i), n = r.min.clone(), a = r.max.clone(), o = this._convertWorldToScreen(n), s = this._convertWorldToScreen(a), l = o.x > s.x ? s.x : o.x, c = o.x < s.x ? s.x : o.x, h = o.y > s.y ? s.y : o.y, u = o.y < s.y ? s.y : o.y, d = [{ x: l, y: u }, { x: l, y: h }, { x: c, y: h }, { x: c, y: u }], p = e.x > t.x ? t.x : e.x, f = e.x < t.x ? t.x : e.x, m = e.y > t.y ? t.y : e.y, g = e.y < t.y ? t.y : e.y, y = [{ x: p, y: g }, { x: p, y: m }, { x: f, y: m }, { x: f, y: g }], v = new Box2(new Vector2(e.x, e.y), new Vector2(t.x, t.y)), _ = new Box2(new Vector2(o.x, o.y), new Vector2(s.x, s.y)), b = v.getCenter(new Vector2), x = _.getCenter(new Vector2); if (this._inPolygon(d[0], y) || this._inPolygon(d[1], y) || this._inPolygon(d[2], y) || this._inPolygon(d[3], y) || this._inPolygon(x, y) || this._inPolygon(y[0], d) || this._inPolygon(y[1], d) || this._inPolygon(y[2], d) || this._inPolygon(y[3], d) || this._inPolygon(b, d)) return i } return null }, this.getIsSelectionNode = i => { let r = _context.defaultObjectTree.getItemByUUID(i.uuid) || {}; if (r && !r.isLock) { i.updateWorldMatrix(); let r = (new Box3).setFromObject(i), n = r.min.clone(), a = r.max.clone(), o = this._convertWorldToScreen(n), s = this._convertWorldToScreen(a), l = o.x > s.x ? s.x : o.x, c = o.x < s.x ? s.x : o.x, h = o.y > s.y ? s.y : o.y, u = o.y < s.y ? s.y : o.y, d = [{ x: l, y: u }, { x: l, y: h }, { x: c, y: h }, { x: c, y: u }], p = e.x > t.x ? t.x : e.x, f = e.x < t.x ? t.x : e.x, m = e.y > t.y ? t.y : e.y, g = e.y < t.y ? t.y : e.y, y = [{ x: p, y: g }, { x: p, y: m }, { x: f, y: m }, { x: f, y: g }], v = new Box2(new Vector2(e.x, e.y), new Vector2(t.x, t.y)), _ = new Box2(new Vector2(o.x, o.y), new Vector2(s.x, s.y)), b = v.getCenter(new Vector2), x = _.getCenter(new Vector2); if (this._inPolygon(d[0], y) || this._inPolygon(d[1], y) || this._inPolygon(d[2], y) || this._inPolygon(d[3], y) || this._inPolygon(x, y) || this._inPolygon(y[0], d) || this._inPolygon(y[1], d) || this._inPolygon(y[2], d) || this._inPolygon(y[3], d) || this._inPolygon(b, d)) return i } return null }, this._getSelectionObject = e => { let t = [], i = []; this.fromBuildingSelection ? this.fromBuildingSelection.traverseVisible && this.fromBuildingSelection.traverseVisible((e => { let i = this.getIsSelectionObject(e); i && t.push(i) })) : _context.scene.models.children.forEach((e => { let i = this.getIsSelectionObject(e); i && t.push(i) })), this.fromModelSelection && this.fromModelSelection.traverseVisible && this.fromModelSelection.traverseVisible((e => { let t = this.getIsSelectionNode(e); t && i.push(t) })); let r = t.map((e => e.uuid)), n = i.map((e => e.uuid)); ModelSelectEvent.selectionList = r, this.dispatchEvent(ModelSelectEvent), NodeSelectEvent.selectionList = n, this.dispatchEvent(NodeSelectEvent) }, this.switchSelection = e => { document.removeEventListener("pointerdown", this._onMouseDown), document.removeEventListener("pointerup", this._onMouseUp), e && (document.addEventListener("pointerdown", this._onMouseDown), document.addEventListener("pointerup", this._onMouseUp)) }, this.setFromModelSelection = e => { this.fromModelSelection = _context.scene.getObjectByProperty("uuid", e) }, this.setFromBuildingSelection = e => { this.fromBuildingSelection = _context.scene.getObjectByProperty("uuid", e) } } } var browser = createCommonjsModule((function (e, t) {
      e.exports = function e(t, i, r) { function n(o, s) { if (!i[o]) { if (!t[o]) { var l = "function" == typeof commonjsRequire && commonjsRequire; if (!s && l) return l(o, !0); if (a) return a(o, !0); var c = new Error("Cannot find module '" + o + "'"); throw c.code = "MODULE_NOT_FOUND", c } var h = i[o] = { exports: {} }; t[o][0].call(h.exports, (function (e) { var i = t[o][1][e]; return n(i || e) }), h, h.exports, e, t, i, r) } return i[o].exports } for (var a = "function" == typeof commonjsRequire && commonjsRequire, o = 0; o < r.length; o++)n(r[o]); return n }({
         1: [function (e, t, i) { (function (t) { (function () { let r = e("./interlace"), n = [function () { }, function (e, t, i, r) { if (r === t.length) throw new Error("Ran out of data"); let n = t[r]; e[i] = n, e[i + 1] = n, e[i + 2] = n, e[i + 3] = 255 }, function (e, t, i, r) { if (r + 1 >= t.length) throw new Error("Ran out of data"); let n = t[r]; e[i] = n, e[i + 1] = n, e[i + 2] = n, e[i + 3] = t[r + 1] }, function (e, t, i, r) { if (r + 2 >= t.length) throw new Error("Ran out of data"); e[i] = t[r], e[i + 1] = t[r + 1], e[i + 2] = t[r + 2], e[i + 3] = 255 }, function (e, t, i, r) { if (r + 3 >= t.length) throw new Error("Ran out of data"); e[i] = t[r], e[i + 1] = t[r + 1], e[i + 2] = t[r + 2], e[i + 3] = t[r + 3] }], a = [function () { }, function (e, t, i, r) { let n = t[0]; e[i] = n, e[i + 1] = n, e[i + 2] = n, e[i + 3] = r }, function (e, t, i) { let r = t[0]; e[i] = r, e[i + 1] = r, e[i + 2] = r, e[i + 3] = t[1] }, function (e, t, i, r) { e[i] = t[0], e[i + 1] = t[1], e[i + 2] = t[2], e[i + 3] = r }, function (e, t, i) { e[i] = t[0], e[i + 1] = t[1], e[i + 2] = t[2], e[i + 3] = t[3] }]; function o(e, t) { let i = [], r = 0; function n() { if (r === e.length) throw new Error("Ran out of data"); let n, a, o, s, l, c, h, u, d = e[r]; switch (r++, t) { default: throw new Error("unrecognised depth"); case 16: h = e[r], r++, i.push((d << 8) + h); break; case 4: h = 15 & d, u = d >> 4, i.push(u, h); break; case 2: l = 3 & d, c = d >> 2 & 3, h = d >> 4 & 3, u = d >> 6 & 3, i.push(u, h, c, l); break; case 1: n = 1 & d, a = d >> 1 & 1, o = d >> 2 & 1, s = d >> 3 & 1, l = d >> 4 & 1, c = d >> 5 & 1, h = d >> 6 & 1, u = d >> 7 & 1, i.push(u, h, c, l, s, o, a, n) } } return { get: function (e) { for (; i.length < e;)n(); let t = i.slice(0, e); return i = i.slice(e), t }, resetAfterLine: function () { i.length = 0 }, end: function () { if (r !== e.length) throw new Error("extra data found") } } } function s(e, t, i, r, a, o) { let s = e.width, l = e.height, c = e.index; for (let e = 0; e < l; e++)for (let l = 0; l < s; l++) { let s = i(l, e, c); n[r](t, a, s, o), o += r } return o } function l(e, t, i, r, n, o) { let s = e.width, l = e.height, c = e.index; for (let e = 0; e < l; e++) { for (let l = 0; l < s; l++) { let s = n.get(r), h = i(l, e, c); a[r](t, s, h, o) } n.resetAfterLine() } } i.dataToBitMap = function (e, i) { let n, a, c = i.width, h = i.height, u = i.depth, d = i.bpp, p = i.interlace; 8 !== u && (n = o(e, u)), a = u <= 8 ? t.alloc(c * h * 4) : new Uint16Array(c * h * 4); let f, m, g = Math.pow(2, u) - 1, y = 0; if (p) f = r.getImagePasses(c, h), m = r.getInterlaceIterator(c, h); else { let e = 0; m = function () { let t = e; return e += 4, t }, f = [{ width: c, height: h }] } for (let t = 0; t < f.length; t++)8 === u ? y = s(f[t], a, m, d, e, y) : l(f[t], a, m, d, n, g); if (8 === u) { if (y !== e.length) throw new Error("extra data found") } else n.end(); return a } }).call(this) }).call(this, e("buffer").Buffer) }, { "./interlace": 11, buffer: 33 }], 2: [function (e, t, i) { (function (i) { (function () { let r = e("./constants"); t.exports = function (e, t, n, a) { let o = -1 !== [r.COLORTYPE_COLOR_ALPHA, r.COLORTYPE_ALPHA].indexOf(a.colorType); if (a.colorType === a.inputColorType) { let t = function () { let e = new ArrayBuffer(2); return new DataView(e).setInt16(0, 256, !0), 256 !== new Int16Array(e)[0] }(); if (8 === a.bitDepth || 16 === a.bitDepth && t) return e } let s = 16 !== a.bitDepth ? e : new Uint16Array(e.buffer), l = 255, c = r.COLORTYPE_TO_BPP_MAP[a.inputColorType]; 4 !== c || a.inputHasAlpha || (c = 3); let h = r.COLORTYPE_TO_BPP_MAP[a.colorType]; 16 === a.bitDepth && (l = 65535, h *= 2); let u = i.alloc(t * n * h), d = 0, p = 0, f = a.bgColor || {}; function m() { let e, t, i, n = l; switch (a.inputColorType) { case r.COLORTYPE_COLOR_ALPHA: n = s[d + 3], e = s[d], t = s[d + 1], i = s[d + 2]; break; case r.COLORTYPE_COLOR: e = s[d], t = s[d + 1], i = s[d + 2]; break; case r.COLORTYPE_ALPHA: n = s[d + 1], e = s[d], t = e, i = e; break; case r.COLORTYPE_GRAYSCALE: e = s[d], t = e, i = e; break; default: throw new Error("input color type:" + a.inputColorType + " is not supported at present") }return a.inputHasAlpha && (o || (n /= l, e = Math.min(Math.max(Math.round((1 - n) * f.red + n * e), 0), l), t = Math.min(Math.max(Math.round((1 - n) * f.green + n * t), 0), l), i = Math.min(Math.max(Math.round((1 - n) * f.blue + n * i), 0), l))), { red: e, green: t, blue: i, alpha: n } } void 0 === f.red && (f.red = l), void 0 === f.green && (f.green = l), void 0 === f.blue && (f.blue = l); for (let e = 0; e < n; e++)for (let e = 0; e < t; e++) { let e = m(); switch (a.colorType) { case r.COLORTYPE_COLOR_ALPHA: case r.COLORTYPE_COLOR: 8 === a.bitDepth ? (u[p] = e.red, u[p + 1] = e.green, u[p + 2] = e.blue, o && (u[p + 3] = e.alpha)) : (u.writeUInt16BE(e.red, p), u.writeUInt16BE(e.green, p + 2), u.writeUInt16BE(e.blue, p + 4), o && u.writeUInt16BE(e.alpha, p + 6)); break; case r.COLORTYPE_ALPHA: case r.COLORTYPE_GRAYSCALE: { let t = (e.red + e.green + e.blue) / 3; 8 === a.bitDepth ? (u[p] = t, o && (u[p + 1] = e.alpha)) : (u.writeUInt16BE(t, p), o && u.writeUInt16BE(e.alpha, p + 2)); break } default: throw new Error("unrecognised color Type " + a.colorType) }d += c, p += h } return u } }).call(this) }).call(this, e("buffer").Buffer) }, { "./constants": 4, buffer: 33 }], 3: [function (e, t, i) { (function (i, r) { (function () { let n = e("util"), a = e("stream"), o = t.exports = function () { a.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = !1, this._encoding = "utf8", this.writable = !0 }; n.inherits(o, a), o.prototype.read = function (e, t) { this._reads.push({ length: Math.abs(e), allowLess: e < 0, func: t }), i.nextTick(function () { this._process(), this._paused && this._reads && this._reads.length > 0 && (this._paused = !1, this.emit("drain")) }.bind(this)) }, o.prototype.write = function (e, t) { if (!this.writable) return this.emit("error", new Error("Stream not writable")), !1; let i; return i = r.isBuffer(e) ? e : r.from(e, t || this._encoding), this._buffers.push(i), this._buffered += i.length, this._process(), this._reads && 0 === this._reads.length && (this._paused = !0), this.writable && !this._paused }, o.prototype.end = function (e, t) { e && this.write(e, t), this.writable = !1, this._buffers && (0 === this._buffers.length ? this._end() : (this._buffers.push(null), this._process())) }, o.prototype.destroySoon = o.prototype.end, o.prototype._end = function () { this._reads.length > 0 && this.emit("error", new Error("Unexpected end of input")), this.destroy() }, o.prototype.destroy = function () { this._buffers && (this.writable = !1, this._reads = null, this._buffers = null, this.emit("close")) }, o.prototype._processReadAllowingLess = function (e) { this._reads.shift(); let t = this._buffers[0]; t.length > e.length ? (this._buffered -= e.length, this._buffers[0] = t.slice(e.length), e.func.call(this, t.slice(0, e.length))) : (this._buffered -= t.length, this._buffers.shift(), e.func.call(this, t)) }, o.prototype._processRead = function (e) { this._reads.shift(); let t = 0, i = 0, n = r.alloc(e.length); for (; t < e.length;) { let r = this._buffers[i++], a = Math.min(r.length, e.length - t); r.copy(n, t, 0, a), t += a, a !== r.length && (this._buffers[--i] = r.slice(a)) } i > 0 && this._buffers.splice(0, i), this._buffered -= e.length, e.func.call(this, n) }, o.prototype._process = function () { try { for (; this._buffered > 0 && this._reads && this._reads.length > 0;) { let e = this._reads[0]; if (e.allowLess) this._processReadAllowingLess(e); else { if (!(this._buffered >= e.length)) break; this._processRead(e) } } this._buffers && !this.writable && this._end() } catch (e) { this.emit("error", e) } } }).call(this) }).call(this, e("_process"), e("buffer").Buffer) }, { _process: 60, buffer: 33, stream: 61, util: 81 }], 4: [function (e, t, i) { t.exports = { PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10], TYPE_IHDR: 1229472850, TYPE_IEND: 1229278788, TYPE_IDAT: 1229209940, TYPE_PLTE: 1347179589, TYPE_tRNS: 1951551059, TYPE_gAMA: 1732332865, COLORTYPE_GRAYSCALE: 0, COLORTYPE_PALETTE: 1, COLORTYPE_COLOR: 2, COLORTYPE_ALPHA: 4, COLORTYPE_PALETTE_COLOR: 3, COLORTYPE_COLOR_ALPHA: 6, COLORTYPE_TO_BPP_MAP: { 0: 1, 2: 3, 3: 1, 4: 2, 6: 4 }, GAMMA_DIVISION: 1e5 } }, {}], 5: [function (e, t, i) { let r = []; !function () { for (let e = 0; e < 256; e++) { let t = e; for (let e = 0; e < 8; e++)1 & t ? t = 3988292384 ^ t >>> 1 : t >>>= 1; r[e] = t } }(); let n = t.exports = function () { this._crc = -1 }; n.prototype.write = function (e) { for (let t = 0; t < e.length; t++)this._crc = r[255 & (this._crc ^ e[t])] ^ this._crc >>> 8; return !0 }, n.prototype.crc32 = function () { return -1 ^ this._crc }, n.crc32 = function (e) { let t = -1; for (let i = 0; i < e.length; i++)t = r[255 & (t ^ e[i])] ^ t >>> 8; return -1 ^ t } }, {}], 6: [function (e, t, i) { (function (i) { (function () { let r = e("./paeth-predictor"); function n(e, t, i, r, n) { for (let a = 0; a < i; a++)r[n + a] = e[t + a] } function a(e, t, i) { let r = 0, n = t + i; for (let i = t; i < n; i++)r += Math.abs(e[i]); return r } function o(e, t, i, r, n, a) { for (let o = 0; o < i; o++) { let i = o >= a ? e[t + o - a] : 0, s = e[t + o] - i; r[n + o] = s } } function s(e, t, i, r) { let n = 0; for (let a = 0; a < i; a++) { let i = a >= r ? e[t + a - r] : 0, o = e[t + a] - i; n += Math.abs(o) } return n } function l(e, t, i, r, n) { for (let a = 0; a < i; a++) { let o = t > 0 ? e[t + a - i] : 0, s = e[t + a] - o; r[n + a] = s } } function c(e, t, i) { let r = 0, n = t + i; for (let a = t; a < n; a++) { let n = t > 0 ? e[a - i] : 0, o = e[a] - n; r += Math.abs(o) } return r } function h(e, t, i, r, n, a) { for (let o = 0; o < i; o++) { let s = o >= a ? e[t + o - a] : 0, l = t > 0 ? e[t + o - i] : 0, c = e[t + o] - (s + l >> 1); r[n + o] = c } } function u(e, t, i, r) { let n = 0; for (let a = 0; a < i; a++) { let o = a >= r ? e[t + a - r] : 0, s = t > 0 ? e[t + a - i] : 0, l = e[t + a] - (o + s >> 1); n += Math.abs(l) } return n } function d(e, t, i, n, a, o) { for (let s = 0; s < i; s++) { let l = s >= o ? e[t + s - o] : 0, c = t > 0 ? e[t + s - i] : 0, h = t > 0 && s >= o ? e[t + s - (i + o)] : 0, u = e[t + s] - r(l, c, h); n[a + s] = u } } function p(e, t, i, n) { let a = 0; for (let o = 0; o < i; o++) { let s = o >= n ? e[t + o - n] : 0, l = t > 0 ? e[t + o - i] : 0, c = t > 0 && o >= n ? e[t + o - (i + n)] : 0, h = e[t + o] - r(s, l, c); a += Math.abs(h) } return a } let f = { 0: n, 1: o, 2: l, 3: h, 4: d }, m = { 0: a, 1: s, 2: c, 3: u, 4: p }; t.exports = function (e, t, r, n, a) { let o; if ("filterType" in n && -1 !== n.filterType) { if ("number" != typeof n.filterType) throw new Error("unrecognised filter types"); o = [n.filterType] } else o = [0, 1, 2, 3, 4]; 16 === n.bitDepth && (a *= 2); let s = t * a, l = 0, c = 0, h = i.alloc((s + 1) * r), u = o[0]; for (let t = 0; t < r; t++) { if (o.length > 1) { let t = 1 / 0; for (let i = 0; i < o.length; i++) { let r = m[o[i]](e, c, s, a); r < t && (u = o[i], t = r) } } h[l] = u, l++, f[u](e, c, s, h, l, a), l += s, c += s } return h } }).call(this) }).call(this, e("buffer").Buffer) }, { "./paeth-predictor": 15, buffer: 33 }], 7: [function (e, t, i) { (function (i) { (function () { let r = e("util"), n = e("./chunkstream"), a = e("./filter-parse"), o = t.exports = function (e) { n.call(this); let t = [], r = this; this._filter = new a(e, { read: this.read.bind(this), write: function (e) { t.push(e) }, complete: function () { r.emit("complete", i.concat(t)) } }), this._filter.start() }; r.inherits(o, n) }).call(this) }).call(this, e("buffer").Buffer) }, { "./chunkstream": 3, "./filter-parse": 9, buffer: 33, util: 81 }], 8: [function (e, t, i) { (function (t) { (function () { let r = e("./sync-reader"), n = e("./filter-parse"); i.process = function (e, i) { let a = [], o = new r(e); return new n(i, { read: o.read.bind(o), write: function (e) { a.push(e) }, complete: function () { } }).start(), o.process(), t.concat(a) } }).call(this) }).call(this, e("buffer").Buffer) }, { "./filter-parse": 9, "./sync-reader": 22, buffer: 33 }], 9: [function (e, t, i) { (function (i) { (function () { let r = e("./interlace"), n = e("./paeth-predictor"); function a(e, t, i) { let r = e * t; return 8 !== i && (r = Math.ceil(r / (8 / i))), r } let o = t.exports = function (e, t) { let i = e.width, n = e.height, o = e.interlace, s = e.bpp, l = e.depth; if (this.read = t.read, this.write = t.write, this.complete = t.complete, this._imageIndex = 0, this._images = [], o) { let e = r.getImagePasses(i, n); for (let t = 0; t < e.length; t++)this._images.push({ byteWidth: a(e[t].width, s, l), height: e[t].height, lineIndex: 0 }) } else this._images.push({ byteWidth: a(i, s, l), height: n, lineIndex: 0 }); this._xComparison = 8 === l ? s : 16 === l ? 2 * s : 1 }; o.prototype.start = function () { this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this)) }, o.prototype._unFilterType1 = function (e, t, i) { let r = this._xComparison, n = r - 1; for (let a = 0; a < i; a++) { let i = e[1 + a], o = a > n ? t[a - r] : 0; t[a] = i + o } }, o.prototype._unFilterType2 = function (e, t, i) { let r = this._lastLine; for (let n = 0; n < i; n++) { let i = e[1 + n], a = r ? r[n] : 0; t[n] = i + a } }, o.prototype._unFilterType3 = function (e, t, i) { let r = this._xComparison, n = r - 1, a = this._lastLine; for (let o = 0; o < i; o++) { let i = e[1 + o], s = a ? a[o] : 0, l = o > n ? t[o - r] : 0, c = Math.floor((l + s) / 2); t[o] = i + c } }, o.prototype._unFilterType4 = function (e, t, i) { let r = this._xComparison, a = r - 1, o = this._lastLine; for (let s = 0; s < i; s++) { let i = e[1 + s], l = o ? o[s] : 0, c = s > a ? t[s - r] : 0, h = s > a && o ? o[s - r] : 0, u = n(c, l, h); t[s] = i + u } }, o.prototype._reverseFilterLine = function (e) { let t, r = e[0], n = this._images[this._imageIndex], a = n.byteWidth; if (0 === r) t = e.slice(1, a + 1); else switch (t = i.alloc(a), r) { case 1: this._unFilterType1(e, t, a); break; case 2: this._unFilterType2(e, t, a); break; case 3: this._unFilterType3(e, t, a); break; case 4: this._unFilterType4(e, t, a); break; default: throw new Error("Unrecognised filter type - " + r) }this.write(t), n.lineIndex++, n.lineIndex >= n.height ? (this._lastLine = null, this._imageIndex++, n = this._images[this._imageIndex]) : this._lastLine = t, n ? this.read(n.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete()) } }).call(this) }).call(this, e("buffer").Buffer) }, { "./interlace": 11, "./paeth-predictor": 15, buffer: 33 }], 10: [function (e, t, i) { (function (e) { (function () { function i(e, t, i, r, n) { let a = 0; for (let o = 0; o < r; o++)for (let r = 0; r < i; r++) { let i = n[e[a]]; if (!i) throw new Error("index " + e[a] + " not in palette"); for (let e = 0; e < 4; e++)t[a + e] = i[e]; a += 4 } } function r(e, t, i, r, n) { let a = 0; for (let o = 0; o < r; o++)for (let r = 0; r < i; r++) { let i = !1; if (1 === n.length ? n[0] === e[a] && (i = !0) : n[0] === e[a] && n[1] === e[a + 1] && n[2] === e[a + 2] && (i = !0), i) for (let e = 0; e < 4; e++)t[a + e] = 0; a += 4 } } function n(e, t, i, r, n) { let a = 255, o = Math.pow(2, n) - 1, s = 0; for (let n = 0; n < r; n++)for (let r = 0; r < i; r++) { for (let i = 0; i < 4; i++)t[s + i] = Math.floor(e[s + i] * a / o + .5); s += 4 } } t.exports = function (t, a, o = !1) { let s = a.depth, l = a.width, c = a.height, h = a.colorType, u = a.transColor, d = a.palette, p = t; return 3 === h ? i(t, p, l, c, d) : (u && r(t, p, l, c, u), 8 === s || o || (16 === s && (p = e.alloc(l * c * 4)), n(t, p, l, c, s))), p } }).call(this) }).call(this, e("buffer").Buffer) }, { buffer: 33 }], 11: [function (e, t, i) { let r = [{ x: [0], y: [0] }, { x: [4], y: [0] }, { x: [0, 4], y: [4] }, { x: [2, 6], y: [0, 4] }, { x: [0, 2, 4, 6], y: [2, 6] }, { x: [1, 3, 5, 7], y: [0, 2, 4, 6] }, { x: [0, 1, 2, 3, 4, 5, 6, 7], y: [1, 3, 5, 7] }]; i.getImagePasses = function (e, t) { let i = [], n = e % 8, a = t % 8, o = (e - n) / 8, s = (t - a) / 8; for (let e = 0; e < r.length; e++) { let t = r[e], l = o * t.x.length, c = s * t.y.length; for (let e = 0; e < t.x.length && t.x[e] < n; e++)l++; for (let e = 0; e < t.y.length && t.y[e] < a; e++)c++; l > 0 && c > 0 && i.push({ width: l, height: c, index: e }) } return i }, i.getInterlaceIterator = function (e) { return function (t, i, n) { let a = t % r[n].x.length, o = (t - a) / r[n].x.length * 8 + r[n].x[a], s = i % r[n].y.length; return 4 * o + ((i - s) / r[n].y.length * 8 + r[n].y[s]) * e * 4 } } }, {}], 12: [function (e, t, i) { (function (i) { (function () { let r = e("util"), n = e("stream"), a = e("./constants"), o = e("./packer"), s = t.exports = function (e) { n.call(this); let t = e || {}; this._packer = new o(t), this._deflate = this._packer.createDeflate(), this.readable = !0 }; r.inherits(s, n), s.prototype.pack = function (e, t, r, n) { this.emit("data", i.from(a.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(t, r)), n && this.emit("data", this._packer.packGAMA(n)); let o = this._packer.filterData(e, t, r); this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", function (e) { this.emit("data", this._packer.packIDAT(e)) }.bind(this)), this._deflate.on("end", function () { this.emit("data", this._packer.packIEND()), this.emit("end") }.bind(this)), this._deflate.end(o) } }).call(this) }).call(this, e("buffer").Buffer) }, { "./constants": 4, "./packer": 14, buffer: 33, stream: 61, util: 81 }], 13: [function (e, t, i) { (function (i) { (function () { let r = !0, n = e("zlib"); n.deflateSync || (r = !1); let a = e("./constants"), o = e("./packer"); t.exports = function (e, t) { if (!r) throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"); let s = new o(t || {}), l = []; l.push(i.from(a.PNG_SIGNATURE)), l.push(s.packIHDR(e.width, e.height)), e.gamma && l.push(s.packGAMA(e.gamma)); let c = s.filterData(e.data, e.width, e.height), h = n.deflateSync(c, s.getDeflateOptions()); if (c = null, !h || !h.length) throw new Error("bad png - invalid compressed data response"); return l.push(s.packIDAT(h)), l.push(s.packIEND()), i.concat(l) } }).call(this) }).call(this, e("buffer").Buffer) }, { "./constants": 4, "./packer": 14, buffer: 33, zlib: 32 }], 14: [function (e, t, i) { (function (i) { (function () { let r = e("./constants"), n = e("./crc"), a = e("./bitpacker"), o = e("./filter-pack"), s = e("zlib"), l = t.exports = function (e) { if (this._options = e, e.deflateChunkSize = e.deflateChunkSize || 32768, e.deflateLevel = null != e.deflateLevel ? e.deflateLevel : 9, e.deflateStrategy = null != e.deflateStrategy ? e.deflateStrategy : 3, e.inputHasAlpha = null == e.inputHasAlpha || e.inputHasAlpha, e.deflateFactory = e.deflateFactory || s.createDeflate, e.bitDepth = e.bitDepth || 8, e.colorType = "number" == typeof e.colorType ? e.colorType : r.COLORTYPE_COLOR_ALPHA, e.inputColorType = "number" == typeof e.inputColorType ? e.inputColorType : r.COLORTYPE_COLOR_ALPHA, -1 === [r.COLORTYPE_GRAYSCALE, r.COLORTYPE_COLOR, r.COLORTYPE_COLOR_ALPHA, r.COLORTYPE_ALPHA].indexOf(e.colorType)) throw new Error("option color type:" + e.colorType + " is not supported at present"); if (-1 === [r.COLORTYPE_GRAYSCALE, r.COLORTYPE_COLOR, r.COLORTYPE_COLOR_ALPHA, r.COLORTYPE_ALPHA].indexOf(e.inputColorType)) throw new Error("option input color type:" + e.inputColorType + " is not supported at present"); if (8 !== e.bitDepth && 16 !== e.bitDepth) throw new Error("option bit depth:" + e.bitDepth + " is not supported at present") }; l.prototype.getDeflateOptions = function () { return { chunkSize: this._options.deflateChunkSize, level: this._options.deflateLevel, strategy: this._options.deflateStrategy } }, l.prototype.createDeflate = function () { return this._options.deflateFactory(this.getDeflateOptions()) }, l.prototype.filterData = function (e, t, i) { let n = a(e, t, i, this._options), s = r.COLORTYPE_TO_BPP_MAP[this._options.colorType]; return o(n, t, i, this._options, s) }, l.prototype._packChunk = function (e, t) { let r = t ? t.length : 0, a = i.alloc(r + 12); return a.writeUInt32BE(r, 0), a.writeUInt32BE(e, 4), t && t.copy(a, 8), a.writeInt32BE(n.crc32(a.slice(4, a.length - 4)), a.length - 4), a }, l.prototype.packGAMA = function (e) { let t = i.alloc(4); return t.writeUInt32BE(Math.floor(e * r.GAMMA_DIVISION), 0), this._packChunk(r.TYPE_gAMA, t) }, l.prototype.packIHDR = function (e, t) { let n = i.alloc(13); return n.writeUInt32BE(e, 0), n.writeUInt32BE(t, 4), n[8] = this._options.bitDepth, n[9] = this._options.colorType, n[10] = 0, n[11] = 0, n[12] = 0, this._packChunk(r.TYPE_IHDR, n) }, l.prototype.packIDAT = function (e) { return this._packChunk(r.TYPE_IDAT, e) }, l.prototype.packIEND = function () { return this._packChunk(r.TYPE_IEND, null) } }).call(this) }).call(this, e("buffer").Buffer) }, { "./bitpacker": 2, "./constants": 4, "./crc": 5, "./filter-pack": 6, buffer: 33, zlib: 32 }], 15: [function (e, t, i) { t.exports = function (e, t, i) { let r = e + t - i, n = Math.abs(r - e), a = Math.abs(r - t), o = Math.abs(r - i); return n <= a && n <= o ? e : a <= o ? t : i } }, {}], 16: [function (e, t, i) { let r = e("util"), n = e("zlib"), a = e("./chunkstream"), o = e("./filter-parse-async"), s = e("./parser"), l = e("./bitmapper"), c = e("./format-normaliser"), h = t.exports = function (e) { a.call(this), this._parser = new s(e, { read: this.read.bind(this), error: this._handleError.bind(this), metadata: this._handleMetaData.bind(this), gamma: this.emit.bind(this, "gamma"), palette: this._handlePalette.bind(this), transColor: this._handleTransColor.bind(this), finished: this._finished.bind(this), inflateData: this._inflateData.bind(this), simpleTransparency: this._simpleTransparency.bind(this), headersFinished: this._headersFinished.bind(this) }), this._options = e, this.writable = !0, this._parser.start() }; r.inherits(h, a), h.prototype._handleError = function (e) { this.emit("error", e), this.writable = !1, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", (function () { }))), this.errord = !0 }, h.prototype._inflateData = function (e) { if (!this._inflate) if (this._bitmapInfo.interlace) this._inflate = n.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter); else { let e = (1 + (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3)) * this._bitmapInfo.height, t = Math.max(e, n.Z_MIN_CHUNK); this._inflate = n.createInflate({ chunkSize: t }); let i = e, r = this.emit.bind(this, "error"); this._inflate.on("error", (function (e) { i && r(e) })), this._filter.on("complete", this._complete.bind(this)); let a = this._filter.write.bind(this._filter); this._inflate.on("data", (function (e) { i && (e.length > i && (e = e.slice(0, i)), i -= e.length, a(e)) })), this._inflate.on("end", this._filter.end.bind(this._filter)) } this._inflate.write(e) }, h.prototype._handleMetaData = function (e) { this._metaData = e, this._bitmapInfo = Object.create(e), this._filter = new o(this._bitmapInfo) }, h.prototype._handleTransColor = function (e) { this._bitmapInfo.transColor = e }, h.prototype._handlePalette = function (e) { this._bitmapInfo.palette = e }, h.prototype._simpleTransparency = function () { this._metaData.alpha = !0 }, h.prototype._headersFinished = function () { this.emit("metadata", this._metaData) }, h.prototype._finished = function () { this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block")) }, h.prototype._complete = function (e) { if (this.errord) return; let t; try { let i = l.dataToBitMap(e, this._bitmapInfo); t = c(i, this._bitmapInfo, this._options.skipRescale), i = null } catch (e) { return void this._handleError(e) } this.emit("parsed", t) } }, { "./bitmapper": 1, "./chunkstream": 3, "./filter-parse-async": 7, "./format-normaliser": 10, "./parser": 18, util: 81, zlib: 32 }], 17: [function (e, t, i) { (function (i) { (function () { let r = !0, n = e("zlib"), a = e("./sync-inflate"); n.deflateSync || (r = !1); let o = e("./sync-reader"), s = e("./filter-parse-sync"), l = e("./parser"), c = e("./bitmapper"), h = e("./format-normaliser"); t.exports = function (e, t) { if (!r) throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0"); let u, d, p; function f(e) { u = e } function m(e) { d = e } function g(e) { d.transColor = e } function y(e) { d.palette = e } function v() { d.alpha = !0 } function _(e) { p = e } let b = []; function x(e) { b.push(e) } let w = new o(e); if (new l(t, { read: w.read.bind(w), error: f, metadata: m, gamma: _, palette: y, transColor: g, inflateData: x, simpleTransparency: v }).start(), w.process(), u) throw u; let S, M = i.concat(b); if (b.length = 0, d.interlace) S = n.inflateSync(M); else { let e = (1 + (d.width * d.bpp * d.depth + 7 >> 3)) * d.height; S = a(M, { chunkSize: e, maxLength: e }) } if (M = null, !S || !S.length) throw new Error("bad png - invalid inflate data response"); let T = s.process(S, d); M = null; let A = c.dataToBitMap(T, d); T = null; let E = h(A, d, t.skipRescale); return d.data = E, d.gamma = p || 0, d } }).call(this) }).call(this, e("buffer").Buffer) }, { "./bitmapper": 1, "./filter-parse-sync": 8, "./format-normaliser": 10, "./parser": 18, "./sync-inflate": 21, "./sync-reader": 22, buffer: 33, zlib: 32 }], 18: [function (e, t, i) { (function (i) { (function () { let r = e("./constants"), n = e("./crc"), a = t.exports = function (e, t) { this._options = e, e.checkCRC = !1 !== e.checkCRC, this._hasIHDR = !1, this._hasIEND = !1, this._emittedHeadersFinished = !1, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[r.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[r.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[r.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[r.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[r.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[r.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = t.read, this.error = t.error, this.metadata = t.metadata, this.gamma = t.gamma, this.transColor = t.transColor, this.palette = t.palette, this.parsed = t.parsed, this.inflateData = t.inflateData, this.finished = t.finished, this.simpleTransparency = t.simpleTransparency, this.headersFinished = t.headersFinished || function () { } }; a.prototype.start = function () { this.read(r.PNG_SIGNATURE.length, this._parseSignature.bind(this)) }, a.prototype._parseSignature = function (e) { let t = r.PNG_SIGNATURE; for (let i = 0; i < t.length; i++)if (e[i] !== t[i]) return void this.error(new Error("Invalid file signature")); this.read(8, this._parseChunkBegin.bind(this)) }, a.prototype._parseChunkBegin = function (e) { let t = e.readUInt32BE(0), a = e.readUInt32BE(4), o = ""; for (let t = 4; t < 8; t++)o += String.fromCharCode(e[t]); let s = Boolean(32 & e[4]); if (this._hasIHDR || a === r.TYPE_IHDR) { if (this._crc = new n, this._crc.write(i.from(o)), this._chunks[a]) return this._chunks[a](t); s ? this.read(t + 4, this._skipChunk.bind(this)) : this.error(new Error("Unsupported critical chunk type " + o)) } else this.error(new Error("Expected IHDR on beggining")) }, a.prototype._skipChunk = function () { this.read(8, this._parseChunkBegin.bind(this)) }, a.prototype._handleChunkEnd = function () { this.read(4, this._parseChunkEnd.bind(this)) }, a.prototype._parseChunkEnd = function (e) { let t = e.readInt32BE(0), i = this._crc.crc32(); this._options.checkCRC && i !== t ? this.error(new Error("Crc error - " + t + " - " + i)) : this._hasIEND || this.read(8, this._parseChunkBegin.bind(this)) }, a.prototype._handleIHDR = function (e) { this.read(e, this._parseIHDR.bind(this)) }, a.prototype._parseIHDR = function (e) { this._crc.write(e); let t = e.readUInt32BE(0), i = e.readUInt32BE(4), n = e[8], a = e[9], o = e[10], s = e[11], l = e[12]; if (8 !== n && 4 !== n && 2 !== n && 1 !== n && 16 !== n) return void this.error(new Error("Unsupported bit depth " + n)); if (!(a in r.COLORTYPE_TO_BPP_MAP)) return void this.error(new Error("Unsupported color type")); if (0 !== o) return void this.error(new Error("Unsupported compression method")); if (0 !== s) return void this.error(new Error("Unsupported filter method")); if (0 !== l && 1 !== l) return void this.error(new Error("Unsupported interlace method")); this._colorType = a; let c = r.COLORTYPE_TO_BPP_MAP[this._colorType]; this._hasIHDR = !0, this.metadata({ width: t, height: i, depth: n, interlace: Boolean(l), palette: Boolean(a & r.COLORTYPE_PALETTE), color: Boolean(a & r.COLORTYPE_COLOR), alpha: Boolean(a & r.COLORTYPE_ALPHA), bpp: c, colorType: a }), this._handleChunkEnd() }, a.prototype._handlePLTE = function (e) { this.read(e, this._parsePLTE.bind(this)) }, a.prototype._parsePLTE = function (e) { this._crc.write(e); let t = Math.floor(e.length / 3); for (let i = 0; i < t; i++)this._palette.push([e[3 * i], e[3 * i + 1], e[3 * i + 2], 255]); this.palette(this._palette), this._handleChunkEnd() }, a.prototype._handleTRNS = function (e) { this.simpleTransparency(), this.read(e, this._parseTRNS.bind(this)) }, a.prototype._parseTRNS = function (e) { if (this._crc.write(e), this._colorType === r.COLORTYPE_PALETTE_COLOR) { if (0 === this._palette.length) return void this.error(new Error("Transparency chunk must be after palette")); if (e.length > this._palette.length) return void this.error(new Error("More transparent colors than palette size")); for (let t = 0; t < e.length; t++)this._palette[t][3] = e[t]; this.palette(this._palette) } this._colorType === r.COLORTYPE_GRAYSCALE && this.transColor([e.readUInt16BE(0)]), this._colorType === r.COLORTYPE_COLOR && this.transColor([e.readUInt16BE(0), e.readUInt16BE(2), e.readUInt16BE(4)]), this._handleChunkEnd() }, a.prototype._handleGAMA = function (e) { this.read(e, this._parseGAMA.bind(this)) }, a.prototype._parseGAMA = function (e) { this._crc.write(e), this.gamma(e.readUInt32BE(0) / r.GAMMA_DIVISION), this._handleChunkEnd() }, a.prototype._handleIDAT = function (e) { this._emittedHeadersFinished || (this._emittedHeadersFinished = !0, this.headersFinished()), this.read(-e, this._parseIDAT.bind(this, e)) }, a.prototype._parseIDAT = function (e, t) { if (this._crc.write(t), this._colorType === r.COLORTYPE_PALETTE_COLOR && 0 === this._palette.length) throw new Error("Expected palette not found"); this.inflateData(t); let i = e - t.length; i > 0 ? this._handleIDAT(i) : this._handleChunkEnd() }, a.prototype._handleIEND = function (e) { this.read(e, this._parseIEND.bind(this)) }, a.prototype._parseIEND = function (e) { this._crc.write(e), this._hasIEND = !0, this._handleChunkEnd(), this.finished && this.finished() } }).call(this) }).call(this, e("buffer").Buffer) }, { "./constants": 4, "./crc": 5, buffer: 33 }], 19: [function (e, t, i) { let r = e("./parser-sync"), n = e("./packer-sync"); i.read = function (e, t) { return r(e, t || {}) }, i.write = function (e, t) { return n(e, t) } }, { "./packer-sync": 13, "./parser-sync": 17 }], 20: [function (e, t, i) { (function (t, r) { (function () { let n = e("util"), a = e("stream"), o = e("./parser-async"), s = e("./packer-async"), l = e("./png-sync"), c = i.PNG = function (e) { a.call(this), e = e || {}, this.width = 0 | e.width, this.height = 0 | e.height, this.data = this.width > 0 && this.height > 0 ? r.alloc(4 * this.width * this.height) : null, e.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = !0, this._parser = new o(e), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", function (e) { this.data = e, this.emit("parsed", e) }.bind(this)), this._packer = new s(e), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error")) }; n.inherits(c, a), c.sync = l, c.prototype.pack = function () { return this.data && this.data.length ? (t.nextTick(function () { this._packer.pack(this.data, this.width, this.height, this.gamma) }.bind(this)), this) : (this.emit("error", "No data provided"), this) }, c.prototype.parse = function (e, t) { if (t) { let e, i; e = function (e) { this.removeListener("error", i), this.data = e, t(null, this) }.bind(this), i = function (i) { this.removeListener("parsed", e), t(i, null) }.bind(this), this.once("parsed", e), this.once("error", i) } return this.end(e), this }, c.prototype.write = function (e) { return this._parser.write(e), !0 }, c.prototype.end = function (e) { this._parser.end(e) }, c.prototype._metadata = function (e) { this.width = e.width, this.height = e.height, this.emit("metadata", e) }, c.prototype._gamma = function (e) { this.gamma = e }, c.prototype._handleClose = function () { this._parser.writable || this._packer.readable || this.emit("close") }, c.bitblt = function (e, t, i, r, n, a, o, s) { if (r |= 0, n |= 0, a |= 0, o |= 0, s |= 0, (i |= 0) > e.width || r > e.height || i + n > e.width || r + a > e.height) throw new Error("bitblt reading outside image"); if (o > t.width || s > t.height || o + n > t.width || s + a > t.height) throw new Error("bitblt writing outside image"); for (let l = 0; l < a; l++)e.data.copy(t.data, (s + l) * t.width + o << 2, (r + l) * e.width + i << 2, (r + l) * e.width + i + n << 2) }, c.prototype.bitblt = function (e, t, i, r, n, a, o) { return c.bitblt(this, e, t, i, r, n, a, o), this }, c.adjustGamma = function (e) { if (e.gamma) { for (let t = 0; t < e.height; t++)for (let i = 0; i < e.width; i++) { let r = e.width * t + i << 2; for (let t = 0; t < 3; t++) { let i = e.data[r + t] / 255; i = Math.pow(i, 1 / 2.2 / e.gamma), e.data[r + t] = Math.round(255 * i) } } e.gamma = 0 } }, c.prototype.adjustGamma = function () { c.adjustGamma(this) } }).call(this) }).call(this, e("_process"), e("buffer").Buffer) }, { "./packer-async": 12, "./parser-async": 16, "./png-sync": 19, _process: 60, buffer: 33, stream: 61, util: 81 }], 21: [function (e, t, i) { (function (r, n) { (function () { let a = e("assert").ok, o = e("zlib"), s = e("util"), l = e("buffer").kMaxLength; function c(e) { if (!(this instanceof c)) return new c(e); e && e.chunkSize < o.Z_MIN_CHUNK && (e.chunkSize = o.Z_MIN_CHUNK), o.Inflate.call(this, e), this._offset = void 0 === this._offset ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, e && null != e.maxLength && (this._maxLength = e.maxLength) } function h(e) { return new c(e) } function u(e, t) { t && r.nextTick(t), e._handle && (e._handle.close(), e._handle = null) } function d(e, t) { if ("string" == typeof t && (t = n.from(t)), !(t instanceof n)) throw new TypeError("Not a string or buffer"); let i = e._finishFlushFlag; return null == i && (i = o.Z_FINISH), e._processChunk(t, i) } function p(e, t) { return d(new c(t), e) } c.prototype._processChunk = function (e, t, i) { if ("function" == typeof i) return o.Inflate._processChunk.call(this, e, t, i); let r, s, c = this, h = e && e.length, d = this._chunkSize - this._offset, p = this._maxLength, f = 0, m = [], g = 0; function y(e, t) { if (c._hadError) return; let i = d - t; if (a(i >= 0, "have should not go down"), i > 0) { let e = c._buffer.slice(c._offset, c._offset + i); if (c._offset += i, e.length > p && (e = e.slice(0, p)), m.push(e), g += e.length, p -= e.length, 0 === p) return !1 } return (0 === t || c._offset >= c._chunkSize) && (d = c._chunkSize, c._offset = 0, c._buffer = n.allocUnsafe(c._chunkSize)), 0 === t && (f += h - e, h = e, !0) } this.on("error", (function (e) { r = e })), a(this._handle, "zlib binding closed"); do { s = this._handle.writeSync(t, e, f, h, this._buffer, this._offset, d), s = s || this._writeState } while (!this._hadError && y(s[0], s[1])); if (this._hadError) throw r; if (g >= l) throw u(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + l.toString(16) + " bytes"); let v = n.concat(m, g); return u(this), v }, s.inherits(c, o.Inflate), t.exports = i = p, i.Inflate = c, i.createInflate = h, i.inflateSync = p }).call(this) }).call(this, e("_process"), e("buffer").Buffer) }, { _process: 60, assert: 23, buffer: 33, util: 81, zlib: 32 }], 22: [function (e, t, i) { let r = t.exports = function (e) { this._buffer = e, this._reads = [] }; r.prototype.read = function (e, t) { this._reads.push({ length: Math.abs(e), allowLess: e < 0, func: t }) }, r.prototype.process = function () { for (; this._reads.length > 0 && this._buffer.length;) { let e = this._reads[0]; if (!this._buffer.length || !(this._buffer.length >= e.length || e.allowLess)) break; { this._reads.shift(); let t = this._buffer; this._buffer = t.slice(e.length), e.func.call(this, t.slice(0, e.length)) } } if (this._reads.length > 0) throw new Error("There are some read requests waitng on finished stream"); if (this._buffer.length > 0) throw new Error("unrecognised content at end of stream") } }, {}], 23: [function (e, t, i) {
            (function (i) {
               (function () {
                  /*!
                     * The buffer module from node.js, for the browser.
                     *
                     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
                     * @license  MIT
                     */
                  function r(e, t) { if (e === t) return 0; for (var i = e.length, r = t.length, n = 0, a = Math.min(i, r); n < a; ++n)if (e[n] !== t[n]) { i = e[n], r = t[n]; break } return i < r ? -1 : r < i ? 1 : 0 } function n(e) { return i.Buffer && "function" == typeof i.Buffer.isBuffer ? i.Buffer.isBuffer(e) : !(null == e || !e._isBuffer) } var a = e("util/"), o = Object.prototype.hasOwnProperty, s = Array.prototype.slice, l = "foo" === function () { }.name; function c(e) { return Object.prototype.toString.call(e) } function h(e) { return !n(e) && "function" == typeof i.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(e) : !!e && (e instanceof DataView || !!(e.buffer && e.buffer instanceof ArrayBuffer))) } var u = t.exports = v, d = /\s*function\s+([^\(\s]*)\s*/; function p(e) { if (a.isFunction(e)) { if (l) return e.name; var t = e.toString().match(d); return t && t[1] } } function f(e, t) { return "string" == typeof e ? e.length < t ? e : e.slice(0, t) : e } function m(e) { if (l || !a.isFunction(e)) return a.inspect(e); var t = p(e); return "[Function" + (t ? ": " + t : "") + "]" } function g(e) { return f(m(e.actual), 128) + " " + e.operator + " " + f(m(e.expected), 128) } function y(e, t, i, r, n) { throw new u.AssertionError({ message: i, actual: e, expected: t, operator: r, stackStartFunction: n }) } function v(e, t) { e || y(e, !0, t, "==", u.ok) } function _(e, t, i, o) { if (e === t) return !0; if (n(e) && n(t)) return 0 === r(e, t); if (a.isDate(e) && a.isDate(t)) return e.getTime() === t.getTime(); if (a.isRegExp(e) && a.isRegExp(t)) return e.source === t.source && e.global === t.global && e.multiline === t.multiline && e.lastIndex === t.lastIndex && e.ignoreCase === t.ignoreCase; if (null !== e && "object" == typeof e || null !== t && "object" == typeof t) { if (h(e) && h(t) && c(e) === c(t) && !(e instanceof Float32Array || e instanceof Float64Array)) return 0 === r(new Uint8Array(e.buffer), new Uint8Array(t.buffer)); if (n(e) !== n(t)) return !1; var s = (o = o || { actual: [], expected: [] }).actual.indexOf(e); return -1 !== s && s === o.expected.indexOf(t) || (o.actual.push(e), o.expected.push(t), x(e, t, i, o)) } return i ? e === t : e == t } function b(e) { return "[object Arguments]" == Object.prototype.toString.call(e) } function x(e, t, i, r) { if (null == e || null == t) return !1; if (a.isPrimitive(e) || a.isPrimitive(t)) return e === t; if (i && Object.getPrototypeOf(e) !== Object.getPrototypeOf(t)) return !1; var n = b(e), o = b(t); if (n && !o || !n && o) return !1; if (n) return _(e = s.call(e), t = s.call(t), i); var l, c, h = A(e), u = A(t); if (h.length !== u.length) return !1; for (h.sort(), u.sort(), c = h.length - 1; c >= 0; c--)if (h[c] !== u[c]) return !1; for (c = h.length - 1; c >= 0; c--)if (!_(e[l = h[c]], t[l], i, r)) return !1; return !0 } function w(e, t, i) { _(e, t, !0) && y(e, t, i, "notDeepStrictEqual", w) } function S(e, t) { if (!e || !t) return !1; if ("[object RegExp]" == Object.prototype.toString.call(t)) return t.test(e); try { if (e instanceof t) return !0 } catch (e) { } return !Error.isPrototypeOf(t) && !0 === t.call({}, e) } function M(e) { var t; try { e() } catch (e) { t = e } return t } function T(e, t, i, r) { var n; if ("function" != typeof t) throw new TypeError('"block" argument must be a function'); "string" == typeof i && (r = i, i = null), n = M(t), r = (i && i.name ? " (" + i.name + ")." : ".") + (r ? " " + r : "."), e && !n && y(n, i, "Missing expected exception" + r); var o = "string" == typeof r, s = !e && n && !i; if ((!e && a.isError(n) && o && S(n, i) || s) && y(n, i, "Got unwanted exception" + r), e && n && i && !S(n, i) || !e && n) throw n } u.AssertionError = function (e) { this.name = "AssertionError", this.actual = e.actual, this.expected = e.expected, this.operator = e.operator, e.message ? (this.message = e.message, this.generatedMessage = !1) : (this.message = g(this), this.generatedMessage = !0); var t = e.stackStartFunction || y; if (Error.captureStackTrace) Error.captureStackTrace(this, t); else { var i = new Error; if (i.stack) { var r = i.stack, n = p(t), a = r.indexOf("\n" + n); if (a >= 0) { var o = r.indexOf("\n", a + 1); r = r.substring(o + 1) } this.stack = r } } }, a.inherits(u.AssertionError, Error), u.fail = y, u.ok = v, u.equal = function (e, t, i) { e != t && y(e, t, i, "==", u.equal) }, u.notEqual = function (e, t, i) { e == t && y(e, t, i, "!=", u.notEqual) }, u.deepEqual = function (e, t, i) { _(e, t, !1) || y(e, t, i, "deepEqual", u.deepEqual) }, u.deepStrictEqual = function (e, t, i) { _(e, t, !0) || y(e, t, i, "deepStrictEqual", u.deepStrictEqual) }, u.notDeepEqual = function (e, t, i) { _(e, t, !1) && y(e, t, i, "notDeepEqual", u.notDeepEqual) }, u.notDeepStrictEqual = w, u.strictEqual = function (e, t, i) { e !== t && y(e, t, i, "===", u.strictEqual) }, u.notStrictEqual = function (e, t, i) { e === t && y(e, t, i, "!==", u.notStrictEqual) }, u.throws = function (e, t, i) { T(!0, e, t, i) }, u.doesNotThrow = function (e, t, i) { T(!1, e, t, i) }, u.ifError = function (e) { if (e) throw e }; var A = Object.keys || function (e) { var t = []; for (var i in e) o.call(e, i) && t.push(i); return t }
               }).call(this)
            }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
         }, { "util/": 26 }], 24: [function (e, t, i) { "function" == typeof Object.create ? t.exports = function (e, t) { e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }) } : t.exports = function (e, t) { e.super_ = t; var i = function () { }; i.prototype = t.prototype, e.prototype = new i, e.prototype.constructor = e } }, {}], 25: [function (e, t, i) { t.exports = function (e) { return e && "object" == typeof e && "function" == typeof e.copy && "function" == typeof e.fill && "function" == typeof e.readUInt8 } }, {}], 26: [function (e, t, i) { (function (t, r) { (function () { var n = /%[sdj%]/g; i.format = function (e) { if (!w(e)) { for (var t = [], i = 0; i < arguments.length; i++)t.push(s(arguments[i])); return t.join(" ") } i = 1; for (var r = arguments, a = r.length, o = String(e).replace(n, (function (e) { if ("%%" === e) return "%"; if (i >= a) return e; switch (e) { case "%s": return String(r[i++]); case "%d": return Number(r[i++]); case "%j": try { return JSON.stringify(r[i++]) } catch (e) { return "[Circular]" } default: return e } })), l = r[i]; i < a; l = r[++i])_(l) || !A(l) ? o += " " + l : o += " " + s(l); return o }, i.deprecate = function (e, n) { if (M(r.process)) return function () { return i.deprecate(e, n).apply(this, arguments) }; if (!0 === t.noDeprecation) return e; var a = !1; function o() { if (!a) { if (t.throwDeprecation) throw new Error(n); t.traceDeprecation ? console.trace(n) : console.error(n), a = !0 } return e.apply(this, arguments) } return o }; var a, o = {}; function s(e, t) { var r = { seen: [], stylize: c }; return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), v(t) ? r.showHidden = t : t && i._extend(r, t), M(r.showHidden) && (r.showHidden = !1), M(r.depth) && (r.depth = 2), M(r.colors) && (r.colors = !1), M(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = l), u(r, e, r.depth) } function l(e, t) { var i = s.styles[t]; return i ? "[" + s.colors[i][0] + "m" + e + "[" + s.colors[i][1] + "m" : e } function c(e, t) { return e } function h(e) { var t = {}; return e.forEach((function (e, i) { t[e] = !0 })), t } function u(e, t, r) { if (e.customInspect && t && L(t.inspect) && t.inspect !== i.inspect && (!t.constructor || t.constructor.prototype !== t)) { var n = t.inspect(r, e); return w(n) || (n = u(e, n, r)), n } var a = d(e, t); if (a) return a; var o = Object.keys(t), s = h(o); if (e.showHidden && (o = Object.getOwnPropertyNames(t)), C(t) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0)) return p(t); if (0 === o.length) { if (L(t)) { var l = t.name ? ": " + t.name : ""; return e.stylize("[Function" + l + "]", "special") } if (T(t)) return e.stylize(RegExp.prototype.toString.call(t), "regexp"); if (E(t)) return e.stylize(Date.prototype.toString.call(t), "date"); if (C(t)) return p(t) } var c, v = "", _ = !1, b = ["{", "}"]; return y(t) && (_ = !0, b = ["[", "]"]), L(t) && (v = " [Function" + (t.name ? ": " + t.name : "") + "]"), T(t) && (v = " " + RegExp.prototype.toString.call(t)), E(t) && (v = " " + Date.prototype.toUTCString.call(t)), C(t) && (v = " " + p(t)), 0 !== o.length || _ && 0 != t.length ? r < 0 ? T(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(t), c = _ ? f(e, t, r, s, o) : o.map((function (i) { return m(e, t, r, s, i, _) })), e.seen.pop(), g(c, v, b)) : b[0] + v + b[1] } function d(e, t) { if (M(t)) return e.stylize("undefined", "undefined"); if (w(t)) { var i = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'"; return e.stylize(i, "string") } return x(t) ? e.stylize("" + t, "number") : v(t) ? e.stylize("" + t, "boolean") : _(t) ? e.stylize("null", "null") : void 0 } function p(e) { return "[" + Error.prototype.toString.call(e) + "]" } function f(e, t, i, r, n) { for (var a = [], o = 0, s = t.length; o < s; ++o)k(t, String(o)) ? a.push(m(e, t, i, r, String(o), !0)) : a.push(""); return n.forEach((function (n) { n.match(/^\d+$/) || a.push(m(e, t, i, r, n, !0)) })), a } function m(e, t, i, r, n, a) { var o, s, l; if ((l = Object.getOwnPropertyDescriptor(t, n) || { value: t[n] }).get ? s = l.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : l.set && (s = e.stylize("[Setter]", "special")), k(r, n) || (o = "[" + n + "]"), s || (e.seen.indexOf(l.value) < 0 ? (s = _(i) ? u(e, l.value, null) : u(e, l.value, i - 1)).indexOf("\n") > -1 && (s = a ? s.split("\n").map((function (e) { return "  " + e })).join("\n").substr(2) : "\n" + s.split("\n").map((function (e) { return "   " + e })).join("\n")) : s = e.stylize("[Circular]", "special")), M(o)) { if (a && n.match(/^\d+$/)) return s; (o = JSON.stringify("" + n)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o = o.substr(1, o.length - 2), o = e.stylize(o, "name")) : (o = o.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o = e.stylize(o, "string")) } return o + ": " + s } function g(e, t, i) { return e.reduce((function (e, t) { return t.indexOf("\n"), e + t.replace(/\u001b\[\d\d?m/g, "").length + 1 }), 0) > 60 ? i[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + i[1] : i[0] + t + " " + e.join(", ") + " " + i[1] } function y(e) { return Array.isArray(e) } function v(e) { return "boolean" == typeof e } function _(e) { return null === e } function b(e) { return null == e } function x(e) { return "number" == typeof e } function w(e) { return "string" == typeof e } function S(e) { return "symbol" == typeof e } function M(e) { return void 0 === e } function T(e) { return A(e) && "[object RegExp]" === D(e) } function A(e) { return "object" == typeof e && null !== e } function E(e) { return A(e) && "[object Date]" === D(e) } function C(e) { return A(e) && ("[object Error]" === D(e) || e instanceof Error) } function L(e) { return "function" == typeof e } function R(e) { return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e } function D(e) { return Object.prototype.toString.call(e) } function P(e) { return e < 10 ? "0" + e.toString(10) : e.toString(10) } i.debuglog = function (e) { if (M(a) && (a = t.env.NODE_DEBUG || ""), e = e.toUpperCase(), !o[e]) if (new RegExp("\\b" + e + "\\b", "i").test(a)) { var r = t.pid; o[e] = function () { var t = i.format.apply(i, arguments); console.error("%s %d: %s", e, r, t) } } else o[e] = function () { }; return o[e] }, i.inspect = s, s.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, s.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i.isArray = y, i.isBoolean = v, i.isNull = _, i.isNullOrUndefined = b, i.isNumber = x, i.isString = w, i.isSymbol = S, i.isUndefined = M, i.isRegExp = T, i.isObject = A, i.isDate = E, i.isError = C, i.isFunction = L, i.isPrimitive = R, i.isBuffer = e("./support/isBuffer"); var O = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; function I() { var e = new Date, t = [P(e.getHours()), P(e.getMinutes()), P(e.getSeconds())].join(":"); return [e.getDate(), O[e.getMonth()], t].join(" ") } function k(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } i.log = function () { console.log("%s - %s", I(), i.format.apply(i, arguments)) }, i.inherits = e("inherits"), i._extend = function (e, t) { if (!t || !A(t)) return e; for (var i = Object.keys(t), r = i.length; r--;)e[i[r]] = t[i[r]]; return e } }).call(this) }).call(this, e("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "./support/isBuffer": 25, _process: 60, inherits: 24 }], 27: [function (e, t, i) { (function (i) { (function () { var r = e("array-filter"); t.exports = function () { return r(["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], (function (e) { return "function" == typeof i[e] })) } }).call(this) }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "array-filter": 28 }], 28: [function (e, t, i) { t.exports = function (e, t, i) { if (e.filter) return e.filter(t, i); if (null == e) throw new TypeError; if ("function" != typeof t) throw new TypeError; for (var n = [], a = 0; a < e.length; a++)if (r.call(e, a)) { var o = e[a]; t.call(i, o, a, e) && n.push(o) } return n }; var r = Object.prototype.hasOwnProperty }, {}], 29: [function (e, t, i) { i.byteLength = h, i.toByteArray = d, i.fromByteArray = m; for (var r = [], n = [], a = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, l = o.length; s < l; ++s)r[s] = o[s], n[o.charCodeAt(s)] = s; function c(e) { var t = e.length; if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var i = e.indexOf("="); return -1 === i && (i = t), [i, i === t ? 0 : 4 - i % 4] } function h(e) { var t = c(e), i = t[0], r = t[1]; return 3 * (i + r) / 4 - r } function u(e, t, i) { return 3 * (t + i) / 4 - i } function d(e) { var t, i, r = c(e), o = r[0], s = r[1], l = new a(u(e, o, s)), h = 0, d = s > 0 ? o - 4 : o; for (i = 0; i < d; i += 4)t = n[e.charCodeAt(i)] << 18 | n[e.charCodeAt(i + 1)] << 12 | n[e.charCodeAt(i + 2)] << 6 | n[e.charCodeAt(i + 3)], l[h++] = t >> 16 & 255, l[h++] = t >> 8 & 255, l[h++] = 255 & t; return 2 === s && (t = n[e.charCodeAt(i)] << 2 | n[e.charCodeAt(i + 1)] >> 4, l[h++] = 255 & t), 1 === s && (t = n[e.charCodeAt(i)] << 10 | n[e.charCodeAt(i + 1)] << 4 | n[e.charCodeAt(i + 2)] >> 2, l[h++] = t >> 8 & 255, l[h++] = 255 & t), l } function p(e) { return r[e >> 18 & 63] + r[e >> 12 & 63] + r[e >> 6 & 63] + r[63 & e] } function f(e, t, i) { for (var r, n = [], a = t; a < i; a += 3)r = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), n.push(p(r)); return n.join("") } function m(e) { for (var t, i = e.length, n = i % 3, a = [], o = 16383, s = 0, l = i - n; s < l; s += o)a.push(f(e, s, s + o > l ? l : s + o)); return 1 === n ? (t = e[i - 1], a.push(r[t >> 2] + r[t << 4 & 63] + "==")) : 2 === n && (t = (e[i - 2] << 8) + e[i - 1], a.push(r[t >> 10] + r[t >> 4 & 63] + r[t << 2 & 63] + "=")), a.join("") } n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63 }, {}], 30: [function (e, t, i) { }, {}], 31: [function (e, t, i) { (function (t, r) { (function () { var n = e("assert"), a = e("pako/lib/zlib/zstream"), o = e("pako/lib/zlib/deflate.js"), s = e("pako/lib/zlib/inflate.js"), l = e("pako/lib/zlib/constants"); for (var c in l) i[c] = l[c]; i.NONE = 0, i.DEFLATE = 1, i.INFLATE = 2, i.GZIP = 3, i.GUNZIP = 4, i.DEFLATERAW = 5, i.INFLATERAW = 6, i.UNZIP = 7; var h = 31, u = 139; function d(e) { if ("number" != typeof e || e < i.DEFLATE || e > i.UNZIP) throw new TypeError("Bad argument"); this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = e, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0 } d.prototype.close = function () { this.write_in_progress ? this.pending_close = !0 : (this.pending_close = !1, n(this.init_done, "close before init"), n(this.mode <= i.UNZIP), this.mode === i.DEFLATE || this.mode === i.GZIP || this.mode === i.DEFLATERAW ? o.deflateEnd(this.strm) : this.mode !== i.INFLATE && this.mode !== i.GUNZIP && this.mode !== i.INFLATERAW && this.mode !== i.UNZIP || s.inflateEnd(this.strm), this.mode = i.NONE, this.dictionary = null) }, d.prototype.write = function (e, t, i, r, n, a, o) { return this._write(!0, e, t, i, r, n, a, o) }, d.prototype.writeSync = function (e, t, i, r, n, a, o) { return this._write(!1, e, t, i, r, n, a, o) }, d.prototype._write = function (e, a, o, s, l, c, h, u) { if (n.equal(arguments.length, 8), n(this.init_done, "write before init"), n(this.mode !== i.NONE, "already finalized"), n.equal(!1, this.write_in_progress, "write already in progress"), n.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, n.equal(!1, void 0 === a, "must provide flush value"), this.write_in_progress = !0, a !== i.Z_NO_FLUSH && a !== i.Z_PARTIAL_FLUSH && a !== i.Z_SYNC_FLUSH && a !== i.Z_FULL_FLUSH && a !== i.Z_FINISH && a !== i.Z_BLOCK) throw new Error("Invalid flush value"); if (null == o && (o = r.alloc(0), l = 0, s = 0), this.strm.avail_in = l, this.strm.input = o, this.strm.next_in = s, this.strm.avail_out = u, this.strm.output = c, this.strm.next_out = h, this.flush = a, !e) return this._process(), this._checkError() ? this._afterSync() : void 0; var d = this; return t.nextTick((function () { d._process(), d._after() })), this }, d.prototype._afterSync = function () { var e = this.strm.avail_out, t = this.strm.avail_in; return this.write_in_progress = !1, [t, e] }, d.prototype._process = function () { var e = null; switch (this.mode) { case i.DEFLATE: case i.GZIP: case i.DEFLATERAW: this.err = o.deflate(this.strm, this.flush); break; case i.UNZIP: switch (this.strm.avail_in > 0 && (e = this.strm.next_in), this.gzip_id_bytes_read) { case 0: if (null === e) break; if (this.strm.input[e] !== h) { this.mode = i.INFLATE; break } if (this.gzip_id_bytes_read = 1, e++, 1 === this.strm.avail_in) break; case 1: if (null === e) break; this.strm.input[e] === u ? (this.gzip_id_bytes_read = 2, this.mode = i.GUNZIP) : this.mode = i.INFLATE; break; default: throw new Error("invalid number of gzip magic number bytes read") }case i.INFLATE: case i.GUNZIP: case i.INFLATERAW: for (this.err = s.inflate(this.strm, this.flush), this.err === i.Z_NEED_DICT && this.dictionary && (this.err = s.inflateSetDictionary(this.strm, this.dictionary), this.err === i.Z_OK ? this.err = s.inflate(this.strm, this.flush) : this.err === i.Z_DATA_ERROR && (this.err = i.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === i.GUNZIP && this.err === i.Z_STREAM_END && 0 !== this.strm.next_in[0];)this.reset(), this.err = s.inflate(this.strm, this.flush); break; default: throw new Error("Unknown mode " + this.mode) } }, d.prototype._checkError = function () { switch (this.err) { case i.Z_OK: case i.Z_BUF_ERROR: if (0 !== this.strm.avail_out && this.flush === i.Z_FINISH) return this._error("unexpected end of file"), !1; break; case i.Z_STREAM_END: break; case i.Z_NEED_DICT: return null == this.dictionary ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1; default: return this._error("Zlib error"), !1 }return !0 }, d.prototype._after = function () { if (this._checkError()) { var e = this.strm.avail_out, t = this.strm.avail_in; this.write_in_progress = !1, this.callback(t, e), this.pending_close && this.close() } }, d.prototype._error = function (e) { this.strm.msg && (e = this.strm.msg), this.onerror(e, this.err), this.write_in_progress = !1, this.pending_close && this.close() }, d.prototype.init = function (e, t, r, a, o) { n(4 === arguments.length || 5 === arguments.length, "init(windowBits, level, memLevel, strategy, [dictionary])"), n(e >= 8 && e <= 15, "invalid windowBits"), n(t >= -1 && t <= 9, "invalid compression level"), n(r >= 1 && r <= 9, "invalid memlevel"), n(a === i.Z_FILTERED || a === i.Z_HUFFMAN_ONLY || a === i.Z_RLE || a === i.Z_FIXED || a === i.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(t, e, r, a, o), this._setDictionary() }, d.prototype.params = function () { throw new Error("deflateParams Not supported") }, d.prototype.reset = function () { this._reset(), this._setDictionary() }, d.prototype._init = function (e, t, r, n, l) { switch (this.level = e, this.windowBits = t, this.memLevel = r, this.strategy = n, this.flush = i.Z_NO_FLUSH, this.err = i.Z_OK, this.mode !== i.GZIP && this.mode !== i.GUNZIP || (this.windowBits += 16), this.mode === i.UNZIP && (this.windowBits += 32), this.mode !== i.DEFLATERAW && this.mode !== i.INFLATERAW || (this.windowBits = -1 * this.windowBits), this.strm = new a, this.mode) { case i.DEFLATE: case i.GZIP: case i.DEFLATERAW: this.err = o.deflateInit2(this.strm, this.level, i.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy); break; case i.INFLATE: case i.GUNZIP: case i.INFLATERAW: case i.UNZIP: this.err = s.inflateInit2(this.strm, this.windowBits); break; default: throw new Error("Unknown mode " + this.mode) }this.err !== i.Z_OK && this._error("Init error"), this.dictionary = l, this.write_in_progress = !1, this.init_done = !0 }, d.prototype._setDictionary = function () { if (null != this.dictionary) { switch (this.err = i.Z_OK, this.mode) { case i.DEFLATE: case i.DEFLATERAW: this.err = o.deflateSetDictionary(this.strm, this.dictionary) }this.err !== i.Z_OK && this._error("Failed to set dictionary") } }, d.prototype._reset = function () { switch (this.err = i.Z_OK, this.mode) { case i.DEFLATE: case i.DEFLATERAW: case i.GZIP: this.err = o.deflateReset(this.strm); break; case i.INFLATE: case i.INFLATERAW: case i.GUNZIP: this.err = s.inflateReset(this.strm) }this.err !== i.Z_OK && this._error("Failed to reset stream") }, i.Zlib = d }).call(this) }).call(this, e("_process"), e("buffer").Buffer) }, { _process: 60, assert: 23, buffer: 33, "pako/lib/zlib/constants": 51, "pako/lib/zlib/deflate.js": 53, "pako/lib/zlib/inflate.js": 55, "pako/lib/zlib/zstream": 59 }], 32: [function (e, t, i) { (function (t) { (function () { var r = e("buffer").Buffer, n = e("stream").Transform, a = e("./binding"), o = e("util"), s = e("assert").ok, l = e("buffer").kMaxLength, c = "Cannot create final Buffer. It would be larger than 0x" + l.toString(16) + " bytes"; a.Z_MIN_WINDOWBITS = 8, a.Z_MAX_WINDOWBITS = 15, a.Z_DEFAULT_WINDOWBITS = 15, a.Z_MIN_CHUNK = 64, a.Z_MAX_CHUNK = 1 / 0, a.Z_DEFAULT_CHUNK = 16384, a.Z_MIN_MEMLEVEL = 1, a.Z_MAX_MEMLEVEL = 9, a.Z_DEFAULT_MEMLEVEL = 8, a.Z_MIN_LEVEL = -1, a.Z_MAX_LEVEL = 9, a.Z_DEFAULT_LEVEL = a.Z_DEFAULT_COMPRESSION; for (var h = Object.keys(a), u = 0; u < h.length; u++) { var d = h[u]; d.match(/^Z/) && Object.defineProperty(i, d, { enumerable: !0, value: a[d], writable: !1 }) } for (var p = { Z_OK: a.Z_OK, Z_STREAM_END: a.Z_STREAM_END, Z_NEED_DICT: a.Z_NEED_DICT, Z_ERRNO: a.Z_ERRNO, Z_STREAM_ERROR: a.Z_STREAM_ERROR, Z_DATA_ERROR: a.Z_DATA_ERROR, Z_MEM_ERROR: a.Z_MEM_ERROR, Z_BUF_ERROR: a.Z_BUF_ERROR, Z_VERSION_ERROR: a.Z_VERSION_ERROR }, f = Object.keys(p), m = 0; m < f.length; m++) { var g = f[m]; p[p[g]] = g } function y(e, t, i) { var n = [], a = 0; function o() { for (var t; null !== (t = e.read());)n.push(t), a += t.length; e.once("readable", o) } function s(t) { e.removeListener("end", h), e.removeListener("readable", o), i(t) } function h() { var t, o = null; a >= l ? o = new RangeError(c) : t = r.concat(n, a), n = [], e.close(), i(o, t) } e.on("error", s), e.on("end", h), e.end(t), o() } function v(e, t) { if ("string" == typeof t && (t = r.from(t)), !r.isBuffer(t)) throw new TypeError("Not a string or buffer"); var i = e._finishFlushFlag; return e._processChunk(t, i) } function _(e) { if (!(this instanceof _)) return new _(e); E.call(this, e, a.DEFLATE) } function b(e) { if (!(this instanceof b)) return new b(e); E.call(this, e, a.INFLATE) } function x(e) { if (!(this instanceof x)) return new x(e); E.call(this, e, a.GZIP) } function w(e) { if (!(this instanceof w)) return new w(e); E.call(this, e, a.GUNZIP) } function S(e) { if (!(this instanceof S)) return new S(e); E.call(this, e, a.DEFLATERAW) } function M(e) { if (!(this instanceof M)) return new M(e); E.call(this, e, a.INFLATERAW) } function T(e) { if (!(this instanceof T)) return new T(e); E.call(this, e, a.UNZIP) } function A(e) { return e === a.Z_NO_FLUSH || e === a.Z_PARTIAL_FLUSH || e === a.Z_SYNC_FLUSH || e === a.Z_FULL_FLUSH || e === a.Z_FINISH || e === a.Z_BLOCK } function E(e, t) { var o = this; if (this._opts = e = e || {}, this._chunkSize = e.chunkSize || i.Z_DEFAULT_CHUNK, n.call(this, e), e.flush && !A(e.flush)) throw new Error("Invalid flush flag: " + e.flush); if (e.finishFlush && !A(e.finishFlush)) throw new Error("Invalid flush flag: " + e.finishFlush); if (this._flushFlag = e.flush || a.Z_NO_FLUSH, this._finishFlushFlag = void 0 !== e.finishFlush ? e.finishFlush : a.Z_FINISH, e.chunkSize && (e.chunkSize < i.Z_MIN_CHUNK || e.chunkSize > i.Z_MAX_CHUNK)) throw new Error("Invalid chunk size: " + e.chunkSize); if (e.windowBits && (e.windowBits < i.Z_MIN_WINDOWBITS || e.windowBits > i.Z_MAX_WINDOWBITS)) throw new Error("Invalid windowBits: " + e.windowBits); if (e.level && (e.level < i.Z_MIN_LEVEL || e.level > i.Z_MAX_LEVEL)) throw new Error("Invalid compression level: " + e.level); if (e.memLevel && (e.memLevel < i.Z_MIN_MEMLEVEL || e.memLevel > i.Z_MAX_MEMLEVEL)) throw new Error("Invalid memLevel: " + e.memLevel); if (e.strategy && e.strategy != i.Z_FILTERED && e.strategy != i.Z_HUFFMAN_ONLY && e.strategy != i.Z_RLE && e.strategy != i.Z_FIXED && e.strategy != i.Z_DEFAULT_STRATEGY) throw new Error("Invalid strategy: " + e.strategy); if (e.dictionary && !r.isBuffer(e.dictionary)) throw new Error("Invalid dictionary: it should be a Buffer instance"); this._handle = new a.Zlib(t); var s = this; this._hadError = !1, this._handle.onerror = function (e, t) { C(s), s._hadError = !0; var r = new Error(e); r.errno = t, r.code = i.codes[t], s.emit("error", r) }; var l = i.Z_DEFAULT_COMPRESSION; "number" == typeof e.level && (l = e.level); var c = i.Z_DEFAULT_STRATEGY; "number" == typeof e.strategy && (c = e.strategy), this._handle.init(e.windowBits || i.Z_DEFAULT_WINDOWBITS, l, e.memLevel || i.Z_DEFAULT_MEMLEVEL, c, e.dictionary), this._buffer = r.allocUnsafe(this._chunkSize), this._offset = 0, this._level = l, this._strategy = c, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: function () { return !o._handle }, configurable: !0, enumerable: !0 }) } function C(e, i) { i && t.nextTick(i), e._handle && (e._handle.close(), e._handle = null) } function L(e) { e.emit("close") } Object.defineProperty(i, "codes", { enumerable: !0, value: Object.freeze(p), writable: !1 }), i.Deflate = _, i.Inflate = b, i.Gzip = x, i.Gunzip = w, i.DeflateRaw = S, i.InflateRaw = M, i.Unzip = T, i.createDeflate = function (e) { return new _(e) }, i.createInflate = function (e) { return new b(e) }, i.createDeflateRaw = function (e) { return new S(e) }, i.createInflateRaw = function (e) { return new M(e) }, i.createGzip = function (e) { return new x(e) }, i.createGunzip = function (e) { return new w(e) }, i.createUnzip = function (e) { return new T(e) }, i.deflate = function (e, t, i) { return "function" == typeof t && (i = t, t = {}), y(new _(t), e, i) }, i.deflateSync = function (e, t) { return v(new _(t), e) }, i.gzip = function (e, t, i) { return "function" == typeof t && (i = t, t = {}), y(new x(t), e, i) }, i.gzipSync = function (e, t) { return v(new x(t), e) }, i.deflateRaw = function (e, t, i) { return "function" == typeof t && (i = t, t = {}), y(new S(t), e, i) }, i.deflateRawSync = function (e, t) { return v(new S(t), e) }, i.unzip = function (e, t, i) { return "function" == typeof t && (i = t, t = {}), y(new T(t), e, i) }, i.unzipSync = function (e, t) { return v(new T(t), e) }, i.inflate = function (e, t, i) { return "function" == typeof t && (i = t, t = {}), y(new b(t), e, i) }, i.inflateSync = function (e, t) { return v(new b(t), e) }, i.gunzip = function (e, t, i) { return "function" == typeof t && (i = t, t = {}), y(new w(t), e, i) }, i.gunzipSync = function (e, t) { return v(new w(t), e) }, i.inflateRaw = function (e, t, i) { return "function" == typeof t && (i = t, t = {}), y(new M(t), e, i) }, i.inflateRawSync = function (e, t) { return v(new M(t), e) }, o.inherits(E, n), E.prototype.params = function (e, r, n) { if (e < i.Z_MIN_LEVEL || e > i.Z_MAX_LEVEL) throw new RangeError("Invalid compression level: " + e); if (r != i.Z_FILTERED && r != i.Z_HUFFMAN_ONLY && r != i.Z_RLE && r != i.Z_FIXED && r != i.Z_DEFAULT_STRATEGY) throw new TypeError("Invalid strategy: " + r); if (this._level !== e || this._strategy !== r) { var o = this; this.flush(a.Z_SYNC_FLUSH, (function () { s(o._handle, "zlib binding closed"), o._handle.params(e, r), o._hadError || (o._level = e, o._strategy = r, n && n()) })) } else t.nextTick(n) }, E.prototype.reset = function () { return s(this._handle, "zlib binding closed"), this._handle.reset() }, E.prototype._flush = function (e) { this._transform(r.alloc(0), "", e) }, E.prototype.flush = function (e, i) { var n = this, o = this._writableState; ("function" == typeof e || void 0 === e && !i) && (i = e, e = a.Z_FULL_FLUSH), o.ended ? i && t.nextTick(i) : o.ending ? i && this.once("end", i) : o.needDrain ? i && this.once("drain", (function () { return n.flush(e, i) })) : (this._flushFlag = e, this.write(r.alloc(0), "", i)) }, E.prototype.close = function (e) { C(this, e), t.nextTick(L, this) }, E.prototype._transform = function (e, t, i) { var n, o = this._writableState, s = (o.ending || o.ended) && (!e || o.length === e.length); return null === e || r.isBuffer(e) ? this._handle ? (s ? n = this._finishFlushFlag : (n = this._flushFlag, e.length >= o.length && (this._flushFlag = this._opts.flush || a.Z_NO_FLUSH)), void this._processChunk(e, n, i)) : i(new Error("zlib binding closed")) : i(new Error("invalid input")) }, E.prototype._processChunk = function (e, t, i) { var n = e && e.length, a = this._chunkSize - this._offset, o = 0, h = this, u = "function" == typeof i; if (!u) { var d, p = [], f = 0; this.on("error", (function (e) { d = e })), s(this._handle, "zlib binding closed"); do { var m = this._handle.writeSync(t, e, o, n, this._buffer, this._offset, a) } while (!this._hadError && v(m[0], m[1])); if (this._hadError) throw d; if (f >= l) throw C(this), new RangeError(c); var g = r.concat(p, f); return C(this), g } s(this._handle, "zlib binding closed"); var y = this._handle.write(t, e, o, n, this._buffer, this._offset, a); function v(l, c) { if (this && (this.buffer = null, this.callback = null), !h._hadError) { var d = a - c; if (s(d >= 0, "have should not go down"), d > 0) { var m = h._buffer.slice(h._offset, h._offset + d); h._offset += d, u ? h.push(m) : (p.push(m), f += m.length) } if ((0 === c || h._offset >= h._chunkSize) && (a = h._chunkSize, h._offset = 0, h._buffer = r.allocUnsafe(h._chunkSize)), 0 === c) { if (o += n - l, n = l, !u) return !0; var g = h._handle.write(t, e, o, n, h._buffer, h._offset, h._chunkSize); return g.callback = v, void (g.buffer = e) } if (!u) return !1; i() } } y.buffer = e, y.callback = v }, o.inherits(_, E), o.inherits(b, E), o.inherits(x, E), o.inherits(w, E), o.inherits(S, E), o.inherits(M, E), o.inherits(T, E) }).call(this) }).call(this, e("_process")) }, { "./binding": 31, _process: 60, assert: 23, buffer: 33, stream: 61, util: 81 }], 33: [function (e, t, i) { (function (t) { (function () { var t = e("base64-js"), r = e("ieee754"); i.Buffer = s, i.SlowBuffer = y, i.INSPECT_MAX_BYTES = 50; var n = 2147483647; function a() { try { var e = new Uint8Array(1); return e.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }, 42 === e.foo() } catch (e) { return !1 } } function o(e) { if (e > n) throw new RangeError('The value "' + e + '" is invalid for option "size"'); var t = new Uint8Array(e); return t.__proto__ = s.prototype, t } function s(e, t, i) { if ("number" == typeof e) { if ("string" == typeof t) throw new TypeError('The "string" argument must be of type string. Received type number'); return u(e) } return l(e, t, i) } function l(e, t, i) { if ("string" == typeof e) return d(e, t); if (ArrayBuffer.isView(e)) return p(e); if (null == e) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e); if (q(e, ArrayBuffer) || e && q(e.buffer, ArrayBuffer)) return f(e, t, i); if ("number" == typeof e) throw new TypeError('The "value" argument must not be of type number. Received type number'); var r = e.valueOf && e.valueOf(); if (null != r && r !== e) return s.from(r, t, i); var n = m(e); if (n) return n; if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive]) return s.from(e[Symbol.toPrimitive]("string"), t, i); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e) } function c(e) { if ("number" != typeof e) throw new TypeError('"size" argument must be of type number'); if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"') } function h(e, t, i) { return c(e), e <= 0 ? o(e) : void 0 !== t ? "string" == typeof i ? o(e).fill(t, i) : o(e).fill(t) : o(e) } function u(e) { return c(e), o(e < 0 ? 0 : 0 | g(e)) } function d(e, t) { if ("string" == typeof t && "" !== t || (t = "utf8"), !s.isEncoding(t)) throw new TypeError("Unknown encoding: " + t); var i = 0 | v(e, t), r = o(i), n = r.write(e, t); return n !== i && (r = r.slice(0, n)), r } function p(e) { for (var t = e.length < 0 ? 0 : 0 | g(e.length), i = o(t), r = 0; r < t; r += 1)i[r] = 255 & e[r]; return i } function f(e, t, i) { if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds'); if (e.byteLength < t + (i || 0)) throw new RangeError('"length" is outside of buffer bounds'); var r; return (r = void 0 === t && void 0 === i ? new Uint8Array(e) : void 0 === i ? new Uint8Array(e, t) : new Uint8Array(e, t, i)).__proto__ = s.prototype, r } function m(e) { if (s.isBuffer(e)) { var t = 0 | g(e.length), i = o(t); return 0 === i.length || e.copy(i, 0, 0, t), i } return void 0 !== e.length ? "number" != typeof e.length || J(e.length) ? o(0) : p(e) : "Buffer" === e.type && Array.isArray(e.data) ? p(e.data) : void 0 } function g(e) { if (e >= n) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n.toString(16) + " bytes"); return 0 | e } function y(e) { return +e != e && (e = 0), s.alloc(+e) } function v(e, t) { if (s.isBuffer(e)) return e.length; if (ArrayBuffer.isView(e) || q(e, ArrayBuffer)) return e.byteLength; if ("string" != typeof e) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e); var i = e.length, r = arguments.length > 2 && !0 === arguments[2]; if (!r && 0 === i) return 0; for (var n = !1; ;)switch (t) { case "ascii": case "latin1": case "binary": return i; case "utf8": case "utf-8": return W(e).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * i; case "hex": return i >>> 1; case "base64": return X(e).length; default: if (n) return r ? -1 : W(e).length; t = ("" + t).toLowerCase(), n = !0 } } function _(e, t, i) { var r = !1; if ((void 0 === t || t < 0) && (t = 0), t > this.length) return ""; if ((void 0 === i || i > this.length) && (i = this.length), i <= 0) return ""; if ((i >>>= 0) <= (t >>>= 0)) return ""; for (e || (e = "utf8"); ;)switch (e) { case "hex": return k(this, t, i); case "utf8": case "utf-8": return R(this, t, i); case "ascii": return O(this, t, i); case "latin1": case "binary": return I(this, t, i); case "base64": return L(this, t, i); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return B(this, t, i); default: if (r) throw new TypeError("Unknown encoding: " + e); e = (e + "").toLowerCase(), r = !0 } } function b(e, t, i) { var r = e[t]; e[t] = e[i], e[i] = r } function x(e, t, i, r, n) { if (0 === e.length) return -1; if ("string" == typeof i ? (r = i, i = 0) : i > 2147483647 ? i = 2147483647 : i < -2147483648 && (i = -2147483648), J(i = +i) && (i = n ? 0 : e.length - 1), i < 0 && (i = e.length + i), i >= e.length) { if (n) return -1; i = e.length - 1 } else if (i < 0) { if (!n) return -1; i = 0 } if ("string" == typeof t && (t = s.from(t, r)), s.isBuffer(t)) return 0 === t.length ? -1 : w(e, t, i, r, n); if ("number" == typeof t) return t &= 255, "function" == typeof Uint8Array.prototype.indexOf ? n ? Uint8Array.prototype.indexOf.call(e, t, i) : Uint8Array.prototype.lastIndexOf.call(e, t, i) : w(e, [t], i, r, n); throw new TypeError("val must be string, number or Buffer") } function w(e, t, i, r, n) { var a, o = 1, s = e.length, l = t.length; if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) { if (e.length < 2 || t.length < 2) return -1; o = 2, s /= 2, l /= 2, i /= 2 } function c(e, t) { return 1 === o ? e[t] : e.readUInt16BE(t * o) } if (n) { var h = -1; for (a = i; a < s; a++)if (c(e, a) === c(t, -1 === h ? 0 : a - h)) { if (-1 === h && (h = a), a - h + 1 === l) return h * o } else -1 !== h && (a -= a - h), h = -1 } else for (i + l > s && (i = s - l), a = i; a >= 0; a--) { for (var u = !0, d = 0; d < l; d++)if (c(e, a + d) !== c(t, d)) { u = !1; break } if (u) return a } return -1 } function S(e, t, i, r) { i = Number(i) || 0; var n = e.length - i; r ? (r = Number(r)) > n && (r = n) : r = n; var a = t.length; r > a / 2 && (r = a / 2); for (var o = 0; o < r; ++o) { var s = parseInt(t.substr(2 * o, 2), 16); if (J(s)) return o; e[i + o] = s } return o } function M(e, t, i, r) { return Z(W(t, e.length - i), e, i, r) } function T(e, t, i, r) { return Z($(t), e, i, r) } function A(e, t, i, r) { return T(e, t, i, r) } function E(e, t, i, r) { return Z(X(t), e, i, r) } function C(e, t, i, r) { return Z(Y(t, e.length - i), e, i, r) } function L(e, i, r) { return 0 === i && r === e.length ? t.fromByteArray(e) : t.fromByteArray(e.slice(i, r)) } function R(e, t, i) { i = Math.min(e.length, i); for (var r = [], n = t; n < i;) { var a, o, s, l, c = e[n], h = null, u = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1; if (n + u <= i) switch (u) { case 1: c < 128 && (h = c); break; case 2: 128 == (192 & (a = e[n + 1])) && (l = (31 & c) << 6 | 63 & a) > 127 && (h = l); break; case 3: a = e[n + 1], o = e[n + 2], 128 == (192 & a) && 128 == (192 & o) && (l = (15 & c) << 12 | (63 & a) << 6 | 63 & o) > 2047 && (l < 55296 || l > 57343) && (h = l); break; case 4: a = e[n + 1], o = e[n + 2], s = e[n + 3], 128 == (192 & a) && 128 == (192 & o) && 128 == (192 & s) && (l = (15 & c) << 18 | (63 & a) << 12 | (63 & o) << 6 | 63 & s) > 65535 && l < 1114112 && (h = l) }null === h ? (h = 65533, u = 1) : h > 65535 && (h -= 65536, r.push(h >>> 10 & 1023 | 55296), h = 56320 | 1023 & h), r.push(h), n += u } return P(r) } i.kMaxLength = n, s.TYPED_ARRAY_SUPPORT = a(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", { enumerable: !0, get: function () { if (s.isBuffer(this)) return this.buffer } }), Object.defineProperty(s.prototype, "offset", { enumerable: !0, get: function () { if (s.isBuffer(this)) return this.byteOffset } }), "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, { value: null, configurable: !0, enumerable: !1, writable: !1 }), s.poolSize = 8192, s.from = function (e, t, i) { return l(e, t, i) }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function (e, t, i) { return h(e, t, i) }, s.allocUnsafe = function (e) { return u(e) }, s.allocUnsafeSlow = function (e) { return u(e) }, s.isBuffer = function (e) { return null != e && !0 === e._isBuffer && e !== s.prototype }, s.compare = function (e, t) { if (q(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), q(t, Uint8Array) && (t = s.from(t, t.offset, t.byteLength)), !s.isBuffer(e) || !s.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (e === t) return 0; for (var i = e.length, r = t.length, n = 0, a = Math.min(i, r); n < a; ++n)if (e[n] !== t[n]) { i = e[n], r = t[n]; break } return i < r ? -1 : r < i ? 1 : 0 }, s.isEncoding = function (e) { switch (String(e).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, s.concat = function (e, t) { if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === e.length) return s.alloc(0); var i; if (void 0 === t) for (t = 0, i = 0; i < e.length; ++i)t += e[i].length; var r = s.allocUnsafe(t), n = 0; for (i = 0; i < e.length; ++i) { var a = e[i]; if (q(a, Uint8Array) && (a = s.from(a)), !s.isBuffer(a)) throw new TypeError('"list" argument must be an Array of Buffers'); a.copy(r, n), n += a.length } return r }, s.byteLength = v, s.prototype._isBuffer = !0, s.prototype.swap16 = function () { var e = this.length; if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var t = 0; t < e; t += 2)b(this, t, t + 1); return this }, s.prototype.swap32 = function () { var e = this.length; if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var t = 0; t < e; t += 4)b(this, t, t + 3), b(this, t + 1, t + 2); return this }, s.prototype.swap64 = function () { var e = this.length; if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var t = 0; t < e; t += 8)b(this, t, t + 7), b(this, t + 1, t + 6), b(this, t + 2, t + 5), b(this, t + 3, t + 4); return this }, s.prototype.toString = function () { var e = this.length; return 0 === e ? "" : 0 === arguments.length ? R(this, 0, e) : _.apply(this, arguments) }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function (e) { if (!s.isBuffer(e)) throw new TypeError("Argument must be a Buffer"); return this === e || 0 === s.compare(this, e) }, s.prototype.inspect = function () { var e = "", t = i.INSPECT_MAX_BYTES; return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">" }, s.prototype.compare = function (e, t, i, r, n) { if (q(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), !s.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e); if (void 0 === t && (t = 0), void 0 === i && (i = e ? e.length : 0), void 0 === r && (r = 0), void 0 === n && (n = this.length), t < 0 || i > e.length || r < 0 || n > this.length) throw new RangeError("out of range index"); if (r >= n && t >= i) return 0; if (r >= n) return -1; if (t >= i) return 1; if (this === e) return 0; for (var a = (n >>>= 0) - (r >>>= 0), o = (i >>>= 0) - (t >>>= 0), l = Math.min(a, o), c = this.slice(r, n), h = e.slice(t, i), u = 0; u < l; ++u)if (c[u] !== h[u]) { a = c[u], o = h[u]; break } return a < o ? -1 : o < a ? 1 : 0 }, s.prototype.includes = function (e, t, i) { return -1 !== this.indexOf(e, t, i) }, s.prototype.indexOf = function (e, t, i) { return x(this, e, t, i, !0) }, s.prototype.lastIndexOf = function (e, t, i) { return x(this, e, t, i, !1) }, s.prototype.write = function (e, t, i, r) { if (void 0 === t) r = "utf8", i = this.length, t = 0; else if (void 0 === i && "string" == typeof t) r = t, i = this.length, t = 0; else { if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); t >>>= 0, isFinite(i) ? (i >>>= 0, void 0 === r && (r = "utf8")) : (r = i, i = void 0) } var n = this.length - t; if ((void 0 === i || i > n) && (i = n), e.length > 0 && (i < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds"); r || (r = "utf8"); for (var a = !1; ;)switch (r) { case "hex": return S(this, e, t, i); case "utf8": case "utf-8": return M(this, e, t, i); case "ascii": return T(this, e, t, i); case "latin1": case "binary": return A(this, e, t, i); case "base64": return E(this, e, t, i); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return C(this, e, t, i); default: if (a) throw new TypeError("Unknown encoding: " + r); r = ("" + r).toLowerCase(), a = !0 } }, s.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; var D = 4096; function P(e) { var t = e.length; if (t <= D) return String.fromCharCode.apply(String, e); for (var i = "", r = 0; r < t;)i += String.fromCharCode.apply(String, e.slice(r, r += D)); return i } function O(e, t, i) { var r = ""; i = Math.min(e.length, i); for (var n = t; n < i; ++n)r += String.fromCharCode(127 & e[n]); return r } function I(e, t, i) { var r = ""; i = Math.min(e.length, i); for (var n = t; n < i; ++n)r += String.fromCharCode(e[n]); return r } function k(e, t, i) { var r = e.length; (!t || t < 0) && (t = 0), (!i || i < 0 || i > r) && (i = r); for (var n = "", a = t; a < i; ++a)n += j(e[a]); return n } function B(e, t, i) { for (var r = e.slice(t, i), n = "", a = 0; a < r.length; a += 2)n += String.fromCharCode(r[a] + 256 * r[a + 1]); return n } function N(e, t, i) { if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint"); if (e + t > i) throw new RangeError("Trying to access beyond buffer length") } function F(e, t, i, r, n, a) { if (!s.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (t > n || t < a) throw new RangeError('"value" argument is out of bounds'); if (i + r > e.length) throw new RangeError("Index out of range") } function U(e, t, i, r, n, a) { if (i + r > e.length) throw new RangeError("Index out of range"); if (i < 0) throw new RangeError("Index out of range") } function z(e, t, i, n, a) { return t = +t, i >>>= 0, a || U(e, t, i, 4), r.write(e, t, i, n, 23, 4), i + 4 } function G(e, t, i, n, a) { return t = +t, i >>>= 0, a || U(e, t, i, 8), r.write(e, t, i, n, 52, 8), i + 8 } s.prototype.slice = function (e, t) { var i = this.length; (e = ~~e) < 0 ? (e += i) < 0 && (e = 0) : e > i && (e = i), (t = void 0 === t ? i : ~~t) < 0 ? (t += i) < 0 && (t = 0) : t > i && (t = i), t < e && (t = e); var r = this.subarray(e, t); return r.__proto__ = s.prototype, r }, s.prototype.readUIntLE = function (e, t, i) { e >>>= 0, t >>>= 0, i || N(e, t, this.length); for (var r = this[e], n = 1, a = 0; ++a < t && (n *= 256);)r += this[e + a] * n; return r }, s.prototype.readUIntBE = function (e, t, i) { e >>>= 0, t >>>= 0, i || N(e, t, this.length); for (var r = this[e + --t], n = 1; t > 0 && (n *= 256);)r += this[e + --t] * n; return r }, s.prototype.readUInt8 = function (e, t) { return e >>>= 0, t || N(e, 1, this.length), this[e] }, s.prototype.readUInt16LE = function (e, t) { return e >>>= 0, t || N(e, 2, this.length), this[e] | this[e + 1] << 8 }, s.prototype.readUInt16BE = function (e, t) { return e >>>= 0, t || N(e, 2, this.length), this[e] << 8 | this[e + 1] }, s.prototype.readUInt32LE = function (e, t) { return e >>>= 0, t || N(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3] }, s.prototype.readUInt32BE = function (e, t) { return e >>>= 0, t || N(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]) }, s.prototype.readIntLE = function (e, t, i) { e >>>= 0, t >>>= 0, i || N(e, t, this.length); for (var r = this[e], n = 1, a = 0; ++a < t && (n *= 256);)r += this[e + a] * n; return r >= (n *= 128) && (r -= Math.pow(2, 8 * t)), r }, s.prototype.readIntBE = function (e, t, i) { e >>>= 0, t >>>= 0, i || N(e, t, this.length); for (var r = t, n = 1, a = this[e + --r]; r > 0 && (n *= 256);)a += this[e + --r] * n; return a >= (n *= 128) && (a -= Math.pow(2, 8 * t)), a }, s.prototype.readInt8 = function (e, t) { return e >>>= 0, t || N(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e] }, s.prototype.readInt16LE = function (e, t) { e >>>= 0, t || N(e, 2, this.length); var i = this[e] | this[e + 1] << 8; return 32768 & i ? 4294901760 | i : i }, s.prototype.readInt16BE = function (e, t) { e >>>= 0, t || N(e, 2, this.length); var i = this[e + 1] | this[e] << 8; return 32768 & i ? 4294901760 | i : i }, s.prototype.readInt32LE = function (e, t) { return e >>>= 0, t || N(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24 }, s.prototype.readInt32BE = function (e, t) { return e >>>= 0, t || N(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3] }, s.prototype.readFloatLE = function (e, t) { return e >>>= 0, t || N(e, 4, this.length), r.read(this, e, !0, 23, 4) }, s.prototype.readFloatBE = function (e, t) { return e >>>= 0, t || N(e, 4, this.length), r.read(this, e, !1, 23, 4) }, s.prototype.readDoubleLE = function (e, t) { return e >>>= 0, t || N(e, 8, this.length), r.read(this, e, !0, 52, 8) }, s.prototype.readDoubleBE = function (e, t) { return e >>>= 0, t || N(e, 8, this.length), r.read(this, e, !1, 52, 8) }, s.prototype.writeUIntLE = function (e, t, i, r) { e = +e, t >>>= 0, i >>>= 0, r || F(this, e, t, i, Math.pow(2, 8 * i) - 1, 0); var n = 1, a = 0; for (this[t] = 255 & e; ++a < i && (n *= 256);)this[t + a] = e / n & 255; return t + i }, s.prototype.writeUIntBE = function (e, t, i, r) { e = +e, t >>>= 0, i >>>= 0, r || F(this, e, t, i, Math.pow(2, 8 * i) - 1, 0); var n = i - 1, a = 1; for (this[t + n] = 255 & e; --n >= 0 && (a *= 256);)this[t + n] = e / a & 255; return t + i }, s.prototype.writeUInt8 = function (e, t, i) { return e = +e, t >>>= 0, i || F(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1 }, s.prototype.writeUInt16LE = function (e, t, i) { return e = +e, t >>>= 0, i || F(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2 }, s.prototype.writeUInt16BE = function (e, t, i) { return e = +e, t >>>= 0, i || F(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2 }, s.prototype.writeUInt32LE = function (e, t, i) { return e = +e, t >>>= 0, i || F(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4 }, s.prototype.writeUInt32BE = function (e, t, i) { return e = +e, t >>>= 0, i || F(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4 }, s.prototype.writeIntLE = function (e, t, i, r) { if (e = +e, t >>>= 0, !r) { var n = Math.pow(2, 8 * i - 1); F(this, e, t, i, n - 1, -n) } var a = 0, o = 1, s = 0; for (this[t] = 255 & e; ++a < i && (o *= 256);)e < 0 && 0 === s && 0 !== this[t + a - 1] && (s = 1), this[t + a] = (e / o >> 0) - s & 255; return t + i }, s.prototype.writeIntBE = function (e, t, i, r) { if (e = +e, t >>>= 0, !r) { var n = Math.pow(2, 8 * i - 1); F(this, e, t, i, n - 1, -n) } var a = i - 1, o = 1, s = 0; for (this[t + a] = 255 & e; --a >= 0 && (o *= 256);)e < 0 && 0 === s && 0 !== this[t + a + 1] && (s = 1), this[t + a] = (e / o >> 0) - s & 255; return t + i }, s.prototype.writeInt8 = function (e, t, i) { return e = +e, t >>>= 0, i || F(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1 }, s.prototype.writeInt16LE = function (e, t, i) { return e = +e, t >>>= 0, i || F(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2 }, s.prototype.writeInt16BE = function (e, t, i) { return e = +e, t >>>= 0, i || F(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2 }, s.prototype.writeInt32LE = function (e, t, i) { return e = +e, t >>>= 0, i || F(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4 }, s.prototype.writeInt32BE = function (e, t, i) { return e = +e, t >>>= 0, i || F(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4 }, s.prototype.writeFloatLE = function (e, t, i) { return z(this, e, t, !0, i) }, s.prototype.writeFloatBE = function (e, t, i) { return z(this, e, t, !1, i) }, s.prototype.writeDoubleLE = function (e, t, i) { return G(this, e, t, !0, i) }, s.prototype.writeDoubleBE = function (e, t, i) { return G(this, e, t, !1, i) }, s.prototype.copy = function (e, t, i, r) { if (!s.isBuffer(e)) throw new TypeError("argument should be a Buffer"); if (i || (i = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < i && (r = i), r === i) return 0; if (0 === e.length || 0 === this.length) return 0; if (t < 0) throw new RangeError("targetStart out of bounds"); if (i < 0 || i >= this.length) throw new RangeError("Index out of range"); if (r < 0) throw new RangeError("sourceEnd out of bounds"); r > this.length && (r = this.length), e.length - t < r - i && (r = e.length - t + i); var n = r - i; if (this === e && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(t, i, r); else if (this === e && i < t && t < r) for (var a = n - 1; a >= 0; --a)e[a + t] = this[a + i]; else Uint8Array.prototype.set.call(e, this.subarray(i, r), t); return n }, s.prototype.fill = function (e, t, i, r) { if ("string" == typeof e) { if ("string" == typeof t ? (r = t, t = 0, i = this.length) : "string" == typeof i && (r = i, i = this.length), void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string"); if ("string" == typeof r && !s.isEncoding(r)) throw new TypeError("Unknown encoding: " + r); if (1 === e.length) { var n = e.charCodeAt(0); ("utf8" === r && n < 128 || "latin1" === r) && (e = n) } } else "number" == typeof e && (e &= 255); if (t < 0 || this.length < t || this.length < i) throw new RangeError("Out of range index"); if (i <= t) return this; var a; if (t >>>= 0, i = void 0 === i ? this.length : i >>> 0, e || (e = 0), "number" == typeof e) for (a = t; a < i; ++a)this[a] = e; else { var o = s.isBuffer(e) ? e : s.from(e, r), l = o.length; if (0 === l) throw new TypeError('The value "' + e + '" is invalid for argument "value"'); for (a = 0; a < i - t; ++a)this[a + t] = o[a % l] } return this }; var H = /[^+/0-9A-Za-z-_]/g; function V(e) { if ((e = (e = e.split("=")[0]).trim().replace(H, "")).length < 2) return ""; for (; e.length % 4 != 0;)e += "="; return e } function j(e) { return e < 16 ? "0" + e.toString(16) : e.toString(16) } function W(e, t) { var i; t = t || 1 / 0; for (var r = e.length, n = null, a = [], o = 0; o < r; ++o) { if ((i = e.charCodeAt(o)) > 55295 && i < 57344) { if (!n) { if (i > 56319) { (t -= 3) > -1 && a.push(239, 191, 189); continue } if (o + 1 === r) { (t -= 3) > -1 && a.push(239, 191, 189); continue } n = i; continue } if (i < 56320) { (t -= 3) > -1 && a.push(239, 191, 189), n = i; continue } i = 65536 + (n - 55296 << 10 | i - 56320) } else n && (t -= 3) > -1 && a.push(239, 191, 189); if (n = null, i < 128) { if ((t -= 1) < 0) break; a.push(i) } else if (i < 2048) { if ((t -= 2) < 0) break; a.push(i >> 6 | 192, 63 & i | 128) } else if (i < 65536) { if ((t -= 3) < 0) break; a.push(i >> 12 | 224, i >> 6 & 63 | 128, 63 & i | 128) } else { if (!(i < 1114112)) throw new Error("Invalid code point"); if ((t -= 4) < 0) break; a.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, 63 & i | 128) } } return a } function $(e) { for (var t = [], i = 0; i < e.length; ++i)t.push(255 & e.charCodeAt(i)); return t } function Y(e, t) { for (var i, r, n, a = [], o = 0; o < e.length && !((t -= 2) < 0); ++o)r = (i = e.charCodeAt(o)) >> 8, n = i % 256, a.push(n), a.push(r); return a } function X(e) { return t.toByteArray(V(e)) } function Z(e, t, i, r) { for (var n = 0; n < r && !(n + i >= t.length || n >= e.length); ++n)t[n + i] = e[n]; return n } function q(e, t) { return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name } function J(e) { return e != e } }).call(this) }).call(this, e("buffer").Buffer) }, { "base64-js": 29, buffer: 33, ieee754: 44 }], 34: [function (e, t, i) { var r, n = TypeError, a = Object.getOwnPropertyDescriptor; if (a) try { a({}, "") } catch (e) { a = null } var o = function () { throw new n }, s = a ? function () { try { return o } catch (e) { try { return a(arguments, "callee").get } catch (e) { return o } } }() : o, l = e("has-symbols")(), c = Object.getPrototypeOf || function (e) { return e.__proto__ }, h = r, u = r, d = r, p = "undefined" == typeof Uint8Array ? r : c(Uint8Array), f = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? r : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? r : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": l ? c([][Symbol.iterator]()) : r, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": r, "%AsyncFunction%": u, "%AsyncFunctionPrototype%": r, "%AsyncGenerator%": r, "%AsyncGeneratorFunction%": d, "%AsyncGeneratorPrototype%": r, "%AsyncIteratorPrototype%": r, "%Atomics%": "undefined" == typeof Atomics ? r : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? r : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? r : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? r : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? r : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? r : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? r : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": r, "%GeneratorFunction%": h, "%GeneratorPrototype%": r, "%Int8Array%": "undefined" == typeof Int8Array ? r : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? r : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? r : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? r : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? r : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? r : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": l ? c(c([][Symbol.iterator]())) : r, "%JSON%": "object" == typeof JSON ? JSON : r, "%JSONParse%": "object" == typeof JSON ? JSON.parse : r, "%Map%": "undefined" == typeof Map ? r : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && l ? c((new Map)[Symbol.iterator]()) : r, "%MapPrototype%": "undefined" == typeof Map ? r : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? r : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? r : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? r : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? r : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? r : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? r : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? r : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? r : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? r : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && l ? c((new Set)[Symbol.iterator]()) : r, "%SetPrototype%": "undefined" == typeof Set ? r : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? r : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? r : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": l ? c(""[Symbol.iterator]()) : r, "%StringPrototype%": String.prototype, "%Symbol%": l ? Symbol : r, "%SymbolPrototype%": l ? Symbol.prototype : r, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": s, "%TypedArray%": p, "%TypedArrayPrototype%": p ? p.prototype : r, "%TypeError%": n, "%TypeErrorPrototype%": n.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? r : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? r : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? r : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? r : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? r : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? r : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? r : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? r : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? r : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? r : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? r : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? r : WeakSet.prototype }, m = e("function-bind").call(Function.call, String.prototype.replace), g = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, y = /\\(\\)?/g, v = function (e) { var t = []; return m(e, g, (function (e, i, r, n) { t[t.length] = r ? m(n, y, "$1") : i || e })), t }, _ = function (e, t) { if (!(e in f)) throw new SyntaxError("intrinsic " + e + " does not exist!"); if (void 0 === f[e] && !t) throw new n("intrinsic " + e + " exists, but is not available. Please file an issue!"); return f[e] }; t.exports = function (e, t) { if ("string" != typeof e || 0 === e.length) throw new TypeError("intrinsic name must be a non-empty string"); if (arguments.length > 1 && "boolean" != typeof t) throw new TypeError('"allowMissing" argument must be a boolean'); for (var i = v(e), r = _("%" + (i.length > 0 ? i[0] : "") + "%", t), o = 1; o < i.length; o += 1)if (null != r) if (a && o + 1 >= i.length) { var s = a(r, i[o]); if (!t && !(i[o] in r)) throw new n("base intrinsic for " + e + " exists, but the property is not available."); r = s ? s.get || s.value : r[i[o]] } else r = r[i[o]]; return r } }, { "function-bind": 41, "has-symbols": 42 }], 35: [function (e, t, i) { var r = e("function-bind"), n = e("../GetIntrinsic")("%Function%"), a = n.apply, o = n.call; t.exports = function () { return r.apply(o, arguments) }, t.exports.apply = function () { return r.apply(a, arguments) } }, { "../GetIntrinsic": 34, "function-bind": 41 }], 36: [function (e, t, i) { var r = e("../GetIntrinsic"), n = e("./callBind"), a = n(r("String.prototype.indexOf")); t.exports = function (e, t) { var i = r(e, !!t); return "function" == typeof i && a(e, ".prototype.") ? n(i) : i } }, { "../GetIntrinsic": 34, "./callBind": 35 }], 37: [function (e, t, i) { var r = e("../GetIntrinsic")("%Object.getOwnPropertyDescriptor%"); if (r) try { r([], "length") } catch (e) { r = null } t.exports = r }, { "../GetIntrinsic": 34 }], 38: [function (e, t, i) { var r, n = "object" == typeof Reflect ? Reflect : null, a = n && "function" == typeof n.apply ? n.apply : function (e, t, i) { return Function.prototype.apply.call(e, t, i) }; function o(e) { console && console.warn && console.warn(e) } r = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function (e) { return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)) } : function (e) { return Object.getOwnPropertyNames(e) }; var s = Number.isNaN || function (e) { return e != e }; function l() { l.init.call(this) } t.exports = l, t.exports.once = b, l.EventEmitter = l, l.prototype._events = void 0, l.prototype._eventsCount = 0, l.prototype._maxListeners = void 0; var c = 10; function h(e) { if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e) } function u(e) { return void 0 === e._maxListeners ? l.defaultMaxListeners : e._maxListeners } function d(e, t, i, r) { var n, a, s; if (h(i), void 0 === (a = e._events) ? (a = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== a.newListener && (e.emit("newListener", t, i.listener ? i.listener : i), a = e._events), s = a[t]), void 0 === s) s = a[t] = i, ++e._eventsCount; else if ("function" == typeof s ? s = a[t] = r ? [i, s] : [s, i] : r ? s.unshift(i) : s.push(i), (n = u(e)) > 0 && s.length > n && !s.warned) { s.warned = !0; var l = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit"); l.name = "MaxListenersExceededWarning", l.emitter = e, l.type = t, l.count = s.length, o(l) } return e } function p() { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments) } function f(e, t, i) { var r = { fired: !1, wrapFn: void 0, target: e, type: t, listener: i }, n = p.bind(r); return n.listener = i, r.wrapFn = n, n } function m(e, t, i) { var r = e._events; if (void 0 === r) return []; var n = r[t]; return void 0 === n ? [] : "function" == typeof n ? i ? [n.listener || n] : [n] : i ? _(n) : y(n, n.length) } function g(e) { var t = this._events; if (void 0 !== t) { var i = t[e]; if ("function" == typeof i) return 1; if (void 0 !== i) return i.length } return 0 } function y(e, t) { for (var i = new Array(t), r = 0; r < t; ++r)i[r] = e[r]; return i } function v(e, t) { for (; t + 1 < e.length; t++)e[t] = e[t + 1]; e.pop() } function _(e) { for (var t = new Array(e.length), i = 0; i < t.length; ++i)t[i] = e[i].listener || e[i]; return t } function b(e, t) { return new Promise((function (i, r) { function n() { void 0 !== a && e.removeListener("error", a), i([].slice.call(arguments)) } var a; "error" !== t && (a = function (i) { e.removeListener(t, n), r(i) }, e.once("error", a)), e.once(t, n) })) } Object.defineProperty(l, "defaultMaxListeners", { enumerable: !0, get: function () { return c }, set: function (e) { if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + "."); c = e } }), l.init = function () { void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }, l.prototype.setMaxListeners = function (e) { if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + "."); return this._maxListeners = e, this }, l.prototype.getMaxListeners = function () { return u(this) }, l.prototype.emit = function (e) { for (var t = [], i = 1; i < arguments.length; i++)t.push(arguments[i]); var r = "error" === e, n = this._events; if (void 0 !== n) r = r && void 0 === n.error; else if (!r) return !1; if (r) { var o; if (t.length > 0 && (o = t[0]), o instanceof Error) throw o; var s = new Error("Unhandled error." + (o ? " (" + o.message + ")" : "")); throw s.context = o, s } var l = n[e]; if (void 0 === l) return !1; if ("function" == typeof l) a(l, this, t); else { var c = l.length, h = y(l, c); for (i = 0; i < c; ++i)a(h[i], this, t) } return !0 }, l.prototype.addListener = function (e, t) { return d(this, e, t, !1) }, l.prototype.on = l.prototype.addListener, l.prototype.prependListener = function (e, t) { return d(this, e, t, !0) }, l.prototype.once = function (e, t) { return h(t), this.on(e, f(this, e, t)), this }, l.prototype.prependOnceListener = function (e, t) { return h(t), this.prependListener(e, f(this, e, t)), this }, l.prototype.removeListener = function (e, t) { var i, r, n, a, o; if (h(t), void 0 === (r = this._events)) return this; if (void 0 === (i = r[e])) return this; if (i === t || i.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[e], r.removeListener && this.emit("removeListener", e, i.listener || t)); else if ("function" != typeof i) { for (n = -1, a = i.length - 1; a >= 0; a--)if (i[a] === t || i[a].listener === t) { o = i[a].listener, n = a; break } if (n < 0) return this; 0 === n ? i.shift() : v(i, n), 1 === i.length && (r[e] = i[0]), void 0 !== r.removeListener && this.emit("removeListener", e, o || t) } return this }, l.prototype.off = l.prototype.removeListener, l.prototype.removeAllListeners = function (e) { var t, i, r; if (void 0 === (i = this._events)) return this; if (void 0 === i.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== i[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete i[e]), this; if (0 === arguments.length) { var n, a = Object.keys(i); for (r = 0; r < a.length; ++r)"removeListener" !== (n = a[r]) && this.removeAllListeners(n); return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this } if ("function" == typeof (t = i[e])) this.removeListener(e, t); else if (void 0 !== t) for (r = t.length - 1; r >= 0; r--)this.removeListener(e, t[r]); return this }, l.prototype.listeners = function (e) { return m(this, e, !0) }, l.prototype.rawListeners = function (e) { return m(this, e, !1) }, l.listenerCount = function (e, t) { return "function" == typeof e.listenerCount ? e.listenerCount(t) : g.call(e, t) }, l.prototype.listenerCount = g, l.prototype.eventNames = function () { return this._eventsCount > 0 ? r(this._events) : [] } }, {}], 39: [function (e, t, i) { var r = Object.prototype.hasOwnProperty, n = Object.prototype.toString; t.exports = function (e, t, i) { if ("[object Function]" !== n.call(t)) throw new TypeError("iterator must be a function"); var a = e.length; if (a === +a) for (var o = 0; o < a; o++)t.call(i, e[o], o, e); else for (var s in e) r.call(e, s) && t.call(i, e[s], s, e) } }, {}], 40: [function (e, t, i) { var r = "Function.prototype.bind called on incompatible ", n = Array.prototype.slice, a = Object.prototype.toString, o = "[object Function]"; t.exports = function (e) { var t = this; if ("function" != typeof t || a.call(t) !== o) throw new TypeError(r + t); for (var i, s = n.call(arguments, 1), l = function () { if (this instanceof i) { var r = t.apply(this, s.concat(n.call(arguments))); return Object(r) === r ? r : this } return t.apply(e, s.concat(n.call(arguments))) }, c = Math.max(0, t.length - s.length), h = [], u = 0; u < c; u++)h.push("$" + u); if (i = Function("binder", "return function (" + h.join(",") + "){ return binder.apply(this,arguments); }")(l), t.prototype) { var d = function () { }; d.prototype = t.prototype, i.prototype = new d, d.prototype = null } return i } }, {}], 41: [function (e, t, i) { var r = e("./implementation"); t.exports = Function.prototype.bind || r }, { "./implementation": 40 }], 42: [function (e, t, i) { (function (i) { (function () { var r = i.Symbol, n = e("./shams"); t.exports = function () { return "function" == typeof r && "function" == typeof Symbol && "symbol" == typeof r("foo") && "symbol" == typeof Symbol("bar") && n() } }).call(this) }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "./shams": 43 }], 43: [function (e, t, i) { t.exports = function () { if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return !1; if ("symbol" == typeof Symbol.iterator) return !0; var e = {}, t = Symbol("test"), i = Object(t); if ("string" == typeof t) return !1; if ("[object Symbol]" !== Object.prototype.toString.call(t)) return !1; if ("[object Symbol]" !== Object.prototype.toString.call(i)) return !1; var r = 42; for (t in e[t] = r, e) return !1; if ("function" == typeof Object.keys && 0 !== Object.keys(e).length) return !1; if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e).length) return !1; var n = Object.getOwnPropertySymbols(e); if (1 !== n.length || n[0] !== t) return !1; if (!Object.prototype.propertyIsEnumerable.call(e, t)) return !1; if ("function" == typeof Object.getOwnPropertyDescriptor) { var a = Object.getOwnPropertyDescriptor(e, t); if (a.value !== r || !0 !== a.enumerable) return !1 } return !0 } }, {}], 44: [function (e, t, i) { i.read = function (e, t, i, r, n) { var a, o, s = 8 * n - r - 1, l = (1 << s) - 1, c = l >> 1, h = -7, u = i ? n - 1 : 0, d = i ? -1 : 1, p = e[t + u]; for (u += d, a = p & (1 << -h) - 1, p >>= -h, h += s; h > 0; a = 256 * a + e[t + u], u += d, h -= 8); for (o = a & (1 << -h) - 1, a >>= -h, h += r; h > 0; o = 256 * o + e[t + u], u += d, h -= 8); if (0 === a) a = 1 - c; else { if (a === l) return o ? NaN : 1 / 0 * (p ? -1 : 1); o += Math.pow(2, r), a -= c } return (p ? -1 : 1) * o * Math.pow(2, a - r) }, i.write = function (e, t, i, r, n, a) { var o, s, l, c = 8 * a - n - 1, h = (1 << c) - 1, u = h >> 1, d = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = r ? 0 : a - 1, f = r ? 1 : -1, m = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, o = h) : (o = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), (t += o + u >= 1 ? d / l : d * Math.pow(2, 1 - u)) * l >= 2 && (o++, l /= 2), o + u >= h ? (s = 0, o = h) : o + u >= 1 ? (s = (t * l - 1) * Math.pow(2, n), o += u) : (s = t * Math.pow(2, u - 1) * Math.pow(2, n), o = 0)); n >= 8; e[i + p] = 255 & s, p += f, s /= 256, n -= 8); for (o = o << n | s, c += n; c > 0; e[i + p] = 255 & o, p += f, o /= 256, c -= 8); e[i + p - f] |= 128 * m } }, {}], 45: [function (e, t, i) { "function" == typeof Object.create ? t.exports = function (e, t) { t && (e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })) } : t.exports = function (e, t) { if (t) { e.super_ = t; var i = function () { }; i.prototype = t.prototype, e.prototype = new i, e.prototype.constructor = e } } }, {}], 46: [function (e, t, i) { var r = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, n = Object.prototype.toString, a = function (e) { return !(r && e && "object" == typeof e && Symbol.toStringTag in e) && "[object Arguments]" === n.call(e) }, o = function (e) { return !!a(e) || null !== e && "object" == typeof e && "number" == typeof e.length && e.length >= 0 && "[object Array]" !== n.call(e) && "[object Function]" === n.call(e.callee) }, s = function () { return a(arguments) }(); a.isLegacyArguments = o, t.exports = s ? a : o }, {}], 47: [function (e, t, i) { var r = Object.prototype.toString, n = Function.prototype.toString, a = /^\s*(?:function)?\*/, o = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, s = Object.getPrototypeOf, l = function () { if (!o) return !1; try { return Function("return function*() {}")() } catch (e) { } }(), c = l ? s(l) : {}; t.exports = function (e) { return "function" == typeof e && (!!a.test(n.call(e)) || (o ? s(e) === c : "[object GeneratorFunction]" === r.call(e))) } }, {}], 48: [function (e, t, i) { (function (i) { (function () { var r = e("foreach"), n = e("available-typed-arrays"), a = e("es-abstract/helpers/callBound"), o = a("Object.prototype.toString"), s = e("has-symbols")() && "symbol" == typeof Symbol.toStringTag, l = n(), c = a("Array.prototype.indexOf", !0) || function (e, t) { for (var i = 0; i < e.length; i += 1)if (e[i] === t) return i; return -1 }, h = a("String.prototype.slice"), u = {}, d = e("es-abstract/helpers/getOwnPropertyDescriptor"), p = Object.getPrototypeOf; s && d && p && r(l, (function (e) { var t = new i[e]; if (!(Symbol.toStringTag in t)) throw new EvalError("this engine has support for Symbol.toStringTag, but " + e + " does not have the property! Please report this."); var r = p(t), n = d(r, Symbol.toStringTag); if (!n) { var a = p(r); n = d(a, Symbol.toStringTag) } u[e] = n.get })); var f = function (e) { var t = !1; return r(u, (function (i, r) { if (!t) try { t = i.call(e) === r } catch (e) { } })), t }; t.exports = function (e) { if (!e || "object" != typeof e) return !1; if (!s) { var t = h(o(e), 8, -1); return c(l, t) > -1 } return !!d && f(e) } }).call(this) }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "available-typed-arrays": 27, "es-abstract/helpers/callBound": 36, "es-abstract/helpers/getOwnPropertyDescriptor": 37, foreach: 39, "has-symbols": 42 }], 49: [function (e, t, i) { var r = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array; function n(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } i.assign = function (e) { for (var t = Array.prototype.slice.call(arguments, 1); t.length;) { var i = t.shift(); if (i) { if ("object" != typeof i) throw new TypeError(i + "must be non-object"); for (var r in i) n(i, r) && (e[r] = i[r]) } } return e }, i.shrinkBuf = function (e, t) { return e.length === t ? e : e.subarray ? e.subarray(0, t) : (e.length = t, e) }; var a = { arraySet: function (e, t, i, r, n) { if (t.subarray && e.subarray) e.set(t.subarray(i, i + r), n); else for (var a = 0; a < r; a++)e[n + a] = t[i + a] }, flattenChunks: function (e) { var t, i, r, n, a, o; for (r = 0, t = 0, i = e.length; t < i; t++)r += e[t].length; for (o = new Uint8Array(r), n = 0, t = 0, i = e.length; t < i; t++)a = e[t], o.set(a, n), n += a.length; return o } }, o = { arraySet: function (e, t, i, r, n) { for (var a = 0; a < r; a++)e[n + a] = t[i + a] }, flattenChunks: function (e) { return [].concat.apply([], e) } }; i.setTyped = function (e) { e ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, a)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, o)) }, i.setTyped(r) }, {}], 50: [function (e, t, i) { function r(e, t, i, r) { for (var n = 65535 & e | 0, a = e >>> 16 & 65535 | 0, o = 0; 0 !== i;) { i -= o = i > 2e3 ? 2e3 : i; do { a = a + (n = n + t[r++] | 0) | 0 } while (--o); n %= 65521, a %= 65521 } return n | a << 16 | 0 } t.exports = r }, {}], 51: [function (e, t, i) { t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 } }, {}], 52: [function (e, t, i) { function r() { for (var e, t = [], i = 0; i < 256; i++) { e = i; for (var r = 0; r < 8; r++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1; t[i] = e } return t } var n = r(); function a(e, t, i, r) { var a = n, o = r + i; e ^= -1; for (var s = r; s < o; s++)e = e >>> 8 ^ a[255 & (e ^ t[s])]; return -1 ^ e } t.exports = a }, {}], 53: [function (e, t, i) { var r, n = e("../utils/common"), a = e("./trees"), o = e("./adler32"), s = e("./crc32"), l = e("./messages"), c = 0, h = 1, u = 3, d = 4, p = 5, f = 0, m = 1, g = -2, y = -3, v = -5, _ = -1, b = 1, x = 2, w = 3, S = 4, M = 0, T = 2, A = 8, E = 9, C = 15, L = 8, R = 286, D = 30, P = 19, O = 2 * R + 1, I = 15, k = 3, B = 258, N = B + k + 1, F = 32, U = 42, z = 69, G = 73, H = 91, V = 103, j = 113, W = 666, $ = 1, Y = 2, X = 3, Z = 4, q = 3; function J(e, t) { return e.msg = l[t], t } function K(e) { return (e << 1) - (e > 4 ? 9 : 0) } function Q(e) { for (var t = e.length; --t >= 0;)e[t] = 0 } function ee(e) { var t = e.state, i = t.pending; i > e.avail_out && (i = e.avail_out), 0 !== i && (n.arraySet(e.output, t.pending_buf, t.pending_out, i, e.next_out), e.next_out += i, t.pending_out += i, e.total_out += i, e.avail_out -= i, t.pending -= i, 0 === t.pending && (t.pending_out = 0)) } function te(e, t) { a._tr_flush_block(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, ee(e.strm) } function ie(e, t) { e.pending_buf[e.pending++] = t } function re(e, t) { e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t } function ne(e, t, i, r) { var a = e.avail_in; return a > r && (a = r), 0 === a ? 0 : (e.avail_in -= a, n.arraySet(t, e.input, e.next_in, a, i), 1 === e.state.wrap ? e.adler = o(e.adler, t, a, i) : 2 === e.state.wrap && (e.adler = s(e.adler, t, a, i)), e.next_in += a, e.total_in += a, a) } function ae(e, t) { var i, r, n = e.max_chain_length, a = e.strstart, o = e.prev_length, s = e.nice_match, l = e.strstart > e.w_size - N ? e.strstart - (e.w_size - N) : 0, c = e.window, h = e.w_mask, u = e.prev, d = e.strstart + B, p = c[a + o - 1], f = c[a + o]; e.prev_length >= e.good_match && (n >>= 2), s > e.lookahead && (s = e.lookahead); do { if (c[(i = t) + o] === f && c[i + o - 1] === p && c[i] === c[a] && c[++i] === c[a + 1]) { a += 2, i++; do { } while (c[++a] === c[++i] && c[++a] === c[++i] && c[++a] === c[++i] && c[++a] === c[++i] && c[++a] === c[++i] && c[++a] === c[++i] && c[++a] === c[++i] && c[++a] === c[++i] && a < d); if (r = B - (d - a), a = d - B, r > o) { if (e.match_start = t, o = r, r >= s) break; p = c[a + o - 1], f = c[a + o] } } } while ((t = u[t & h]) > l && 0 != --n); return o <= e.lookahead ? o : e.lookahead } function oe(e) { var t, i, r, a, o, s = e.w_size; do { if (a = e.window_size - e.lookahead - e.strstart, e.strstart >= s + (s - N)) { n.arraySet(e.window, e.window, s, s, 0), e.match_start -= s, e.strstart -= s, e.block_start -= s, t = i = e.hash_size; do { r = e.head[--t], e.head[t] = r >= s ? r - s : 0 } while (--i); t = i = s; do { r = e.prev[--t], e.prev[t] = r >= s ? r - s : 0 } while (--i); a += s } if (0 === e.strm.avail_in) break; if (i = ne(e.strm, e.window, e.strstart + e.lookahead, a), e.lookahead += i, e.lookahead + e.insert >= k) for (o = e.strstart - e.insert, e.ins_h = e.window[o], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[o + 1]) & e.hash_mask; e.insert && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[o + k - 1]) & e.hash_mask, e.prev[o & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = o, o++, e.insert--, !(e.lookahead + e.insert < k));); } while (e.lookahead < N && 0 !== e.strm.avail_in) } function se(e, t) { var i = 65535; for (i > e.pending_buf_size - 5 && (i = e.pending_buf_size - 5); ;) { if (e.lookahead <= 1) { if (oe(e), 0 === e.lookahead && t === c) return $; if (0 === e.lookahead) break } e.strstart += e.lookahead, e.lookahead = 0; var r = e.block_start + i; if ((0 === e.strstart || e.strstart >= r) && (e.lookahead = e.strstart - r, e.strstart = r, te(e, !1), 0 === e.strm.avail_out)) return $; if (e.strstart - e.block_start >= e.w_size - N && (te(e, !1), 0 === e.strm.avail_out)) return $ } return e.insert = 0, t === d ? (te(e, !0), 0 === e.strm.avail_out ? X : Z) : (e.strstart > e.block_start && (te(e, !1), e.strm.avail_out), $) } function le(e, t) { for (var i, r; ;) { if (e.lookahead < N) { if (oe(e), e.lookahead < N && t === c) return $; if (0 === e.lookahead) break } if (i = 0, e.lookahead >= k && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + k - 1]) & e.hash_mask, i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 !== i && e.strstart - i <= e.w_size - N && (e.match_length = ae(e, i)), e.match_length >= k) if (r = a._tr_tally(e, e.strstart - e.match_start, e.match_length - k), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= k) { e.match_length--; do { e.strstart++, e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + k - 1]) & e.hash_mask, i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart } while (0 != --e.match_length); e.strstart++ } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + 1]) & e.hash_mask; else r = a._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++; if (r && (te(e, !1), 0 === e.strm.avail_out)) return $ } return e.insert = e.strstart < k - 1 ? e.strstart : k - 1, t === d ? (te(e, !0), 0 === e.strm.avail_out ? X : Z) : e.last_lit && (te(e, !1), 0 === e.strm.avail_out) ? $ : Y } function ce(e, t) { for (var i, r, n; ;) { if (e.lookahead < N) { if (oe(e), e.lookahead < N && t === c) return $; if (0 === e.lookahead) break } if (i = 0, e.lookahead >= k && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + k - 1]) & e.hash_mask, i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = k - 1, 0 !== i && e.prev_length < e.max_lazy_match && e.strstart - i <= e.w_size - N && (e.match_length = ae(e, i), e.match_length <= 5 && (e.strategy === b || e.match_length === k && e.strstart - e.match_start > 4096) && (e.match_length = k - 1)), e.prev_length >= k && e.match_length <= e.prev_length) { n = e.strstart + e.lookahead - k, r = a._tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - k), e.lookahead -= e.prev_length - 1, e.prev_length -= 2; do { ++e.strstart <= n && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + k - 1]) & e.hash_mask, i = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart) } while (0 != --e.prev_length); if (e.match_available = 0, e.match_length = k - 1, e.strstart++, r && (te(e, !1), 0 === e.strm.avail_out)) return $ } else if (e.match_available) { if ((r = a._tr_tally(e, 0, e.window[e.strstart - 1])) && te(e, !1), e.strstart++, e.lookahead--, 0 === e.strm.avail_out) return $ } else e.match_available = 1, e.strstart++, e.lookahead-- } return e.match_available && (r = a._tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < k - 1 ? e.strstart : k - 1, t === d ? (te(e, !0), 0 === e.strm.avail_out ? X : Z) : e.last_lit && (te(e, !1), 0 === e.strm.avail_out) ? $ : Y } function he(e, t) { for (var i, r, n, o, s = e.window; ;) { if (e.lookahead <= B) { if (oe(e), e.lookahead <= B && t === c) return $; if (0 === e.lookahead) break } if (e.match_length = 0, e.lookahead >= k && e.strstart > 0 && (r = s[n = e.strstart - 1]) === s[++n] && r === s[++n] && r === s[++n]) { o = e.strstart + B; do { } while (r === s[++n] && r === s[++n] && r === s[++n] && r === s[++n] && r === s[++n] && r === s[++n] && r === s[++n] && r === s[++n] && n < o); e.match_length = B - (o - n), e.match_length > e.lookahead && (e.match_length = e.lookahead) } if (e.match_length >= k ? (i = a._tr_tally(e, 1, e.match_length - k), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (i = a._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), i && (te(e, !1), 0 === e.strm.avail_out)) return $ } return e.insert = 0, t === d ? (te(e, !0), 0 === e.strm.avail_out ? X : Z) : e.last_lit && (te(e, !1), 0 === e.strm.avail_out) ? $ : Y } function ue(e, t) { for (var i; ;) { if (0 === e.lookahead && (oe(e), 0 === e.lookahead)) { if (t === c) return $; break } if (e.match_length = 0, i = a._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, i && (te(e, !1), 0 === e.strm.avail_out)) return $ } return e.insert = 0, t === d ? (te(e, !0), 0 === e.strm.avail_out ? X : Z) : e.last_lit && (te(e, !1), 0 === e.strm.avail_out) ? $ : Y } function de(e, t, i, r, n) { this.good_length = e, this.max_lazy = t, this.nice_length = i, this.max_chain = r, this.func = n } function pe(e) { e.window_size = 2 * e.w_size, Q(e.head), e.max_lazy_match = r[e.level].max_lazy, e.good_match = r[e.level].good_length, e.nice_match = r[e.level].nice_length, e.max_chain_length = r[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = k - 1, e.match_available = 0, e.ins_h = 0 } function fe() { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = A, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new n.Buf16(2 * O), this.dyn_dtree = new n.Buf16(2 * (2 * D + 1)), this.bl_tree = new n.Buf16(2 * (2 * P + 1)), Q(this.dyn_ltree), Q(this.dyn_dtree), Q(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new n.Buf16(I + 1), this.heap = new n.Buf16(2 * R + 1), Q(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new n.Buf16(2 * R + 1), Q(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } function me(e) { var t; return e && e.state ? (e.total_in = e.total_out = 0, e.data_type = T, (t = e.state).pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? U : j, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = c, a._tr_init(t), f) : J(e, g) } function ge(e) { var t = me(e); return t === f && pe(e.state), t } function ye(e, t) { return e && e.state ? 2 !== e.state.wrap ? g : (e.state.gzhead = t, f) : g } function ve(e, t, i, r, a, o) { if (!e) return g; var s = 1; if (t === _ && (t = 6), r < 0 ? (s = 0, r = -r) : r > 15 && (s = 2, r -= 16), a < 1 || a > E || i !== A || r < 8 || r > 15 || t < 0 || t > 9 || o < 0 || o > S) return J(e, g); 8 === r && (r = 9); var l = new fe; return e.state = l, l.strm = e, l.wrap = s, l.gzhead = null, l.w_bits = r, l.w_size = 1 << l.w_bits, l.w_mask = l.w_size - 1, l.hash_bits = a + 7, l.hash_size = 1 << l.hash_bits, l.hash_mask = l.hash_size - 1, l.hash_shift = ~~((l.hash_bits + k - 1) / k), l.window = new n.Buf8(2 * l.w_size), l.head = new n.Buf16(l.hash_size), l.prev = new n.Buf16(l.w_size), l.lit_bufsize = 1 << a + 6, l.pending_buf_size = 4 * l.lit_bufsize, l.pending_buf = new n.Buf8(l.pending_buf_size), l.d_buf = 1 * l.lit_bufsize, l.l_buf = 3 * l.lit_bufsize, l.level = t, l.strategy = o, l.method = i, ge(e) } function _e(e, t) { return ve(e, t, A, C, L, M) } function be(e, t) { var i, n, o, l; if (!e || !e.state || t > p || t < 0) return e ? J(e, g) : g; if (n = e.state, !e.output || !e.input && 0 !== e.avail_in || n.status === W && t !== d) return J(e, 0 === e.avail_out ? v : g); if (n.strm = e, i = n.last_flush, n.last_flush = t, n.status === U) if (2 === n.wrap) e.adler = 0, ie(n, 31), ie(n, 139), ie(n, 8), n.gzhead ? (ie(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)), ie(n, 255 & n.gzhead.time), ie(n, n.gzhead.time >> 8 & 255), ie(n, n.gzhead.time >> 16 & 255), ie(n, n.gzhead.time >> 24 & 255), ie(n, 9 === n.level ? 2 : n.strategy >= x || n.level < 2 ? 4 : 0), ie(n, 255 & n.gzhead.os), n.gzhead.extra && n.gzhead.extra.length && (ie(n, 255 & n.gzhead.extra.length), ie(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (e.adler = s(e.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = z) : (ie(n, 0), ie(n, 0), ie(n, 0), ie(n, 0), ie(n, 0), ie(n, 9 === n.level ? 2 : n.strategy >= x || n.level < 2 ? 4 : 0), ie(n, q), n.status = j); else { var y = A + (n.w_bits - 8 << 4) << 8; y |= (n.strategy >= x || n.level < 2 ? 0 : n.level < 6 ? 1 : 6 === n.level ? 2 : 3) << 6, 0 !== n.strstart && (y |= F), y += 31 - y % 31, n.status = j, re(n, y), 0 !== n.strstart && (re(n, e.adler >>> 16), re(n, 65535 & e.adler)), e.adler = 1 } if (n.status === z) if (n.gzhead.extra) { for (o = n.pending; n.gzindex < (65535 & n.gzhead.extra.length) && (n.pending !== n.pending_buf_size || (n.gzhead.hcrc && n.pending > o && (e.adler = s(e.adler, n.pending_buf, n.pending - o, o)), ee(e), o = n.pending, n.pending !== n.pending_buf_size));)ie(n, 255 & n.gzhead.extra[n.gzindex]), n.gzindex++; n.gzhead.hcrc && n.pending > o && (e.adler = s(e.adler, n.pending_buf, n.pending - o, o)), n.gzindex === n.gzhead.extra.length && (n.gzindex = 0, n.status = G) } else n.status = G; if (n.status === G) if (n.gzhead.name) { o = n.pending; do { if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > o && (e.adler = s(e.adler, n.pending_buf, n.pending - o, o)), ee(e), o = n.pending, n.pending === n.pending_buf_size)) { l = 1; break } l = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0, ie(n, l) } while (0 !== l); n.gzhead.hcrc && n.pending > o && (e.adler = s(e.adler, n.pending_buf, n.pending - o, o)), 0 === l && (n.gzindex = 0, n.status = H) } else n.status = H; if (n.status === H) if (n.gzhead.comment) { o = n.pending; do { if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > o && (e.adler = s(e.adler, n.pending_buf, n.pending - o, o)), ee(e), o = n.pending, n.pending === n.pending_buf_size)) { l = 1; break } l = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0, ie(n, l) } while (0 !== l); n.gzhead.hcrc && n.pending > o && (e.adler = s(e.adler, n.pending_buf, n.pending - o, o)), 0 === l && (n.status = V) } else n.status = V; if (n.status === V && (n.gzhead.hcrc ? (n.pending + 2 > n.pending_buf_size && ee(e), n.pending + 2 <= n.pending_buf_size && (ie(n, 255 & e.adler), ie(n, e.adler >> 8 & 255), e.adler = 0, n.status = j)) : n.status = j), 0 !== n.pending) { if (ee(e), 0 === e.avail_out) return n.last_flush = -1, f } else if (0 === e.avail_in && K(t) <= K(i) && t !== d) return J(e, v); if (n.status === W && 0 !== e.avail_in) return J(e, v); if (0 !== e.avail_in || 0 !== n.lookahead || t !== c && n.status !== W) { var _ = n.strategy === x ? ue(n, t) : n.strategy === w ? he(n, t) : r[n.level].func(n, t); if (_ !== X && _ !== Z || (n.status = W), _ === $ || _ === X) return 0 === e.avail_out && (n.last_flush = -1), f; if (_ === Y && (t === h ? a._tr_align(n) : t !== p && (a._tr_stored_block(n, 0, 0, !1), t === u && (Q(n.head), 0 === n.lookahead && (n.strstart = 0, n.block_start = 0, n.insert = 0))), ee(e), 0 === e.avail_out)) return n.last_flush = -1, f } return t !== d ? f : n.wrap <= 0 ? m : (2 === n.wrap ? (ie(n, 255 & e.adler), ie(n, e.adler >> 8 & 255), ie(n, e.adler >> 16 & 255), ie(n, e.adler >> 24 & 255), ie(n, 255 & e.total_in), ie(n, e.total_in >> 8 & 255), ie(n, e.total_in >> 16 & 255), ie(n, e.total_in >> 24 & 255)) : (re(n, e.adler >>> 16), re(n, 65535 & e.adler)), ee(e), n.wrap > 0 && (n.wrap = -n.wrap), 0 !== n.pending ? f : m) } function xe(e) { var t; return e && e.state ? (t = e.state.status) !== U && t !== z && t !== G && t !== H && t !== V && t !== j && t !== W ? J(e, g) : (e.state = null, t === j ? J(e, y) : f) : g } function we(e, t) { var i, r, a, s, l, c, h, u, d = t.length; if (!e || !e.state) return g; if (2 === (s = (i = e.state).wrap) || 1 === s && i.status !== U || i.lookahead) return g; for (1 === s && (e.adler = o(e.adler, t, d, 0)), i.wrap = 0, d >= i.w_size && (0 === s && (Q(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0), u = new n.Buf8(i.w_size), n.arraySet(u, t, d - i.w_size, i.w_size, 0), t = u, d = i.w_size), l = e.avail_in, c = e.next_in, h = e.input, e.avail_in = d, e.next_in = 0, e.input = t, oe(i); i.lookahead >= k;) { r = i.strstart, a = i.lookahead - (k - 1); do { i.ins_h = (i.ins_h << i.hash_shift ^ i.window[r + k - 1]) & i.hash_mask, i.prev[r & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = r, r++ } while (--a); i.strstart = r, i.lookahead = k - 1, oe(i) } return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = k - 1, i.match_available = 0, e.next_in = c, e.input = h, e.avail_in = l, i.wrap = s, f } r = [new de(0, 0, 0, 0, se), new de(4, 4, 8, 4, le), new de(4, 5, 16, 8, le), new de(4, 6, 32, 32, le), new de(4, 4, 16, 16, ce), new de(8, 16, 32, 32, ce), new de(8, 16, 128, 128, ce), new de(8, 32, 128, 256, ce), new de(32, 128, 258, 1024, ce), new de(32, 258, 258, 4096, ce)], i.deflateInit = _e, i.deflateInit2 = ve, i.deflateReset = ge, i.deflateResetKeep = me, i.deflateSetHeader = ye, i.deflate = be, i.deflateEnd = xe, i.deflateSetDictionary = we, i.deflateInfo = "pako deflate (from Nodeca project)" }, { "../utils/common": 49, "./adler32": 50, "./crc32": 52, "./messages": 57, "./trees": 58 }], 54: [function (e, t, i) { var r = 30, n = 12; t.exports = function (e, t) { var i, a, o, s, l, c, h, u, d, p, f, m, g, y, v, _, b, x, w, S, M, T, A, E, C; i = e.state, a = e.next_in, E = e.input, o = a + (e.avail_in - 5), s = e.next_out, C = e.output, l = s - (t - e.avail_out), c = s + (e.avail_out - 257), h = i.dmax, u = i.wsize, d = i.whave, p = i.wnext, f = i.window, m = i.hold, g = i.bits, y = i.lencode, v = i.distcode, _ = (1 << i.lenbits) - 1, b = (1 << i.distbits) - 1; e: do { g < 15 && (m += E[a++] << g, g += 8, m += E[a++] << g, g += 8), x = y[m & _]; t: for (; ;) { if (m >>>= w = x >>> 24, g -= w, 0 == (w = x >>> 16 & 255)) C[s++] = 65535 & x; else { if (!(16 & w)) { if (0 == (64 & w)) { x = y[(65535 & x) + (m & (1 << w) - 1)]; continue t } if (32 & w) { i.mode = n; break e } e.msg = "invalid literal/length code", i.mode = r; break e } S = 65535 & x, (w &= 15) && (g < w && (m += E[a++] << g, g += 8), S += m & (1 << w) - 1, m >>>= w, g -= w), g < 15 && (m += E[a++] << g, g += 8, m += E[a++] << g, g += 8), x = v[m & b]; i: for (; ;) { if (m >>>= w = x >>> 24, g -= w, !(16 & (w = x >>> 16 & 255))) { if (0 == (64 & w)) { x = v[(65535 & x) + (m & (1 << w) - 1)]; continue i } e.msg = "invalid distance code", i.mode = r; break e } if (M = 65535 & x, g < (w &= 15) && (m += E[a++] << g, (g += 8) < w && (m += E[a++] << g, g += 8)), (M += m & (1 << w) - 1) > h) { e.msg = "invalid distance too far back", i.mode = r; break e } if (m >>>= w, g -= w, M > (w = s - l)) { if ((w = M - w) > d && i.sane) { e.msg = "invalid distance too far back", i.mode = r; break e } if (T = 0, A = f, 0 === p) { if (T += u - w, w < S) { S -= w; do { C[s++] = f[T++] } while (--w); T = s - M, A = C } } else if (p < w) { if (T += u + p - w, (w -= p) < S) { S -= w; do { C[s++] = f[T++] } while (--w); if (T = 0, p < S) { S -= w = p; do { C[s++] = f[T++] } while (--w); T = s - M, A = C } } } else if (T += p - w, w < S) { S -= w; do { C[s++] = f[T++] } while (--w); T = s - M, A = C } for (; S > 2;)C[s++] = A[T++], C[s++] = A[T++], C[s++] = A[T++], S -= 3; S && (C[s++] = A[T++], S > 1 && (C[s++] = A[T++])) } else { T = s - M; do { C[s++] = C[T++], C[s++] = C[T++], C[s++] = C[T++], S -= 3 } while (S > 2); S && (C[s++] = C[T++], S > 1 && (C[s++] = C[T++])) } break } } break } } while (a < o && s < c); a -= S = g >> 3, m &= (1 << (g -= S << 3)) - 1, e.next_in = a, e.next_out = s, e.avail_in = a < o ? o - a + 5 : 5 - (a - o), e.avail_out = s < c ? c - s + 257 : 257 - (s - c), i.hold = m, i.bits = g } }, {}], 55: [function (e, t, i) { var r = e("../utils/common"), n = e("./adler32"), a = e("./crc32"), o = e("./inffast"), s = e("./inftrees"), l = 0, c = 1, h = 2, u = 4, d = 5, p = 6, f = 0, m = 1, g = 2, y = -2, v = -3, _ = -4, b = -5, x = 8, w = 1, S = 2, M = 3, T = 4, A = 5, E = 6, C = 7, L = 8, R = 9, D = 10, P = 11, O = 12, I = 13, k = 14, B = 15, N = 16, F = 17, U = 18, z = 19, G = 20, H = 21, V = 22, j = 23, W = 24, $ = 25, Y = 26, X = 27, Z = 28, q = 29, J = 30, K = 31, Q = 32, ee = 852, te = 592, ie = 15; function re(e) { return (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24) } function ne() { this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0 } function ae(e) { var t; return e && e.state ? (t = e.state, e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = w, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new r.Buf32(ee), t.distcode = t.distdyn = new r.Buf32(te), t.sane = 1, t.back = -1, f) : y } function oe(e) { var t; return e && e.state ? ((t = e.state).wsize = 0, t.whave = 0, t.wnext = 0, ae(e)) : y } function se(e, t) { var i, r; return e && e.state ? (r = e.state, t < 0 ? (i = 0, t = -t) : (i = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? y : (null !== r.window && r.wbits !== t && (r.window = null), r.wrap = i, r.wbits = t, oe(e))) : y } function le(e, t) { var i, r; return e ? (r = new ne, e.state = r, r.window = null, (i = se(e, t)) !== f && (e.state = null), i) : y } function ce(e) { return le(e, ie) } var he, ue, de = !0; function pe(e) { if (de) { var t; for (he = new r.Buf32(512), ue = new r.Buf32(32), t = 0; t < 144;)e.lens[t++] = 8; for (; t < 256;)e.lens[t++] = 9; for (; t < 280;)e.lens[t++] = 7; for (; t < 288;)e.lens[t++] = 8; for (s(c, e.lens, 0, 288, he, 0, e.work, { bits: 9 }), t = 0; t < 32;)e.lens[t++] = 5; s(h, e.lens, 0, 32, ue, 0, e.work, { bits: 5 }), de = !1 } e.lencode = he, e.lenbits = 9, e.distcode = ue, e.distbits = 5 } function fe(e, t, i, n) { var a, o = e.state; return null === o.window && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new r.Buf8(o.wsize)), n >= o.wsize ? (r.arraySet(o.window, t, i - o.wsize, o.wsize, 0), o.wnext = 0, o.whave = o.wsize) : ((a = o.wsize - o.wnext) > n && (a = n), r.arraySet(o.window, t, i - n, a, o.wnext), (n -= a) ? (r.arraySet(o.window, t, i - n, n, 0), o.wnext = n, o.whave = o.wsize) : (o.wnext += a, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += a))), 0 } function me(e, t) { var i, ee, te, ie, ne, ae, oe, se, le, ce, he, ue, de, me, ge, ye, ve, _e, be, xe, we, Se, Me, Te, Ae = 0, Ee = new r.Buf8(4), Ce = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return y; (i = e.state).mode === O && (i.mode = I), ne = e.next_out, te = e.output, oe = e.avail_out, ie = e.next_in, ee = e.input, ae = e.avail_in, se = i.hold, le = i.bits, ce = ae, he = oe, Se = f; e: for (; ;)switch (i.mode) { case w: if (0 === i.wrap) { i.mode = I; break } for (; le < 16;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } if (2 & i.wrap && 35615 === se) { i.check = 0, Ee[0] = 255 & se, Ee[1] = se >>> 8 & 255, i.check = a(i.check, Ee, 2, 0), se = 0, le = 0, i.mode = S; break } if (i.flags = 0, i.head && (i.head.done = !1), !(1 & i.wrap) || (((255 & se) << 8) + (se >> 8)) % 31) { e.msg = "incorrect header check", i.mode = J; break } if ((15 & se) !== x) { e.msg = "unknown compression method", i.mode = J; break } if (le -= 4, we = 8 + (15 & (se >>>= 4)), 0 === i.wbits) i.wbits = we; else if (we > i.wbits) { e.msg = "invalid window size", i.mode = J; break } i.dmax = 1 << we, e.adler = i.check = 1, i.mode = 512 & se ? D : O, se = 0, le = 0; break; case S: for (; le < 16;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } if (i.flags = se, (255 & i.flags) !== x) { e.msg = "unknown compression method", i.mode = J; break } if (57344 & i.flags) { e.msg = "unknown header flags set", i.mode = J; break } i.head && (i.head.text = se >> 8 & 1), 512 & i.flags && (Ee[0] = 255 & se, Ee[1] = se >>> 8 & 255, i.check = a(i.check, Ee, 2, 0)), se = 0, le = 0, i.mode = M; case M: for (; le < 32;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } i.head && (i.head.time = se), 512 & i.flags && (Ee[0] = 255 & se, Ee[1] = se >>> 8 & 255, Ee[2] = se >>> 16 & 255, Ee[3] = se >>> 24 & 255, i.check = a(i.check, Ee, 4, 0)), se = 0, le = 0, i.mode = T; case T: for (; le < 16;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } i.head && (i.head.xflags = 255 & se, i.head.os = se >> 8), 512 & i.flags && (Ee[0] = 255 & se, Ee[1] = se >>> 8 & 255, i.check = a(i.check, Ee, 2, 0)), se = 0, le = 0, i.mode = A; case A: if (1024 & i.flags) { for (; le < 16;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } i.length = se, i.head && (i.head.extra_len = se), 512 & i.flags && (Ee[0] = 255 & se, Ee[1] = se >>> 8 & 255, i.check = a(i.check, Ee, 2, 0)), se = 0, le = 0 } else i.head && (i.head.extra = null); i.mode = E; case E: if (1024 & i.flags && ((ue = i.length) > ae && (ue = ae), ue && (i.head && (we = i.head.extra_len - i.length, i.head.extra || (i.head.extra = new Array(i.head.extra_len)), r.arraySet(i.head.extra, ee, ie, ue, we)), 512 & i.flags && (i.check = a(i.check, ee, ue, ie)), ae -= ue, ie += ue, i.length -= ue), i.length)) break e; i.length = 0, i.mode = C; case C: if (2048 & i.flags) { if (0 === ae) break e; ue = 0; do { we = ee[ie + ue++], i.head && we && i.length < 65536 && (i.head.name += String.fromCharCode(we)) } while (we && ue < ae); if (512 & i.flags && (i.check = a(i.check, ee, ue, ie)), ae -= ue, ie += ue, we) break e } else i.head && (i.head.name = null); i.length = 0, i.mode = L; case L: if (4096 & i.flags) { if (0 === ae) break e; ue = 0; do { we = ee[ie + ue++], i.head && we && i.length < 65536 && (i.head.comment += String.fromCharCode(we)) } while (we && ue < ae); if (512 & i.flags && (i.check = a(i.check, ee, ue, ie)), ae -= ue, ie += ue, we) break e } else i.head && (i.head.comment = null); i.mode = R; case R: if (512 & i.flags) { for (; le < 16;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } if (se !== (65535 & i.check)) { e.msg = "header crc mismatch", i.mode = J; break } se = 0, le = 0 } i.head && (i.head.hcrc = i.flags >> 9 & 1, i.head.done = !0), e.adler = i.check = 0, i.mode = O; break; case D: for (; le < 32;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } e.adler = i.check = re(se), se = 0, le = 0, i.mode = P; case P: if (0 === i.havedict) return e.next_out = ne, e.avail_out = oe, e.next_in = ie, e.avail_in = ae, i.hold = se, i.bits = le, g; e.adler = i.check = 1, i.mode = O; case O: if (t === d || t === p) break e; case I: if (i.last) { se >>>= 7 & le, le -= 7 & le, i.mode = X; break } for (; le < 3;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } switch (i.last = 1 & se, le -= 1, 3 & (se >>>= 1)) { case 0: i.mode = k; break; case 1: if (pe(i), i.mode = G, t === p) { se >>>= 2, le -= 2; break e } break; case 2: i.mode = F; break; case 3: e.msg = "invalid block type", i.mode = J }se >>>= 2, le -= 2; break; case k: for (se >>>= 7 & le, le -= 7 & le; le < 32;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } if ((65535 & se) != (se >>> 16 ^ 65535)) { e.msg = "invalid stored block lengths", i.mode = J; break } if (i.length = 65535 & se, se = 0, le = 0, i.mode = B, t === p) break e; case B: i.mode = N; case N: if (ue = i.length) { if (ue > ae && (ue = ae), ue > oe && (ue = oe), 0 === ue) break e; r.arraySet(te, ee, ie, ue, ne), ae -= ue, ie += ue, oe -= ue, ne += ue, i.length -= ue; break } i.mode = O; break; case F: for (; le < 14;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } if (i.nlen = 257 + (31 & se), se >>>= 5, le -= 5, i.ndist = 1 + (31 & se), se >>>= 5, le -= 5, i.ncode = 4 + (15 & se), se >>>= 4, le -= 4, i.nlen > 286 || i.ndist > 30) { e.msg = "too many length or distance symbols", i.mode = J; break } i.have = 0, i.mode = U; case U: for (; i.have < i.ncode;) { for (; le < 3;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } i.lens[Ce[i.have++]] = 7 & se, se >>>= 3, le -= 3 } for (; i.have < 19;)i.lens[Ce[i.have++]] = 0; if (i.lencode = i.lendyn, i.lenbits = 7, Me = { bits: i.lenbits }, Se = s(l, i.lens, 0, 19, i.lencode, 0, i.work, Me), i.lenbits = Me.bits, Se) { e.msg = "invalid code lengths set", i.mode = J; break } i.have = 0, i.mode = z; case z: for (; i.have < i.nlen + i.ndist;) { for (; ye = (Ae = i.lencode[se & (1 << i.lenbits) - 1]) >>> 16 & 255, ve = 65535 & Ae, !((ge = Ae >>> 24) <= le);) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } if (ve < 16) se >>>= ge, le -= ge, i.lens[i.have++] = ve; else { if (16 === ve) { for (Te = ge + 2; le < Te;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } if (se >>>= ge, le -= ge, 0 === i.have) { e.msg = "invalid bit length repeat", i.mode = J; break } we = i.lens[i.have - 1], ue = 3 + (3 & se), se >>>= 2, le -= 2 } else if (17 === ve) { for (Te = ge + 3; le < Te;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } le -= ge, we = 0, ue = 3 + (7 & (se >>>= ge)), se >>>= 3, le -= 3 } else { for (Te = ge + 7; le < Te;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } le -= ge, we = 0, ue = 11 + (127 & (se >>>= ge)), se >>>= 7, le -= 7 } if (i.have + ue > i.nlen + i.ndist) { e.msg = "invalid bit length repeat", i.mode = J; break } for (; ue--;)i.lens[i.have++] = we } } if (i.mode === J) break; if (0 === i.lens[256]) { e.msg = "invalid code -- missing end-of-block", i.mode = J; break } if (i.lenbits = 9, Me = { bits: i.lenbits }, Se = s(c, i.lens, 0, i.nlen, i.lencode, 0, i.work, Me), i.lenbits = Me.bits, Se) { e.msg = "invalid literal/lengths set", i.mode = J; break } if (i.distbits = 6, i.distcode = i.distdyn, Me = { bits: i.distbits }, Se = s(h, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, Me), i.distbits = Me.bits, Se) { e.msg = "invalid distances set", i.mode = J; break } if (i.mode = G, t === p) break e; case G: i.mode = H; case H: if (ae >= 6 && oe >= 258) { e.next_out = ne, e.avail_out = oe, e.next_in = ie, e.avail_in = ae, i.hold = se, i.bits = le, o(e, he), ne = e.next_out, te = e.output, oe = e.avail_out, ie = e.next_in, ee = e.input, ae = e.avail_in, se = i.hold, le = i.bits, i.mode === O && (i.back = -1); break } for (i.back = 0; ye = (Ae = i.lencode[se & (1 << i.lenbits) - 1]) >>> 16 & 255, ve = 65535 & Ae, !((ge = Ae >>> 24) <= le);) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } if (ye && 0 == (240 & ye)) { for (_e = ge, be = ye, xe = ve; ye = (Ae = i.lencode[xe + ((se & (1 << _e + be) - 1) >> _e)]) >>> 16 & 255, ve = 65535 & Ae, !(_e + (ge = Ae >>> 24) <= le);) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } se >>>= _e, le -= _e, i.back += _e } if (se >>>= ge, le -= ge, i.back += ge, i.length = ve, 0 === ye) { i.mode = Y; break } if (32 & ye) { i.back = -1, i.mode = O; break } if (64 & ye) { e.msg = "invalid literal/length code", i.mode = J; break } i.extra = 15 & ye, i.mode = V; case V: if (i.extra) { for (Te = i.extra; le < Te;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } i.length += se & (1 << i.extra) - 1, se >>>= i.extra, le -= i.extra, i.back += i.extra } i.was = i.length, i.mode = j; case j: for (; ye = (Ae = i.distcode[se & (1 << i.distbits) - 1]) >>> 16 & 255, ve = 65535 & Ae, !((ge = Ae >>> 24) <= le);) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } if (0 == (240 & ye)) { for (_e = ge, be = ye, xe = ve; ye = (Ae = i.distcode[xe + ((se & (1 << _e + be) - 1) >> _e)]) >>> 16 & 255, ve = 65535 & Ae, !(_e + (ge = Ae >>> 24) <= le);) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } se >>>= _e, le -= _e, i.back += _e } if (se >>>= ge, le -= ge, i.back += ge, 64 & ye) { e.msg = "invalid distance code", i.mode = J; break } i.offset = ve, i.extra = 15 & ye, i.mode = W; case W: if (i.extra) { for (Te = i.extra; le < Te;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } i.offset += se & (1 << i.extra) - 1, se >>>= i.extra, le -= i.extra, i.back += i.extra } if (i.offset > i.dmax) { e.msg = "invalid distance too far back", i.mode = J; break } i.mode = $; case $: if (0 === oe) break e; if (ue = he - oe, i.offset > ue) { if ((ue = i.offset - ue) > i.whave && i.sane) { e.msg = "invalid distance too far back", i.mode = J; break } ue > i.wnext ? (ue -= i.wnext, de = i.wsize - ue) : de = i.wnext - ue, ue > i.length && (ue = i.length), me = i.window } else me = te, de = ne - i.offset, ue = i.length; ue > oe && (ue = oe), oe -= ue, i.length -= ue; do { te[ne++] = me[de++] } while (--ue); 0 === i.length && (i.mode = H); break; case Y: if (0 === oe) break e; te[ne++] = i.length, oe--, i.mode = H; break; case X: if (i.wrap) { for (; le < 32;) { if (0 === ae) break e; ae--, se |= ee[ie++] << le, le += 8 } if (he -= oe, e.total_out += he, i.total += he, he && (e.adler = i.check = i.flags ? a(i.check, te, he, ne - he) : n(i.check, te, he, ne - he)), he = oe, (i.flags ? se : re(se)) !== i.check) { e.msg = "incorrect data check", i.mode = J; break } se = 0, le = 0 } i.mode = Z; case Z: if (i.wrap && i.flags) { for (; le < 32;) { if (0 === ae) break e; ae--, se += ee[ie++] << le, le += 8 } if (se !== (4294967295 & i.total)) { e.msg = "incorrect length check", i.mode = J; break } se = 0, le = 0 } i.mode = q; case q: Se = m; break e; case J: Se = v; break e; case K: return _; case Q: default: return y }return e.next_out = ne, e.avail_out = oe, e.next_in = ie, e.avail_in = ae, i.hold = se, i.bits = le, (i.wsize || he !== e.avail_out && i.mode < J && (i.mode < X || t !== u)) && fe(e, e.output, e.next_out, he - e.avail_out), ce -= e.avail_in, he -= e.avail_out, e.total_in += ce, e.total_out += he, i.total += he, i.wrap && he && (e.adler = i.check = i.flags ? a(i.check, te, he, e.next_out - he) : n(i.check, te, he, e.next_out - he)), e.data_type = i.bits + (i.last ? 64 : 0) + (i.mode === O ? 128 : 0) + (i.mode === G || i.mode === B ? 256 : 0), (0 === ce && 0 === he || t === u) && Se === f && (Se = b), Se } function ge(e) { if (!e || !e.state) return y; var t = e.state; return t.window && (t.window = null), e.state = null, f } function ye(e, t) { var i; return e && e.state ? 0 == (2 & (i = e.state).wrap) ? y : (i.head = t, t.done = !1, f) : y } function ve(e, t) { var i, r = t.length; return e && e.state ? 0 !== (i = e.state).wrap && i.mode !== P ? y : i.mode === P && n(1, t, r, 0) !== i.check ? v : fe(e, t, r, r) ? (i.mode = K, _) : (i.havedict = 1, f) : y } i.inflateReset = oe, i.inflateReset2 = se, i.inflateResetKeep = ae, i.inflateInit = ce, i.inflateInit2 = le, i.inflate = me, i.inflateEnd = ge, i.inflateGetHeader = ye, i.inflateSetDictionary = ve, i.inflateInfo = "pako inflate (from Nodeca project)" }, { "../utils/common": 49, "./adler32": 50, "./crc32": 52, "./inffast": 54, "./inftrees": 56 }], 56: [function (e, t, i) { var r = e("../utils/common"), n = 15, a = 852, o = 592, s = 0, l = 1, c = 2, h = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], u = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], d = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], p = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]; t.exports = function (e, t, i, f, m, g, y, v) { var _, b, x, w, S, M, T, A, E, C = v.bits, L = 0, R = 0, D = 0, P = 0, O = 0, I = 0, k = 0, B = 0, N = 0, F = 0, U = null, z = 0, G = new r.Buf16(n + 1), H = new r.Buf16(n + 1), V = null, j = 0; for (L = 0; L <= n; L++)G[L] = 0; for (R = 0; R < f; R++)G[t[i + R]]++; for (O = C, P = n; P >= 1 && 0 === G[P]; P--); if (O > P && (O = P), 0 === P) return m[g++] = 20971520, m[g++] = 20971520, v.bits = 1, 0; for (D = 1; D < P && 0 === G[D]; D++); for (O < D && (O = D), B = 1, L = 1; L <= n; L++)if (B <<= 1, (B -= G[L]) < 0) return -1; if (B > 0 && (e === s || 1 !== P)) return -1; for (H[1] = 0, L = 1; L < n; L++)H[L + 1] = H[L] + G[L]; for (R = 0; R < f; R++)0 !== t[i + R] && (y[H[t[i + R]]++] = R); if (e === s ? (U = V = y, M = 19) : e === l ? (U = h, z -= 257, V = u, j -= 257, M = 256) : (U = d, V = p, M = -1), F = 0, R = 0, L = D, S = g, I = O, k = 0, x = -1, w = (N = 1 << O) - 1, e === l && N > a || e === c && N > o) return 1; for (; ;) { T = L - k, y[R] < M ? (A = 0, E = y[R]) : y[R] > M ? (A = V[j + y[R]], E = U[z + y[R]]) : (A = 96, E = 0), _ = 1 << L - k, D = b = 1 << I; do { m[S + (F >> k) + (b -= _)] = T << 24 | A << 16 | E | 0 } while (0 !== b); for (_ = 1 << L - 1; F & _;)_ >>= 1; if (0 !== _ ? (F &= _ - 1, F += _) : F = 0, R++, 0 == --G[L]) { if (L === P) break; L = t[i + y[R]] } if (L > O && (F & w) !== x) { for (0 === k && (k = O), S += D, B = 1 << (I = L - k); I + k < P && !((B -= G[I + k]) <= 0);)I++, B <<= 1; if (N += 1 << I, e === l && N > a || e === c && N > o) return 1; m[x = F & w] = O << 24 | I << 16 | S - g | 0 } } return 0 !== F && (m[S + F] = L - k << 24 | 64 << 16 | 0), v.bits = O, 0 } }, { "../utils/common": 49 }], 57: [function (e, t, i) { t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" } }, {}], 58: [function (e, t, i) { var r = e("../utils/common"), n = 4, a = 0, o = 1, s = 2; function l(e) { for (var t = e.length; --t >= 0;)e[t] = 0 } var c = 0, h = 1, u = 2, d = 3, p = 258, f = 29, m = 256, g = m + 1 + f, y = 30, v = 19, _ = 2 * g + 1, b = 15, x = 16, w = 7, S = 256, M = 16, T = 17, A = 18, E = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], C = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], L = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], R = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], D = 512, P = new Array(2 * (g + 2)); l(P); var O = new Array(2 * y); l(O); var I = new Array(D); l(I); var k = new Array(p - d + 1); l(k); var B = new Array(f); l(B); var N, F, U, z = new Array(y); function G(e, t, i, r, n) { this.static_tree = e, this.extra_bits = t, this.extra_base = i, this.elems = r, this.max_length = n, this.has_stree = e && e.length } function H(e, t) { this.dyn_tree = e, this.max_code = 0, this.stat_desc = t } function V(e) { return e < 256 ? I[e] : I[256 + (e >>> 7)] } function j(e, t) { e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255 } function W(e, t, i) { e.bi_valid > x - i ? (e.bi_buf |= t << e.bi_valid & 65535, j(e, e.bi_buf), e.bi_buf = t >> x - e.bi_valid, e.bi_valid += i - x) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += i) } function $(e, t, i) { W(e, i[2 * t], i[2 * t + 1]) } function Y(e, t) { var i = 0; do { i |= 1 & e, e >>>= 1, i <<= 1 } while (--t > 0); return i >>> 1 } function X(e) { 16 === e.bi_valid ? (j(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8) } function Z(e, t) { var i, r, n, a, o, s, l = t.dyn_tree, c = t.max_code, h = t.stat_desc.static_tree, u = t.stat_desc.has_stree, d = t.stat_desc.extra_bits, p = t.stat_desc.extra_base, f = t.stat_desc.max_length, m = 0; for (a = 0; a <= b; a++)e.bl_count[a] = 0; for (l[2 * e.heap[e.heap_max] + 1] = 0, i = e.heap_max + 1; i < _; i++)(a = l[2 * l[2 * (r = e.heap[i]) + 1] + 1] + 1) > f && (a = f, m++), l[2 * r + 1] = a, r > c || (e.bl_count[a]++, o = 0, r >= p && (o = d[r - p]), s = l[2 * r], e.opt_len += s * (a + o), u && (e.static_len += s * (h[2 * r + 1] + o))); if (0 !== m) { do { for (a = f - 1; 0 === e.bl_count[a];)a--; e.bl_count[a]--, e.bl_count[a + 1] += 2, e.bl_count[f]--, m -= 2 } while (m > 0); for (a = f; 0 !== a; a--)for (r = e.bl_count[a]; 0 !== r;)(n = e.heap[--i]) > c || (l[2 * n + 1] !== a && (e.opt_len += (a - l[2 * n + 1]) * l[2 * n], l[2 * n + 1] = a), r--) } } function q(e, t, i) { var r, n, a = new Array(b + 1), o = 0; for (r = 1; r <= b; r++)a[r] = o = o + i[r - 1] << 1; for (n = 0; n <= t; n++) { var s = e[2 * n + 1]; 0 !== s && (e[2 * n] = Y(a[s]++, s)) } } function J() { var e, t, i, r, n, a = new Array(b + 1); for (i = 0, r = 0; r < f - 1; r++)for (B[r] = i, e = 0; e < 1 << E[r]; e++)k[i++] = r; for (k[i - 1] = r, n = 0, r = 0; r < 16; r++)for (z[r] = n, e = 0; e < 1 << C[r]; e++)I[n++] = r; for (n >>= 7; r < y; r++)for (z[r] = n << 7, e = 0; e < 1 << C[r] - 7; e++)I[256 + n++] = r; for (t = 0; t <= b; t++)a[t] = 0; for (e = 0; e <= 143;)P[2 * e + 1] = 8, e++, a[8]++; for (; e <= 255;)P[2 * e + 1] = 9, e++, a[9]++; for (; e <= 279;)P[2 * e + 1] = 7, e++, a[7]++; for (; e <= 287;)P[2 * e + 1] = 8, e++, a[8]++; for (q(P, g + 1, a), e = 0; e < y; e++)O[2 * e + 1] = 5, O[2 * e] = Y(e, 5); N = new G(P, E, m + 1, g, b), F = new G(O, C, 0, y, b), U = new G(new Array(0), L, 0, v, w) } function K(e) { var t; for (t = 0; t < g; t++)e.dyn_ltree[2 * t] = 0; for (t = 0; t < y; t++)e.dyn_dtree[2 * t] = 0; for (t = 0; t < v; t++)e.bl_tree[2 * t] = 0; e.dyn_ltree[2 * S] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0 } function Q(e) { e.bi_valid > 8 ? j(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0 } function ee(e, t, i, n) { Q(e), n && (j(e, i), j(e, ~i)), r.arraySet(e.pending_buf, e.window, t, i, e.pending), e.pending += i } function te(e, t, i, r) { var n = 2 * t, a = 2 * i; return e[n] < e[a] || e[n] === e[a] && r[t] <= r[i] } function ie(e, t, i) { for (var r = e.heap[i], n = i << 1; n <= e.heap_len && (n < e.heap_len && te(t, e.heap[n + 1], e.heap[n], e.depth) && n++, !te(t, r, e.heap[n], e.depth));)e.heap[i] = e.heap[n], i = n, n <<= 1; e.heap[i] = r } function re(e, t, i) { var r, n, a, o, s = 0; if (0 !== e.last_lit) do { r = e.pending_buf[e.d_buf + 2 * s] << 8 | e.pending_buf[e.d_buf + 2 * s + 1], n = e.pending_buf[e.l_buf + s], s++, 0 === r ? $(e, n, t) : ($(e, (a = k[n]) + m + 1, t), 0 !== (o = E[a]) && W(e, n -= B[a], o), $(e, a = V(--r), i), 0 !== (o = C[a]) && W(e, r -= z[a], o)) } while (s < e.last_lit); $(e, S, t) } function ne(e, t) { var i, r, n, a = t.dyn_tree, o = t.stat_desc.static_tree, s = t.stat_desc.has_stree, l = t.stat_desc.elems, c = -1; for (e.heap_len = 0, e.heap_max = _, i = 0; i < l; i++)0 !== a[2 * i] ? (e.heap[++e.heap_len] = c = i, e.depth[i] = 0) : a[2 * i + 1] = 0; for (; e.heap_len < 2;)a[2 * (n = e.heap[++e.heap_len] = c < 2 ? ++c : 0)] = 1, e.depth[n] = 0, e.opt_len--, s && (e.static_len -= o[2 * n + 1]); for (t.max_code = c, i = e.heap_len >> 1; i >= 1; i--)ie(e, a, i); n = l; do { i = e.heap[1], e.heap[1] = e.heap[e.heap_len--], ie(e, a, 1), r = e.heap[1], e.heap[--e.heap_max] = i, e.heap[--e.heap_max] = r, a[2 * n] = a[2 * i] + a[2 * r], e.depth[n] = (e.depth[i] >= e.depth[r] ? e.depth[i] : e.depth[r]) + 1, a[2 * i + 1] = a[2 * r + 1] = n, e.heap[1] = n++, ie(e, a, 1) } while (e.heap_len >= 2); e.heap[--e.heap_max] = e.heap[1], Z(e, t), q(a, c, e.bl_count) } function ae(e, t, i) { var r, n, a = -1, o = t[1], s = 0, l = 7, c = 4; for (0 === o && (l = 138, c = 3), t[2 * (i + 1) + 1] = 65535, r = 0; r <= i; r++)n = o, o = t[2 * (r + 1) + 1], ++s < l && n === o || (s < c ? e.bl_tree[2 * n] += s : 0 !== n ? (n !== a && e.bl_tree[2 * n]++, e.bl_tree[2 * M]++) : s <= 10 ? e.bl_tree[2 * T]++ : e.bl_tree[2 * A]++, s = 0, a = n, 0 === o ? (l = 138, c = 3) : n === o ? (l = 6, c = 3) : (l = 7, c = 4)) } function oe(e, t, i) { var r, n, a = -1, o = t[1], s = 0, l = 7, c = 4; for (0 === o && (l = 138, c = 3), r = 0; r <= i; r++)if (n = o, o = t[2 * (r + 1) + 1], !(++s < l && n === o)) { if (s < c) do { $(e, n, e.bl_tree) } while (0 != --s); else 0 !== n ? (n !== a && ($(e, n, e.bl_tree), s--), $(e, M, e.bl_tree), W(e, s - 3, 2)) : s <= 10 ? ($(e, T, e.bl_tree), W(e, s - 3, 3)) : ($(e, A, e.bl_tree), W(e, s - 11, 7)); s = 0, a = n, 0 === o ? (l = 138, c = 3) : n === o ? (l = 6, c = 3) : (l = 7, c = 4) } } function se(e) { var t; for (ae(e, e.dyn_ltree, e.l_desc.max_code), ae(e, e.dyn_dtree, e.d_desc.max_code), ne(e, e.bl_desc), t = v - 1; t >= 3 && 0 === e.bl_tree[2 * R[t] + 1]; t--); return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t } function le(e, t, i, r) { var n; for (W(e, t - 257, 5), W(e, i - 1, 5), W(e, r - 4, 4), n = 0; n < r; n++)W(e, e.bl_tree[2 * R[n] + 1], 3); oe(e, e.dyn_ltree, t - 1), oe(e, e.dyn_dtree, i - 1) } function ce(e) { var t, i = 4093624447; for (t = 0; t <= 31; t++, i >>>= 1)if (1 & i && 0 !== e.dyn_ltree[2 * t]) return a; if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return o; for (t = 32; t < m; t++)if (0 !== e.dyn_ltree[2 * t]) return o; return a } l(z); var he = !1; function ue(e) { he || (J(), he = !0), e.l_desc = new H(e.dyn_ltree, N), e.d_desc = new H(e.dyn_dtree, F), e.bl_desc = new H(e.bl_tree, U), e.bi_buf = 0, e.bi_valid = 0, K(e) } function de(e, t, i, r) { W(e, (c << 1) + (r ? 1 : 0), 3), ee(e, t, i, !0) } function pe(e) { W(e, h << 1, 3), $(e, S, P), X(e) } function fe(e, t, i, r) { var a, o, l = 0; e.level > 0 ? (e.strm.data_type === s && (e.strm.data_type = ce(e)), ne(e, e.l_desc), ne(e, e.d_desc), l = se(e), a = e.opt_len + 3 + 7 >>> 3, (o = e.static_len + 3 + 7 >>> 3) <= a && (a = o)) : a = o = i + 5, i + 4 <= a && -1 !== t ? de(e, t, i, r) : e.strategy === n || o === a ? (W(e, (h << 1) + (r ? 1 : 0), 3), re(e, P, O)) : (W(e, (u << 1) + (r ? 1 : 0), 3), le(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, l + 1), re(e, e.dyn_ltree, e.dyn_dtree)), K(e), r && Q(e) } function me(e, t, i) { return e.pending_buf[e.d_buf + 2 * e.last_lit] = t >>> 8 & 255, e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t, e.pending_buf[e.l_buf + e.last_lit] = 255 & i, e.last_lit++, 0 === t ? e.dyn_ltree[2 * i]++ : (e.matches++, t--, e.dyn_ltree[2 * (k[i] + m + 1)]++, e.dyn_dtree[2 * V(t)]++), e.last_lit === e.lit_bufsize - 1 } i._tr_init = ue, i._tr_stored_block = de, i._tr_flush_block = fe, i._tr_tally = me, i._tr_align = pe }, { "../utils/common": 49 }], 59: [function (e, t, i) { function r() { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0 } t.exports = r }, {}], 60: [function (e, t, i) { var r, n, a = t.exports = {}; function o() { throw new Error("setTimeout has not been defined") } function s() { throw new Error("clearTimeout has not been defined") } function l(e) { if (r === setTimeout) return setTimeout(e, 0); if ((r === o || !r) && setTimeout) return r = setTimeout, setTimeout(e, 0); try { return r(e, 0) } catch (t) { try { return r.call(null, e, 0) } catch (t) { return r.call(this, e, 0) } } } function c(e) { if (n === clearTimeout) return clearTimeout(e); if ((n === s || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e); try { return n(e) } catch (t) { try { return n.call(null, e) } catch (t) { return n.call(this, e) } } } !function () { try { r = "function" == typeof setTimeout ? setTimeout : o } catch (e) { r = o } try { n = "function" == typeof clearTimeout ? clearTimeout : s } catch (e) { n = s } }(); var h, u = [], d = !1, p = -1; function f() { d && h && (d = !1, h.length ? u = h.concat(u) : p = -1, u.length && m()) } function m() { if (!d) { var e = l(f); d = !0; for (var t = u.length; t;) { for (h = u, u = []; ++p < t;)h && h[p].run(); p = -1, t = u.length } h = null, d = !1, c(e) } } function g(e, t) { this.fun = e, this.array = t } function y() { } a.nextTick = function (e) { var t = new Array(arguments.length - 1); if (arguments.length > 1) for (var i = 1; i < arguments.length; i++)t[i - 1] = arguments[i]; u.push(new g(e, t)), 1 !== u.length || d || l(m) }, g.prototype.run = function () { this.fun.apply(null, this.array) }, a.title = "browser", a.browser = !0, a.env = {}, a.argv = [], a.version = "", a.versions = {}, a.on = y, a.addListener = y, a.once = y, a.off = y, a.removeListener = y, a.removeAllListeners = y, a.emit = y, a.prependListener = y, a.prependOnceListener = y, a.listeners = function (e) { return [] }, a.binding = function (e) { throw new Error("process.binding is not supported") }, a.cwd = function () { return "/" }, a.chdir = function (e) { throw new Error("process.chdir is not supported") }, a.umask = function () { return 0 } }, {}], 61: [function (e, t, i) { t.exports = n; var r = e("events").EventEmitter; function n() { r.call(this) } e("inherits")(n, r), n.Readable = e("readable-stream/lib/_stream_readable.js"), n.Writable = e("readable-stream/lib/_stream_writable.js"), n.Duplex = e("readable-stream/lib/_stream_duplex.js"), n.Transform = e("readable-stream/lib/_stream_transform.js"), n.PassThrough = e("readable-stream/lib/_stream_passthrough.js"), n.finished = e("readable-stream/lib/internal/streams/end-of-stream.js"), n.pipeline = e("readable-stream/lib/internal/streams/pipeline.js"), n.Stream = n, n.prototype.pipe = function (e, t) { var i = this; function n(t) { e.writable && !1 === e.write(t) && i.pause && i.pause() } function a() { i.readable && i.resume && i.resume() } i.on("data", n), e.on("drain", a), e._isStdio || t && !1 === t.end || (i.on("end", s), i.on("close", l)); var o = !1; function s() { o || (o = !0, e.end()) } function l() { o || (o = !0, "function" == typeof e.destroy && e.destroy()) } function c(e) { if (h(), 0 === r.listenerCount(this, "error")) throw e } function h() { i.removeListener("data", n), e.removeListener("drain", a), i.removeListener("end", s), i.removeListener("close", l), i.removeListener("error", c), e.removeListener("error", c), i.removeListener("end", h), i.removeListener("close", h), e.removeListener("close", h) } return i.on("error", c), e.on("error", c), i.on("end", h), i.on("close", h), e.on("close", h), e.emit("pipe", i), e } }, { events: 38, inherits: 45, "readable-stream/lib/_stream_duplex.js": 63, "readable-stream/lib/_stream_passthrough.js": 64, "readable-stream/lib/_stream_readable.js": 65, "readable-stream/lib/_stream_transform.js": 66, "readable-stream/lib/_stream_writable.js": 67, "readable-stream/lib/internal/streams/end-of-stream.js": 71, "readable-stream/lib/internal/streams/pipeline.js": 73 }], 62: [function (e, t, i) { function r(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t } var n = {}; function a(e, t, i) { function a(e, i, r) { return "string" == typeof t ? t : t(e, i, r) } i || (i = Error); var o = function (e) { function t(t, i, r) { return e.call(this, a(t, i, r)) || this } return r(t, e), t }(i); o.prototype.name = i.name, o.prototype.code = e, n[e] = o } function o(e, t) { if (Array.isArray(e)) { var i = e.length; return e = e.map((function (e) { return String(e) })), i > 2 ? "one of ".concat(t, " ").concat(e.slice(0, i - 1).join(", "), ", or ") + e[i - 1] : 2 === i ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]) } return "of ".concat(t, " ").concat(String(e)) } function s(e, t, i) { return e.substr(!i || i < 0 ? 0 : +i, t.length) === t } function l(e, t, i) { return (void 0 === i || i > e.length) && (i = e.length), e.substring(i - t.length, i) === t } function c(e, t, i) { return "number" != typeof i && (i = 0), !(i + t.length > e.length) && -1 !== e.indexOf(t, i) } a("ERR_INVALID_OPT_VALUE", (function (e, t) { return 'The value "' + t + '" is invalid for option "' + e + '"' }), TypeError), a("ERR_INVALID_ARG_TYPE", (function (e, t, i) { var r, n; if ("string" == typeof t && s(t, "not ") ? (r = "must not be", t = t.replace(/^not /, "")) : r = "must be", l(e, " argument")) n = "The ".concat(e, " ").concat(r, " ").concat(o(t, "type")); else { var a = c(e, ".") ? "property" : "argument"; n = 'The "'.concat(e, '" ').concat(a, " ").concat(r, " ").concat(o(t, "type")) } return n += ". Received type ".concat(typeof i) }), TypeError), a("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), a("ERR_METHOD_NOT_IMPLEMENTED", (function (e) { return "The " + e + " method is not implemented" })), a("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), a("ERR_STREAM_DESTROYED", (function (e) { return "Cannot call " + e + " after a stream was destroyed" })), a("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), a("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), a("ERR_STREAM_WRITE_AFTER_END", "write after end"), a("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), a("ERR_UNKNOWN_ENCODING", (function (e) { return "Unknown encoding: " + e }), TypeError), a("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t.exports.codes = n }, {}], 63: [function (e, t, i) { (function (i) { (function () { var r = Object.keys || function (e) { var t = []; for (var i in e) t.push(i); return t }; t.exports = c; var n = e("./_stream_readable"), a = e("./_stream_writable"); e("inherits")(c, n); for (var o = r(a.prototype), s = 0; s < o.length; s++) { var l = o[s]; c.prototype[l] || (c.prototype[l] = a.prototype[l]) } function c(e) { if (!(this instanceof c)) return new c(e); n.call(this, e), a.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", h))) } function h() { this._writableState.ended || i.nextTick(u, this) } function u(e) { e.end() } Object.defineProperty(c.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }), Object.defineProperty(c.prototype, "writableBuffer", { enumerable: !1, get: function () { return this._writableState && this._writableState.getBuffer() } }), Object.defineProperty(c.prototype, "writableLength", { enumerable: !1, get: function () { return this._writableState.length } }), Object.defineProperty(c.prototype, "destroyed", { enumerable: !1, get: function () { return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed }, set: function (e) { void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e) } }) }).call(this) }).call(this, e("_process")) }, { "./_stream_readable": 65, "./_stream_writable": 67, _process: 60, inherits: 45 }], 64: [function (e, t, i) { t.exports = n; var r = e("./_stream_transform"); function n(e) { if (!(this instanceof n)) return new n(e); r.call(this, e) } e("inherits")(n, r), n.prototype._transform = function (e, t, i) { i(null, e) } }, { "./_stream_transform": 66, inherits: 45 }], 65: [function (e, t, i) { (function (i, r) { (function () { var n; t.exports = C, C.ReadableState = E, e("events").EventEmitter; var a = function (e, t) { return e.listeners(t).length }, o = e("./internal/streams/stream"), s = e("buffer").Buffer, l = r.Uint8Array || function () { }; function c(e) { return s.from(e) } function h(e) { return s.isBuffer(e) || e instanceof l } var u, d = e("util"); u = d && d.debuglog ? d.debuglog("stream") : function () { }; var p, f, m, g = e("./internal/streams/buffer_list"), y = e("./internal/streams/destroy"), v = e("./internal/streams/state").getHighWaterMark, _ = e("../errors").codes, b = _.ERR_INVALID_ARG_TYPE, x = _.ERR_STREAM_PUSH_AFTER_EOF, w = _.ERR_METHOD_NOT_IMPLEMENTED, S = _.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; e("inherits")(C, o); var M = y.errorOrDestroy, T = ["error", "close", "destroy", "pause", "resume"]; function A(e, t, i) { if ("function" == typeof e.prependListener) return e.prependListener(t, i); e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(i) : e._events[t] = [i, e._events[t]] : e.on(t, i) } function E(t, i, r) { n = n || e("./_stream_duplex"), t = t || {}, "boolean" != typeof r && (r = i instanceof n), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = v(this, t, "readableHighWaterMark", r), this.buffer = new g, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (p || (p = e("string_decoder/").StringDecoder), this.decoder = new p(t.encoding), this.encoding = t.encoding) } function C(t) { if (n = n || e("./_stream_duplex"), !(this instanceof C)) return new C(t); var i = this instanceof n; this._readableState = new E(t, this, i), this.readable = !0, t && ("function" == typeof t.read && (this._read = t.read), "function" == typeof t.destroy && (this._destroy = t.destroy)), o.call(this) } function L(e, t, i, r, n) { u("readableAddChunk", t); var a, o = e._readableState; if (null === t) o.reading = !1, k(e, o); else if (n || (a = D(o, t)), a) M(e, a); else if (o.objectMode || t && t.length > 0) if ("string" == typeof t || o.objectMode || Object.getPrototypeOf(t) === s.prototype || (t = c(t)), r) o.endEmitted ? M(e, new S) : R(e, o, t, !0); else if (o.ended) M(e, new x); else { if (o.destroyed) return !1; o.reading = !1, o.decoder && !i ? (t = o.decoder.write(t), o.objectMode || 0 !== t.length ? R(e, o, t, !1) : F(e, o)) : R(e, o, t, !1) } else r || (o.reading = !1, F(e, o)); return !o.ended && (o.length < o.highWaterMark || 0 === o.length) } function R(e, t, i, r) { t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", i)) : (t.length += t.objectMode ? 1 : i.length, r ? t.buffer.unshift(i) : t.buffer.push(i), t.needReadable && B(e)), F(e, t) } function D(e, t) { var i; return h(t) || "string" == typeof t || void 0 === t || e.objectMode || (i = new b("chunk", ["string", "Buffer", "Uint8Array"], t)), i } Object.defineProperty(C.prototype, "destroyed", { enumerable: !1, get: function () { return void 0 !== this._readableState && this._readableState.destroyed }, set: function (e) { this._readableState && (this._readableState.destroyed = e) } }), C.prototype.destroy = y.destroy, C.prototype._undestroy = y.undestroy, C.prototype._destroy = function (e, t) { t(e) }, C.prototype.push = function (e, t) { var i, r = this._readableState; return r.objectMode ? i = !0 : "string" == typeof e && ((t = t || r.defaultEncoding) !== r.encoding && (e = s.from(e, t), t = ""), i = !0), L(this, e, t, !1, i) }, C.prototype.unshift = function (e) { return L(this, e, null, !0, !1) }, C.prototype.isPaused = function () { return !1 === this._readableState.flowing }, C.prototype.setEncoding = function (t) { p || (p = e("string_decoder/").StringDecoder); var i = new p(t); this._readableState.decoder = i, this._readableState.encoding = this._readableState.decoder.encoding; for (var r = this._readableState.buffer.head, n = ""; null !== r;)n += i.write(r.data), r = r.next; return this._readableState.buffer.clear(), "" !== n && this._readableState.buffer.push(n), this._readableState.length = n.length, this }; var P = 1073741824; function O(e) { return e >= P ? e = P : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e } function I(e, t) { return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = O(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0)) } function k(e, t) { if (u("onEofChunk"), !t.ended) { if (t.decoder) { var i = t.decoder.end(); i && i.length && (t.buffer.push(i), t.length += t.objectMode ? 1 : i.length) } t.ended = !0, t.sync ? B(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, N(e))) } } function B(e) { var t = e._readableState; u("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (u("emitReadable", t.flowing), t.emittedReadable = !0, i.nextTick(N, e)) } function N(e) { var t = e._readableState; u("emitReadable_", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, W(e) } function F(e, t) { t.readingMore || (t.readingMore = !0, i.nextTick(U, e, t)) } function U(e, t) { for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);) { var i = t.length; if (u("maybeReadMore read 0"), e.read(0), i === t.length) break } t.readingMore = !1 } function z(e) { return function () { var t = e._readableState; u("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && a(e, "data") && (t.flowing = !0, W(e)) } } function G(e) { var t = e._readableState; t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume() } function H(e) { u("readable nexttick read 0"), e.read(0) } function V(e, t) { t.resumeScheduled || (t.resumeScheduled = !0, i.nextTick(j, e, t)) } function j(e, t) { u("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), W(e), t.flowing && !t.reading && e.read(0) } function W(e) { var t = e._readableState; for (u("flow", t.flowing); t.flowing && null !== e.read();); } function $(e, t) { return 0 === t.length ? null : (t.objectMode ? i = t.buffer.shift() : !e || e >= t.length ? (i = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : i = t.buffer.consume(e, t.decoder), i); var i } function Y(e) { var t = e._readableState; u("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, i.nextTick(X, t, e)) } function X(e, t) { if (u("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) { var i = t._writableState; (!i || i.autoDestroy && i.finished) && t.destroy() } } function Z(e, t) { for (var i = 0, r = e.length; i < r; i++)if (e[i] === t) return i; return -1 } C.prototype.read = function (e) { u("read", e), e = parseInt(e, 10); var t = this._readableState, i = e; if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return u("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? Y(this) : B(this), null; if (0 === (e = I(e, t)) && t.ended) return 0 === t.length && Y(this), null; var r, n = t.needReadable; return u("need readable", n), (0 === t.length || t.length - e < t.highWaterMark) && u("length less than watermark", n = !0), t.ended || t.reading ? u("reading or ended", n = !1) : n && (u("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = I(i, t))), null === (r = e > 0 ? $(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), i !== e && t.ended && Y(this)), null !== r && this.emit("data", r), r }, C.prototype._read = function (e) { M(this, new w("_read()")) }, C.prototype.pipe = function (e, t) { var r = this, n = this._readableState; switch (n.pipesCount) { case 0: n.pipes = e; break; case 1: n.pipes = [n.pipes, e]; break; default: n.pipes.push(e) }n.pipesCount += 1, u("pipe count=%d opts=%j", n.pipesCount, t); var o = t && !1 === t.end || e === i.stdout || e === i.stderr ? y : l; function s(e, t) { u("onunpipe"), e === r && t && !1 === t.hasUnpiped && (t.hasUnpiped = !0, d()) } function l() { u("onend"), e.end() } n.endEmitted ? i.nextTick(o) : r.once("end", o), e.on("unpipe", s); var c = z(r); e.on("drain", c); var h = !1; function d() { u("cleanup"), e.removeListener("close", m), e.removeListener("finish", g), e.removeListener("drain", c), e.removeListener("error", f), e.removeListener("unpipe", s), r.removeListener("end", l), r.removeListener("end", y), r.removeListener("data", p), h = !0, !n.awaitDrain || e._writableState && !e._writableState.needDrain || c() } function p(t) { u("ondata"); var i = e.write(t); u("dest.write", i), !1 === i && ((1 === n.pipesCount && n.pipes === e || n.pipesCount > 1 && -1 !== Z(n.pipes, e)) && !h && (u("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause()) } function f(t) { u("onerror", t), y(), e.removeListener("error", f), 0 === a(e, "error") && M(e, t) } function m() { e.removeListener("finish", g), y() } function g() { u("onfinish"), e.removeListener("close", m), y() } function y() { u("unpipe"), r.unpipe(e) } return r.on("data", p), A(e, "error", f), e.once("close", m), e.once("finish", g), e.emit("pipe", r), n.flowing || (u("pipe resume"), r.resume()), e }, C.prototype.unpipe = function (e) { var t = this._readableState, i = { hasUnpiped: !1 }; if (0 === t.pipesCount) return this; if (1 === t.pipesCount) return e && e !== t.pipes || (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, i)), this; if (!e) { var r = t.pipes, n = t.pipesCount; t.pipes = null, t.pipesCount = 0, t.flowing = !1; for (var a = 0; a < n; a++)r[a].emit("unpipe", this, { hasUnpiped: !1 }); return this } var o = Z(t.pipes, e); return -1 === o || (t.pipes.splice(o, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, i)), this }, C.prototype.on = function (e, t) { var r = o.prototype.on.call(this, e, t), n = this._readableState; return "data" === e ? (n.readableListening = this.listenerCount("readable") > 0, !1 !== n.flowing && this.resume()) : "readable" === e && (n.endEmitted || n.readableListening || (n.readableListening = n.needReadable = !0, n.flowing = !1, n.emittedReadable = !1, u("on readable", n.length, n.reading), n.length ? B(this) : n.reading || i.nextTick(H, this))), r }, C.prototype.addListener = C.prototype.on, C.prototype.removeListener = function (e, t) { var r = o.prototype.removeListener.call(this, e, t); return "readable" === e && i.nextTick(G, this), r }, C.prototype.removeAllListeners = function (e) { var t = o.prototype.removeAllListeners.apply(this, arguments); return "readable" !== e && void 0 !== e || i.nextTick(G, this), t }, C.prototype.resume = function () { var e = this._readableState; return e.flowing || (u("resume"), e.flowing = !e.readableListening, V(this, e)), e.paused = !1, this }, C.prototype.pause = function () { return u("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this }, C.prototype.wrap = function (e) { var t = this, i = this._readableState, r = !1; for (var n in e.on("end", (function () { if (u("wrapped end"), i.decoder && !i.ended) { var e = i.decoder.end(); e && e.length && t.push(e) } t.push(null) })), e.on("data", (function (n) { u("wrapped data"), i.decoder && (n = i.decoder.write(n)), i.objectMode && null == n || (i.objectMode || n && n.length) && (t.push(n) || (r = !0, e.pause())) })), e) void 0 === this[n] && "function" == typeof e[n] && (this[n] = function (t) { return function () { return e[t].apply(e, arguments) } }(n)); for (var a = 0; a < T.length; a++)e.on(T[a], this.emit.bind(this, T[a])); return this._read = function (t) { u("wrapped _read", t), r && (r = !1, e.resume()) }, this }, "function" == typeof Symbol && (C.prototype[Symbol.asyncIterator] = function () { return void 0 === f && (f = e("./internal/streams/async_iterator")), f(this) }), Object.defineProperty(C.prototype, "readableHighWaterMark", { enumerable: !1, get: function () { return this._readableState.highWaterMark } }), Object.defineProperty(C.prototype, "readableBuffer", { enumerable: !1, get: function () { return this._readableState && this._readableState.buffer } }), Object.defineProperty(C.prototype, "readableFlowing", { enumerable: !1, get: function () { return this._readableState.flowing }, set: function (e) { this._readableState && (this._readableState.flowing = e) } }), C._fromList = $, Object.defineProperty(C.prototype, "readableLength", { enumerable: !1, get: function () { return this._readableState.length } }), "function" == typeof Symbol && (C.from = function (t, i) { return void 0 === m && (m = e("./internal/streams/from")), m(C, t, i) }) }).call(this) }).call(this, e("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "../errors": 62, "./_stream_duplex": 63, "./internal/streams/async_iterator": 68, "./internal/streams/buffer_list": 69, "./internal/streams/destroy": 70, "./internal/streams/from": 72, "./internal/streams/state": 74, "./internal/streams/stream": 75, _process: 60, buffer: 33, events: 38, inherits: 45, "string_decoder/": 76, util: 30 }], 66: [function (e, t, i) { t.exports = h; var r = e("../errors").codes, n = r.ERR_METHOD_NOT_IMPLEMENTED, a = r.ERR_MULTIPLE_CALLBACK, o = r.ERR_TRANSFORM_ALREADY_TRANSFORMING, s = r.ERR_TRANSFORM_WITH_LENGTH_0, l = e("./_stream_duplex"); function c(e, t) { var i = this._transformState; i.transforming = !1; var r = i.writecb; if (null === r) return this.emit("error", new a); i.writechunk = null, i.writecb = null, null != t && this.push(t), r(e); var n = this._readableState; n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark) } function h(e) { if (!(this instanceof h)) return new h(e); l.call(this, e), this._transformState = { afterTransform: c.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && ("function" == typeof e.transform && (this._transform = e.transform), "function" == typeof e.flush && (this._flush = e.flush)), this.on("prefinish", u) } function u() { var e = this; "function" != typeof this._flush || this._readableState.destroyed ? d(this, null, null) : this._flush((function (t, i) { d(e, t, i) })) } function d(e, t, i) { if (t) return e.emit("error", t); if (null != i && e.push(i), e._writableState.length) throw new s; if (e._transformState.transforming) throw new o; return e.push(null) } e("inherits")(h, l), h.prototype.push = function (e, t) { return this._transformState.needTransform = !1, l.prototype.push.call(this, e, t) }, h.prototype._transform = function (e, t, i) { i(new n("_transform()")) }, h.prototype._write = function (e, t, i) { var r = this._transformState; if (r.writecb = i, r.writechunk = e, r.writeencoding = t, !r.transforming) { var n = this._readableState; (r.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark) } }, h.prototype._read = function (e) { var t = this._transformState; null === t.writechunk || t.transforming ? t.needTransform = !0 : (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) }, h.prototype._destroy = function (e, t) { l.prototype._destroy.call(this, e, (function (e) { t(e) })) } }, { "../errors": 62, "./_stream_duplex": 63, inherits: 45 }], 67: [function (e, t, i) { (function (i, r) { (function () { function n(e) { var t = this; this.next = null, this.entry = null, this.finish = function () { j(t, e) } } var a; t.exports = E, E.WritableState = A; var o = { deprecate: e("util-deprecate") }, s = e("./internal/streams/stream"), l = e("buffer").Buffer, c = r.Uint8Array || function () { }; function h(e) { return l.from(e) } function u(e) { return l.isBuffer(e) || e instanceof c } var d, p = e("./internal/streams/destroy"), f = e("./internal/streams/state").getHighWaterMark, m = e("../errors").codes, g = m.ERR_INVALID_ARG_TYPE, y = m.ERR_METHOD_NOT_IMPLEMENTED, v = m.ERR_MULTIPLE_CALLBACK, _ = m.ERR_STREAM_CANNOT_PIPE, b = m.ERR_STREAM_DESTROYED, x = m.ERR_STREAM_NULL_VALUES, w = m.ERR_STREAM_WRITE_AFTER_END, S = m.ERR_UNKNOWN_ENCODING, M = p.errorOrDestroy; function T() { } function A(t, i, r) { a = a || e("./_stream_duplex"), t = t || {}, "boolean" != typeof r && (r = i instanceof a), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = f(this, t, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1; var o = !1 === t.decodeStrings; this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (e) { k(i, e) }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n(this) } function E(t) { var i = this instanceof (a = a || e("./_stream_duplex")); if (!i && !d.call(E, this)) return new E(t); this._writableState = new A(t, this, i), this.writable = !0, t && ("function" == typeof t.write && (this._write = t.write), "function" == typeof t.writev && (this._writev = t.writev), "function" == typeof t.destroy && (this._destroy = t.destroy), "function" == typeof t.final && (this._final = t.final)), s.call(this) } function C(e, t) { var r = new w; M(e, r), i.nextTick(t, r) } function L(e, t, r, n) { var a; return null === r ? a = new x : "string" == typeof r || t.objectMode || (a = new g("chunk", ["string", "Buffer"], r)), !a || (M(e, a), i.nextTick(n, a), !1) } function R(e, t, i) { return e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = l.from(t, i)), t } function D(e, t, i, r, n, a) { if (!i) { var o = R(t, r, n); r !== o && (i = !0, n = "buffer", r = o) } var s = t.objectMode ? 1 : r.length; t.length += s; var l = t.length < t.highWaterMark; if (l || (t.needDrain = !0), t.writing || t.corked) { var c = t.lastBufferedRequest; t.lastBufferedRequest = { chunk: r, encoding: n, isBuf: i, callback: a, next: null }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1 } else P(e, t, !1, s, r, n, a); return l } function P(e, t, i, r, n, a, o) { t.writelen = r, t.writecb = o, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new b("write")) : i ? e._writev(n, t.onwrite) : e._write(n, a, t.onwrite), t.sync = !1 } function O(e, t, r, n, a) { --t.pendingcb, r ? (i.nextTick(a, n), i.nextTick(H, e, t), e._writableState.errorEmitted = !0, M(e, n)) : (a(n), e._writableState.errorEmitted = !0, M(e, n), H(e, t)) } function I(e) { e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0 } function k(e, t) { var r = e._writableState, n = r.sync, a = r.writecb; if ("function" != typeof a) throw new v; if (I(r), t) O(e, r, n, t, a); else { var o = U(r) || e.destroyed; o || r.corked || r.bufferProcessing || !r.bufferedRequest || F(e, r), n ? i.nextTick(B, e, r, o, a) : B(e, r, o, a) } } function B(e, t, i, r) { i || N(e, t), t.pendingcb--, r(), H(e, t) } function N(e, t) { 0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain")) } function F(e, t) { t.bufferProcessing = !0; var i = t.bufferedRequest; if (e._writev && i && i.next) { var r = t.bufferedRequestCount, a = new Array(r), o = t.corkedRequestsFree; o.entry = i; for (var s = 0, l = !0; i;)a[s] = i, i.isBuf || (l = !1), i = i.next, s += 1; a.allBuffers = l, P(e, t, !0, t.length, a, "", o.finish), t.pendingcb++, t.lastBufferedRequest = null, o.next ? (t.corkedRequestsFree = o.next, o.next = null) : t.corkedRequestsFree = new n(t), t.bufferedRequestCount = 0 } else { for (; i;) { var c = i.chunk, h = i.encoding, u = i.callback; if (P(e, t, !1, t.objectMode ? 1 : c.length, c, h, u), i = i.next, t.bufferedRequestCount--, t.writing) break } null === i && (t.lastBufferedRequest = null) } t.bufferedRequest = i, t.bufferProcessing = !1 } function U(e) { return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing } function z(e, t) { e._final((function (i) { t.pendingcb--, i && M(e, i), t.prefinished = !0, e.emit("prefinish"), H(e, t) })) } function G(e, t) { t.prefinished || t.finalCalled || ("function" != typeof e._final || t.destroyed ? (t.prefinished = !0, e.emit("prefinish")) : (t.pendingcb++, t.finalCalled = !0, i.nextTick(z, e, t))) } function H(e, t) { var i = U(t); if (i && (G(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"), t.autoDestroy))) { var r = e._readableState; (!r || r.autoDestroy && r.endEmitted) && e.destroy() } return i } function V(e, t, r) { t.ending = !0, H(e, t), r && (t.finished ? i.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1 } function j(e, t, i) { var r = e.entry; for (e.entry = null; r;) { var n = r.callback; t.pendingcb--, n(i), r = r.next } t.corkedRequestsFree.next = e } e("inherits")(E, s), A.prototype.getBuffer = function () { for (var e = this.bufferedRequest, t = []; e;)t.push(e), e = e.next; return t }, function () { try { Object.defineProperty(A.prototype, "buffer", { get: o.deprecate((function () { return this.getBuffer() }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") }) } catch (e) { } }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (d = Function.prototype[Symbol.hasInstance], Object.defineProperty(E, Symbol.hasInstance, { value: function (e) { return !!d.call(this, e) || this === E && e && e._writableState instanceof A } })) : d = function (e) { return e instanceof this }, E.prototype.pipe = function () { M(this, new _) }, E.prototype.write = function (e, t, i) { var r = this._writableState, n = !1, a = !r.objectMode && u(e); return a && !l.isBuffer(e) && (e = h(e)), "function" == typeof t && (i = t, t = null), a ? t = "buffer" : t || (t = r.defaultEncoding), "function" != typeof i && (i = T), r.ending ? C(this, i) : (a || L(this, r, e, i)) && (r.pendingcb++, n = D(this, r, a, e, t, i)), n }, E.prototype.cork = function () { this._writableState.corked++ }, E.prototype.uncork = function () { var e = this._writableState; e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || F(this, e)) }, E.prototype.setDefaultEncoding = function (e) { if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new S(e); return this._writableState.defaultEncoding = e, this }, Object.defineProperty(E.prototype, "writableBuffer", { enumerable: !1, get: function () { return this._writableState && this._writableState.getBuffer() } }), Object.defineProperty(E.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }), E.prototype._write = function (e, t, i) { i(new y("_write()")) }, E.prototype._writev = null, E.prototype.end = function (e, t, i) { var r = this._writableState; return "function" == typeof e ? (i = e, e = null, t = null) : "function" == typeof t && (i = t, t = null), null != e && this.write(e, t), r.corked && (r.corked = 1, this.uncork()), r.ending || V(this, r, i), this }, Object.defineProperty(E.prototype, "writableLength", { enumerable: !1, get: function () { return this._writableState.length } }), Object.defineProperty(E.prototype, "destroyed", { enumerable: !1, get: function () { return void 0 !== this._writableState && this._writableState.destroyed }, set: function (e) { this._writableState && (this._writableState.destroyed = e) } }), E.prototype.destroy = p.destroy, E.prototype._undestroy = p.undestroy, E.prototype._destroy = function (e, t) { t(e) } }).call(this) }).call(this, e("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "../errors": 62, "./_stream_duplex": 63, "./internal/streams/destroy": 70, "./internal/streams/state": 74, "./internal/streams/stream": 75, _process: 60, buffer: 33, inherits: 45, "util-deprecate": 78 }], 68: [function (e, t, i) { (function (i) { (function () { var r; function n(e, t, i) { return t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } var a = e("./end-of-stream"), o = Symbol("lastResolve"), s = Symbol("lastReject"), l = Symbol("error"), c = Symbol("ended"), h = Symbol("lastPromise"), u = Symbol("handlePromise"), d = Symbol("stream"); function p(e, t) { return { value: e, done: t } } function f(e) { var t = e[o]; if (null !== t) { var i = e[d].read(); null !== i && (e[h] = null, e[o] = null, e[s] = null, t(p(i, !1))) } } function m(e) { i.nextTick(f, e) } function g(e, t) { return function (i, r) { e.then((function () { t[c] ? i(p(void 0, !0)) : t[u](i, r) }), r) } } var y = Object.getPrototypeOf((function () { })), v = Object.setPrototypeOf((n(r = { get stream() { return this[d] }, next: function () { var e = this, t = this[l]; if (null !== t) return Promise.reject(t); if (this[c]) return Promise.resolve(p(void 0, !0)); if (this[d].destroyed) return new Promise((function (t, r) { i.nextTick((function () { e[l] ? r(e[l]) : t(p(void 0, !0)) })) })); var r, n = this[h]; if (n) r = new Promise(g(n, this)); else { var a = this[d].read(); if (null !== a) return Promise.resolve(p(a, !1)); r = new Promise(this[u]) } return this[h] = r, r } }, Symbol.asyncIterator, (function () { return this })), n(r, "return", (function () { var e = this; return new Promise((function (t, i) { e[d].destroy(null, (function (e) { e ? i(e) : t(p(void 0, !0)) })) })) })), r), y), _ = function (e) { var t, i = Object.create(v, (n(t = {}, d, { value: e, writable: !0 }), n(t, o, { value: null, writable: !0 }), n(t, s, { value: null, writable: !0 }), n(t, l, { value: null, writable: !0 }), n(t, c, { value: e._readableState.endEmitted, writable: !0 }), n(t, u, { value: function (e, t) { var r = i[d].read(); r ? (i[h] = null, i[o] = null, i[s] = null, e(p(r, !1))) : (i[o] = e, i[s] = t) }, writable: !0 }), t)); return i[h] = null, a(e, (function (e) { if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) { var t = i[s]; return null !== t && (i[h] = null, i[o] = null, i[s] = null, t(e)), void (i[l] = e) } var r = i[o]; null !== r && (i[h] = null, i[o] = null, i[s] = null, r(p(void 0, !0))), i[c] = !0 })), e.on("readable", m.bind(null, i)), i }; t.exports = _ }).call(this) }).call(this, e("_process")) }, { "./end-of-stream": 71, _process: 60 }], 69: [function (e, t, i) { function r(e, t) { var i = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), i.push.apply(i, r) } return i } function n(e) { for (var t = 1; t < arguments.length; t++) { var i = null != arguments[t] ? arguments[t] : {}; t % 2 ? r(Object(i), !0).forEach((function (t) { a(e, t, i[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : r(Object(i)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t)) })) } return e } function a(e, t, i) { return t in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } function o(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function s(e, t) { for (var i = 0; i < t.length; i++) { var r = t[i]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } function l(e, t, i) { return t && s(e.prototype, t), i && s(e, i), e } var c = e("buffer").Buffer, h = e("util").inspect, u = h && h.custom || "inspect"; function d(e, t, i) { c.prototype.copy.call(e, t, i) } t.exports = function () { function e() { o(this, e), this.head = null, this.tail = null, this.length = 0 } return l(e, [{ key: "push", value: function (e) { var t = { data: e, next: null }; this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length } }, { key: "unshift", value: function (e) { var t = { data: e, next: this.head }; 0 === this.length && (this.tail = t), this.head = t, ++this.length } }, { key: "shift", value: function () { if (0 !== this.length) { var e = this.head.data; return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e } } }, { key: "clear", value: function () { this.head = this.tail = null, this.length = 0 } }, { key: "join", value: function (e) { if (0 === this.length) return ""; for (var t = this.head, i = "" + t.data; t = t.next;)i += e + t.data; return i } }, { key: "concat", value: function (e) { if (0 === this.length) return c.alloc(0); for (var t = c.allocUnsafe(e >>> 0), i = this.head, r = 0; i;)d(i.data, t, r), r += i.data.length, i = i.next; return t } }, { key: "consume", value: function (e, t) { var i; return e < this.head.data.length ? (i = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : i = e === this.head.data.length ? this.shift() : t ? this._getString(e) : this._getBuffer(e), i } }, { key: "first", value: function () { return this.head.data } }, { key: "_getString", value: function (e) { var t = this.head, i = 1, r = t.data; for (e -= r.length; t = t.next;) { var n = t.data, a = e > n.length ? n.length : e; if (a === n.length ? r += n : r += n.slice(0, e), 0 == (e -= a)) { a === n.length ? (++i, t.next ? this.head = t.next : this.head = this.tail = null) : (this.head = t, t.data = n.slice(a)); break } ++i } return this.length -= i, r } }, { key: "_getBuffer", value: function (e) { var t = c.allocUnsafe(e), i = this.head, r = 1; for (i.data.copy(t), e -= i.data.length; i = i.next;) { var n = i.data, a = e > n.length ? n.length : e; if (n.copy(t, t.length - e, 0, a), 0 == (e -= a)) { a === n.length ? (++r, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = n.slice(a)); break } ++r } return this.length -= r, t } }, { key: u, value: function (e, t) { return h(this, n({}, t, { depth: 0, customInspect: !1 })) } }]), e }() }, { buffer: 33, util: 30 }], 70: [function (e, t, i) { (function (e) { (function () { function i(t, i) { var a = this, s = this._readableState && this._readableState.destroyed, l = this._writableState && this._writableState.destroyed; return s || l ? (i ? i(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(o, this, t)) : e.nextTick(o, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, (function (t) { !i && t ? a._writableState ? a._writableState.errorEmitted ? e.nextTick(n, a) : (a._writableState.errorEmitted = !0, e.nextTick(r, a, t)) : e.nextTick(r, a, t) : i ? (e.nextTick(n, a), i(t)) : e.nextTick(n, a) })), this) } function r(e, t) { o(e, t), n(e) } function n(e) { e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close") } function a() { this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1) } function o(e, t) { e.emit("error", t) } function s(e, t) { var i = e._readableState, r = e._writableState; i && i.autoDestroy || r && r.autoDestroy ? e.destroy(t) : e.emit("error", t) } t.exports = { destroy: i, undestroy: a, errorOrDestroy: s } }).call(this) }).call(this, e("_process")) }, { _process: 60 }], 71: [function (e, t, i) { var r = e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE; function n(e) { var t = !1; return function () { if (!t) { t = !0; for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++)r[n] = arguments[n]; e.apply(this, r) } } } function a() { } function o(e) { return e.setHeader && "function" == typeof e.abort } function s(e, t, i) { if ("function" == typeof t) return s(e, null, t); t || (t = {}), i = n(i || a); var l = t.readable || !1 !== t.readable && e.readable, c = t.writable || !1 !== t.writable && e.writable, h = function () { e.writable || d() }, u = e._writableState && e._writableState.finished, d = function () { c = !1, u = !0, l || i.call(e) }, p = e._readableState && e._readableState.endEmitted, f = function () { l = !1, p = !0, c || i.call(e) }, m = function (t) { i.call(e, t) }, g = function () { var t; return l && !p ? (e._readableState && e._readableState.ended || (t = new r), i.call(e, t)) : c && !u ? (e._writableState && e._writableState.ended || (t = new r), i.call(e, t)) : void 0 }, y = function () { e.req.on("finish", d) }; return o(e) ? (e.on("complete", d), e.on("abort", g), e.req ? y() : e.on("request", y)) : c && !e._writableState && (e.on("end", h), e.on("close", h)), e.on("end", f), e.on("finish", d), !1 !== t.error && e.on("error", m), e.on("close", g), function () { e.removeListener("complete", d), e.removeListener("abort", g), e.removeListener("request", y), e.req && e.req.removeListener("finish", d), e.removeListener("end", h), e.removeListener("close", h), e.removeListener("finish", d), e.removeListener("end", f), e.removeListener("error", m), e.removeListener("close", g) } } t.exports = s }, { "../../../errors": 62 }], 72: [function (e, t, i) { t.exports = function () { throw new Error("Readable.from is not available in the browser") } }, {}], 73: [function (e, t, i) { var r; function n(e) { var t = !1; return function () { t || (t = !0, e.apply(void 0, arguments)) } } var a = e("../../../errors").codes, o = a.ERR_MISSING_ARGS, s = a.ERR_STREAM_DESTROYED; function l(e) { if (e) throw e } function c(e) { return e.setHeader && "function" == typeof e.abort } function h(t, i, a, o) { o = n(o); var l = !1; t.on("close", (function () { l = !0 })), void 0 === r && (r = e("./end-of-stream")), r(t, { readable: i, writable: a }, (function (e) { if (e) return o(e); l = !0, o() })); var h = !1; return function (e) { if (!l && !h) return h = !0, c(t) ? t.abort() : "function" == typeof t.destroy ? t.destroy() : void o(e || new s("pipe")) } } function u(e) { e() } function d(e, t) { return e.pipe(t) } function p(e) { return e.length ? "function" != typeof e[e.length - 1] ? l : e.pop() : l } function f() { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; var r, n = p(t); if (Array.isArray(t[0]) && (t = t[0]), t.length < 2) throw new o("streams"); var a = t.map((function (e, i) { var o = i < t.length - 1; return h(e, o, i > 0, (function (e) { r || (r = e), e && a.forEach(u), o || (a.forEach(u), n(r)) })) })); return t.reduce(d) } t.exports = f }, { "../../../errors": 62, "./end-of-stream": 71 }], 74: [function (e, t, i) { var r = e("../../../errors").codes.ERR_INVALID_OPT_VALUE; function n(e, t, i) { return null != e.highWaterMark ? e.highWaterMark : t ? e[i] : null } function a(e, t, i, a) { var o = n(t, a, i); if (null != o) { if (!isFinite(o) || Math.floor(o) !== o || o < 0) throw new r(a ? i : "highWaterMark", o); return Math.floor(o) } return e.objectMode ? 16 : 16384 } t.exports = { getHighWaterMark: a } }, { "../../../errors": 62 }], 75: [function (e, t, i) { t.exports = e("events").EventEmitter }, { events: 38 }], 76: [function (e, t, i) { var r = e("safe-buffer").Buffer, n = r.isEncoding || function (e) { switch ((e = "" + e) && e.toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": case "raw": return !0; default: return !1 } }; function a(e) { if (!e) return "utf8"; for (var t; ;)switch (e) { case "utf8": case "utf-8": return "utf8"; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return "utf16le"; case "latin1": case "binary": return "latin1"; case "base64": case "ascii": case "hex": return e; default: if (t) return; e = ("" + e).toLowerCase(), t = !0 } } function o(e) { var t = a(e); if ("string" != typeof t && (r.isEncoding === n || !n(e))) throw new Error("Unknown encoding: " + e); return t || e } function s(e) { var t; switch (this.encoding = o(e), this.encoding) { case "utf16le": this.text = f, this.end = m, t = 4; break; case "utf8": this.fillLast = u, t = 4; break; case "base64": this.text = g, this.end = y, t = 3; break; default: return this.write = v, void (this.end = _) }this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r.allocUnsafe(t) } function l(e) { return e <= 127 ? 0 : e >> 5 == 6 ? 2 : e >> 4 == 14 ? 3 : e >> 3 == 30 ? 4 : e >> 6 == 2 ? -1 : -2 } function c(e, t, i) { var r = t.length - 1; if (r < i) return 0; var n = l(t[r]); return n >= 0 ? (n > 0 && (e.lastNeed = n - 1), n) : --r < i || -2 === n ? 0 : (n = l(t[r])) >= 0 ? (n > 0 && (e.lastNeed = n - 2), n) : --r < i || -2 === n ? 0 : (n = l(t[r])) >= 0 ? (n > 0 && (2 === n ? n = 0 : e.lastNeed = n - 3), n) : 0 } function h(e, t, i) { if (128 != (192 & t[0])) return e.lastNeed = 0, "�"; if (e.lastNeed > 1 && t.length > 1) { if (128 != (192 & t[1])) return e.lastNeed = 1, "�"; if (e.lastNeed > 2 && t.length > 2 && 128 != (192 & t[2])) return e.lastNeed = 2, "�" } } function u(e) { var t = this.lastTotal - this.lastNeed, i = h(this, e); return void 0 !== i ? i : this.lastNeed <= e.length ? (e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e.copy(this.lastChar, t, 0, e.length), void (this.lastNeed -= e.length)) } function d(e, t) { var i = c(this, e, t); if (!this.lastNeed) return e.toString("utf8", t); this.lastTotal = i; var r = e.length - (i - this.lastNeed); return e.copy(this.lastChar, 0, r), e.toString("utf8", t, r) } function p(e) { var t = e && e.length ? this.write(e) : ""; return this.lastNeed ? t + "�" : t } function f(e, t) { if ((e.length - t) % 2 == 0) { var i = e.toString("utf16le", t); if (i) { var r = i.charCodeAt(i.length - 1); if (r >= 55296 && r <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], i.slice(0, -1) } return i } return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1) } function m(e) { var t = e && e.length ? this.write(e) : ""; if (this.lastNeed) { var i = this.lastTotal - this.lastNeed; return t + this.lastChar.toString("utf16le", 0, i) } return t } function g(e, t) { var i = (e.length - t) % 3; return 0 === i ? e.toString("base64", t) : (this.lastNeed = 3 - i, this.lastTotal = 3, 1 === i ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - i)) } function y(e) { var t = e && e.length ? this.write(e) : ""; return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t } function v(e) { return e.toString(this.encoding) } function _(e) { return e && e.length ? this.write(e) : "" } i.StringDecoder = s, s.prototype.write = function (e) { if (0 === e.length) return ""; var t, i; if (this.lastNeed) { if (void 0 === (t = this.fillLast(e))) return ""; i = this.lastNeed, this.lastNeed = 0 } else i = 0; return i < e.length ? t ? t + this.text(e, i) : this.text(e, i) : t || "" }, s.prototype.end = p, s.prototype.text = d, s.prototype.fillLast = function (e) { if (this.lastNeed <= e.length) return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal); e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length } }, { "safe-buffer": 77 }], 77: [function (e, t, i) {/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */var r = e("buffer"), n = r.Buffer; function a(e, t) { for (var i in e) t[i] = e[i] } function o(e, t, i) { return n(e, t, i) } n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? t.exports = r : (a(r, i), i.Buffer = o), o.prototype = Object.create(n.prototype), a(n, o), o.from = function (e, t, i) { if ("number" == typeof e) throw new TypeError("Argument must not be a number"); return n(e, t, i) }, o.alloc = function (e, t, i) { if ("number" != typeof e) throw new TypeError("Argument must be a number"); var r = n(e); return void 0 !== t ? "string" == typeof i ? r.fill(t, i) : r.fill(t) : r.fill(0), r }, o.allocUnsafe = function (e) { if ("number" != typeof e) throw new TypeError("Argument must be a number"); return n(e) }, o.allocUnsafeSlow = function (e) { if ("number" != typeof e) throw new TypeError("Argument must be a number"); return r.SlowBuffer(e) } }, { buffer: 33 }], 78: [function (e, t, i) { (function (e) { (function () { function i(e, t) { if (r("noDeprecation")) return e; var i = !1; function n() { if (!i) { if (r("throwDeprecation")) throw new Error(t); r("traceDeprecation") ? console.trace(t) : console.warn(t), i = !0 } return e.apply(this, arguments) } return n } function r(t) { try { if (!e.localStorage) return !1 } catch (e) { return !1 } var i = e.localStorage[t]; return null != i && "true" === String(i).toLowerCase() } t.exports = i }).call(this) }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, {}], 79: [function (e, t, i) { arguments[4][25][0].apply(i, arguments) }, { dup: 25 }], 80: [function (e, t, i) { var r = e("is-arguments"), n = e("is-generator-function"), a = e("which-typed-array"), o = e("is-typed-array"); function s(e) { return e.call.bind(e) } var l = "undefined" != typeof BigInt, c = "undefined" != typeof Symbol, h = s(Object.prototype.toString), u = s(Number.prototype.valueOf), d = s(String.prototype.valueOf), p = s(Boolean.prototype.valueOf); if (l) var f = s(BigInt.prototype.valueOf); if (c) var m = s(Symbol.prototype.valueOf); function g(e, t) { if ("object" != typeof e) return !1; try { return t(e), !0 } catch (e) { return !1 } } function y(e) { return "undefined" != typeof Promise && e instanceof Promise || null !== e && "object" == typeof e && "function" == typeof e.then && "function" == typeof e.catch } function v(e) { return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : o(e) || G(e) } function _(e) { return "Uint8Array" === a(e) } function b(e) { return "Uint8ClampedArray" === a(e) } function x(e) { return "Uint16Array" === a(e) } function w(e) { return "Uint32Array" === a(e) } function S(e) { return "Int8Array" === a(e) } function M(e) { return "Int16Array" === a(e) } function T(e) { return "Int32Array" === a(e) } function A(e) { return "Float32Array" === a(e) } function E(e) { return "Float64Array" === a(e) } function C(e) { return "BigInt64Array" === a(e) } function L(e) { return "BigUint64Array" === a(e) } function R(e) { return "[object Map]" === h(e) } function D(e) { return "undefined" != typeof Map && (R.working ? R(e) : e instanceof Map) } function P(e) { return "[object Set]" === h(e) } function O(e) { return "undefined" != typeof Set && (P.working ? P(e) : e instanceof Set) } function I(e) { return "[object WeakMap]" === h(e) } function k(e) { return "undefined" != typeof WeakMap && (I.working ? I(e) : e instanceof WeakMap) } function B(e) { return "[object WeakSet]" === h(e) } function N(e) { return B(e) } function F(e) { return "[object ArrayBuffer]" === h(e) } function U(e) { return "undefined" != typeof ArrayBuffer && (F.working ? F(e) : e instanceof ArrayBuffer) } function z(e) { return "[object DataView]" === h(e) } function G(e) { return "undefined" != typeof DataView && (z.working ? z(e) : e instanceof DataView) } function H(e) { return "[object SharedArrayBuffer]" === h(e) } function V(e) { return "undefined" != typeof SharedArrayBuffer && (H.working ? H(e) : e instanceof SharedArrayBuffer) } function j(e) { return "[object AsyncFunction]" === h(e) } function W(e) { return "[object Map Iterator]" === h(e) } function $(e) { return "[object Set Iterator]" === h(e) } function Y(e) { return "[object Generator]" === h(e) } function X(e) { return "[object WebAssembly.Module]" === h(e) } function Z(e) { return g(e, u) } function q(e) { return g(e, d) } function J(e) { return g(e, p) } function K(e) { return l && g(e, f) } function Q(e) { return c && g(e, m) } function ee(e) { return Z(e) || q(e) || J(e) || K(e) || Q(e) } function te(e) { return "undefined" != typeof Uint8Array && (U(e) || V(e)) } i.isArgumentsObject = r, i.isGeneratorFunction = n, i.isTypedArray = o, i.isPromise = y, i.isArrayBufferView = v, i.isUint8Array = _, i.isUint8ClampedArray = b, i.isUint16Array = x, i.isUint32Array = w, i.isInt8Array = S, i.isInt16Array = M, i.isInt32Array = T, i.isFloat32Array = A, i.isFloat64Array = E, i.isBigInt64Array = C, i.isBigUint64Array = L, R.working = "undefined" != typeof Map && R(new Map), i.isMap = D, P.working = "undefined" != typeof Set && P(new Set), i.isSet = O, I.working = "undefined" != typeof WeakMap && I(new WeakMap), i.isWeakMap = k, B.working = "undefined" != typeof WeakSet && B(new WeakSet), i.isWeakSet = N, F.working = "undefined" != typeof ArrayBuffer && F(new ArrayBuffer), i.isArrayBuffer = U, z.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && z(new DataView(new ArrayBuffer(1), 0, 1)), i.isDataView = G, H.working = "undefined" != typeof SharedArrayBuffer && H(new SharedArrayBuffer), i.isSharedArrayBuffer = V, i.isAsyncFunction = j, i.isMapIterator = W, i.isSetIterator = $, i.isGeneratorObject = Y, i.isWebAssemblyCompiledModule = X, i.isNumberObject = Z, i.isStringObject = q, i.isBooleanObject = J, i.isBigIntObject = K, i.isSymbolObject = Q, i.isBoxedPrimitive = ee, i.isAnyArrayBuffer = te, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach((function (e) { Object.defineProperty(i, e, { enumerable: !1, value: function () { throw new Error(e + " is not supported in userland") } }) })) }, { "is-arguments": 46, "is-generator-function": 47, "is-typed-array": 48, "which-typed-array": 82 }], 81: [function (e, t, i) { (function (t) { (function () { var r = Object.getOwnPropertyDescriptors || function (e) { for (var t = Object.keys(e), i = {}, r = 0; r < t.length; r++)i[t[r]] = Object.getOwnPropertyDescriptor(e, t[r]); return i }, n = /%[sdj%]/g; i.format = function (e) { if (!S(e)) { for (var t = [], i = 0; i < arguments.length; i++)t.push(l(arguments[i])); return t.join(" ") } i = 1; for (var r = arguments, a = r.length, o = String(e).replace(n, (function (e) { if ("%%" === e) return "%"; if (i >= a) return e; switch (e) { case "%s": return String(r[i++]); case "%d": return Number(r[i++]); case "%j": try { return JSON.stringify(r[i++]) } catch (e) { return "[Circular]" } default: return e } })), s = r[i]; i < a; s = r[++i])b(s) || !E(s) ? o += " " + s : o += " " + l(s); return o }, i.deprecate = function (e, r) { if (void 0 !== t && !0 === t.noDeprecation) return e; if (void 0 === t) return function () { return i.deprecate(e, r).apply(this, arguments) }; var n = !1; function a() { if (!n) { if (t.throwDeprecation) throw new Error(r); t.traceDeprecation ? console.trace(r) : console.error(r), n = !0 } return e.apply(this, arguments) } return a }; var a = {}, o = /^$/; if (t.env.NODE_DEBUG) { var s = t.env.NODE_DEBUG; s = s.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), o = new RegExp("^" + s + "$", "i") } function l(e, t) { var r = { seen: [], stylize: h }; return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), _(t) ? r.showHidden = t : t && i._extend(r, t), T(r.showHidden) && (r.showHidden = !1), T(r.depth) && (r.depth = 2), T(r.colors) && (r.colors = !1), T(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = c), d(r, e, r.depth) } function c(e, t) { var i = l.styles[t]; return i ? "[" + l.colors[i][0] + "m" + e + "[" + l.colors[i][1] + "m" : e } function h(e, t) { return e } function u(e) { var t = {}; return e.forEach((function (e, i) { t[e] = !0 })), t } function d(e, t, r) { if (e.customInspect && t && R(t.inspect) && t.inspect !== i.inspect && (!t.constructor || t.constructor.prototype !== t)) { var n = t.inspect(r, e); return S(n) || (n = d(e, n, r)), n } var a = p(e, t); if (a) return a; var o = Object.keys(t), s = u(o); if (e.showHidden && (o = Object.getOwnPropertyNames(t)), L(t) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0)) return f(t); if (0 === o.length) { if (R(t)) { var l = t.name ? ": " + t.name : ""; return e.stylize("[Function" + l + "]", "special") } if (A(t)) return e.stylize(RegExp.prototype.toString.call(t), "regexp"); if (C(t)) return e.stylize(Date.prototype.toString.call(t), "date"); if (L(t)) return f(t) } var c, h = "", _ = !1, b = ["{", "}"]; return v(t) && (_ = !0, b = ["[", "]"]), R(t) && (h = " [Function" + (t.name ? ": " + t.name : "") + "]"), A(t) && (h = " " + RegExp.prototype.toString.call(t)), C(t) && (h = " " + Date.prototype.toUTCString.call(t)), L(t) && (h = " " + f(t)), 0 !== o.length || _ && 0 != t.length ? r < 0 ? A(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(t), c = _ ? m(e, t, r, s, o) : o.map((function (i) { return g(e, t, r, s, i, _) })), e.seen.pop(), y(c, h, b)) : b[0] + h + b[1] } function p(e, t) { if (T(t)) return e.stylize("undefined", "undefined"); if (S(t)) { var i = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'"; return e.stylize(i, "string") } return w(t) ? e.stylize("" + t, "number") : _(t) ? e.stylize("" + t, "boolean") : b(t) ? e.stylize("null", "null") : void 0 } function f(e) { return "[" + Error.prototype.toString.call(e) + "]" } function m(e, t, i, r, n) { for (var a = [], o = 0, s = t.length; o < s; ++o)B(t, String(o)) ? a.push(g(e, t, i, r, String(o), !0)) : a.push(""); return n.forEach((function (n) { n.match(/^\d+$/) || a.push(g(e, t, i, r, n, !0)) })), a } function g(e, t, i, r, n, a) { var o, s, l; if ((l = Object.getOwnPropertyDescriptor(t, n) || { value: t[n] }).get ? s = l.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : l.set && (s = e.stylize("[Setter]", "special")), B(r, n) || (o = "[" + n + "]"), s || (e.seen.indexOf(l.value) < 0 ? (s = b(i) ? d(e, l.value, null) : d(e, l.value, i - 1)).indexOf("\n") > -1 && (s = a ? s.split("\n").map((function (e) { return "  " + e })).join("\n").substr(2) : "\n" + s.split("\n").map((function (e) { return "   " + e })).join("\n")) : s = e.stylize("[Circular]", "special")), T(o)) { if (a && n.match(/^\d+$/)) return s; (o = JSON.stringify("" + n)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o = o.substr(1, o.length - 2), o = e.stylize(o, "name")) : (o = o.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o = e.stylize(o, "string")) } return o + ": " + s } function y(e, t, i) { return e.reduce((function (e, t) { return t.indexOf("\n"), e + t.replace(/\u001b\[\d\d?m/g, "").length + 1 }), 0) > 60 ? i[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + i[1] : i[0] + t + " " + e.join(", ") + " " + i[1] } function v(e) { return Array.isArray(e) } function _(e) { return "boolean" == typeof e } function b(e) { return null === e } function x(e) { return null == e } function w(e) { return "number" == typeof e } function S(e) { return "string" == typeof e } function M(e) { return "symbol" == typeof e } function T(e) { return void 0 === e } function A(e) { return E(e) && "[object RegExp]" === P(e) } function E(e) { return "object" == typeof e && null !== e } function C(e) { return E(e) && "[object Date]" === P(e) } function L(e) { return E(e) && ("[object Error]" === P(e) || e instanceof Error) } function R(e) { return "function" == typeof e } function D(e) { return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e } function P(e) { return Object.prototype.toString.call(e) } function O(e) { return e < 10 ? "0" + e.toString(10) : e.toString(10) } i.debuglog = function (e) { if (e = e.toUpperCase(), !a[e]) if (o.test(e)) { var r = t.pid; a[e] = function () { var t = i.format.apply(i, arguments); console.error("%s %d: %s", e, r, t) } } else a[e] = function () { }; return a[e] }, i.inspect = l, l.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, l.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i.types = e("./support/types"), i.isArray = v, i.isBoolean = _, i.isNull = b, i.isNullOrUndefined = x, i.isNumber = w, i.isString = S, i.isSymbol = M, i.isUndefined = T, i.isRegExp = A, i.types.isRegExp = A, i.isObject = E, i.isDate = C, i.types.isDate = C, i.isError = L, i.types.isNativeError = L, i.isFunction = R, i.isPrimitive = D, i.isBuffer = e("./support/isBuffer"); var I = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; function k() { var e = new Date, t = [O(e.getHours()), O(e.getMinutes()), O(e.getSeconds())].join(":"); return [e.getDate(), I[e.getMonth()], t].join(" ") } function B(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } i.log = function () { console.log("%s - %s", k(), i.format.apply(i, arguments)) }, i.inherits = e("inherits"), i._extend = function (e, t) { if (!t || !E(t)) return e; for (var i = Object.keys(t), r = i.length; r--;)e[i[r]] = t[i[r]]; return e }; var N = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0; function F(e, t) { if (!e) { var i = new Error("Promise was rejected with a falsy value"); i.reason = e, e = i } return t(e) } function U(e) { if ("function" != typeof e) throw new TypeError('The "original" argument must be of type Function'); function i() { for (var i = [], r = 0; r < arguments.length; r++)i.push(arguments[r]); var n = i.pop(); if ("function" != typeof n) throw new TypeError("The last argument must be of type Function"); var a = this, o = function () { return n.apply(a, arguments) }; e.apply(this, i).then((function (e) { t.nextTick(o.bind(null, null, e)) }), (function (e) { t.nextTick(F.bind(null, e, o)) })) } return Object.setPrototypeOf(i, Object.getPrototypeOf(e)), Object.defineProperties(i, r(e)), i } i.promisify = function (e) { if ("function" != typeof e) throw new TypeError('The "original" argument must be of type Function'); if (N && e[N]) { var t; if ("function" != typeof (t = e[N])) throw new TypeError('The "util.promisify.custom" argument must be of type Function'); return Object.defineProperty(t, N, { value: t, enumerable: !1, writable: !1, configurable: !0 }), t } function t() { for (var t, i, r = new Promise((function (e, r) { t = e, i = r })), n = [], a = 0; a < arguments.length; a++)n.push(arguments[a]); n.push((function (e, r) { e ? i(e) : t(r) })); try { e.apply(this, n) } catch (e) { i(e) } return r } return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), N && Object.defineProperty(t, N, { value: t, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(t, r(e)) }, i.promisify.custom = N, i.callbackify = U }).call(this) }).call(this, e("_process")) }, { "./support/isBuffer": 79, "./support/types": 80, _process: 60, inherits: 45 }], 82: [function (e, t, i) { (function (i) { (function () { var r = e("foreach"), n = e("available-typed-arrays"), a = e("es-abstract/helpers/callBound"), o = a("Object.prototype.toString"), s = e("has-symbols")() && "symbol" == typeof Symbol.toStringTag, l = n(), c = a("String.prototype.slice"), h = {}, u = e("es-abstract/helpers/getOwnPropertyDescriptor"), d = Object.getPrototypeOf; s && u && d && r(l, (function (e) { if ("function" == typeof i[e]) { var t = new i[e]; if (!(Symbol.toStringTag in t)) throw new EvalError("this engine has support for Symbol.toStringTag, but " + e + " does not have the property! Please report this."); var r = d(t), n = u(r, Symbol.toStringTag); if (!n) { var a = d(r); n = u(a, Symbol.toStringTag) } h[e] = n.get } })); var p = function (e) { var t = !1; return r(h, (function (i, r) { if (!t) try { var n = i.call(e); n === r && (t = n) } catch (e) { } })), t }, f = e("is-typed-array"); t.exports = function (e) { return !!f(e) && (s ? p(e) : c(o(e), 8, -1)) } }).call(this) }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "available-typed-arrays": 27, "es-abstract/helpers/callBound": 36, "es-abstract/helpers/getOwnPropertyDescriptor": 37, foreach: 39, "has-symbols": 42, "is-typed-array": 48 }]
      }, {}, [20])(20)
   })); function handleGL$1(e) { let t = document.createElement("canvas").getContext("webgl2"); t.activeTexture(t.TEXTURE0); let i = t.createTexture(); t.bindTexture(t.TEXTURE_2D, i); const r = t.createFramebuffer(); t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, i, 0), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, e), t.drawBuffers([t.COLOR_ATTACHMENT0]); let n = new Uint8Array(e.width * e.height * 4); return t.readPixels(0, 0, e.width, e.height, t.RGBA, t.UNSIGNED_BYTE, n), n } const getMaxSize = (e, t) => { const i = [e.width, e.height, t.width, t.height]; let r = i[0]; for (let e = 0; e < i.length; e++)r = Math.max(r, i[e]); return r }, textureCombine = (e, t, i) => { if (!e) return t; if (!t) return e; let r; if (e.image === t.image) r = new Texture$1(e.image); else { let n = getMaxSize(e.image, t.image); i && n > i && (n = i), n > 16384 && (n = 16384); const a = document.createElement("canvas"); a.width = n, a.height = n; const o = a.getContext("2d"); o.fillstyle = "#ffffff", o.fillRect(0, 0, n, n); const s = o.getImageData(0, 0, n, n), l = t?.image, c = e?.image; if (t) { o.drawImage(l, 0, 0, n, n, 0, 0, n, n); const e = o.getImageData(0, 0, n, n).data; for (let t = 1; t < e.length; t += 4)s.data[t] = e[t] } if (e) { o.drawImage(c, 0, 0, n, n, 0, 0, n, n); const e = o.getImageData(0, 0, n, n).data; for (let t = 2; t < e.length; t += 4)s.data[t] = e[t] } o.putImageData(s, 0, 0), r = new Texture$1(a) } return r.name = t?.name === e?.name ? t?.name : t?.name + "#MetalnessAndRoughness#" + e?.name, r }; class GLTFExporter { constructor() { this.pluginCallbacks = [], this.register((function (e) { return new GLTFLightExtension(e) })), this.register((function (e) { return new GLTFMaterialsUnlitExtension(e) })), this.register((function (e) { return new GLTFMaterialsPBRSpecularGlossiness(e) })) } register(e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this } unregister(e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, i) { const r = new GLTFWriter, n = []; for (let e = 0, t = this.pluginCallbacks.length; e < t; e++)n.push(this.pluginCallbacks[e](r)); r.setPlugins(n), r.write(e, t, i) } } const WEBGL_CONSTANTS = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123, FLOAT: 5126, UNSIGNED_INT: 5125, ARRAY_BUFFER: 34962, ELEMENT_ARRAY_BUFFER: 34963, NEAREST: 9728, LINEAR: 9729, NEAREST_MIPMAP_NEAREST: 9984, LINEAR_MIPMAP_NEAREST: 9985, NEAREST_MIPMAP_LINEAR: 9986, LINEAR_MIPMAP_LINEAR: 9987, CLAMP_TO_EDGE: 33071, MIRRORED_REPEAT: 33648, REPEAT: 10497 }, THREE_TO_WEBGL = {}; THREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST, THREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST, THREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR, THREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR, THREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST, THREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR, THREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE, THREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT, THREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT; const PATH_PROPERTIES = { scale: "scale", position: "translation", quaternion: "rotation", morphTargetInfluences: "weights" }, GLB_HEADER_BYTES = 12, GLB_HEADER_MAGIC = 1179937895, GLB_VERSION = 2, GLB_CHUNK_PREFIX_BYTES = 8, GLB_CHUNK_TYPE_JSON = 1313821514, GLB_CHUNK_TYPE_BIN = 5130562; function equalArray(e, t) { return e.length === t.length && e.every((function (e, i) { return e === t[i] })) } function stringToArrayBuffer(e) { if (void 0 !== window.TextEncoder) return (new TextEncoder).encode(e).buffer; const t = new Uint8Array(new ArrayBuffer(e.length)); for (let i = 0, r = e.length; i < r; i++) { const r = e.charCodeAt(i); t[i] = r > 255 ? 32 : r } return t.buffer } function isIdentityMatrix(e) { return equalArray(e.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) } function getMinMax(e, t, i) { const r = { min: new Array(e.itemSize).fill(Number.POSITIVE_INFINITY), max: new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY) }; for (let n = t; n < t + i; n++)for (let t = 0; t < e.itemSize; t++) { let i; e.itemSize > 4 ? i = e.array[n * e.itemSize + t] : 0 === t ? i = e.getX(n) : 1 === t ? i = e.getY(n) : 2 === t ? i = e.getZ(n) : 3 === t && (i = e.getW(n)), r.min[t] = Math.min(r.min[t], i), r.max[t] = Math.max(r.max[t], i) } return r } function getPaddedBufferSize(e) { return 4 * Math.ceil(e / 4) } function getPaddedArrayBuffer(e, t = 0) { const i = getPaddedBufferSize(e.byteLength); if (i !== e.byteLength) { const r = new Uint8Array(i); if (r.set(new Uint8Array(e)), 0 !== t) for (let n = e.byteLength; n < i; n++)r[n] = t; return r.buffer } return e } let cachedCanvas = null; class GLTFWriter { constructor() { this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map, this.skins = [], this.extensionsUsed = {}, this.uids = new Map, this.uid = 0, this.json = { asset: { version: "2.0", generator: "THREE.GLTFExporter" } }, this.cache = { meshes: new Map, attributes: new Map, attributesNormalized: new Map, materials: new Map, textures: new Map, images: new Map } } setPlugins(e) { this.plugins = e } write(e, t, i) { this.options = Object.assign({}, { binary: !1, trs: !1, onlyVisible: !0, truncateDrawRange: !0, embedImages: !0, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: !1 }, i), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e); const r = this; Promise.all(this.pending).then((function () { const e = r.buffers, i = r.json, n = r.options, a = r.extensionsUsed, o = new Blob(e, { type: "application/octet-stream" }), s = Object.keys(a); if (s.length > 0 && (i.extensionsUsed = s), i.buffers && i.buffers.length > 0 && (i.buffers[0].byteLength = o.size), !0 === n.binary) { const e = new window.FileReader; e.readAsArrayBuffer(o), e.onloadend = function () { const r = getPaddedArrayBuffer(e.result), n = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES)); n.setUint32(0, r.byteLength, !0), n.setUint32(4, GLB_CHUNK_TYPE_BIN, !0); const a = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(i)), 32), o = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES)); o.setUint32(0, a.byteLength, !0), o.setUint32(4, GLB_CHUNK_TYPE_JSON, !0); const s = new ArrayBuffer(GLB_HEADER_BYTES), l = new DataView(s); l.setUint32(0, GLB_HEADER_MAGIC, !0), l.setUint32(4, GLB_VERSION, !0); const c = GLB_HEADER_BYTES + o.byteLength + a.byteLength + n.byteLength + r.byteLength; l.setUint32(8, c, !0); const h = new Blob([s, o, a, n, r], { type: "application/octet-stream" }), u = new window.FileReader; u.readAsArrayBuffer(h), u.onloadend = function () { t(u.result) } } } else if (i.buffers && i.buffers.length > 0) { const e = new window.FileReader; e.readAsDataURL(o), e.onloadend = function () { const r = e.result; i.buffers[0].uri = r, t(i) } } else t(i) })) } serializeUserData(e, t) { if (0 === Object.keys(e.userData).length) return; const i = this.options, r = this.extensionsUsed; try { const n = JSON.parse(JSON.stringify(e.userData)); if (i.includeCustomExtensions && n.gltfExtensions) { void 0 === t.extensions && (t.extensions = {}); for (const e in n.gltfExtensions) t.extensions[e] = n.gltfExtensions[e], r[e] = !0; delete n.gltfExtensions } Object.keys(n).length > 0 && (t.extras = n) } catch (t) { logger.warn("THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + t.message) } } getUID(e) { return this.uids.has(e) || this.uids.set(e, this.uid++), this.uids.get(e) } isNormalizedNormalAttribute(e) { if (this.cache.attributesNormalized.has(e)) return !1; const t = new Vector3; for (let i = 0, r = e.count; i < r; i++)if (Math.abs(t.fromBufferAttribute(e, i).length() - 1) > 5e-4) return !1; return !0 } createNormalizedNormalAttribute(e) { const t = this.cache; if (t.attributesNormalized.has(e)) return t.attributesNormalized.get(e); const i = e.clone(), r = new Vector3; for (let e = 0, t = i.count; e < t; e++)r.fromBufferAttribute(i, e), 0 === r.x && 0 === r.y && 0 === r.z ? r.setX(1) : r.normalize(), i.setXYZ(e, r.x, r.y, r.z); return t.attributesNormalized.set(e, i), i } applyTextureTransform(e, t) { let i = !1; const r = {}; 0 === t.offset.x && 0 === t.offset.y || (r.offset = t.offset.toArray(), i = !0), 0 !== t.rotation && (r.rotation = t.rotation, i = !0), 1 === t.repeat.x && 1 === t.repeat.y || (r.scale = t.repeat.toArray(), i = !0), i && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = r, this.extensionsUsed.KHR_texture_transform = !0) } processBuffer(e) { const t = this.json, i = this.buffers; return t.buffers || (t.buffers = [{ byteLength: 0 }]), i.push(e), 0 } processBufferView(e, t, i, r, n) { const a = this.json; let o; a.bufferViews || (a.bufferViews = []), o = t === WEBGL_CONSTANTS.UNSIGNED_BYTE ? 1 : t === WEBGL_CONSTANTS.UNSIGNED_SHORT ? 2 : 4; const s = getPaddedBufferSize(r * e.itemSize * o), l = new DataView(new ArrayBuffer(s)); let c = 0; for (let n = i; n < i + r; n++)for (let i = 0; i < e.itemSize; i++) { let r; e.itemSize > 4 ? r = e.array[n * e.itemSize + i] : 0 === i ? r = e.getX(n) : 1 === i ? r = e.getY(n) : 2 === i ? r = e.getZ(n) : 3 === i && (r = e.getW(n)), t === WEBGL_CONSTANTS.FLOAT ? l.setFloat32(c, r, !0) : t === WEBGL_CONSTANTS.UNSIGNED_INT ? l.setUint32(c, r, !0) : t === WEBGL_CONSTANTS.UNSIGNED_SHORT ? l.setUint16(c, r, !0) : t === WEBGL_CONSTANTS.UNSIGNED_BYTE && l.setUint8(c, r), c += o } const h = { buffer: this.processBuffer(l.buffer), byteOffset: this.byteOffset, byteLength: s }; void 0 !== n && (h.target = n), n === WEBGL_CONSTANTS.ARRAY_BUFFER && (h.byteStride = e.itemSize * o), this.byteOffset += s, a.bufferViews.push(h); return { id: a.bufferViews.length - 1, byteLength: 0 } } processBufferViewImage(e) { const t = this, i = t.json; return i.bufferViews || (i.bufferViews = []), new Promise((function (r) { const n = new window.FileReader; n.readAsArrayBuffer(e), n.onloadend = function () { const e = getPaddedArrayBuffer(n.result), a = { buffer: t.processBuffer(e), byteOffset: t.byteOffset, byteLength: e.byteLength }; t.byteOffset += e.byteLength, r(i.bufferViews.push(a) - 1) } })) } processAccessor(e, t, i, r) { const n = this.options, a = this.json; let o; if (e.array.constructor === Float32Array) o = WEBGL_CONSTANTS.FLOAT; else if (e.array.constructor === Uint32Array) o = WEBGL_CONSTANTS.UNSIGNED_INT; else if (e.array.constructor === Uint16Array) o = WEBGL_CONSTANTS.UNSIGNED_SHORT; else { if (e.array.constructor !== Uint8Array) throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type."); o = WEBGL_CONSTANTS.UNSIGNED_BYTE } if (void 0 === i && (i = 0), void 0 === r && (r = e.count), n.truncateDrawRange && void 0 !== t && null === t.index) { const n = i + r, a = t.drawRange.count === 1 / 0 ? e.count : t.drawRange.start + t.drawRange.count; i = Math.max(i, t.drawRange.start), (r = Math.min(n, a) - i) < 0 && (r = 0) } if (0 === r) return null; const s = getMinMax(e, i, r); let l; void 0 !== t && (l = e === t.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER); const c = this.processBufferView(e, o, i, r, l), h = { bufferView: c.id, byteOffset: c.byteOffset, componentType: o, count: r, max: s.max, min: s.min, type: { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 16: "MAT4" }[e.itemSize] }; return !0 === e.normalized && (h.normalized = !0), a.accessors || (a.accessors = []), a.accessors.push(h) - 1 } processImage(e, t, i) { const r = this, n = r.cache, a = r.json, o = r.options, s = r.pending; n.images.has(e) || n.images.set(e, {}); const l = n.images.get(e), c = t === RGBAFormat ? "image/png" : "image/jpeg", h = c + ":flipY/" + i.toString(); if (void 0 !== l[h]) return l[h]; a.images || (a.images = []); const u = { mimeType: c }; if (o.embedImages) { const n = cachedCanvas = cachedCanvas || document.createElement("canvas"); n.width = Math.min(e.width, o.maxTextureSize), n.height = Math.min(e.height, o.maxTextureSize); const a = n.getContext("2d"); if (!0 === i && (a.translate(0, n.height), a.scale(1, -1)), "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) a.drawImage(e, 0, 0, n.width, n.height); else { t !== RGBAFormat && t !== RGBFormat && logger.error("GLTFExporter: Only RGB and RGBA formats are supported."), (e.width > o.maxTextureSize || e.height > o.maxTextureSize) && logger.warn("GLTFExporter: Image size is bigger than maxTextureSize", e); let i = e.data; if (t === RGBFormat) { i = new Uint8ClampedArray(e.height * e.width * 4); for (let t = 0, r = 0; t < i.length; t += 4, r += 3)i[t + 0] = e.data[r + 0], i[t + 1] = e.data[r + 1], i[t + 2] = e.data[r + 2], i[t + 3] = 255 } a.putImageData(new ImageData(i, e.width, e.height), 0, 0) } !0 === o.binary ? (!o.maxTextureSize || o.maxTextureSize === 1 / 0) && e instanceof ImageBitmap && ImageBitMapCache && ImageBitMapCache.get(e) ? s.push(new Promise((function (t) { let i = ImageBitMapCache.get(e); r.processBufferViewImage(i).then((function (e) { u.bufferView = e, t() })) }))) : s.push(new Promise((function (t) { n.toBlob((function (i) { if ("image/png" === i.type) { let t = handleGL$1(e), r = new browser.PNG({ width: e.width, height: e.height, filterType: 4 }); for (let e = 0; e < r.data.length; e += 4)r.data[e + 0] = t[e + 0], r.data[e + 1] = t[e + 1], r.data[e + 2] = t[e + 2], r.data[e + 3] = t[e + 3]; r.pack(); var n = browser.PNG.sync.write(r, { colorType: 6 }); i = new Blob([n], { type: i.type }) } r.processBufferViewImage(i).then((function (e) { u.bufferView = e, t() })) }), c, 1) }))) : u.uri = n.toDataURL(c) } else u.uri = e.src; const d = a.images.push(u) - 1; return l[h] = d, d } processSampler(e) { const t = this.json; t.samplers || (t.samplers = []); const i = { magFilter: THREE_TO_WEBGL[e.magFilter], minFilter: THREE_TO_WEBGL[e.minFilter], wrapS: THREE_TO_WEBGL[e.wrapS], wrapT: THREE_TO_WEBGL[e.wrapT] }; return t.samplers.push(i) - 1 } processTexture(e) { const t = this.cache, i = this.json; if (t.textures.has(e)) return t.textures.get(e); i.textures || (i.textures = []); const r = { sampler: this.processSampler(e), source: this.processImage(e.image, e.format, e.flipY) }; e.name && (r.name = e.name), this._invokeAll((function (t) { t.writeTexture && t.writeTexture(e, r) })); const n = i.textures.push(r) - 1; return t.textures.set(e, n), n } processMaterial(e) { const t = this.cache, i = this.json; if (t.materials.has(e)) return t.materials.get(e); if (e.isShaderMaterial) return logger.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null; i.materials || (i.materials = []); const r = { pbrMetallicRoughness: {} }; !0 !== e.isMeshStandardMaterial && !0 !== e.isMeshBasicMaterial && logger.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results."); const n = e.color.toArray().concat([e.opacity]); if (equalArray(n, [1, 1, 1, 1]) || (r.pbrMetallicRoughness.baseColorFactor = n), e.isMeshStandardMaterial ? (r.pbrMetallicRoughness.metallicFactor = e.metalness, r.pbrMetallicRoughness.roughnessFactor = e.roughness) : (r.pbrMetallicRoughness.metallicFactor = .5, r.pbrMetallicRoughness.roughnessFactor = .5), e.metalnessMap || e.roughnessMap) { const t = textureCombine(e.metalnessMap, e.roughnessMap, this.options.maxTextureSize), i = { index: this.processTexture(t) }; this.applyTextureTransform(i, t), r.pbrMetallicRoughness.metallicRoughnessTexture = i } if (e.map) { const t = { index: this.processTexture(e.map) }; this.applyTextureTransform(t, e.map), r.pbrMetallicRoughness.baseColorTexture = t } if (e.emissive) { const t = e.emissive.clone().multiplyScalar(e.emissiveIntensity).toArray(); if (equalArray(t, [0, 0, 0]) || (r.emissiveFactor = t), e.emissiveMap) { const t = { index: this.processTexture(e.emissiveMap) }; this.applyTextureTransform(t, e.emissiveMap), r.emissiveTexture = t } } if (e.normalMap) { const t = { index: this.processTexture(e.normalMap) }; e.normalScale && -1 !== e.normalScale.x && (e.normalScale.x !== e.normalScale.y && logger.warn("THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."), t.scale = e.normalScale.x), this.applyTextureTransform(t, e.normalMap), r.normalTexture = t } if (e.aoMap) { const t = { index: this.processTexture(e.aoMap), texCoord: 1 }; 1 !== e.aoMapIntensity && (t.strength = e.aoMapIntensity), this.applyTextureTransform(t, e.aoMap), r.occlusionTexture = t } e.transparent ? r.alphaMode = "BLEND" : e.alphaTest > 0 && (r.alphaMode = "MASK", r.alphaCutoff = e.alphaTest), e.side === DoubleSide && (r.doubleSided = !0), "" !== e.name && (r.name = e.name), this.serializeUserData(e, r), this._invokeAll((function (t) { t.writeMaterial && t.writeMaterial(e, r) })); const a = i.materials.push(r) - 1; return t.materials.set(e, a), a } processMesh(e) { const t = this.cache, i = this.json, r = [e.geometry.uuid]; if (Array.isArray(e.material)) for (let t = 0, i = e.material.length; t < i; t++)r.push(e.material[t].uuid); else r.push(e.material.uuid); const n = r.join(":"); if (t.meshes.has(n)) return t.meshes.get(n); const a = e.geometry; let o; if (o = e.isLineSegments ? WEBGL_CONSTANTS.LINES : e.isLineLoop ? WEBGL_CONSTANTS.LINE_LOOP : e.isLine ? WEBGL_CONSTANTS.LINE_STRIP : e.isPoints ? WEBGL_CONSTANTS.POINTS : e.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES, !0 !== a.isBufferGeometry) throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry."); const s = {}, l = {}, c = [], h = [], u = { uv: "TEXCOORD_0", uv2: "TEXCOORD_1", color: "COLOR_0", skinWeight: "WEIGHTS_0", skinIndex: "JOINTS_0" }, d = a.getAttribute("normal"); void 0 === d || this.isNormalizedNormalAttribute(d) || (logger.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), a.setAttribute("normal", this.createNormalizedNormalAttribute(d))); let p = null; for (let e in a.attributes) { if ("morph" === e.substr(0, 5)) continue; const i = a.attributes[e]; e = u[e] || e.toUpperCase(); if (/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e) || (e = "_" + e), t.attributes.has(this.getUID(i))) { l[e] = t.attributes.get(this.getUID(i)); continue } p = null; const r = i.array; "JOINTS_0" !== e || r instanceof Uint16Array || r instanceof Uint8Array || (logger.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), p = new BufferAttribute(new Uint16Array(r), i.itemSize, i.normalized)); const n = this.processAccessor(p || i, a); null !== n && (l[e] = n, t.attributes.set(this.getUID(i), n)) } if (void 0 !== d && a.setAttribute("normal", d), 0 === Object.keys(l).length) return null; if (void 0 !== e.morphTargetInfluences && e.morphTargetInfluences.length > 0) { const i = [], r = [], n = {}; if (void 0 !== e.morphTargetDictionary) for (const t in e.morphTargetDictionary) n[e.morphTargetDictionary[t]] = t; for (let o = 0; o < e.morphTargetInfluences.length; ++o) { const s = {}; let l = !1; for (const e in a.morphAttributes) { if ("position" !== e && "normal" !== e) { l || (logger.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), l = !0); continue } const i = a.morphAttributes[e][o], r = e.toUpperCase(), n = a.attributes[e]; if (t.attributes.has(this.getUID(i))) { s[r] = t.attributes.get(this.getUID(i)); continue } const c = i.clone(); if (!a.morphTargetsRelative) for (let e = 0, t = i.count; e < t; e++)c.setXYZ(e, i.getX(e) - n.getX(e), i.getY(e) - n.getY(e), i.getZ(e) - n.getZ(e)); s[r] = this.processAccessor(c, a), t.attributes.set(this.getUID(n), s[r]) } h.push(s), i.push(e.morphTargetInfluences[o]), void 0 !== e.morphTargetDictionary && r.push(n[o]) } s.weights = i, r.length > 0 && (s.extras = {}, s.extras.targetNames = r) } const f = Array.isArray(e.material); if (f && 0 === a.groups.length) return null; const m = f ? e.material : [e.material], g = f ? a.groups : [{ materialIndex: 0, start: void 0, count: void 0 }]; for (let e = 0, i = g.length; e < i; e++) { const i = { mode: o, attributes: l }; if (this.serializeUserData(a, i), h.length > 0 && (i.targets = h), null !== a.index) { let r = this.getUID(a.index); void 0 === g[e].start && void 0 === g[e].count || (r += ":" + g[e].start + ":" + g[e].count), t.attributes.has(r) ? i.indices = t.attributes.get(r) : (i.indices = this.processAccessor(a.index, a, g[e].start, g[e].count), t.attributes.set(r, i.indices)), null === i.indices && delete i.indices } const r = this.processMaterial(m[g[e].materialIndex]); null !== r && (i.material = r), c.push(i) } s.primitives = c, i.meshes || (i.meshes = []), this._invokeAll((function (t) { t.writeMesh && t.writeMesh(e, s) })); const y = i.meshes.push(s) - 1; return t.meshes.set(n, y), y } processCamera(e) { const t = this.json; t.cameras || (t.cameras = []); const i = e.isOrthographicCamera, r = { type: i ? "orthographic" : "perspective" }; return i ? r.orthographic = { xmag: 2 * e.right, ymag: 2 * e.top, zfar: e.far <= 0 ? .001 : e.far, znear: e.near < 0 ? 0 : e.near } : r.perspective = { aspectRatio: e.aspect, yfov: MathUtils.degToRad(e.fov), zfar: e.far <= 0 ? .001 : e.far, znear: e.near < 0 ? 0 : e.near }, "" !== e.name && (r.name = e.type), t.cameras.push(r) - 1 } processAnimation(e, t) { const i = this.json, r = this.nodeMap; i.animations || (i.animations = []); const n = (e = GLTFExporter.Utils.mergeMorphTargetTracks(e.clone(), t)).tracks, a = [], o = []; for (let e = 0; e < n.length; ++e) { const i = n[e], s = PropertyBinding.parseTrackName(i.name); let l = PropertyBinding.findNode(t, s.nodeName); const c = PATH_PROPERTIES[s.propertyName]; if ("bones" === s.objectName && (l = !0 === l.isSkinnedMesh ? l.skeleton.getBoneByName(s.objectIndex) : void 0), !l || !c) return logger.warn('THREE.GLTFExporter: Could not export animation track "%s".', i.name), null; const h = 1; let u, d = i.values.length / i.times.length; c === PATH_PROPERTIES.morphTargetInfluences && (d /= l.morphTargetInfluences.length), !0 === i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (u = "CUBICSPLINE", d /= 3) : u = i.getInterpolation() === InterpolateDiscrete ? "STEP" : "LINEAR", o.push({ input: this.processAccessor(new BufferAttribute(i.times, h)), output: this.processAccessor(new BufferAttribute(i.values, d)), interpolation: u }), a.push({ sampler: o.length - 1, target: { node: r.get(l), path: c } }) } return i.animations.push({ name: e.name || "clip_" + i.animations.length, samplers: o, channels: a }), i.animations.length - 1 } processSkin(e) { const t = this.json, i = this.nodeMap, r = t.nodes[i.get(e)], n = e.skeleton; if (void 0 === n) return null; const a = e.skeleton.bones[0]; if (void 0 === a) return null; const o = [], s = new Float32Array(16 * n.bones.length), l = new Matrix4; for (let t = 0; t < n.bones.length; ++t)o.push(i.get(n.bones[t])), l.copy(n.boneInverses[t]), l.multiply(e.bindMatrix).toArray(s, 16 * t); void 0 === t.skins && (t.skins = []), t.skins.push({ inverseBindMatrices: this.processAccessor(new BufferAttribute(s, 16)), joints: o, skeleton: i.get(a) }); return r.skin = t.skins.length - 1 } processNode(e) { const t = this.json, i = this.options, r = this.nodeMap; t.nodes || (t.nodes = []); const n = {}; if (i.trs) { const t = e.quaternion.toArray(), i = e.position.toArray(), r = e.scale.toArray(); equalArray(t, [0, 0, 0, 1]) || (n.rotation = t), equalArray(i, [0, 0, 0]) || (n.translation = i), equalArray(r, [1, 1, 1]) || (n.scale = r) } else e.matrixAutoUpdate && e.updateMatrix(), !1 === isIdentityMatrix(e.matrix) && (n.matrix = e.matrix.elements); if ("" !== e.name && (n.name = String(e.name)), this.serializeUserData(e, n), e.isMesh || e.isLine || e.isPoints) { const t = this.processMesh(e); null !== t && (n.mesh = t) } else e.isCamera && (n.camera = this.processCamera(e)); if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) { const t = []; for (let r = 0, n = e.children.length; r < n; r++) { const n = e.children[r]; if (n.visible || !1 === i.onlyVisible) { const e = this.processNode(n); null !== e && t.push(e) } } t.length > 0 && (n.children = t) } this._invokeAll((function (t) { t.writeNode && t.writeNode(e, n) })); const a = t.nodes.push(n) - 1; return r.set(e, a), a } processScene(e) { const t = this.json, i = this.options; t.scenes || (t.scenes = [], t.scene = 0); const r = {}; "" !== e.name && (r.name = e.name), t.scenes.push(r); const n = []; for (let t = 0, r = e.children.length; t < r; t++) { const r = e.children[t]; if (r.visible || !1 === i.onlyVisible) { const e = this.processNode(r); null !== e && n.push(e) } } n.length > 0 && (r.nodes = n), this.serializeUserData(e, r) } processObjects(e) { const t = new Scene; t.name = "AuxScene"; for (let i = 0; i < e.length; i++)t.children.push(e[i]); this.processScene(t) } processInput(e) { const t = this.options; e = e instanceof Array ? e : [e], this._invokeAll((function (t) { t.beforeParse && t.beforeParse(e) })); const i = []; for (let t = 0; t < e.length; t++)e[t] instanceof Scene ? this.processScene(e[t]) : i.push(e[t]); i.length > 0 && this.processObjects(i); for (let e = 0; e < this.skins.length; ++e)this.processSkin(this.skins[e]); for (let i = 0; i < t.animations.length; ++i)this.processAnimation(t.animations[i], e[0]); this._invokeAll((function (t) { t.afterParse && t.afterParse(e) })) } _invokeAll(e) { for (let t = 0, i = this.plugins.length; t < i; t++)e(this.plugins[t]) } } class GLTFLightExtension { constructor(e) { this.writer = e, this.name = "KHR_lights_punctual" } writeNode(e, t) { if (!e.isLight) return; if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) return void logger.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e); const i = this.writer, r = i.json, n = i.extensionsUsed, a = {}; e.name && (a.name = e.name), a.color = e.color.toArray(), a.intensity = e.intensity, e.isDirectionalLight ? a.type = "directional" : e.isPointLight ? (a.type = "point", e.distance > 0 && (a.range = e.distance)) : e.isSpotLight && (a.type = "spot", e.distance > 0 && (a.range = e.distance), a.spot = {}, a.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, a.spot.outerConeAngle = e.angle), void 0 !== e.decay && 2 !== e.decay && logger.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !e.target || e.target.parent === e && 0 === e.target.position.x && 0 === e.target.position.y && -1 === e.target.position.z || logger.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), n[this.name] || (r.extensions = r.extensions || {}, r.extensions[this.name] = { lights: [] }, n[this.name] = !0); const o = r.extensions[this.name].lights; o.push(a), t.extensions = t.extensions || {}, t.extensions[this.name] = { light: o.length - 1 } } } class GLTFMaterialsUnlitExtension { constructor(e) { this.writer = e, this.name = "KHR_materials_unlit" } writeMaterial(e, t) { if (!e.isMeshBasicMaterial) return; const i = this.writer.extensionsUsed; t.extensions = t.extensions || {}, t.extensions[this.name] = {}, i[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = .9 } } class GLTFMaterialsPBRSpecularGlossiness { constructor(e) { this.writer = e, this.name = "KHR_materials_pbrSpecularGlossiness" } writeMaterial(e, t) { if (!e.isGLTFSpecularGlossinessMaterial) return; const i = this.writer, r = i.extensionsUsed, n = {}; t.pbrMetallicRoughness.baseColorFactor && (n.diffuseFactor = t.pbrMetallicRoughness.baseColorFactor); const a = [1, 1, 1]; if (e.specular.toArray(a, 0), n.specularFactor = a, n.glossinessFactor = e.glossiness, t.pbrMetallicRoughness.baseColorTexture && (n.diffuseTexture = t.pbrMetallicRoughness.baseColorTexture), e.specularMap) { const t = { index: i.processTexture(e.specularMap) }; i.applyTextureTransform(t, e.specularMap), n.specularGlossinessTexture = t } t.extensions = t.extensions || {}, t.extensions[this.name] = n, r[this.name] = !0 } } GLTFExporter.Utils = { insertKeyframe: function (e, t) { const i = .001, r = e.getValueSize(), n = new e.TimeBufferType(e.times.length + 1), a = new e.ValueBufferType(e.values.length + r), o = e.createInterpolant(new e.ValueBufferType(r)); let s; if (0 === e.times.length) { n[0] = t; for (let e = 0; e < r; e++)a[e] = 0; s = 0 } else if (t < e.times[0]) { if (Math.abs(e.times[0] - t) < i) return 0; n[0] = t, n.set(e.times, 1), a.set(o.evaluate(t), 0), a.set(e.values, r), s = 0 } else if (t > e.times[e.times.length - 1]) { if (Math.abs(e.times[e.times.length - 1] - t) < i) return e.times.length - 1; n[n.length - 1] = t, n.set(e.times, 0), a.set(e.values, 0), a.set(o.evaluate(t), e.values.length), s = n.length - 1 } else for (let l = 0; l < e.times.length; l++) { if (Math.abs(e.times[l] - t) < i) return l; if (e.times[l] < t && e.times[l + 1] > t) { n.set(e.times.slice(0, l + 1), 0), n[l + 1] = t, n.set(e.times.slice(l + 1), l + 2), a.set(e.values.slice(0, (l + 1) * r), 0), a.set(o.evaluate(t), (l + 1) * r), a.set(e.values.slice((l + 1) * r), (l + 2) * r), s = l + 1; break } } return e.times = n, e.values = a, s }, mergeMorphTargetTracks: function (e, t) { const i = [], r = {}, n = e.tracks; for (let e = 0; e < n.length; ++e) { let a = n[e]; const o = PropertyBinding.parseTrackName(a.name), s = PropertyBinding.findNode(t, o.nodeName); if ("morphTargetInfluences" !== o.propertyName || void 0 === o.propertyIndex) { i.push(a); continue } if (a.createInterpolant !== a.InterpolantFactoryMethodDiscrete && a.createInterpolant !== a.InterpolantFactoryMethodLinear) { if (a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation."); logger.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), a = a.clone(), a.setInterpolation(InterpolateLinear) } const l = s.morphTargetInfluences.length, c = s.morphTargetDictionary[o.propertyIndex]; if (void 0 === c) throw new Error("THREE.GLTFExporter: Morph target name not found: " + o.propertyIndex); let h; if (void 0 === r[s.uuid]) { h = a.clone(); const e = new h.ValueBufferType(l * h.times.length); for (let t = 0; t < h.times.length; t++)e[t * l + c] = h.values[t]; h.name = (o.nodeName || "") + ".morphTargetInfluences", h.values = e, r[s.uuid] = h, i.push(h); continue } const u = a.createInterpolant(new a.ValueBufferType(1)); h = r[s.uuid]; for (let e = 0; e < h.times.length; e++)h.values[e * l + c] = u.evaluate(h.times[e]); for (let e = 0; e < a.times.length; e++) { const t = this.insertKeyframe(h, a.times[e]); h.values[t * l + c] = a.values[e] } } return e.tracks = i, e } }; let _arrayBufferToBlob$1 = e => new Blob([e], { type: "application/octet-stream" }); class DHExporter { constructor(e, t) { this._scene = e, this._context = t, this._gltfExporter = new GLTFExporter } concat(...e) { let t = 0; for (let i of e) t += i.length; let i = new Uint8Array(t), r = 0; for (let t of e) i.set(t, r), r += t.length; return i } exportBlob({ type: e = "glb", maxTextureSize: t, onFinish: i, onError: r }) { logger.debug(this._context.getSettings()); let n = new Group; n.userData.dhExtension = JSON.parse(JSON.stringify(_context.sceneSettings)), n.userData.dhExtension.VERSION = "20220602-NEW-AVWS"; let a = _context.cacheStore.getPublishSceneObject3D(_context.sceneSettings); n.add(a), _context.sceneSettings.cache.forEach(((e, t) => { if (e.refCount > 1) { let t = _context.cacheStore._cache.get(md5(e.resourcePath)); t ? (t.resource.userData = { needExport: t.needExport, refCount: t.refCount, resourcePath: t.resourcePath, type: t.type }, n.add(t.resource)) : window.logger.warn(`${e.resourcePath}-资源丢失`) } })); let o = _context.customTextureStore.getExportTextureGroup(); switch (o && n.add(o), e.toLowerCase()) { case "glb": default: let e = { trs: !0, onlyVisible: !1, truncateDrawRange: !0, binary: !0, forcePowerOfTwoTextures: !0, includeCustomExtensions: !0, maxTextureSize: t || 1 / 0 }; this._gltfExporter.parse(n, (e => { e instanceof ArrayBuffer && i && i(_arrayBufferToBlob$1(e)) }), e) } } } const instanceOfAny = (e, t) => t.some((t => e instanceof t)); let idbProxyableTypes, cursorAdvanceMethods; function getIdbProxyableTypes() { return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]) } function getCursorAdvanceMethods() { return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]) } const cursorRequestMap = new WeakMap, transactionDoneMap = new WeakMap, transactionStoreNamesMap = new WeakMap, transformCache = new WeakMap, reverseTransformCache = new WeakMap; function promisifyRequest(e) { const t = new Promise(((t, i) => { const r = () => { e.removeEventListener("success", n), e.removeEventListener("error", a) }, n = () => { t(wrap(e.result)), r() }, a = () => { i(e.error), r() }; e.addEventListener("success", n), e.addEventListener("error", a) })); return t.then((t => { t instanceof IDBCursor && cursorRequestMap.set(t, e) })).catch((() => { })), reverseTransformCache.set(t, e), t } function cacheDonePromiseForTransaction(e) { if (transactionDoneMap.has(e)) return; const t = new Promise(((t, i) => { const r = () => { e.removeEventListener("complete", n), e.removeEventListener("error", a), e.removeEventListener("abort", a) }, n = () => { t(), r() }, a = () => { i(e.error || new DOMException("AbortError", "AbortError")), r() }; e.addEventListener("complete", n), e.addEventListener("error", a), e.addEventListener("abort", a) })); transactionDoneMap.set(e, t) } let idbProxyTraps = { get(e, t, i) { if (e instanceof IDBTransaction) { if ("done" === t) return transactionDoneMap.get(e); if ("objectStoreNames" === t) return e.objectStoreNames || transactionStoreNamesMap.get(e); if ("store" === t) return i.objectStoreNames[1] ? void 0 : i.objectStore(i.objectStoreNames[0]) } return wrap(e[t]) }, set: (e, t, i) => (e[t] = i, !0), has: (e, t) => e instanceof IDBTransaction && ("done" === t || "store" === t) || t in e }; function replaceTraps(e) { idbProxyTraps = e(idbProxyTraps) } function wrapFunction(e) { return e !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? getCursorAdvanceMethods().includes(e) ? function (...t) { return e.apply(unwrap(this), t), wrap(cursorRequestMap.get(this)) } : function (...t) { return wrap(e.apply(unwrap(this), t)) } : function (t, ...i) { const r = e.call(unwrap(this), t, ...i); return transactionStoreNamesMap.set(r, t.sort ? t.sort() : [t]), wrap(r) } } function transformCachableValue(e) { return "function" == typeof e ? wrapFunction(e) : (e instanceof IDBTransaction && cacheDonePromiseForTransaction(e), instanceOfAny(e, getIdbProxyableTypes()) ? new Proxy(e, idbProxyTraps) : e) } function wrap(e) { if (e instanceof IDBRequest) return promisifyRequest(e); if (transformCache.has(e)) return transformCache.get(e); const t = transformCachableValue(e); return t !== e && (transformCache.set(e, t), reverseTransformCache.set(t, e)), t } const unwrap = e => reverseTransformCache.get(e); function openDB(e, t, { blocked: i, upgrade: r, blocking: n, terminated: a } = {}) { const o = indexedDB.open(e, t), s = wrap(o); return r && o.addEventListener("upgradeneeded", (e => { r(wrap(o.result), e.oldVersion, e.newVersion, wrap(o.transaction)) })), i && o.addEventListener("blocked", (() => i())), s.then((e => { a && e.addEventListener("close", (() => a())), n && e.addEventListener("versionchange", (() => n())) })).catch((() => { })), s } const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"], writeMethods = ["put", "add", "delete", "clear"], cachedMethods = new Map; function getMethod(e, t) { if (!(e instanceof IDBDatabase) || t in e || "string" != typeof t) return; if (cachedMethods.get(t)) return cachedMethods.get(t); const i = t.replace(/FromIndex$/, ""), r = t !== i, n = writeMethods.includes(i); if (!(i in (r ? IDBIndex : IDBObjectStore).prototype) || !n && !readMethods.includes(i)) return; const a = async function (e, ...t) { const a = this.transaction(e, n ? "readwrite" : "readonly"); let o = a.store; return r && (o = o.index(t.shift())), (await Promise.all([o[i](...t), n && a.done]))[0] }; return cachedMethods.set(t, a), a } replaceTraps((e => ({ ...e, get: (t, i, r) => getMethod(t, i) || e.get(t, i, r), has: (t, i) => !!getMethod(t, i) || e.has(t, i) }))); var DHLoader = function () { function e(e) { Loader.call(this, e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.dbPromise = openDB(INDEXED_DB_NAME, INDEXED_DB_VERSION, { upgrade(e, t, i, r) { e.createObjectStore(INDEXED_DB_OBJECT_STORE) }, blocked() { logger.warn("indexeddb request blocked.") }, blocking() { logger.warn("indexeddb blocking another request.") }, terminated() { logger.warn("indexeddb request terminated.") } }), this.register((function (e) { return new a(e) })), this.register((function (e) { return new s(e) })), this.register((function (e) { return new l(e) })), this.register((function (e) { return new o(e) })), this.register((function (e) { return new r(e) })), this.register((function (e) { return new c(e) })) } function t() { var e = {}; return { get: function (t) { return e[t] }, add: function (t, i) { e[t] = i }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } e.prototype = Object.assign(Object.create(Loader.prototype), { constructor: e, load: function (e, t, i, r, n) { var a, o = this; a = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : LoaderUtils.extractUrlBase(e), this.manager.itemStart(e); var s = function (t) { r ? r(t) : logger.error(t), o.manager.itemError(e), o.manager.itemEnd(e) }, l = new FileLoader(this.manager); l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials); let c = []; for (let e in this.requestHeader) c.push({ key: e, value: this.requestHeader[e] }); let h = util$1.fetchContentLastModified(e, c), u = md5(e); h.then((r => { if ("0" === r) return void l.load(e, (function (i) { try { o.parse(i, a, (function (i) { t(i), o.manager.itemEnd(e) }), s) } catch (e) { s(e) } }), i, s); let c = md5(r); this.dbPromise.then((r => { r.getAllKeys(INDEXED_DB_OBJECT_STORE).then((h => { let d = !1; for (let n of h) if (0 === n.indexOf(u)) { n === `${u}:${c}` ? (d = !0, r.get(INDEXED_DB_OBJECT_STORE, n).then((r => { let n = r.byteLength; i && i({ type: "progress", total: n, loaded: n / 2 }); try { o.parse(r, a, (function (r) { i && i({ type: "progress", total: n, loaded: n }), t(r), o.manager.itemEnd(e) }), s) } catch (e) { s(e) } }))) : r.delete(INDEXED_DB_OBJECT_STORE, n).then((() => { })); break } if (!d) { let h = l.load(e, (function (i) { try { o.parse(i, a, (function (i) { t(i), o.manager.itemEnd(e) }), s), r.put(INDEXED_DB_OBJECT_STORE, i, `${u}:${c}`).then((() => { logger.debug("db.put(CONST.INDEXED_DB_OBJECT_STORE, data, `${urlKey}:${lastModifiedKey}`)") })) } catch (e) { s(e) } }), i, s); n && n(h) } })) })) })).catch((() => { let r = l.load(e, (function (i) { try { o.parse(i, a, (function (i) { t(i), o.manager.itemEnd(e) }), s) } catch (e) { s(e) } }), i, s); n && n(r) })) }, setDRACOLoader: function (e) { return this.dracoLoader = e, this }, setDDSLoader: function () { throw new Error('THREE.DHLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') }, setKTX2Loader: function (e) { return this.ktx2Loader = e, this }, setMeshoptDecoder: function (e) { return this.meshoptDecoder = e, this }, register: function (e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this }, unregister: function (e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this }, parse: function (e, t, r, a) { var o, s = {}, l = {}; if ("string" == typeof e) o = e; else { let t = new Uint8Array(e, 0, AVW_HEADER.length); if (t[0] === AVW_HEADER[0] && t[AVW_HEADER.length - 1] === AVW_HEADER[AVW_HEADER.length - 1]) { e = e.slice(AVW_HEADER.length, e.byteLength); let t = new Uint8Array(e), i = 8 - AVW_STEP; for (let e = 0; e < t.length; e++)t[e] = t[e] << AVW_STEP | t[e] >> i } if (LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === h) { try { s[i.KHR_BINARY_GLTF] = new p(e) } catch (e) { return void (a && a(e)) } o = s[i.KHR_BINARY_GLTF].content } else o = LoaderUtils.decodeText(new Uint8Array(e)) } var c = JSON.parse(o); if (void 0 === c.asset || c.asset.version[0] < 2) a && a(new Error("THREE.DHLoader: Unsupported asset. glTF versions >=2.0 are supported.")); else { var u = new H(c, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); u.fileLoader.setRequestHeader(this.requestHeader); for (var d = 0; d < this.pluginCallbacks.length; d++) { var g = this.pluginCallbacks[d](u); l[g.name] = g, s[g.name] = !0 } if (c.extensionsUsed) for (d = 0; d < c.extensionsUsed.length; ++d) { var _ = c.extensionsUsed[d], b = c.extensionsRequired || []; switch (_) { case i.KHR_MATERIALS_UNLIT: s[_] = new n; break; case i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: s[_] = new y; break; case i.KHR_DRACO_MESH_COMPRESSION: s[_] = new f(c, this.dracoLoader); break; case i.KHR_TEXTURE_TRANSFORM: s[_] = new m; break; case i.KHR_MESH_QUANTIZATION: s[_] = new v; break; default: b.indexOf(_) >= 0 && void 0 === l[_] && logger.warn('THREE.DHLoader: Unknown extension "' + _ + '".') } } u.setExtensions(s), u.setPlugins(l), u.parse(r, a) } } }); var i = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" }; function r(e) { this.parser = e, this.name = i.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } function n() { this.name = i.KHR_MATERIALS_UNLIT } function a(e) { this.parser = e, this.name = i.KHR_MATERIALS_CLEARCOAT } function o(e) { this.parser = e, this.name = i.KHR_MATERIALS_TRANSMISSION } function s(e) { this.parser = e, this.name = i.KHR_TEXTURE_BASISU } function l(e) { this.parser = e, this.name = i.EXT_TEXTURE_WEBP, this.isSupported = null } function c(e) { this.name = i.EXT_MESHOPT_COMPRESSION, this.parser = e } r.prototype._markDefs = function () { for (var e = this.parser, t = this.parser.json.nodes || [], i = 0, r = t.length; i < r; i++) { var n = t[i]; n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && e._addNodeRef(this.cache, n.extensions[this.name].light) } }, r.prototype._loadLight = function (e) { var t = this.parser, i = "light:" + e, r = t.cache.get(i); if (r) return r; var n, a = t.json, o = ((a.extensions && a.extensions[this.name] || {}).lights || [])[e], s = new Color$1(16777215); void 0 !== o.color && s.fromArray(o.color); var l = void 0 !== o.range ? o.range : 0; switch (o.type) { case "directional": (n = new DirectionalLight(s)).target.position.set(0, 0, -1), n.add(n.target); break; case "point": (n = new PointLight(s)).distance = l; break; case "spot": (n = new SpotLight(s)).distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, n.angle = o.spot.outerConeAngle, n.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, n.target.position.set(0, 0, -1), n.add(n.target); break; default: throw new Error("THREE.DHLoader: Unexpected light type: " + o.type) }return n.position.set(0, 0, 0), n.decay = 2, void 0 !== o.intensity && (n.intensity = o.intensity), n.name = t.createUniqueName(o.name || "light_" + e), r = Promise.resolve(n), t.cache.add(i, r), r }, r.prototype.createNodeAttachment = function (e) { var t = this, i = this.parser, r = i.json.nodes[e], n = (r.extensions && r.extensions[this.name] || {}).light; return void 0 === n ? null : this._loadLight(n).then((function (e) { return i._getNodeRef(t.cache, n, e) })) }, n.prototype.getMaterialType = function () { return MeshBasicMaterial }, n.prototype.extendParams = function (e, t, i) { var r = []; e.color = new Color$1(1, 1, 1), e.opacity = 1; var n = t.pbrMetallicRoughness; if (n) { if (Array.isArray(n.baseColorFactor)) { var a = n.baseColorFactor; e.color.fromArray(a), e.opacity = a[3] } void 0 !== n.baseColorTexture && r.push(i.assignTexture(e, "map", n.baseColorTexture)) } return Promise.all(r) }, a.prototype.getMaterialType = function (e) { var t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null }, a.prototype.extendMaterialParams = function (e, t) { var i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); var n = [], a = r.extensions[this.name]; if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && n.push(i.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && n.push(i.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (n.push(i.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) { var o = a.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new Vector2(o, -o) } return Promise.all(n) }, o.prototype.getMaterialType = function (e) { var t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null }, o.prototype.extendMaterialParams = function (e, t) { var i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); var n = [], a = r.extensions[this.name]; return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor), void 0 !== a.transmissionTexture && n.push(i.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(n) }, s.prototype.loadTexture = function (e) { var t = this.parser, i = t.json, r = i.textures[e]; if (!r.extensions || !r.extensions[this.name]) return null; var n = r.extensions[this.name], a = i.images[n.source], o = t.options.ktx2Loader; if (!o) { if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.DHLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, a, o) }, l.prototype.loadTexture = function (e) { var t = this.name, i = this.parser, r = i.json, n = r.textures[e]; if (!n.extensions || !n.extensions[t]) return null; var a = n.extensions[t], o = r.images[a.source], s = i.textureLoader; if (o.uri) { var l = i.options.manager.getHandler(o.uri); null !== l && (s = l) } return this.detectSupport().then((function (n) { if (n) return i.loadTextureImage(e, o, s); if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.DHLoader: WebP required by asset but unsupported."); return i.loadTexture(e) })) }, l.prototype.detectSupport = function () { return this.isSupported || (this.isSupported = new Promise((function (e) { var t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported }, c.prototype.loadBufferView = function (e) { var t = this.parser.json, i = t.bufferViews[e]; if (i.extensions && i.extensions[this.name]) { var r = i.extensions[this.name], n = this.parser.getDependency("buffer", r.buffer), a = this.parser.options.meshoptDecoder; if (!a || !a.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.DHLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return Promise.all([n, a.ready]).then((function (e) { var t = r.byteOffset || 0, i = r.byteLength || 0, n = r.count, o = r.byteStride, s = new ArrayBuffer(n * o), l = new Uint8Array(e[0], t, i); return a.decodeGltfBuffer(new Uint8Array(s), n, o, l, r.mode, r.filter), s })) } return null }; var h = "glTF", u = 1313821514, d = 5130562; function p(e) { this.name = i.KHR_BINARY_GLTF, this.content = null, this.body = null; var t = new DataView(e, 0, 12); if (this.header = { magic: LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== h) throw new Error("THREE.DHLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.DHLoader: Legacy binary file detected."); for (var r = this.header.length - 12, n = new DataView(e, 12), a = 0; a < r;) { var o = n.getUint32(a, !0); a += 4; var s = n.getUint32(a, !0); if (a += 4, s === u) { var l = new Uint8Array(e, 12 + a, o); this.content = LoaderUtils.decodeText(l) } else if (s === d) { var c = 12 + a; this.body = e.slice(c, c + o) } a += o } if (null === this.content) throw new Error("THREE.DHLoader: JSON content not found.") } function f(e, t) { if (!t) throw new Error("THREE.DHLoader: No DRACOLoader instance provided."); this.name = i.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } function m() { this.name = i.KHR_TEXTURE_TRANSFORM } function g(e) { MeshStandardMaterial.call(this), this.isGLTFSpecularGlossinessMaterial = !0; var t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), i = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), n = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), a = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), o = { specular: { value: (new Color$1).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = o, this.onBeforeCompile = function (e) { for (var s in o) e.uniforms[s] = o[s]; e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", n).replace("#include <lights_physical_fragment>", a) }, Object.defineProperties(this, { specular: { get: function () { return o.specular.value }, set: function (e) { o.specular.value = e } }, specularMap: { get: function () { return o.specularMap.value }, set: function (e) { o.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function () { return o.glossiness.value }, set: function (e) { o.glossiness.value = e } }, glossinessMap: { get: function () { return o.glossinessMap.value }, set: function (e) { o.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e) } function y() { return { name: i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"], getMaterialType: function () { return g }, extendParams: function (e, t, i) { var r = t.extensions[this.name]; e.color = new Color$1(1, 1, 1), e.opacity = 1; var n = []; if (Array.isArray(r.diffuseFactor)) { var a = r.diffuseFactor; e.color.fromArray(a), e.opacity = a[3] } if (void 0 !== r.diffuseTexture && n.push(i.assignTexture(e, "map", r.diffuseTexture)), e.emissive = new Color$1(0, 0, 0), e.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, e.specular = new Color$1(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) { var o = r.specularGlossinessTexture; n.push(i.assignTexture(e, "glossinessMap", o)), n.push(i.assignTexture(e, "specularMap", o)) } return Promise.all(n) }, createMaterial: function (e) { var t = new g(e); return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = TangentSpaceNormalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } } function v() { this.name = i.KHR_MESH_QUANTIZATION } function _(e, t, i, r) { Interpolant.call(this, e, t, i, r) } f.prototype.decodePrimitive = function (e, t) { var i = this.json, r = this.dracoLoader, n = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, s = {}, l = {}; for (var c in a) { var h = D[c] || c.toLowerCase(); o[h] = a[c] } for (c in e.attributes) { h = D[c] || c.toLowerCase(); if (void 0 !== a[c]) { var u = i.accessors[e.attributes[c]], d = E[u.componentType]; l[h] = d, s[h] = !0 === u.normalized } } return t.getDependency("bufferView", n).then((function (e) { return new Promise((function (t) { r.decodeDracoFile(e, (function (e) { for (var i in e.attributes) { var r = e.attributes[i], n = s[i]; void 0 !== n && (r.normalized = n) } t(e) }), o, l) })) })) }, m.prototype.extendTexture = function (e, t) { return e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), void 0 !== t.texCoord && logger.warn('THREE.DHLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), e.needsUpdate = !0, e }, g.prototype = Object.create(MeshStandardMaterial.prototype), g.prototype.constructor = g, g.prototype.copy = function (e) { return MeshStandardMaterial.prototype.copy.call(this, e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this }, _.prototype = Object.create(Interpolant.prototype), _.prototype.constructor = _, _.prototype.copySampleValue_ = function (e) { for (var t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, n = e * r * 3 + r, a = 0; a !== r; a++)t[a] = i[n + a]; return t }, _.prototype.beforeStart_ = _.prototype.copySampleValue_, _.prototype.afterEnd_ = _.prototype.copySampleValue_, _.prototype.interpolate_ = function (e, t, i, r) { for (var n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = 2 * o, l = 3 * o, c = r - t, h = (i - t) / c, u = h * h, d = u * h, p = e * l, f = p - l, m = -2 * d + 3 * u, g = d - u, y = 1 - m, v = g - u + h, _ = 0; _ !== o; _++) { var b = a[f + _ + o], x = a[f + _ + s] * c, w = a[p + _ + o], S = a[p + _] * c; n[_] = y * b + v * x + m * w + g * S } return n }; var b = 0, x = 1, w = 2, S = 3, M = 4, T = 5, A = 6, E = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, C = { 9728: NearestFilter, 9729: LinearFilter, 9984: NearestMipmapNearestFilter, 9985: LinearMipmapNearestFilter, 9986: NearestMipmapLinearFilter, 9987: LinearMipmapLinearFilter }, L = { 33071: ClampToEdgeWrapping, 33648: MirroredRepeatWrapping, 10497: RepeatWrapping }, R = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, D = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, P = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, O = { CUBICSPLINE: void 0, LINEAR: InterpolateLinear, STEP: InterpolateDiscrete }, I = "OPAQUE", k = "MASK", B = "BLEND"; function N(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } function F(e, t, i) { for (var r in i.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = i.extensions[r]) } function U(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : logger.warn("THREE.DHLoader: Ignoring primitive type .extras, " + t.extras)) } function z(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (var i = 0, r = t.weights.length; i < r; i++)e.morphTargetInfluences[i] = t.weights[i]; if (t.extras && Array.isArray(t.extras.targetNames)) { var n = t.extras.targetNames; if (e.morphTargetInfluences.length === n.length) { e.morphTargetDictionary = {}; for (i = 0, r = n.length; i < r; i++)e.morphTargetDictionary[n[i]] = i } else logger.warn("THREE.DHLoader: Invalid extras.targetNames length. Ignoring names.") } } function G(e) { for (var t = "", i = Object.keys(e).sort(), r = 0, n = i.length; r < n; r++)t += i[r] + ":" + e[i[r]] + ";"; return t } function H(e, i) { this.json = e || {}, this.extensions = {}, this.plugins = {}, this.options = i || {}, this.cache = new t, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new ImageBitmapLoader(this.options.manager) : this.textureLoader = new TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } function V(e, t, i) { var r = t.attributes, n = []; function a(t, r) { return i.getDependency("accessor", t).then((function (t) { e.setAttribute(r, t) })) } for (var o in r) { var s = D[o] || o.toLowerCase(); s in e.attributes || n.push(a(r[o], s)) } if (void 0 !== t.indices && !e.index) { var l = i.getDependency("accessor", t.indices).then((function (t) { e.setIndex(t) })); n.push(l) } return U(e, t), function (e, t, i) { var r = t.attributes, n = new Box3; if (void 0 !== r.POSITION) { var a = (d = i.json.accessors[r.POSITION]).min, o = d.max; if (void 0 !== a && void 0 !== o) { n.set(new Vector3(a[0], a[1], a[2]), new Vector3(o[0], o[1], o[2])); var s = t.targets; if (void 0 !== s) { for (var l = new Vector3, c = new Vector3, h = 0, u = s.length; h < u; h++) { var d, p = s[h]; if (void 0 !== p.POSITION) a = (d = i.json.accessors[p.POSITION]).min, o = d.max, void 0 !== a && void 0 !== o ? (c.setX(Math.max(Math.abs(a[0]), Math.abs(o[0]))), c.setY(Math.max(Math.abs(a[1]), Math.abs(o[1]))), c.setZ(Math.max(Math.abs(a[2]), Math.abs(o[2]))), l.max(c)) : logger.warn("THREE.DHLoader: Missing min/max properties for accessor POSITION.") } n.expandByVector(l) } e.boundingBox = n; var f = new Sphere; n.getCenter(f.center), f.radius = n.min.distanceTo(n.max) / 2, e.boundingSphere = f } else logger.warn("THREE.DHLoader: Missing min/max properties for accessor POSITION.") } }(e, t, i), Promise.all(n).then((function () { return void 0 !== t.targets ? function (e, t, i) { for (var r = !1, n = !1, a = 0, o = t.length; a < o && (void 0 !== (c = t[a]).POSITION && (r = !0), void 0 !== c.NORMAL && (n = !0), !r || !n); a++); if (!r && !n) return Promise.resolve(e); var s = [], l = []; for (a = 0, o = t.length; a < o; a++) { var c = t[a]; if (r) { var h = void 0 !== c.POSITION ? i.getDependency("accessor", c.POSITION) : e.attributes.position; s.push(h) } n && (h = void 0 !== c.NORMAL ? i.getDependency("accessor", c.NORMAL) : e.attributes.normal, l.push(h)) } return Promise.all([Promise.all(s), Promise.all(l)]).then((function (t) { var i = t[0], a = t[1]; return r && (e.morphAttributes.position = i), n && (e.morphAttributes.normal = a), e.morphTargetsRelative = !0, e })) }(e, t.targets, i) : e })) } function j(e, t) { var i = e.getIndex(); if (null === i) { var r = [], n = e.getAttribute("position"); if (void 0 === n) return logger.error("THREE.DHLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (var a = 0; a < n.count; a++)r.push(a); e.setIndex(r), i = e.getIndex() } var o = i.count - 2, s = []; if (t === TriangleFanDrawMode) for (a = 1; a <= o; a++)s.push(i.getX(0)), s.push(i.getX(a)), s.push(i.getX(a + 1)); else for (a = 0; a < o; a++)a % 2 == 0 ? (s.push(i.getX(a)), s.push(i.getX(a + 1)), s.push(i.getX(a + 2))) : (s.push(i.getX(a + 2)), s.push(i.getX(a + 1)), s.push(i.getX(a))); s.length / 3 !== o && logger.error("THREE.DHLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); var l = e.clone(); return l.setIndex(s), l } return H.prototype.setExtensions = function (e) { this.extensions = e }, H.prototype.setPlugins = function (e) { this.plugins = e }, H.prototype.parse = function (e, t) { var i = this, r = this.json, n = this.extensions; this.cache.removeAll(), this._invokeAll((function (e) { return e._markDefs && e._markDefs() })), Promise.all(this._invokeAll((function (e) { return e.beforeRoot && e.beforeRoot() }))).then((function () { return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")]) })).then((function (t) { var a = { scene: t[0][r.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: r.asset, parser: i, userData: {} }; F(n, a, r), U(a, r), Promise.all(i._invokeAll((function (e) { return e.afterRoot && e.afterRoot(a) }))).then((function () { e(a) })) })).catch(t) }, H.prototype._markDefs = function () { for (var e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || [], r = 0, n = t.length; r < n; r++)for (var a = t[r].joints, o = 0, s = a.length; o < s; o++)e[a[o]].isBone = !0; for (var l = 0, c = e.length; l < c; l++) { var h = e[l]; void 0 !== h.mesh && (this._addNodeRef(this.meshCache, h.mesh), void 0 !== h.skin && (i[h.mesh].isSkinnedMesh = !0)), void 0 !== h.camera && this._addNodeRef(this.cameraCache, h.camera) } }, H.prototype._addNodeRef = function (e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) }, H.prototype._getNodeRef = function (e, t, i) { if (e.refs[t] <= 1) return i; var r = i.clone(); return r.name += "_instance_" + e.uses[t]++, r }, H.prototype._invokeOne = function (e) { var t = Object.values(this.plugins); t.push(this); for (var i = 0; i < t.length; i++) { var r = e(t[i]); if (r) return r } }, H.prototype._invokeAll = function (e) { var t = Object.values(this.plugins); t.unshift(this); for (var i = [], r = 0; r < t.length; r++) { var n = e(t[r]); n && i.push(n) } return i }, H.prototype.getDependency = function (e, t) { var i = e + ":" + t, r = this.cache.get(i); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this.loadNode(t); break; case "mesh": r = this._invokeOne((function (e) { return e.loadMesh && e.loadMesh(t) })); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this._invokeOne((function (e) { return e.loadBufferView && e.loadBufferView(t) })); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this._invokeOne((function (e) { return e.loadMaterial && e.loadMaterial(t) })); break; case "texture": r = this._invokeOne((function (e) { return e.loadTexture && e.loadTexture(t) })); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this.loadAnimation(t); break; case "camera": r = this.loadCamera(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(i, r) } return r }, H.prototype.getDependencies = function (e) { var t = this.cache.get(e); if (!t) { var i = this, r = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(r.map((function (t, r) { return i.getDependency(e, r) }))), this.cache.add(e, t) } return t }, H.prototype.loadBuffer = function (e) { var t = this.json.buffers[e], r = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.DHLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[i.KHR_BINARY_GLTF].body); var n = this.options; return new Promise((function (e, i) { r.load(N(t.uri, n.path), e, void 0, (function () { i(new Error('THREE.DHLoader: Failed to load buffer "' + t.uri + '".')) })) })) }, H.prototype.loadBufferView = function (e) { var t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then((function (e) { var i = t.byteLength || 0, r = t.byteOffset || 0; return e.slice(r, r + i) })) }, H.prototype.loadAccessor = function (e) { var t = this, i = this.json, r = this.json.accessors[e]; if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null); var n = []; return void 0 !== r.bufferView ? n.push(this.getDependency("bufferView", r.bufferView)) : n.push(null), void 0 !== r.sparse && (n.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), n.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(n).then((function (e) { var n, a = e[0], o = R[r.type], s = E[r.componentType], l = s.BYTES_PER_ELEMENT, c = l * o, h = r.byteOffset || 0, u = void 0 !== r.bufferView ? i.bufferViews[r.bufferView].byteStride : void 0, d = !0 === r.normalized; if (u && u !== c) { var p = Math.floor(h / u), f = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + p + ":" + r.count, m = t.cache.get(f); m || (m = new InterleavedBuffer(new s(a, p * u, r.count * u / l), u / l), t.cache.add(f, m)), n = new InterleavedBufferAttribute(m, o, h % u / l, d) } else n = new BufferAttribute(null === a ? new s(r.count * o) : new s(a, h, r.count * o), o, d); if (void 0 !== r.sparse) { var g = R.SCALAR, y = E[r.sparse.indices.componentType], v = r.sparse.indices.byteOffset || 0, _ = r.sparse.values.byteOffset || 0, b = new y(e[1], v, r.sparse.count * g), x = new s(e[2], _, r.sparse.count * o); null !== a && (n = new BufferAttribute(n.array.slice(), n.itemSize, n.normalized)); for (var w = 0, S = b.length; w < S; w++) { var M = b[w]; if (n.setX(M, x[w * o]), o >= 2 && n.setY(M, x[w * o + 1]), o >= 3 && n.setZ(M, x[w * o + 2]), o >= 4 && n.setW(M, x[w * o + 3]), o >= 5) throw new Error("THREE.DHLoader: Unsupported itemSize in sparse BufferAttribute.") } } return n })) }, H.prototype.loadTexture = function (e) { var t = this.json, i = this.options, r = t.textures[e], n = t.images[r.source], a = this.textureLoader; if (n.uri) { var o = i.manager.getHandler(n.uri); null !== o && (a = o) } return this.loadTextureImage(e, n, a) }, H.prototype.loadTextureImage = function (e, t, i) { var r = this, n = this.json, a = this.options, o = n.textures[e], s = self.URL || self.webkitURL, l = t.uri, c = !1, h = !0; if ("image/jpeg" === t.mimeType && (h = !1), void 0 !== t.bufferView) l = r.getDependency("bufferView", t.bufferView).then((function (e) { if ("image/png" === t.mimeType) { var i = new DataView(e, 25, 1).getUint8(0, !1); h = 6 === i || 4 === i || 3 === i } if (c = !0, ImageBitMapCache.has(t)) return ImageBitMapCache.get(t); var r = new Blob([e], { type: t.mimeType }); return l = s.createObjectURL(r), ImageBitMapCache.set(t, l), l })); else if (void 0 === t.uri) throw new Error("THREE.DHLoader: Image " + e + " is missing URI and bufferView"); return Promise.resolve(l).then((function (e) { return new Promise((function (t, r) { var n = t; !0 === i.isImageBitmapLoader && (n = function (e) { t(new CanvasTexture(e)) }), i.load(N(e, a.path), n, void 0, r) })) })).then((function (t) { !0 === c && s.revokeObjectURL(l), t.flipY = !1, o.name && (t.name = o.name), h || (t.format = RGBFormat); var i = (n.samplers || {})[o.sampler] || {}; return t.magFilter = C[i.magFilter] || LinearFilter, t.minFilter = C[i.minFilter] || LinearMipmapLinearFilter, t.wrapS = L[i.wrapS] || RepeatWrapping, t.wrapT = L[i.wrapT] || RepeatWrapping, r.associations.set(t, { type: "textures", index: e }), t })) }, H.prototype.assignTexture = function (e, t, r) { var n = this; return this.getDependency("texture", r.index).then((function (a) { if (void 0 === r.texCoord || 0 == r.texCoord || "aoMap" === t && 1 == r.texCoord || logger.warn("THREE.DHLoader: Custom UV set " + r.texCoord + " for texture " + t + " not yet supported."), n.extensions[i.KHR_TEXTURE_TRANSFORM]) { var o = void 0 !== r.extensions ? r.extensions[i.KHR_TEXTURE_TRANSFORM] : void 0; if (o) { var s = n.associations.get(a); a = n.extensions[i.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), n.associations.set(a, s) } } e[t] = a })) }, H.prototype.assignFinalMaterial = function (e) { var t = e.geometry, i = e.material, r = void 0 !== t.attributes.tangent, n = void 0 !== t.attributes.color, a = void 0 === t.attributes.normal, o = !0 === e.isSkinnedMesh, s = Object.keys(t.morphAttributes).length > 0, l = s && void 0 !== t.morphAttributes.normal; if (e.isPoints) { var c = "PointsMaterial:" + i.uuid, h = this.cache.get(c); h || (h = new PointsMaterial, Material$1.prototype.copy.call(h, i), h.color.copy(i.color), h.map = i.map, h.sizeAttenuation = !1, this.cache.add(c, h)), i = h } else if (e.isLine) { c = "LineBasicMaterial:" + i.uuid; var u = this.cache.get(c); u || (u = new LineBasicMaterial, Material$1.prototype.copy.call(u, i), u.color.copy(i.color), this.cache.add(c, u)), i = u } if (r || n || a || o || s) { c = "ClonedMaterial:" + i.uuid + ":"; i.isGLTFSpecularGlossinessMaterial && (c += "specular-glossiness:"), o && (c += "skinning:"), r && (c += "vertex-tangents:"), n && (c += "vertex-colors:"), a && (c += "flat-shading:"), s && (c += "morph-targets:"), l && (c += "morph-normals:"); var d = this.cache.get(c); d || (d = i.clone(), o && (d.skinning = !0), n && (d.vertexColors = !0), a && (d.flatShading = !0), s && (d.morphTargets = !0), l && (d.morphNormals = !0), r && (d.vertexTangents = !0, d.normalScale && (d.normalScale.y *= -1), d.clearcoatNormalScale && (d.clearcoatNormalScale.y *= -1)), this.cache.add(c, d), this.associations.set(d, this.associations.get(i))), i = d } i.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = i }, H.prototype.getMaterialType = function () { return MeshStandardMaterial }, H.prototype.loadMaterial = function (e) { var t, r = this, n = this.json, a = this.extensions, o = n.materials[e], s = {}, l = o.extensions || {}, c = []; if (l[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { var h = a[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; t = h.getMaterialType(), c.push(h.extendParams(s, o, r)) } else if (l[i.KHR_MATERIALS_UNLIT] && a[i.KHR_MATERIALS_UNLIT]) { var u = a[i.KHR_MATERIALS_UNLIT]; t = u.getMaterialType(), c.push(u.extendParams(s, o, r)) } else { var d = o.pbrMetallicRoughness || {}; if (s.color = new Color$1(1, 1, 1), s.opacity = 1, Array.isArray(d.baseColorFactor)) { var p = d.baseColorFactor; s.color.fromArray(p), s.opacity = p[3] } void 0 !== d.baseColorTexture && c.push(r.assignTexture(s, "map", d.baseColorTexture)), s.metalness = void 0 !== d.metallicFactor ? d.metallicFactor : 1, s.roughness = void 0 !== d.roughnessFactor ? d.roughnessFactor : 1, void 0 !== d.metallicRoughnessTexture && (c.push(r.assignTexture(s, "metalnessMap", d.metallicRoughnessTexture)), c.push(r.assignTexture(s, "roughnessMap", d.metallicRoughnessTexture))), t = this._invokeOne((function (t) { return t.getMaterialType && t.getMaterialType(e) })), c.push(Promise.all(this._invokeAll((function (t) { return t.extendMaterialParams && t.extendMaterialParams(e, s) })))) } !0 === o.doubleSided && (s.side = DoubleSide); var f = o.alphaMode || I; return f === B ? (s.transparent = !0, s.depthWrite = !1) : (s.transparent = !1, f === k && (s.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : .5)), void 0 !== o.normalTexture && t !== MeshBasicMaterial && (c.push(r.assignTexture(s, "normalMap", o.normalTexture)), s.normalScale = new Vector2(1, -1), void 0 !== o.normalTexture.scale && s.normalScale.set(o.normalTexture.scale, -o.normalTexture.scale)), void 0 !== o.occlusionTexture && t !== MeshBasicMaterial && (c.push(r.assignTexture(s, "aoMap", o.occlusionTexture)), void 0 !== o.occlusionTexture.strength && (s.aoMapIntensity = o.occlusionTexture.strength)), void 0 !== o.emissiveFactor && t !== MeshBasicMaterial && (s.emissive = (new Color$1).fromArray(o.emissiveFactor)), void 0 !== o.emissiveTexture && t !== MeshBasicMaterial && c.push(r.assignTexture(s, "emissiveMap", o.emissiveTexture)), Promise.all(c).then((function () { var n; return n = t === g ? a[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s) : new t(s), o.name && (n.name = o.name), n.map && (n.map.encoding = sRGBEncoding), n.emissiveMap && (n.emissiveMap.encoding = sRGBEncoding), U(n, o), r.associations.set(n, { type: "materials", index: e }), o.extensions && F(a, n, o), n })) }, H.prototype.createUniqueName = function (e) { for (var t = PropertyBinding.sanitizeNodeName(e || ""), i = t, r = 1; this.nodeNamesUsed[i]; ++r)i = t + "_" + r; return this.nodeNamesUsed[i] = !0, i }, H.prototype.loadGeometries = function (e) { var t = this, r = this.extensions, n = this.primitiveCache; function a(e) { return r[i.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (i) { return V(i, e, t) })) } for (var o, s, l = [], c = 0, h = e.length; c < h; c++) { var u, d = e[c], p = (s = void 0, (s = (o = d).extensions && o.extensions[i.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + s.bufferView + ":" + s.indices + ":" + G(s.attributes) : o.indices + ":" + G(o.attributes) + ":" + o.mode), f = n[p]; if (f) l.push(f.promise); else u = d.extensions && d.extensions[i.KHR_DRACO_MESH_COMPRESSION] ? a(d) : V(new BufferGeometry, d, t), n[p] = { primitive: d, promise: u }, l.push(u) } return Promise.all(l) }, H.prototype.loadMesh = function (e) { for (var t, i = this, r = this.json, n = this.extensions, a = r.meshes[e], o = a.primitives, s = [], l = 0, c = o.length; l < c; l++) { var h = void 0 === o[l].material ? (void 0 === (t = this.cache).DefaultMaterial && (t.DefaultMaterial = new MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: FrontSide })), t.DefaultMaterial) : this.getDependency("material", o[l].material); s.push(h) } return s.push(i.loadGeometries(o)), Promise.all(s).then((function (t) { for (var r = t.slice(0, t.length - 1), s = t[t.length - 1], l = [], c = 0, h = s.length; c < h; c++) { var u, d = s[c], p = o[c], f = r[c]; if (p.mode === M || p.mode === T || p.mode === A || void 0 === p.mode) !0 !== (u = !0 === a.isSkinnedMesh ? new SkinnedMesh(d, f) : new Mesh(d, f)).isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), p.mode === T ? u.geometry = j(u.geometry, TriangleStripDrawMode) : p.mode === A && (u.geometry = j(u.geometry, TriangleFanDrawMode)); else if (p.mode === x) u = new LineSegments(d, f); else if (p.mode === S) u = new Line(d, f); else if (p.mode === w) u = new LineLoop(d, f); else { if (p.mode !== b) throw new Error("THREE.DHLoader: Primitive mode unsupported: " + p.mode); u = new Points(d, f) } Object.keys(u.geometry.morphAttributes).length > 0 && z(u, a), u.name = i.createUniqueName(a.name || "mesh_" + e), U(u, a), p.extensions && F(n, u, p), i.assignFinalMaterial(u), l.push(u) } if (1 === l.length) return l[0]; var m = new Group; for (c = 0, h = l.length; c < h; c++)m.add(l[c]); return m })) }, H.prototype.loadCamera = function (e) { var t, i = this.json.cameras[e], r = i[i.type]; if (r) return "perspective" === i.type ? t = new PerspectiveCamera(MathUtils.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === i.type && (t = new OrthographicCamera(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), i.name && (t.name = this.createUniqueName(i.name)), U(t, i), Promise.resolve(t); logger.warn("THREE.DHLoader: Missing camera parameters.") }, H.prototype.loadSkin = function (e) { var t = this.json.skins[e], i = { joints: t.joints }; return void 0 === t.inverseBindMatrices ? Promise.resolve(i) : this.getDependency("accessor", t.inverseBindMatrices).then((function (e) { return i.inverseBindMatrices = e, i })) }, H.prototype.loadAnimation = function (e) { for (var t = this.json.animations[e], i = [], r = [], n = [], a = [], o = [], s = 0, l = t.channels.length; s < l; s++) { var c = t.channels[s], h = t.samplers[c.sampler], u = c.target, d = void 0 !== u.node ? u.node : u.id, p = void 0 !== t.parameters ? t.parameters[h.input] : h.input, f = void 0 !== t.parameters ? t.parameters[h.output] : h.output; i.push(this.getDependency("node", d)), r.push(this.getDependency("accessor", p)), n.push(this.getDependency("accessor", f)), a.push(h), o.push(u) } return Promise.all([Promise.all(i), Promise.all(r), Promise.all(n), Promise.all(a), Promise.all(o)]).then((function (i) { for (var r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], l = [], c = 0, h = r.length; c < h; c++) { var u = r[c], d = n[c], p = a[c], f = o[c], m = s[c]; if (void 0 !== u) { var g; switch (u.updateMatrix(), u.matrixAutoUpdate = !0, P[m.path]) { case P.weights: g = NumberKeyframeTrack; break; case P.rotation: g = QuaternionKeyframeTrack; break; case P.position: case P.scale: default: g = VectorKeyframeTrack }var y = u.name ? u.name : u.uuid, v = void 0 !== f.interpolation ? O[f.interpolation] : InterpolateLinear, b = []; P[m.path] === P.weights ? u.traverse((function (e) { !0 === e.isMesh && e.morphTargetInfluences && b.push(e.name ? e.name : e.uuid) })) : b.push(y); var x = p.array; if (p.normalized) { var w; if (x.constructor === Int8Array) w = 1 / 127; else if (x.constructor === Uint8Array) w = 1 / 255; else if (x.constructor == Int16Array) w = 1 / 32767; else { if (x.constructor !== Uint16Array) throw new Error("THREE.DHLoader: Unsupported output accessor component type."); w = 1 / 65535 } for (var S = new Float32Array(x.length), M = 0, T = x.length; M < T; M++)S[M] = x[M] * w; x = S } for (M = 0, T = b.length; M < T; M++) { var A = new g(b[M] + "." + P[m.path], d.array, x, v); "CUBICSPLINE" === f.interpolation && (A.createInterpolant = function (e) { return new _(this.times, this.values, this.getValueSize() / 3, e) }, A.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(A) } } } var E = t.name ? t.name : "animation_" + e; return new AnimationClip(E, void 0, l) })) }, H.prototype.loadNode = function (e) { var t, i = this.json, r = this.extensions, n = this, a = i.nodes[e], o = a.name ? n.createUniqueName(a.name) : ""; return (t = [], void 0 !== a.mesh && t.push(n.getDependency("mesh", a.mesh).then((function (e) { var t = n._getNodeRef(n.meshCache, a.mesh, e); return void 0 !== a.weights && t.traverse((function (e) { if (e.isMesh) for (var t = 0, i = a.weights.length; t < i; t++)e.morphTargetInfluences[t] = a.weights[t] })), t }))), void 0 !== a.camera && t.push(n.getDependency("camera", a.camera).then((function (e) { return n._getNodeRef(n.cameraCache, a.camera, e) }))), n._invokeAll((function (t) { return t.createNodeAttachment && t.createNodeAttachment(e) })).forEach((function (e) { t.push(e) })), Promise.all(t)).then((function (t) { var i; if ((i = !0 === a.isBone ? new Bone : t.length > 1 ? new Group : 1 === t.length ? t[0] : new Object3D) !== t[0]) for (var s = 0, l = t.length; s < l; s++)i.add(t[s]); if (a.name && (i.userData.name = a.name, i.name = o), U(i, a), a.extensions && F(r, i, a), void 0 !== a.matrix) { var c = new Matrix4; c.fromArray(a.matrix), i.applyMatrix4(c) } else void 0 !== a.translation && i.position.fromArray(a.translation), void 0 !== a.rotation && i.quaternion.fromArray(a.rotation), void 0 !== a.scale && i.scale.fromArray(a.scale); return n.associations.set(i, { type: "nodes", index: e }), i })) }, H.prototype.loadScene = function () { function e(t, i, r, n) { var a = r.nodes[t]; return n.getDependency("node", t).then((function (e) { return void 0 === a.skin ? e : n.getDependency("skin", a.skin).then((function (e) { for (var i = [], r = 0, a = (t = e).joints.length; r < a; r++)i.push(n.getDependency("node", t.joints[r])); return Promise.all(i) })).then((function (i) { return e.traverse((function (e) { if (e.isMesh) { for (var r = [], n = [], a = 0, o = i.length; a < o; a++) { var s = i[a]; if (s) { r.push(s); var l = new Matrix4; void 0 !== t.inverseBindMatrices && l.fromArray(t.inverseBindMatrices.array, 16 * a), n.push(l) } else logger.warn('THREE.DHLoader: Joint "%s" could not be found.', t.joints[a]) } e.bind(new Skeleton(r, n), e.matrixWorld) } })), e })); var t })).then((function (t) { i.add(t); var o = []; if (a.children) for (var s = a.children, l = 0, c = s.length; l < c; l++) { var h = s[l]; o.push(e(h, t, r, n)) } return Promise.all(o) })) } return function (t) { var i = this.json, r = this.extensions, n = this.json.scenes[t], a = new Group; n.name && (a.name = this.createUniqueName(n.name)), U(a, n), n.extensions && F(r, a, n); for (var o = n.nodes || [], s = [], l = 0, c = o.length; l < c; l++)s.push(e(o[l], a, i, this)); return Promise.all(s).then((function () { return a })) } }(), e }(), DHLoaderAVWS = function () { function e(e) { Loader.call(this, e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.dbPromise = openDB(INDEXED_DB_NAME, INDEXED_DB_VERSION, { upgrade(e, t, i, r) { e.createObjectStore(INDEXED_DB_OBJECT_STORE) }, blocked() { logger.warn("indexeddb request blocked.") }, blocking() { logger.warn("indexeddb blocking another request.") }, terminated() { logger.warn("indexeddb request terminated.") } }), this.register((function (e) { return new a(e) })), this.register((function (e) { return new s(e) })), this.register((function (e) { return new l(e) })), this.register((function (e) { return new o(e) })), this.register((function (e) { return new r(e) })), this.register((function (e) { return new c(e) })) } function t() { var e = {}; return { get: function (t) { return e[t] }, add: function (t, i) { e[t] = i }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } e.prototype = Object.assign(Object.create(Loader.prototype), { constructor: e, load: function (e, t, i, r, n, a) { var o, s = this; s.secretKey = a, o = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : LoaderUtils.extractUrlBase(e), this.manager.itemStart(e); var l = function (t) { r ? r(t) : logger.error(t), s.manager.itemError(e), s.manager.itemEnd(e) }, c = new FileLoader(this.manager); c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials); let h = []; for (let e in this.requestHeader) h.push({ key: e, value: this.requestHeader[e] }); let u = util$1.fetchContentLastModified(e, h), d = md5(e); u.then(((r, n) => { if ("0" === r) return void c.load(e, (function (i) { try { s.parse(i, o, (function (i) { t(i), s.manager.itemEnd(e) }), l) } catch (e) { l(e) } }), i, l); s.secretKey = s.secretKey || n; let a = md5(r); this.dbPromise.then((r => { r.getAllKeys(INDEXED_DB_OBJECT_STORE).then((n => { let h = !1; for (let c of n) if (0 === c.indexOf(d)) { c === `${d}:${a}` ? (h = !0, r.get(INDEXED_DB_OBJECT_STORE, c).then((r => { let n = r.byteLength; i && i({ type: "progress", total: n, loaded: n / 2 }); try { s.parse(r, o, (function (r) { i && i({ type: "progress", total: n, loaded: n }), t(r), s.manager.itemEnd(e) }), l) } catch (e) { l(e) } }))) : r.delete(INDEXED_DB_OBJECT_STORE, c).then((() => { })); break } h || c.load(e, (function (i) { try { s.parse(i, o, (function (i) { t(i), s.manager.itemEnd(e) }), l), r.put(INDEXED_DB_OBJECT_STORE, i, `${d}:${a}`).then((() => { logger.debug("db.put(CONST.INDEXED_DB_OBJECT_STORE, data, `${urlKey}:${lastModifiedKey}`)") })) } catch (e) { l(e) } }), i, l) })) })) })).catch((() => { c.load(e, (function (i) { try { s.parse(i, o, (function (i) { t(i), s.manager.itemEnd(e) }), l) } catch (e) { l(e) } }), i, l) })) }, setDRACOLoader: function (e) { return this.dracoLoader = e, this }, setDDSLoader: function () { throw new Error('THREE.DHLoaderAVWS: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') }, setKTX2Loader: function (e) { return this.ktx2Loader = e, this }, setMeshoptDecoder: function (e) { return this.meshoptDecoder = e, this }, register: function (e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this }, unregister: function (e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this }, parse: function (e, t, r, a) { var o, s = {}, l = {}; if ("string" == typeof e) o = e; else { let t = new Uint8Array(e, 0, AVW_HEADER.length); if (t[0] === AVW_HEADER[0] && t[AVW_HEADER.length - 1] === AVW_HEADER[AVW_HEADER.length - 1]) { e = e.slice(AVW_HEADER.length, e.byteLength); let t = new Uint8Array(e), i = 8 - AVW_STEP; for (let e = 0; e < t.length; e++)t[e] = t[e] << AVW_STEP | t[e] >> i } if (t[0] === AVW_HEADER_VAR[0] && t[AVW_HEADER_VAR.length - 1] === AVW_HEADER_VAR[AVW_HEADER_VAR.length - 1]) { if ("string" != typeof this.secretKey) return; if (this.secretKey.length < 8 || this.secretKey.length > 128) return; const t = []; for (let e = 0; e < this.secretKey.length; e++)t.push(this.secretKey.charCodeAt(e)); e = e.slice(AVW_HEADER_VAR.length, e.byteLength); let i, r, n = new Uint8Array(e); for (let e = 0; e < n.length; e++)i = t[e % t.length] % 8, r = 8 - i, n[e] = n[e] << i | n[e] >> r; this.secretKey = "" } if (LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === h) { try { s[i.KHR_BINARY_GLTF] = new p(e) } catch (e) { return void (a && a(e)) } o = s[i.KHR_BINARY_GLTF].content } else o = LoaderUtils.decodeText(new Uint8Array(e)) } var c = JSON.parse(o); if (void 0 === c.asset || c.asset.version[0] < 2) a && a(new Error("THREE.DHLoaderAVWS: Unsupported asset. glTF versions >=2.0 are supported.")); else { var u = new H(c, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); u.fileLoader.setRequestHeader(this.requestHeader); for (var d = 0; d < this.pluginCallbacks.length; d++) { var g = this.pluginCallbacks[d](u); l[g.name] = g, s[g.name] = !0 } if (c.extensionsUsed) for (d = 0; d < c.extensionsUsed.length; ++d) { var _ = c.extensionsUsed[d], b = c.extensionsRequired || []; switch (_) { case i.KHR_MATERIALS_UNLIT: s[_] = new n; break; case i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: s[_] = new y; break; case i.KHR_DRACO_MESH_COMPRESSION: s[_] = new f(c, this.dracoLoader); break; case i.KHR_TEXTURE_TRANSFORM: s[_] = new m; break; case i.KHR_MESH_QUANTIZATION: s[_] = new v; break; default: b.indexOf(_) >= 0 && void 0 === l[_] && logger.warn('THREE.DHLoaderAVWS: Unknown extension "' + _ + '".') } } u.setExtensions(s), u.setPlugins(l), u.parse(r, a) } } }); var i = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" }; function r(e) { this.parser = e, this.name = i.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } function n() { this.name = i.KHR_MATERIALS_UNLIT } function a(e) { this.parser = e, this.name = i.KHR_MATERIALS_CLEARCOAT } function o(e) { this.parser = e, this.name = i.KHR_MATERIALS_TRANSMISSION } function s(e) { this.parser = e, this.name = i.KHR_TEXTURE_BASISU } function l(e) { this.parser = e, this.name = i.EXT_TEXTURE_WEBP, this.isSupported = null } function c(e) { this.name = i.EXT_MESHOPT_COMPRESSION, this.parser = e } r.prototype._markDefs = function () { for (var e = this.parser, t = this.parser.json.nodes || [], i = 0, r = t.length; i < r; i++) { var n = t[i]; n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && e._addNodeRef(this.cache, n.extensions[this.name].light) } }, r.prototype._loadLight = function (e) { var t = this.parser, i = "light:" + e, r = t.cache.get(i); if (r) return r; var n, a = t.json, o = ((a.extensions && a.extensions[this.name] || {}).lights || [])[e], s = new Color$1(16777215); void 0 !== o.color && s.fromArray(o.color); var l = void 0 !== o.range ? o.range : 0; switch (o.type) { case "directional": (n = new DirectionalLight(s)).target.position.set(0, 0, -1), n.add(n.target); break; case "point": (n = new PointLight(s)).distance = l; break; case "spot": (n = new SpotLight(s)).distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, n.angle = o.spot.outerConeAngle, n.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, n.target.position.set(0, 0, -1), n.add(n.target); break; default: throw new Error("THREE.DHLoaderAVWS: Unexpected light type: " + o.type) }return n.position.set(0, 0, 0), n.decay = 2, void 0 !== o.intensity && (n.intensity = o.intensity), n.name = t.createUniqueName(o.name || "light_" + e), r = Promise.resolve(n), t.cache.add(i, r), r }, r.prototype.createNodeAttachment = function (e) { var t = this, i = this.parser, r = i.json.nodes[e], n = (r.extensions && r.extensions[this.name] || {}).light; return void 0 === n ? null : this._loadLight(n).then((function (e) { return i._getNodeRef(t.cache, n, e) })) }, n.prototype.getMaterialType = function () { return MeshBasicMaterial }, n.prototype.extendParams = function (e, t, i) { var r = []; e.color = new Color$1(1, 1, 1), e.opacity = 1; var n = t.pbrMetallicRoughness; if (n) { if (Array.isArray(n.baseColorFactor)) { var a = n.baseColorFactor; e.color.fromArray(a), e.opacity = a[3] } void 0 !== n.baseColorTexture && r.push(i.assignTexture(e, "map", n.baseColorTexture)) } return Promise.all(r) }, a.prototype.getMaterialType = function (e) { var t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null }, a.prototype.extendMaterialParams = function (e, t) { var i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); var n = [], a = r.extensions[this.name]; if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && n.push(i.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && n.push(i.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (n.push(i.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) { var o = a.clearcoatNormalTexture.scale; t.clearcoatNormalScale = new Vector2(o, -o) } return Promise.all(n) }, o.prototype.getMaterialType = function (e) { var t = this.parser.json.materials[e]; return t.extensions && t.extensions[this.name] ? MeshPhysicalMaterial : null }, o.prototype.extendMaterialParams = function (e, t) { var i = this.parser, r = i.json.materials[e]; if (!r.extensions || !r.extensions[this.name]) return Promise.resolve(); var n = [], a = r.extensions[this.name]; return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor), void 0 !== a.transmissionTexture && n.push(i.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(n) }, s.prototype.loadTexture = function (e) { var t = this.parser, i = t.json, r = i.textures[e]; if (!r.extensions || !r.extensions[this.name]) return null; var n = r.extensions[this.name], a = i.images[n.source], o = t.options.ktx2Loader; if (!o) { if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.DHLoaderAVWS: setKTX2Loader must be called before loading KTX2 textures"); return null } return t.loadTextureImage(e, a, o) }, l.prototype.loadTexture = function (e) { var t = this.name, i = this.parser, r = i.json, n = r.textures[e]; if (!n.extensions || !n.extensions[t]) return null; var a = n.extensions[t], o = r.images[a.source], s = i.textureLoader; if (o.uri) { var l = i.options.manager.getHandler(o.uri); null !== l && (s = l) } return this.detectSupport().then((function (n) { if (n) return i.loadTextureImage(e, o, s); if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.DHLoaderAVWS: WebP required by asset but unsupported."); return i.loadTexture(e) })) }, l.prototype.detectSupport = function () { return this.isSupported || (this.isSupported = new Promise((function (e) { var t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(1 === t.height) } }))), this.isSupported }, c.prototype.loadBufferView = function (e) { var t = this.parser.json, i = t.bufferViews[e]; if (i.extensions && i.extensions[this.name]) { var r = i.extensions[this.name], n = this.parser.getDependency("buffer", r.buffer), a = this.parser.options.meshoptDecoder; if (!a || !a.supported) { if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.DHLoaderAVWS: setMeshoptDecoder must be called before loading compressed files"); return null } return Promise.all([n, a.ready]).then((function (e) { var t = r.byteOffset || 0, i = r.byteLength || 0, n = r.count, o = r.byteStride, s = new ArrayBuffer(n * o), l = new Uint8Array(e[0], t, i); return a.decodeGltfBuffer(new Uint8Array(s), n, o, l, r.mode, r.filter), s })) } return null }; var h = "glTF", u = 1313821514, d = 5130562; function p(e) { this.name = i.KHR_BINARY_GLTF, this.content = null, this.body = null; var t = new DataView(e, 0, 12); if (this.header = { magic: LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== h) throw new Error("THREE.DHLoaderAVWS: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.DHLoaderAVWS: Legacy binary file detected."); for (var r = this.header.length - 12, n = new DataView(e, 12), a = 0; a < r;) { var o = n.getUint32(a, !0); a += 4; var s = n.getUint32(a, !0); if (a += 4, s === u) { var l = new Uint8Array(e, 12 + a, o); this.content = LoaderUtils.decodeText(l) } else if (s === d) { var c = 12 + a; this.body = e.slice(c, c + o) } a += o } if (null === this.content) throw new Error("THREE.DHLoaderAVWS: JSON content not found.") } function f(e, t) { if (!t) throw new Error("THREE.DHLoaderAVWS: No DRACOLoader instance provided."); this.name = i.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } function m() { this.name = i.KHR_TEXTURE_TRANSFORM } function g(e) { MeshStandardMaterial.call(this), this.isGLTFSpecularGlossinessMaterial = !0; var t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), i = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), r = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), n = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), a = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), o = { specular: { value: (new Color$1).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = o, this.onBeforeCompile = function (e) { for (var s in o) e.uniforms[s] = o[s]; e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", r).replace("#include <metalnessmap_fragment>", n).replace("#include <lights_physical_fragment>", a) }, Object.defineProperties(this, { specular: { get: function () { return o.specular.value }, set: function (e) { o.specular.value = e } }, specularMap: { get: function () { return o.specularMap.value }, set: function (e) { o.specularMap.value = e, e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function () { return o.glossiness.value }, set: function (e) { o.glossiness.value = e } }, glossinessMap: { get: function () { return o.glossinessMap.value }, set: function (e) { o.glossinessMap.value = e, e ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e) } function y() { return { name: i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"], getMaterialType: function () { return g }, extendParams: function (e, t, i) { var r = t.extensions[this.name]; e.color = new Color$1(1, 1, 1), e.opacity = 1; var n = []; if (Array.isArray(r.diffuseFactor)) { var a = r.diffuseFactor; e.color.fromArray(a), e.opacity = a[3] } if (void 0 !== r.diffuseTexture && n.push(i.assignTexture(e, "map", r.diffuseTexture)), e.emissive = new Color$1(0, 0, 0), e.glossiness = void 0 !== r.glossinessFactor ? r.glossinessFactor : 1, e.specular = new Color$1(1, 1, 1), Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor), void 0 !== r.specularGlossinessTexture) { var o = r.specularGlossinessTexture; n.push(i.assignTexture(e, "glossinessMap", o)), n.push(i.assignTexture(e, "specularMap", o)) } return Promise.all(n) }, createMaterial: function (e) { var t = new g(e); return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = TangentSpaceNormalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } } function v() { this.name = i.KHR_MESH_QUANTIZATION } function _(e, t, i, r) { Interpolant.call(this, e, t, i, r) } f.prototype.decodePrimitive = function (e, t) { var i = this.json, r = this.dracoLoader, n = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, s = {}, l = {}; for (var c in a) { var h = D[c] || c.toLowerCase(); o[h] = a[c] } for (c in e.attributes) { h = D[c] || c.toLowerCase(); if (void 0 !== a[c]) { var u = i.accessors[e.attributes[c]], d = E[u.componentType]; l[h] = d, s[h] = !0 === u.normalized } } return t.getDependency("bufferView", n).then((function (e) { return new Promise((function (t) { r.decodeDracoFile(e, (function (e) { for (var i in e.attributes) { var r = e.attributes[i], n = s[i]; void 0 !== n && (r.normalized = n) } t(e) }), o, l) })) })) }, m.prototype.extendTexture = function (e, t) { return e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), void 0 !== t.texCoord && logger.warn('THREE.DHLoaderAVWS: Custom UV sets in "' + this.name + '" extension not yet supported.'), e.needsUpdate = !0, e }, g.prototype = Object.create(MeshStandardMaterial.prototype), g.prototype.constructor = g, g.prototype.copy = function (e) { return MeshStandardMaterial.prototype.copy.call(this, e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this }, _.prototype = Object.create(Interpolant.prototype), _.prototype.constructor = _, _.prototype.copySampleValue_ = function (e) { for (var t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, n = e * r * 3 + r, a = 0; a !== r; a++)t[a] = i[n + a]; return t }, _.prototype.beforeStart_ = _.prototype.copySampleValue_, _.prototype.afterEnd_ = _.prototype.copySampleValue_, _.prototype.interpolate_ = function (e, t, i, r) { for (var n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = 2 * o, l = 3 * o, c = r - t, h = (i - t) / c, u = h * h, d = u * h, p = e * l, f = p - l, m = -2 * d + 3 * u, g = d - u, y = 1 - m, v = g - u + h, _ = 0; _ !== o; _++) { var b = a[f + _ + o], x = a[f + _ + s] * c, w = a[p + _ + o], S = a[p + _] * c; n[_] = y * b + v * x + m * w + g * S } return n }; var b = 0, x = 1, w = 2, S = 3, M = 4, T = 5, A = 6, E = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, C = { 9728: NearestFilter, 9729: LinearFilter, 9984: NearestMipmapNearestFilter, 9985: LinearMipmapNearestFilter, 9986: NearestMipmapLinearFilter, 9987: LinearMipmapLinearFilter }, L = { 33071: ClampToEdgeWrapping, 33648: MirroredRepeatWrapping, 10497: RepeatWrapping }, R = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, D = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, P = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, O = { CUBICSPLINE: void 0, LINEAR: InterpolateLinear, STEP: InterpolateDiscrete }, I = "OPAQUE", k = "MASK", B = "BLEND"; function N(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } function F(e, t, i) { for (var r in i.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = i.extensions[r]) } function U(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : logger.warn("THREE.DHLoaderAVWS: Ignoring primitive type .extras, " + t.extras)) } function z(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (var i = 0, r = t.weights.length; i < r; i++)e.morphTargetInfluences[i] = t.weights[i]; if (t.extras && Array.isArray(t.extras.targetNames)) { var n = t.extras.targetNames; if (e.morphTargetInfluences.length === n.length) { e.morphTargetDictionary = {}; for (i = 0, r = n.length; i < r; i++)e.morphTargetDictionary[n[i]] = i } else logger.warn("THREE.DHLoaderAVWS: Invalid extras.targetNames length. Ignoring names.") } } function G(e) { for (var t = "", i = Object.keys(e).sort(), r = 0, n = i.length; r < n; r++)t += i[r] + ":" + e[i[r]] + ";"; return t } function H(e, i) { this.json = e || {}, this.extensions = {}, this.plugins = {}, this.options = i || {}, this.cache = new t, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new ImageBitmapLoader(this.options.manager) : this.textureLoader = new TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } function V(e, t, i) { var r = t.attributes, n = []; function a(t, r) { return i.getDependency("accessor", t).then((function (t) { e.setAttribute(r, t) })) } for (var o in r) { var s = D[o] || o.toLowerCase(); s in e.attributes || n.push(a(r[o], s)) } if (void 0 !== t.indices && !e.index) { var l = i.getDependency("accessor", t.indices).then((function (t) { e.setIndex(t) })); n.push(l) } return U(e, t), function (e, t, i) { var r = t.attributes, n = new Box3; if (void 0 !== r.POSITION) { var a = (d = i.json.accessors[r.POSITION]).min, o = d.max; if (void 0 !== a && void 0 !== o) { n.set(new Vector3(a[0], a[1], a[2]), new Vector3(o[0], o[1], o[2])); var s = t.targets; if (void 0 !== s) { for (var l = new Vector3, c = new Vector3, h = 0, u = s.length; h < u; h++) { var d, p = s[h]; if (void 0 !== p.POSITION) a = (d = i.json.accessors[p.POSITION]).min, o = d.max, void 0 !== a && void 0 !== o ? (c.setX(Math.max(Math.abs(a[0]), Math.abs(o[0]))), c.setY(Math.max(Math.abs(a[1]), Math.abs(o[1]))), c.setZ(Math.max(Math.abs(a[2]), Math.abs(o[2]))), l.max(c)) : logger.warn("THREE.DHLoaderAVWS: Missing min/max properties for accessor POSITION.") } n.expandByVector(l) } e.boundingBox = n; var f = new Sphere; n.getCenter(f.center), f.radius = n.min.distanceTo(n.max) / 2, e.boundingSphere = f } else logger.warn("THREE.DHLoaderAVWS: Missing min/max properties for accessor POSITION.") } }(e, t, i), Promise.all(n).then((function () { return void 0 !== t.targets ? function (e, t, i) { for (var r = !1, n = !1, a = 0, o = t.length; a < o && (void 0 !== (c = t[a]).POSITION && (r = !0), void 0 !== c.NORMAL && (n = !0), !r || !n); a++); if (!r && !n) return Promise.resolve(e); var s = [], l = []; for (a = 0, o = t.length; a < o; a++) { var c = t[a]; if (r) { var h = void 0 !== c.POSITION ? i.getDependency("accessor", c.POSITION) : e.attributes.position; s.push(h) } n && (h = void 0 !== c.NORMAL ? i.getDependency("accessor", c.NORMAL) : e.attributes.normal, l.push(h)) } return Promise.all([Promise.all(s), Promise.all(l)]).then((function (t) { var i = t[0], a = t[1]; return r && (e.morphAttributes.position = i), n && (e.morphAttributes.normal = a), e.morphTargetsRelative = !0, e })) }(e, t.targets, i) : e })) } function j(e, t) { var i = e.getIndex(); if (null === i) { var r = [], n = e.getAttribute("position"); if (void 0 === n) return logger.error("THREE.DHLoaderAVWS.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (var a = 0; a < n.count; a++)r.push(a); e.setIndex(r), i = e.getIndex() } var o = i.count - 2, s = []; if (t === TriangleFanDrawMode) for (a = 1; a <= o; a++)s.push(i.getX(0)), s.push(i.getX(a)), s.push(i.getX(a + 1)); else for (a = 0; a < o; a++)a % 2 == 0 ? (s.push(i.getX(a)), s.push(i.getX(a + 1)), s.push(i.getX(a + 2))) : (s.push(i.getX(a + 2)), s.push(i.getX(a + 1)), s.push(i.getX(a))); s.length / 3 !== o && logger.error("THREE.DHLoaderAVWS.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); var l = e.clone(); return l.setIndex(s), l } return H.prototype.setExtensions = function (e) { this.extensions = e }, H.prototype.setPlugins = function (e) { this.plugins = e }, H.prototype.parse = function (e, t) { var i = this, r = this.json, n = this.extensions; this.cache.removeAll(), this._invokeAll((function (e) { return e._markDefs && e._markDefs() })), Promise.all(this._invokeAll((function (e) { return e.beforeRoot && e.beforeRoot() }))).then((function () { return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")]) })).then((function (t) { var a = { scene: t[0][r.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: r.asset, parser: i, userData: {} }; F(n, a, r), U(a, r), Promise.all(i._invokeAll((function (e) { return e.afterRoot && e.afterRoot(a) }))).then((function () { e(a) })) })).catch(t) }, H.prototype._markDefs = function () { for (var e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || [], r = 0, n = t.length; r < n; r++)for (var a = t[r].joints, o = 0, s = a.length; o < s; o++)e[a[o]].isBone = !0; for (var l = 0, c = e.length; l < c; l++) { var h = e[l]; void 0 !== h.mesh && (this._addNodeRef(this.meshCache, h.mesh), void 0 !== h.skin && (i[h.mesh].isSkinnedMesh = !0)), void 0 !== h.camera && this._addNodeRef(this.cameraCache, h.camera) } }, H.prototype._addNodeRef = function (e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) }, H.prototype._getNodeRef = function (e, t, i) { if (e.refs[t] <= 1) return i; var r = i.clone(); return r.name += "_instance_" + e.uses[t]++, r }, H.prototype._invokeOne = function (e) { var t = Object.values(this.plugins); t.push(this); for (var i = 0; i < t.length; i++) { var r = e(t[i]); if (r) return r } }, H.prototype._invokeAll = function (e) { var t = Object.values(this.plugins); t.unshift(this); for (var i = [], r = 0; r < t.length; r++) { var n = e(t[r]); n && i.push(n) } return i }, H.prototype.getDependency = function (e, t) { var i = e + ":" + t, r = this.cache.get(i); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this.loadNode(t); break; case "mesh": r = this._invokeOne((function (e) { return e.loadMesh && e.loadMesh(t) })); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this._invokeOne((function (e) { return e.loadBufferView && e.loadBufferView(t) })); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this._invokeOne((function (e) { return e.loadMaterial && e.loadMaterial(t) })); break; case "texture": r = this._invokeOne((function (e) { return e.loadTexture && e.loadTexture(t) })); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this.loadAnimation(t); break; case "camera": r = this.loadCamera(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(i, r) } return r }, H.prototype.getDependencies = function (e) { var t = this.cache.get(e); if (!t) { var i = this, r = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(r.map((function (t, r) { return i.getDependency(e, r) }))), this.cache.add(e, t) } return t }, H.prototype.loadBuffer = function (e) { var t = this.json.buffers[e], r = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.DHLoaderAVWS: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[i.KHR_BINARY_GLTF].body); var n = this.options; return new Promise((function (e, i) { r.load(N(t.uri, n.path), e, void 0, (function () { i(new Error('THREE.DHLoaderAVWS: Failed to load buffer "' + t.uri + '".')) })) })) }, H.prototype.loadBufferView = function (e) { var t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then((function (e) { var i = t.byteLength || 0, r = t.byteOffset || 0; return e.slice(r, r + i) })) }, H.prototype.loadAccessor = function (e) { var t = this, i = this.json, r = this.json.accessors[e]; if (void 0 === r.bufferView && void 0 === r.sparse) return Promise.resolve(null); var n = []; return void 0 !== r.bufferView ? n.push(this.getDependency("bufferView", r.bufferView)) : n.push(null), void 0 !== r.sparse && (n.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), n.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(n).then((function (e) { var n, a = e[0], o = R[r.type], s = E[r.componentType], l = s.BYTES_PER_ELEMENT, c = l * o, h = r.byteOffset || 0, u = void 0 !== r.bufferView ? i.bufferViews[r.bufferView].byteStride : void 0, d = !0 === r.normalized; if (u && u !== c) { var p = Math.floor(h / u), f = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + p + ":" + r.count, m = t.cache.get(f); m || (m = new InterleavedBuffer(new s(a, p * u, r.count * u / l), u / l), t.cache.add(f, m)), n = new InterleavedBufferAttribute(m, o, h % u / l, d) } else n = new BufferAttribute(null === a ? new s(r.count * o) : new s(a, h, r.count * o), o, d); if (void 0 !== r.sparse) { var g = R.SCALAR, y = E[r.sparse.indices.componentType], v = r.sparse.indices.byteOffset || 0, _ = r.sparse.values.byteOffset || 0, b = new y(e[1], v, r.sparse.count * g), x = new s(e[2], _, r.sparse.count * o); null !== a && (n = new BufferAttribute(n.array.slice(), n.itemSize, n.normalized)); for (var w = 0, S = b.length; w < S; w++) { var M = b[w]; if (n.setX(M, x[w * o]), o >= 2 && n.setY(M, x[w * o + 1]), o >= 3 && n.setZ(M, x[w * o + 2]), o >= 4 && n.setW(M, x[w * o + 3]), o >= 5) throw new Error("THREE.DHLoaderAVWS: Unsupported itemSize in sparse BufferAttribute.") } } return n })) }, H.prototype.loadTexture = function (e) { var t = this.json, i = this.options, r = t.textures[e], n = t.images[r.source], a = this.textureLoader; if (n.uri) { var o = i.manager.getHandler(n.uri); null !== o && (a = o) } return this.loadTextureImage(e, n, a) }, H.prototype.loadTextureImage = function (e, t, i) { var r = this, n = this.json, a = this.options, o = n.textures[e], s = self.URL || self.webkitURL, l = t.uri, c = !1, h = !0; if ("image/jpeg" === t.mimeType && (h = !1), void 0 !== t.bufferView) l = r.getDependency("bufferView", t.bufferView).then((function (e) { if ("image/png" === t.mimeType) { var i = new DataView(e, 25, 1).getUint8(0, !1); h = 6 === i || 4 === i || 3 === i } c = !0; var r = new Blob([e], { type: t.mimeType }); return l = s.createObjectURL(r) })); else if (void 0 === t.uri) throw new Error("THREE.DHLoaderAVWS: Image " + e + " is missing URI and bufferView"); return Promise.resolve(l).then((function (e) { return new Promise((function (t, r) { var n = t; !0 === i.isImageBitmapLoader && (n = function (e) { t(new CanvasTexture(e)) }), i.load(N(e, a.path), n, void 0, r) })) })).then((function (t) { !0 === c && s.revokeObjectURL(l), t.flipY = !1, o.name && (t.name = o.name), h || (t.format = RGBFormat); var i = (n.samplers || {})[o.sampler] || {}; return t.magFilter = C[i.magFilter] || LinearFilter, t.minFilter = C[i.minFilter] || LinearMipmapLinearFilter, t.wrapS = L[i.wrapS] || RepeatWrapping, t.wrapT = L[i.wrapT] || RepeatWrapping, r.associations.set(t, { type: "textures", index: e }), t })) }, H.prototype.assignTexture = function (e, t, r) { var n = this; return this.getDependency("texture", r.index).then((function (a) { if (void 0 === r.texCoord || 0 == r.texCoord || "aoMap" === t && 1 == r.texCoord || logger.warn("THREE.DHLoaderAVWS: Custom UV set " + r.texCoord + " for texture " + t + " not yet supported."), n.extensions[i.KHR_TEXTURE_TRANSFORM]) { var o = void 0 !== r.extensions ? r.extensions[i.KHR_TEXTURE_TRANSFORM] : void 0; if (o) { var s = n.associations.get(a); a = n.extensions[i.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), n.associations.set(a, s) } } e[t] = a })) }, H.prototype.assignFinalMaterial = function (e) { var t = e.geometry, i = e.material, r = void 0 !== t.attributes.tangent, n = void 0 !== t.attributes.color, a = void 0 === t.attributes.normal, o = !0 === e.isSkinnedMesh, s = Object.keys(t.morphAttributes).length > 0, l = s && void 0 !== t.morphAttributes.normal; if (e.isPoints) { var c = "PointsMaterial:" + i.uuid, h = this.cache.get(c); h || (h = new PointsMaterial, Material$1.prototype.copy.call(h, i), h.color.copy(i.color), h.map = i.map, h.sizeAttenuation = !1, this.cache.add(c, h)), i = h } else if (e.isLine) { c = "LineBasicMaterial:" + i.uuid; var u = this.cache.get(c); u || (u = new LineBasicMaterial, Material$1.prototype.copy.call(u, i), u.color.copy(i.color), this.cache.add(c, u)), i = u } if (r || n || a || o || s) { c = "ClonedMaterial:" + i.uuid + ":"; i.isGLTFSpecularGlossinessMaterial && (c += "specular-glossiness:"), o && (c += "skinning:"), r && (c += "vertex-tangents:"), n && (c += "vertex-colors:"), a && (c += "flat-shading:"), s && (c += "morph-targets:"), l && (c += "morph-normals:"); var d = this.cache.get(c); d || (d = i.clone(), o && (d.skinning = !0), n && (d.vertexColors = !0), a && (d.flatShading = !0), s && (d.morphTargets = !0), l && (d.morphNormals = !0), r && (d.vertexTangents = !0, d.normalScale && (d.normalScale.y *= -1), d.clearcoatNormalScale && (d.clearcoatNormalScale.y *= -1)), this.cache.add(c, d), this.associations.set(d, this.associations.get(i))), i = d } i.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = i }, H.prototype.getMaterialType = function () { return MeshStandardMaterial }, H.prototype.loadMaterial = function (e) { var t, r = this, n = this.json, a = this.extensions, o = n.materials[e], s = {}, l = o.extensions || {}, c = []; if (l[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { var h = a[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; t = h.getMaterialType(), c.push(h.extendParams(s, o, r)) } else if (l[i.KHR_MATERIALS_UNLIT]) { var u = a[i.KHR_MATERIALS_UNLIT]; t = u.getMaterialType(), c.push(u.extendParams(s, o, r)) } else { var d = o.pbrMetallicRoughness || {}; if (s.color = new Color$1(1, 1, 1), s.opacity = 1, Array.isArray(d.baseColorFactor)) { var p = d.baseColorFactor; s.color.fromArray(p), s.opacity = p[3] } void 0 !== d.baseColorTexture && c.push(r.assignTexture(s, "map", d.baseColorTexture)), s.metalness = void 0 !== d.metallicFactor ? d.metallicFactor : 1, s.roughness = void 0 !== d.roughnessFactor ? d.roughnessFactor : 1, void 0 !== d.metallicRoughnessTexture && (c.push(r.assignTexture(s, "metalnessMap", d.metallicRoughnessTexture)), c.push(r.assignTexture(s, "roughnessMap", d.metallicRoughnessTexture))), t = this._invokeOne((function (t) { return t.getMaterialType && t.getMaterialType(e) })), c.push(Promise.all(this._invokeAll((function (t) { return t.extendMaterialParams && t.extendMaterialParams(e, s) })))) } !0 === o.doubleSided && (s.side = DoubleSide); var f = o.alphaMode || I; return f === B ? (s.transparent = !0, s.depthWrite = !1) : (s.transparent = !1, f === k && (s.alphaTest = void 0 !== o.alphaCutoff ? o.alphaCutoff : .5)), void 0 !== o.normalTexture && t !== MeshBasicMaterial && (c.push(r.assignTexture(s, "normalMap", o.normalTexture)), s.normalScale = new Vector2(1, -1), void 0 !== o.normalTexture.scale && s.normalScale.set(o.normalTexture.scale, -o.normalTexture.scale)), void 0 !== o.occlusionTexture && t !== MeshBasicMaterial && (c.push(r.assignTexture(s, "aoMap", o.occlusionTexture)), void 0 !== o.occlusionTexture.strength && (s.aoMapIntensity = o.occlusionTexture.strength)), void 0 !== o.emissiveFactor && t !== MeshBasicMaterial && (s.emissive = (new Color$1).fromArray(o.emissiveFactor)), void 0 !== o.emissiveTexture && t !== MeshBasicMaterial && c.push(r.assignTexture(s, "emissiveMap", o.emissiveTexture)), Promise.all(c).then((function () { var n; return n = t === g ? a[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s) : new t(s), o.name && (n.name = o.name), n.map && (n.map.encoding = sRGBEncoding), n.emissiveMap && (n.emissiveMap.encoding = sRGBEncoding), U(n, o), r.associations.set(n, { type: "materials", index: e }), o.extensions && F(a, n, o), n })) }, H.prototype.createUniqueName = function (e) { return e }, H.prototype.loadGeometries = function (e) { var t = this, r = this.extensions, n = this.primitiveCache; function a(e) { return r[i.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (i) { return V(i, e, t) })) } for (var o, s, l = [], c = 0, h = e.length; c < h; c++) { var u, d = e[c], p = (s = void 0, (s = (o = d).extensions && o.extensions[i.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + s.bufferView + ":" + s.indices + ":" + G(s.attributes) : o.indices + ":" + G(o.attributes) + ":" + o.mode), f = n[p]; if (f) l.push(f.promise); else u = d.extensions && d.extensions[i.KHR_DRACO_MESH_COMPRESSION] ? a(d) : V(new BufferGeometry, d, t), n[p] = { primitive: d, promise: u }, l.push(u) } return Promise.all(l) }, H.prototype.loadMesh = function (e) { for (var t, i = this, r = this.json, n = this.extensions, a = r.meshes[e], o = a.primitives, s = [], l = 0, c = o.length; l < c; l++) { var h = void 0 === o[l].material ? (void 0 === (t = this.cache).DefaultMaterial && (t.DefaultMaterial = new MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: FrontSide })), t.DefaultMaterial) : this.getDependency("material", o[l].material); s.push(h) } return s.push(i.loadGeometries(o)), Promise.all(s).then((function (t) { for (var r = t.slice(0, t.length - 1), s = t[t.length - 1], l = [], c = 0, h = s.length; c < h; c++) { var u, d = s[c], p = o[c], f = r[c]; if (p.mode === M || p.mode === T || p.mode === A || void 0 === p.mode) !0 !== (u = !0 === a.isSkinnedMesh ? new SkinnedMesh(d, f) : new Mesh(d, f)).isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), p.mode === T ? u.geometry = j(u.geometry, TriangleStripDrawMode) : p.mode === A && (u.geometry = j(u.geometry, TriangleFanDrawMode)); else if (p.mode === x) u = new LineSegments(d, f); else if (p.mode === S) u = new Line(d, f); else if (p.mode === w) u = new LineLoop(d, f); else { if (p.mode !== b) throw new Error("THREE.DHLoaderAVWS: Primitive mode unsupported: " + p.mode); u = new Points(d, f) } Object.keys(u.geometry.morphAttributes).length > 0 && z(u, a), u.name = i.createUniqueName(a.name || "mesh_" + e), U(u, a), p.extensions && F(n, u, p), i.assignFinalMaterial(u), l.push(u) } if (1 === l.length) return l[0]; var m = new Group; for (c = 0, h = l.length; c < h; c++)m.add(l[c]); return m })) }, H.prototype.loadCamera = function (e) { var t, i = this.json.cameras[e], r = i[i.type]; if (r) return "perspective" === i.type ? t = new PerspectiveCamera(MathUtils.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === i.type && (t = new OrthographicCamera(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), i.name && (t.name = this.createUniqueName(i.name)), U(t, i), Promise.resolve(t); logger.warn("THREE.DHLoaderAVWS: Missing camera parameters.") }, H.prototype.loadSkin = function (e) { var t = this.json.skins[e], i = { joints: t.joints }; return void 0 === t.inverseBindMatrices ? Promise.resolve(i) : this.getDependency("accessor", t.inverseBindMatrices).then((function (e) { return i.inverseBindMatrices = e, i })) }, H.prototype.loadAnimation = function (e) { for (var t = this.json.animations[e], i = [], r = [], n = [], a = [], o = [], s = 0, l = t.channels.length; s < l; s++) { var c = t.channels[s], h = t.samplers[c.sampler], u = c.target, d = void 0 !== u.node ? u.node : u.id, p = void 0 !== t.parameters ? t.parameters[h.input] : h.input, f = void 0 !== t.parameters ? t.parameters[h.output] : h.output; i.push(this.getDependency("node", d)), r.push(this.getDependency("accessor", p)), n.push(this.getDependency("accessor", f)), a.push(h), o.push(u) } return Promise.all([Promise.all(i), Promise.all(r), Promise.all(n), Promise.all(a), Promise.all(o)]).then((function (i) { for (var r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], l = [], c = 0, h = r.length; c < h; c++) { var u = r[c], d = n[c], p = a[c], f = o[c], m = s[c]; if (void 0 !== u) { var g; switch (u.updateMatrix(), u.matrixAutoUpdate = !0, P[m.path]) { case P.weights: g = NumberKeyframeTrack; break; case P.rotation: g = QuaternionKeyframeTrack; break; case P.position: case P.scale: default: g = VectorKeyframeTrack }var y = u.name ? u.name : u.uuid, v = void 0 !== f.interpolation ? O[f.interpolation] : InterpolateLinear, b = []; P[m.path] === P.weights ? u.traverse((function (e) { !0 === e.isMesh && e.morphTargetInfluences && b.push(e.name ? e.name : e.uuid) })) : b.push(y); var x = p.array; if (p.normalized) { var w; if (x.constructor === Int8Array) w = 1 / 127; else if (x.constructor === Uint8Array) w = 1 / 255; else if (x.constructor == Int16Array) w = 1 / 32767; else { if (x.constructor !== Uint16Array) throw new Error("THREE.DHLoaderAVWS: Unsupported output accessor component type."); w = 1 / 65535 } for (var S = new Float32Array(x.length), M = 0, T = x.length; M < T; M++)S[M] = x[M] * w; x = S } for (M = 0, T = b.length; M < T; M++) { var A = new g(b[M] + "." + P[m.path], d.array, x, v); "CUBICSPLINE" === f.interpolation && (A.createInterpolant = function (e) { return new _(this.times, this.values, this.getValueSize() / 3, e) }, A.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(A) } } } var E = t.name ? t.name : "animation_" + e; return new AnimationClip(E, void 0, l) })) }, H.prototype.loadNode = function (e) { var t, i = this.json, r = this.extensions, n = this, a = i.nodes[e], o = a.name ? n.createUniqueName(a.name) : ""; return (t = [], void 0 !== a.mesh && t.push(n.getDependency("mesh", a.mesh).then((function (e) { var t = n._getNodeRef(n.meshCache, a.mesh, e); return void 0 !== a.weights && t.traverse((function (e) { if (e.isMesh) for (var t = 0, i = a.weights.length; t < i; t++)e.morphTargetInfluences[t] = a.weights[t] })), t }))), void 0 !== a.camera && t.push(n.getDependency("camera", a.camera).then((function (e) { return n._getNodeRef(n.cameraCache, a.camera, e) }))), n._invokeAll((function (t) { return t.createNodeAttachment && t.createNodeAttachment(e) })).forEach((function (e) { t.push(e) })), Promise.all(t)).then((function (t) { var i; if ((i = !0 === a.isBone ? new Bone : t.length > 1 ? new Group : 1 === t.length ? t[0] : new Object3D) !== t[0]) for (var s = 0, l = t.length; s < l; s++)i.add(t[s]); if (a.name && (i.userData.name = a.name, i.name = o), U(i, a), a.extensions && F(r, i, a), void 0 !== a.matrix) { var c = new Matrix4; c.fromArray(a.matrix), i.applyMatrix4(c) } else void 0 !== a.translation && i.position.fromArray(a.translation), void 0 !== a.rotation && i.quaternion.fromArray(a.rotation), void 0 !== a.scale && i.scale.fromArray(a.scale); return n.associations.set(i, { type: "nodes", index: e }), i })) }, H.prototype.loadScene = function () { function e(t, i, r, n) { var a = r.nodes[t]; return n.getDependency("node", t).then((function (e) { return void 0 === a.skin ? e : n.getDependency("skin", a.skin).then((function (e) { for (var i = [], r = 0, a = (t = e).joints.length; r < a; r++)i.push(n.getDependency("node", t.joints[r])); return Promise.all(i) })).then((function (i) { return e.traverse((function (e) { if (e.isMesh) { for (var r = [], n = [], a = 0, o = i.length; a < o; a++) { var s = i[a]; if (s) { r.push(s); var l = new Matrix4; void 0 !== t.inverseBindMatrices && l.fromArray(t.inverseBindMatrices.array, 16 * a), n.push(l) } else logger.warn('THREE.DHLoaderAVWS: Joint "%s" could not be found.', t.joints[a]) } e.bind(new Skeleton(r, n), e.matrixWorld) } })), e })); var t })).then((function (t) { i.add(t); var o = []; if (a.children) for (var s = a.children, l = 0, c = s.length; l < c; l++) { var h = s[l]; o.push(e(h, t, r, n)) } return Promise.all(o) })) } return function (t) { var i = this.json, r = this.extensions, n = this.json.scenes[t], a = new Group; n.name && (a.name = this.createUniqueName(n.name)), U(a, n), n.extensions && F(r, a, n); for (var o = n.nodes || [], s = [], l = 0, c = o.length; l < c; l++)s.push(e(o[l], a, i, this)); return Promise.all(s).then((function () { return a })) } }(), e }(), gn = {}, bn = function (e, t, i, r, n) { var a = gn[t] || (gn[t] = URL.createObjectURL(new Blob([e], { type: "text/javascript" }))), o = new Worker(a); return o.onerror = function (e) { return n(e.error, null) }, o.onmessage = function (e) { return n(null, e.data) }, o.postMessage(i, r), o }, A = Uint8Array, R = Uint16Array, nr = Uint32Array, ur = new A([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), lr = new A([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), Mr = new A([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), wn = function (e, t) { for (var i = new R(31), r = 0; r < 31; ++r)i[r] = t += 1 << e[r - 1]; var n = new nr(i[30]); for (r = 1; r < 30; ++r)for (var a = i[r]; a < i[r + 1]; ++a)n[a] = a - i[r] << 5 | r; return [i, n] }, yn = wn(ur, 2), Nr = yn[0], Ir = yn[1]; Nr[28] = 258, Ir[258] = 28; for (var mn = wn(lr, 0), zn = mn[0], Qr = mn[1], Ur = new R(32768), T = 0; T < 32768; ++T) { var ir = (43690 & T) >>> 1 | (21845 & T) << 1; ir = (52428 & ir) >>> 2 | (13107 & ir) << 2, ir = (61680 & ir) >>> 4 | (3855 & ir) << 4, Ur[T] = ((65280 & ir) >>> 8 | (255 & ir) << 8) >>> 1 } for (var V = function (e, t, i) { for (var r = e.length, n = 0, a = new R(t); n < r; ++n)++a[e[n] - 1]; var o, s = new R(t); for (n = 0; n < t; ++n)s[n] = s[n - 1] + a[n - 1] << 1; if (i) { o = new R(1 << t); var l = 15 - t; for (n = 0; n < r; ++n)if (e[n]) for (var c = n << 4 | e[n], h = t - e[n], u = s[e[n] - 1]++ << h, d = u | (1 << h) - 1; u <= d; ++u)o[Ur[u] >>> l] = c } else for (o = new R(r), n = 0; n < r; ++n)e[n] && (o[n] = Ur[s[e[n] - 1]++] >>> 15 - e[n]); return o }, tr = new A(288), T = 0; T < 144; ++T)tr[T] = 8; for (var T = 144; T < 256; ++T)tr[T] = 9; for (var T = 256; T < 280; ++T)tr[T] = 7; for (var T = 280; T < 288; ++T)tr[T] = 8; for (var vr = new A(32), T = 0; T < 32; ++T)vr[T] = 5; var xn = V(tr, 9, 0), An = V(tr, 9, 1), Dn = V(vr, 5, 0), Mn = V(vr, 5, 1), Gr = function (e) { for (var t = e[0], i = 1; i < e.length; ++i)e[i] > t && (t = e[i]); return t }, X = function (e, t, i) { var r = t / 8 | 0; return (e[r] | e[r + 1] << 8) >> (7 & t) & i }, Or = function (e, t) { var i = t / 8 | 0; return (e[i] | e[i + 1] << 8 | e[i + 2] << 16) >> (7 & t) }, Cr = function (e) { return (e / 8 | 0) + (7 & e && 1) }, $ = function (e, t, i) { (null == t || t < 0) && (t = 0), (null == i || i > e.length) && (i = e.length); var r = new (e instanceof R ? R : e instanceof nr ? nr : A)(i - t); return r.set(e.subarray(t, i)), r }, Fr = function (e, t, i) { var r = e.length; if (!r || i && !i.l && r < 5) return t || new A(0); var n = !t || i, a = !i || i.i; i || (i = {}), t || (t = new A(3 * r)); var o = function (e) { var i = t.length; if (e > i) { var r = new A(Math.max(2 * i, e)); r.set(t), t = r } }, s = i.f || 0, l = i.p || 0, c = i.b || 0, h = i.l, u = i.d, d = i.m, p = i.n, f = 8 * r; do { if (!h) { i.f = s = X(e, l, 1); var m = X(e, l + 1, 3); if (l += 3, !m) { var g = e[(C = Cr(l) + 4) - 4] | e[C - 3] << 8, y = C + g; if (y > r) { if (a) throw "unexpected EOF"; break } n && o(c + g), t.set(e.subarray(C, y), c), i.b = c += g, i.p = l = 8 * y; continue } if (1 == m) h = An, u = Mn, d = 9, p = 5; else { if (2 != m) throw "invalid block type"; var v = X(e, l, 31) + 257, _ = X(e, l + 10, 15) + 4, b = v + X(e, l + 5, 31) + 1; l += 14; for (var x = new A(b), w = new A(19), S = 0; S < _; ++S)w[Mr[S]] = X(e, l + 3 * S, 7); l += 3 * _; var M = Gr(w), T = (1 << M) - 1; if (!a && l + b * (M + 7) > f) break; var E = V(w, M, 1); for (S = 0; S < b;) { var C, L = E[X(e, l, T)]; if (l += 15 & L, (C = L >>> 4) < 16) x[S++] = C; else { var R = 0, D = 0; for (16 == C ? (D = 3 + X(e, l, 3), l += 2, R = x[S - 1]) : 17 == C ? (D = 3 + X(e, l, 7), l += 3) : 18 == C && (D = 11 + X(e, l, 127), l += 7); D--;)x[S++] = R } } var P = x.subarray(0, v), O = x.subarray(v); d = Gr(P), p = Gr(O), h = V(P, d, 1), u = V(O, p, 1) } if (l > f) throw "unexpected EOF" } n && o(c + 131072); for (var I = (1 << d) - 1, k = (1 << p) - 1, B = d + p + 18; a || l + B < f;) { var N = (R = h[Or(e, l) & I]) >>> 4; if ((l += 15 & R) > f) throw "unexpected EOF"; if (!R) throw "invalid length/literal"; if (N < 256) t[c++] = N; else { if (256 == N) { h = null; break } var F = N - 254; if (N > 264) { var U = ur[S = N - 257]; F = X(e, l, (1 << U) - 1) + Nr[S], l += U } var z = u[Or(e, l) & k], G = z >>> 4; if (!z) throw "invalid distance"; l += 15 & z; O = zn[G]; if (G > 3) { U = lr[G]; O += Or(e, l) & (1 << U) - 1, l += U } if (l > f) throw "unexpected EOF"; n && o(c + 131072); for (var H = c + F; c < H; c += 4)t[c] = t[c - O], t[c + 1] = t[c + 1 - O], t[c + 2] = t[c + 2 - O], t[c + 3] = t[c + 3 - O]; c = H } } i.l = h, i.p = l, i.b = c, h && (s = 1, i.m = d, i.d = u, i.n = p) } while (!s); return c == t.length ? t : $(t, 0, c) }, b = function (e, t, i) { i <<= 7 & t; var r = t / 8 | 0; e[r] |= i, e[r + 1] |= i >>> 8 }, cr = function (e, t, i) { i <<= 7 & t; var r = t / 8 | 0; e[r] |= i, e[r + 1] |= i >>> 8, e[r + 2] |= i >>> 16 }, Er = function (e, t) { for (var i = [], r = 0; r < e.length; ++r)e[r] && i.push({ s: r, f: e[r] }); var n = i.length, a = i.slice(); if (!n) return [er, 0]; if (1 == n) { var o = new A(i[0].s + 1); return o[i[0].s] = 1, [o, 1] } i.sort((function (e, t) { return e.f - t.f })), i.push({ s: -1, f: 25001 }); var s = i[0], l = i[1], c = 0, h = 1, u = 2; for (i[0] = { s: -1, f: s.f + l.f, l: s, r: l }; h != n - 1;)s = i[i[c].f < i[u].f ? c++ : u++], l = i[c != h && i[c].f < i[u].f ? c++ : u++], i[h++] = { s: -1, f: s.f + l.f, l: s, r: l }; var d = a[0].s; for (r = 1; r < n; ++r)a[r].s > d && (d = a[r].s); var p = new R(d + 1), f = Pr(i[h - 1], p, 0); if (f > t) { r = 0; var m = 0, g = f - t, y = 1 << g; for (a.sort((function (e, t) { return p[t.s] - p[e.s] || e.f - t.f })); r < n; ++r) { var v = a[r].s; if (!(p[v] > t)) break; m += y - (1 << f - p[v]), p[v] = t } for (m >>>= g; m > 0;) { var _ = a[r].s; p[_] < t ? m -= 1 << t - p[_]++ - 1 : ++r } for (; r >= 0 && m; --r) { var b = a[r].s; p[b] == t && (--p[b], ++m) } f = t } return [new A(p), f] }, Pr = function (e, t, i) { return -1 == e.s ? Math.max(Pr(e.l, t, i + 1), Pr(e.r, t, i + 1)) : t[e.s] = i }, Vr = function (e) { for (var t = e.length; t && !e[--t];); for (var i = new R(++t), r = 0, n = e[0], a = 1, o = function (e) { i[r++] = e }, s = 1; s <= t; ++s)if (e[s] == n && s != t) ++a; else { if (!n && a > 2) { for (; a > 138; a -= 138)o(32754); a > 2 && (o(a > 10 ? a - 11 << 5 | 28690 : a - 3 << 5 | 12305), a = 0) } else if (a > 3) { for (o(n), --a; a > 6; a -= 6)o(8304); a > 2 && (o(a - 3 << 5 | 8208), a = 0) } for (; a--;)o(n); a = 1, n = e[s] } return [i.subarray(0, r), t] }, pr = function (e, t) { for (var i = 0, r = 0; r < t.length; ++r)i += e[r] * t[r]; return i }, Sr = function (e, t, i) { var r = i.length, n = Cr(t + 2); e[n] = 255 & r, e[n + 1] = r >>> 8, e[n + 2] = 255 ^ e[n], e[n + 3] = 255 ^ e[n + 1]; for (var a = 0; a < r; ++a)e[n + a + 4] = i[a]; return 8 * (n + 4 + r) }, Xr = function (e, t, i, r, n, a, o, s, l, c, h) { b(t, h++, i), ++n[256]; for (var u = Er(n, 15), d = u[0], p = u[1], f = Er(a, 15), m = f[0], g = f[1], y = Vr(d), v = y[0], _ = y[1], x = Vr(m), w = x[0], S = x[1], M = new R(19), T = 0; T < v.length; ++T)M[31 & v[T]]++; for (T = 0; T < w.length; ++T)M[31 & w[T]]++; for (var A = Er(M, 7), E = A[0], C = A[1], L = 19; L > 4 && !E[Mr[L - 1]]; --L); var D, P, O, I, k = c + 5 << 3, B = pr(n, tr) + pr(a, vr) + o, N = pr(n, d) + pr(a, m) + o + 14 + 3 * L + pr(M, E) + (2 * M[16] + 3 * M[17] + 7 * M[18]); if (k <= B && k <= N) return Sr(t, h, e.subarray(l, l + c)); if (b(t, h, 1 + (N < B)), h += 2, N < B) { D = V(d, p, 0), P = d, O = V(m, g, 0), I = m; var F = V(E, C, 0); b(t, h, _ - 257), b(t, h + 5, S - 1), b(t, h + 10, L - 4), h += 14; for (T = 0; T < L; ++T)b(t, h + 3 * T, E[Mr[T]]); h += 3 * L; for (var U = [v, w], z = 0; z < 2; ++z) { var G = U[z]; for (T = 0; T < G.length; ++T) { var H = 31 & G[T]; b(t, h, F[H]), h += E[H], H > 15 && (b(t, h, G[T] >>> 5 & 127), h += G[T] >>> 12) } } } else D = xn, P = tr, O = Dn, I = vr; for (T = 0; T < s; ++T)if (r[T] > 255) { H = r[T] >>> 18 & 31; cr(t, h, D[H + 257]), h += P[H + 257], H > 7 && (b(t, h, r[T] >>> 23 & 31), h += ur[H]); var j = 31 & r[T]; cr(t, h, O[j]), h += I[j], j > 3 && (cr(t, h, r[T] >>> 5 & 8191), h += lr[j]) } else cr(t, h, D[r[T]]), h += P[r[T]]; return cr(t, h, D[256]), h + P[256] }, Un = new nr([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), er = new A(0), Cn = function (e, t, i, r, n, a) { var o = e.length, s = new A(r + o + 5 * (1 + Math.ceil(o / 7e3)) + n), l = s.subarray(r, s.length - n), c = 0; if (!t || o < 8) for (var h = 0; h <= o; h += 65535) { var u = h + 65535; u < o ? c = Sr(l, c, e.subarray(h, u)) : (l[h] = a, c = Sr(l, c, e.subarray(h, o))) } else { for (var d = Un[t - 1], p = d >>> 13, f = 8191 & d, m = (1 << i) - 1, g = new R(32768), y = new R(m + 1), v = Math.ceil(i / 3), _ = 2 * v, b = function (t) { return (e[t] ^ e[t + 1] << v ^ e[t + 2] << _) & m }, x = new nr(25e3), w = new R(288), S = new R(32), M = 0, T = 0, E = (h = 0, 0), C = 0, L = 0; h < o; ++h) { var D = b(h), P = 32767 & h, O = y[D]; if (g[P] = O, y[D] = P, C <= h) { var I = o - h; if ((M > 7e3 || E > 24576) && I > 423) { c = Xr(e, l, 0, x, w, S, T, E, L, h - L, c), E = M = T = 0, L = h; for (var k = 0; k < 286; ++k)w[k] = 0; for (k = 0; k < 30; ++k)S[k] = 0 } var B = 2, N = 0, F = f, U = P - O & 32767; if (I > 2 && D == b(h - U)) for (var z = Math.min(p, I) - 1, G = Math.min(32767, h), H = Math.min(258, I); U <= G && --F && P != O;) { if (e[h + B] == e[h + B - U]) { for (var V = 0; V < H && e[h + V] == e[h + V - U]; ++V); if (V > B) { if (B = V, N = U, V > z) break; var j = Math.min(U, V - 2), W = 0; for (k = 0; k < j; ++k) { var Y = h - U + k + 32768 & 32767, X = Y - g[Y] + 32768 & 32767; X > W && (W = X, O = Y) } } } U += (P = O) - (O = g[P]) + 32768 & 32767 } if (N) { x[E++] = 268435456 | Ir[B] << 18 | Qr[N]; var Z = 31 & Ir[B], q = 31 & Qr[N]; T += ur[Z] + lr[q], ++w[257 + Z], ++S[q], C = h + B, ++M } else x[E++] = e[h], ++w[e[h]] } } c = Xr(e, l, a, x, w, S, T, E, L, h - L, c), !a && 7 & c && (c = Sr(l, c + 1, er)) } return $(s, 0, r + Cr(c) + n) }, Fn = function () { for (var e = new nr(256), t = 0; t < 256; ++t) { for (var i = t, r = 9; --r;)i = (1 & i && 3988292384) ^ i >>> 1; e[t] = i } return e }(), gr = function () { var e = -1; return { p: function (t) { for (var i = e, r = 0; r < t.length; ++r)i = Fn[255 & i ^ t[r]] ^ i >>> 8; e = i }, d: function () { return ~e } } }, $r = function () { var e = 1, t = 0; return { p: function (i) { for (var r = e, n = t, a = i.length, o = 0; o != a;) { for (var s = Math.min(o + 2655, a); o < s; ++o)n += r += i[o]; r = (65535 & r) + 15 * (r >> 16), n = (65535 & n) + 15 * (n >> 16) } e = r, t = n }, d: function () { return ((e %= 65521) >>> 8 << 16 | (255 & (t %= 65521)) << 8 | t >>> 8) + 2 * ((255 & e) << 23) } } }, sr = function (e, t, i, r, n) { return Cn(e, null == t.level ? 6 : t.level, null == t.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e.length)))) : 12 + t.mem, i, r, !n) }, Zr = function (e, t) { var i = {}; for (var r in e) i[r] = e[r]; for (var r in t) i[r] = t[r]; return i }, Sn = function (e, t, i) { for (var r = e(), n = e.toString(), a = n.slice(n.indexOf("[") + 1, n.lastIndexOf("]")).replace(/ /g, "").split(","), o = 0; o < r.length; ++o) { var s = r[o], l = a[o]; if ("function" == typeof s) { t += ";" + l + "="; var c = s.toString(); if (s.prototype) if (-1 != c.indexOf("[native code]")) { var h = c.indexOf(" ", 8) + 1; t += c.slice(h, c.indexOf("(", h)) } else for (var u in t += c, s.prototype) t += ";" + l + ".prototype." + u + "=" + s.prototype[u].toString(); else t += c } else i[l] = s } return [t, i] }, Rr = [], rt = function (e) { var t = []; for (var i in e) (e[i] instanceof A || e[i] instanceof R || e[i] instanceof nr) && t.push((e[i] = new e[i].constructor(e[i])).buffer); return t }, Zn = function (e, t, i, r) { var n; if (!Rr[i]) { for (var a = "", o = {}, s = e.length - 1, l = 0; l < s; ++l)a = (n = Sn(e[l], a, o))[0], o = n[1]; Rr[i] = Sn(e[s], a, o) } var c = Zr({}, Rr[i][1]); return bn(Rr[i][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + t.toString() + "}", i, c, rt(c), r) }, wr = function () { return [A, R, nr, ur, lr, Mr, Nr, zn, An, Mn, Ur, V, Gr, X, Or, Cr, $, Fr, xr, ar, Lr] }, yr = function () { return [A, R, nr, ur, lr, Mr, Ir, Qr, xn, tr, Dn, vr, Ur, Un, er, V, b, cr, Er, Pr, Vr, pr, Sr, Xr, Cr, $, Cn, sr, kr, ar] }, kn = function () { return [_r, rn, F, gr, Fn] }, Bn = function () { return [br, Gn] }, Tn = function () { return [nn, F, $r] }, In = function () { return [On] }, ar = function (e) { return postMessage(e, [e.buffer]) }, Lr = function (e) { return e && e.size && new A(e.size) }, mr = function (e, t, i, r, n, a) { var o = Zn(i, r, n, (function (e, t) { o.terminate(), a(e, t) })); return o.postMessage([e, t], t.consume ? [e.buffer] : []), function () { o.terminate() } }, L = function (e) { return e.ondata = function (e, t) { return postMessage([e, t], [e.buffer]) }, function (t) { return e.push(t.data[0], t.data[1]) } }, zr = function (e, t, i, r, n) { var a, o = Zn(e, r, n, (function (e, i) { e ? (o.terminate(), t.ondata.call(t, e)) : (i[1] && o.terminate(), t.ondata.call(t, e, i[0], i[1])) })); o.postMessage(i), t.push = function (e, i) { if (a) throw "stream finished"; if (!t.ondata) throw "no stream handler"; o.postMessage([e, a = i], [e.buffer]) }, t.terminate = function () { o.terminate() } }, Y = function (e, t) { return e[t] | e[t + 1] << 8 }, P = function (e, t) { return (e[t] | e[t + 1] << 8 | e[t + 2] << 16) + 2 * (e[t + 3] << 23) }, dr = function (e, t) { return P(e, t) | 4294967296 * P(e, t) }, F = function (e, t, i) { for (; i; ++t)e[t] = i, i >>>= 8 }, _r = function (e, t) { var i = t.filename; if (e[0] = 31, e[1] = 139, e[2] = 8, e[8] = t.level < 2 ? 4 : 9 == t.level ? 2 : 0, e[9] = 3, 0 != t.mtime && F(e, 4, Math.floor(new Date(t.mtime || Date.now()) / 1e3)), i) { e[3] = 8; for (var r = 0; r <= i.length; ++r)e[r + 10] = i.charCodeAt(r) } }, br = function (e) { if (31 != e[0] || 139 != e[1] || 8 != e[2]) throw "invalid gzip data"; var t = e[3], i = 10; 4 & t && (i += e[10] | 2 + (e[11] << 8)); for (var r = (t >> 3 & 1) + (t >> 4 & 1); r > 0; r -= !e[i++]); return i + (2 & t) }, Gn = function (e) { var t = e.length; return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16) + 2 * (e[t - 1] << 23) }, rn = function (e) { return 10 + (e.filename && e.filename.length + 1 || 0) }, nn = function (e, t) { var i = t.level, r = 0 == i ? 0 : i < 6 ? 1 : 9 == i ? 3 : 2; e[0] = 120, e[1] = r << 6 | (r ? 32 - 2 * r : 1) }, On = function (e) { if (8 != (15 & e[0]) || e[0] >>> 4 > 7 || (e[0] << 8 | e[1]) % 31) throw "invalid zlib data"; if (32 & e[1]) throw "invalid zlib data: preset dictionaries not supported" }; function tn(e, t) { return !t && "function" == typeof e && (t = e, e = {}), this.ondata = t, e } var rr = function () { function e(e, t) { !t && "function" == typeof e && (t = e, e = {}), this.ondata = t, this.o = e || {} } return e.prototype.p = function (e, t) { this.ondata(sr(e, this.o, 0, 0, !t), t) }, e.prototype.push = function (e, t) { if (this.d) throw "stream finished"; if (!this.ondata) throw "no stream handler"; this.d = t, this.p(e, t || !1) }, e }(), En = function (e, t) { zr([yr, function () { return [L, rr] }], this, tn.call(this, e, t), (function (e) { var t = new rr(e.data); onmessage = L(t) }), 6) }; function Pn(e, t, i) { if (i || (i = t, t = {}), "function" != typeof i) throw "no callback"; return mr(e, t, [yr], (function (e) { return ar(kr(e.data[0], e.data[1])) }), 0, i) } function kr(e, t) { return sr(e, t || {}, 0, 0) } var J = function () { function e(e) { this.s = {}, this.p = new A(0), this.ondata = e } return e.prototype.e = function (e) { if (this.d) throw "stream finished"; if (!this.ondata) throw "no stream handler"; var t = this.p.length, i = new A(t + e.length); i.set(this.p), i.set(e, t), this.p = i }, e.prototype.c = function (e) { this.d = this.s.i = e || !1; var t = this.s.b, i = Fr(this.p, this.o, this.s); this.ondata($(i, t, this.s.b), this.d), this.o = $(i, this.s.b - 32768), this.s.b = this.o.length, this.p = $(this.p, this.s.p / 8 | 0), this.s.p &= 7 }, e.prototype.push = function (e, t) { this.e(e), this.c(t) }, e }(), en = function (e) { this.ondata = e, zr([wr, function () { return [L, J] }], this, 0, (function () { var e = new J; onmessage = L(e) }), 7) }; function an(e, t, i) { if (i || (i = t, t = {}), "function" != typeof i) throw "no callback"; return mr(e, t, [wr], (function (e) { return ar(xr(e.data[0], Lr(e.data[1]))) }), 1, i) } function xr(e, t) { return Fr(e, t) } var qr = function () { function e(e, t) { this.c = gr(), this.l = 0, this.v = 1, rr.call(this, e, t) } return e.prototype.push = function (e, t) { rr.prototype.push.call(this, e, t) }, e.prototype.p = function (e, t) { this.c.p(e), this.l += e.length; var i = sr(e, this.o, this.v && rn(this.o), t && 8, !t); this.v && (_r(i, this.o), this.v = 0), t && (F(i, i.length - 8, this.c.d()), F(i, i.length - 4, this.l)), this.ondata(i, t) }, e }(), Rn = function (e, t) { zr([yr, kn, function () { return [L, rr, qr] }], this, tn.call(this, e, t), (function (e) { var t = new qr(e.data); onmessage = L(t) }), 8) }; function qn(e, t, i) { if (i || (i = t, t = {}), "function" != typeof i) throw "no callback"; return mr(e, t, [yr, kn, function () { return [Hr] }], (function (e) { return ar(Hr(e.data[0], e.data[1])) }), 2, i) } function Hr(e, t) { t || (t = {}); var i = gr(), r = e.length; i.p(e); var n = sr(e, t, rn(t), 8), a = n.length; return _r(n, t), F(n, a - 8, i.d()), F(n, a - 4, r), n } var Wr = function () { function e(e) { this.v = 1, J.call(this, e) } return e.prototype.push = function (e, t) { if (J.prototype.e.call(this, e), this.v) { var i = this.p.length > 3 ? br(this.p) : 4; if (i >= this.p.length && !t) return; this.p = this.p.subarray(i), this.v = 0 } if (t) { if (this.p.length < 8) throw "invalid gzip stream"; this.p = this.p.subarray(0, -8) } J.prototype.c.call(this, t) }, e }(), Hn = function (e) { this.ondata = e, zr([wr, Bn, function () { return [L, J, Wr] }], this, 0, (function () { var e = new Wr; onmessage = L(e) }), 9) }; function Wn(e, t, i) { if (i || (i = t, t = {}), "function" != typeof i) throw "no callback"; return mr(e, t, [wr, Bn, function () { return [Yr] }], (function (e) { return ar(Yr(e.data[0])) }), 3, i) } function Yr(e, t) { return Fr(e.subarray(br(e), -8), t || new A(Gn(e))) } var on = function () { function e(e, t) { this.c = $r(), this.v = 1, rr.call(this, e, t) } return e.prototype.push = function (e, t) { rr.prototype.push.call(this, e, t) }, e.prototype.p = function (e, t) { this.c.p(e); var i = sr(e, this.o, this.v && 2, t && 4, !t); this.v && (nn(i, this.o), this.v = 0), t && F(i, i.length - 4, this.c.d()), this.ondata(i, t) }, e }(), nt = function (e, t) { zr([yr, Tn, function () { return [L, rr, on] }], this, tn.call(this, e, t), (function (e) { var t = new on(e.data); onmessage = L(t) }), 10) }; function tt(e, t, i) { if (i || (i = t, t = {}), "function" != typeof i) throw "no callback"; return mr(e, t, [yr, Tn, function () { return [fn] }], (function (e) { return ar(fn(e.data[0], e.data[1])) }), 4, i) } function fn(e, t) { t || (t = {}); var i = $r(); i.p(e); var r = sr(e, t, 2, 4); return nn(r, t), F(r, r.length - 4, i.d()), r } var jr = function () { function e(e) { this.v = 1, J.call(this, e) } return e.prototype.push = function (e, t) { if (J.prototype.e.call(this, e), this.v) { if (this.p.length < 2 && !t) return; this.p = this.p.subarray(2), this.v = 0 } if (t) { if (this.p.length < 4) throw "invalid zlib stream"; this.p = this.p.subarray(0, -4) } J.prototype.c.call(this, t) }, e }(), Yn = function (e) { this.ondata = e, zr([wr, In, function () { return [L, J, jr] }], this, 0, (function () { var e = new jr; onmessage = L(e) }), 11) }; function jn(e, t, i) { if (i || (i = t, t = {}), "function" != typeof i) throw "no callback"; return mr(e, t, [wr, In, function () { return [Jr] }], (function (e) { return ar(Jr(e.data[0], Lr(e.data[1]))) }), 5, i) } function Jr(e, t) { return Fr((On(e), e.subarray(2, -4)), t) } var Jn = function () { function e(e) { this.G = Wr, this.I = J, this.Z = jr, this.ondata = e } return e.prototype.push = function (e, t) { if (!this.ondata) throw "no stream handler"; if (this.s) this.s.push(e, t); else { if (this.p && this.p.length) { var i = new A(this.p.length + e.length); i.set(this.p), i.set(e, this.p.length) } else this.p = e; if (this.p.length > 2) { var r = this, n = function () { r.ondata.apply(r, arguments) }; this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(n) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(n) : new this.Z(n), this.s.push(this.p, t), this.p = null } } }, e }(), et = function () { function e(e) { this.G = Hn, this.I = en, this.Z = Yn, this.ondata = e } return e.prototype.push = function (e, t) { Jn.prototype.push.call(this, e, t) }, e }(); function it(e, t, i) { if (i || (i = t, t = {}), "function" != typeof i) throw "no callback"; return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Wn(e, t, i) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? an(e, t, i) : jn(e, t, i) } function at(e, t) { return 31 == e[0] && 139 == e[1] && 8 == e[2] ? Yr(e, t) : 8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31 ? xr(e, t) : Jr(e, t) } var sn = function (e, t, i, r) { for (var n in e) { var a = e[n], o = t + n; a instanceof A ? i[o] = [a, r] : Array.isArray(a) ? i[o] = [a[0], Zr(r, a[1])] : sn(a, o + "/", i, r) } }, Kn = "undefined" != typeof TextEncoder && new TextEncoder, hn = "undefined" != typeof TextDecoder && new TextDecoder, Nn = 0; try { hn.decode(er, { stream: !0 }), Nn = 1 } catch (e) { } var Qn = function (e) { for (var t = "", i = 0; ;) { var r = e[i++], n = (r > 127) + (r > 223) + (r > 239); if (i + n > e.length) return [t, $(e, i - 1)]; n ? 3 == n ? (r = ((15 & r) << 18 | (63 & e[i++]) << 12 | (63 & e[i++]) << 6 | 63 & e[i++]) - 65536, t += String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)) : t += 1 & n ? String.fromCharCode((31 & r) << 6 | 63 & e[i++]) : String.fromCharCode((15 & r) << 12 | (63 & e[i++]) << 6 | 63 & e[i++]) : t += String.fromCharCode(r) } }, ot = function () { function e(e) { this.ondata = e, Nn ? this.t = new TextDecoder : this.p = er } return e.prototype.push = function (e, t) { if (!this.ondata) throw "no callback"; if (t || (t = !1), this.t) return this.ondata(this.t.decode(e, { stream: !t }), t); var i = new A(this.p.length + e.length); i.set(this.p), i.set(e, this.p.length); var r = Qn(i), n = r[0], a = r[1]; if (t && a.length) throw "invalid utf-8 data"; this.p = a, this.ondata(n, t) }, e }(), ft = function () { function e(e) { this.ondata = e } return e.prototype.push = function (e, t) { if (!this.ondata) throw "no callback"; this.ondata(or(e), t || !1) }, e }(); function or(e, t) { if (t) { for (var i = new A(e.length), r = 0; r < e.length; ++r)i[r] = e.charCodeAt(r); return i } if (Kn) return Kn.encode(e); var n = e.length, a = new A(e.length + (e.length >> 1)), o = 0, s = function (e) { a[o++] = e }; for (r = 0; r < n; ++r) { if (o + 5 > a.length) { var l = new A(o + 8 + (n - r << 1)); l.set(a), a = l } var c = e.charCodeAt(r); c < 128 || t ? s(c) : c < 2048 ? (s(192 | c >>> 6), s(128 | 63 & c)) : c > 55295 && c < 57344 ? (s(240 | (c = 65536 + (1047552 & c) | 1023 & e.charCodeAt(++r)) >>> 18), s(128 | c >>> 12 & 63), s(128 | c >>> 6 & 63), s(128 | 63 & c)) : (s(224 | c >>> 12), s(128 | c >>> 6 & 63), s(128 | 63 & c)) } return $(a, 0, o) } function un(e, t) { if (t) { for (var i = "", r = 0; r < e.length; r += 16384)i += String.fromCharCode.apply(null, e.subarray(r, r + 16384)); return i } if (hn) return hn.decode(e); var n = Qn(e), a = n[0]; if (n[1].length) throw "invalid utf-8 data"; return a } var Vn = function (e) { return 1 == e ? 3 : e < 6 ? 2 : 9 == e ? 1 : 0 }, Xn = function (e, t) { return t + 30 + Y(e, t + 26) + Y(e, t + 28) }, $n = function (e, t, i) { var r = Y(e, t + 28), n = un(e.subarray(t + 46, t + 46 + r), !(2048 & Y(e, t + 8))), a = t + 46 + r, o = P(e, t + 20), s = i && 4294967295 == o ? Ln(e, a) : [o, P(e, t + 24), P(e, t + 42)], l = s[0], c = s[1], h = s[2]; return [Y(e, t + 10), l, c, n, a + Y(e, t + 30) + Y(e, t + 32), h] }, Ln = function (e, t) { for (; 1 != Y(e, t); t += 4 + Y(e, t + 2)); return [dr(e, t + 12), dr(e, t + 4), dr(e, t + 20)] }, fr = function (e) { var t = 0; if (e) for (var i in e) { var r = e[i].length; if (r > 65535) throw "extra field too long"; t += r + 4 } return t }, Ar = function (e, t, i, r, n, a, o, s) { var l = r.length, c = i.extra, h = s && s.length, u = fr(c); F(e, t, null != o ? 33639248 : 67324752), t += 4, null != o && (e[t++] = 20, e[t++] = i.os), e[t] = 20, t += 2, e[t++] = i.flag << 1 | (null == a && 8), e[t++] = n && 8, e[t++] = 255 & i.compression, e[t++] = i.compression >> 8; var d = new Date(null == i.mtime ? Date.now() : i.mtime), p = d.getFullYear() - 1980; if (p < 0 || p > 119) throw "date not in range 1980-2099"; if (F(e, t, 2 * (p << 24) | d.getMonth() + 1 << 21 | d.getDate() << 16 | d.getHours() << 11 | d.getMinutes() << 5 | d.getSeconds() >>> 1), t += 4, null != a && (F(e, t, i.crc), F(e, t + 4, a), F(e, t + 8, i.size)), F(e, t + 12, l), F(e, t + 14, u), t += 16, null != o && (F(e, t, h), F(e, t + 6, i.attrs), F(e, t + 10, o), t += 14), e.set(r, t), t += l, u) for (var f in c) { var m = c[f], g = m.length; F(e, t, +f), F(e, t + 2, g), e.set(m, t + 4), t += 4 + g } return h && (e.set(s, t), t += h), t }, ln = function (e, t, i, r, n) { F(e, t, 101010256), F(e, t + 8, i), F(e, t + 10, i), F(e, t + 12, r), F(e, t + 16, n) }, Br = function () { function e(e) { this.filename = e, this.c = gr(), this.size = 0, this.compression = 0 } return e.prototype.process = function (e, t) { this.ondata(null, e, t) }, e.prototype.push = function (e, t) { if (!this.ondata) throw "no callback - add to ZIP archive before pushing"; this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1) }, e }(), st = function () { function e(e, t) { var i = this; t || (t = {}), Br.call(this, e), this.d = new rr(t, (function (e, t) { i.ondata(null, e, t) })), this.compression = 8, this.flag = Vn(t.level) } return e.prototype.process = function (e, t) { try { this.d.push(e, t) } catch (e) { this.ondata(e, null, t) } }, e.prototype.push = function (e, t) { Br.prototype.push.call(this, e, t) }, e }(), ht = function () { function e(e, t) { var i = this; t || (t = {}), Br.call(this, e), this.d = new En(t, (function (e, t, r) { i.ondata(e, t, r) })), this.compression = 8, this.flag = Vn(t.level), this.terminate = this.d.terminate } return e.prototype.process = function (e, t) { this.d.push(e, t) }, e.prototype.push = function (e, t) { Br.prototype.push.call(this, e, t) }, e }(), ut = function () { function e(e) { this.ondata = e, this.u = [], this.d = 1 } return e.prototype.add = function (e) { var t = this; if (2 & this.d) throw "stream finished"; var i = or(e.filename), r = i.length, n = e.comment, a = n && or(n), o = r != e.filename.length || a && n.length != a.length, s = r + fr(e.extra) + 30; if (r > 65535) throw "filename too long"; var l = new A(s); Ar(l, 0, e, i, o); var c = [l], h = function () { for (var e = 0, i = c; e < i.length; e++) { var r = i[e]; t.ondata(null, r, !1) } c = [] }, u = this.d; this.d = 0; var d = this.u.length, p = Zr(e, { f: i, u: o, o: a, t: function () { e.terminate && e.terminate() }, r: function () { if (h(), u) { var e = t.u[d + 1]; e ? e.r() : t.d = 1 } u = 1 } }), f = 0; e.ondata = function (i, r, n) { if (i) t.ondata(i, r, n), t.terminate(); else if (f += r.length, c.push(r), n) { var a = new A(16); F(a, 0, 134695760), F(a, 4, e.crc), F(a, 8, f), F(a, 12, e.size), c.push(a), p.c = f, p.b = s + f + 16, p.crc = e.crc, p.size = e.size, u && p.r(), u = 1 } else u && h() }, this.u.push(p) }, e.prototype.end = function () { var e = this; if (2 & this.d) throw 1 & this.d ? "stream finishing" : "stream finished"; this.d ? this.e() : this.u.push({ r: function () { 1 & e.d && (e.u.splice(-1, 1), e.e()) }, t: function () { } }), this.d = 3 }, e.prototype.e = function () { for (var e = 0, t = 0, i = 0, r = 0, n = this.u; r < n.length; r++) { i += 46 + (l = n[r]).f.length + fr(l.extra) + (l.o ? l.o.length : 0) } for (var a = new A(i + 22), o = 0, s = this.u; o < s.length; o++) { var l = s[o]; Ar(a, e, l, l.f, l.u, l.c, t, l.o), e += 46 + l.f.length + fr(l.extra) + (l.o ? l.o.length : 0), t += l.b } ln(a, e, this.u.length, i, t), this.ondata(null, a, !0), this.d = 2 }, e.prototype.terminate = function () { for (var e = 0, t = this.u; e < t.length; e++) { t[e].t() } this.d = 2 }, e }(); function lt(e, t, i) { if (i || (i = t, t = {}), "function" != typeof i) throw "no callback"; var r = {}; sn(e, "", r, t); var n = Object.keys(r), a = n.length, o = 0, s = 0, l = a, c = new Array(a), h = [], u = function () { for (var e = 0; e < h.length; ++e)h[e]() }, d = function () { var e = new A(s + 22), t = o, r = s - o; s = 0; for (var n = 0; n < l; ++n) { var a = c[n]; try { var h = a.c.length; Ar(e, s, a, a.f, a.u, h); var u = 30 + a.f.length + fr(a.extra), d = s + u; e.set(a.c, d), Ar(e, o, a, a.f, a.u, h, s, a.m), o += 16 + u + (a.m ? a.m.length : 0), s = d + h } catch (e) { return i(e, null) } } ln(e, o, c.length, r, t), i(null, e) }; a || d(); for (var p = function (e) { var t = n[e], l = r[t], p = l[0], f = l[1], m = gr(), g = p.length; m.p(p); var y = or(t), v = y.length, _ = f.comment, b = _ && or(_), x = b && b.length, w = fr(f.extra), S = 0 == f.level ? 0 : 8, M = function (r, n) { if (r) u(), i(r, null); else { var l = n.length; c[e] = Zr(f, { size: g, crc: m.d(), c: n, f: y, m: b, u: v != t.length || b && _.length != x, compression: S }), o += 30 + v + w + l, s += 76 + 2 * (v + w) + (x || 0) + l, --a || d() } }; if (v > 65535 && M("filename too long", null), S) if (g < 16e4) try { M(null, kr(p, f)) } catch (e) { M(e, null) } else h.push(Pn(p, f, M)); else M(null, p) }, f = 0; f < l; ++f)p(f); return u } function vt(e, t) { t || (t = {}); var i = {}, r = []; sn(e, "", i, t); var n = 0, a = 0; for (var o in i) { var s = i[o], l = s[0], c = s[1], h = 0 == c.level ? 0 : 8, u = (S = or(o)).length, d = c.comment, p = d && or(d), f = p && p.length, m = fr(c.extra); if (u > 65535) throw "filename too long"; var g = h ? kr(l, c) : l, y = g.length, v = gr(); v.p(l), r.push(Zr(c, { size: l.length, crc: v.d(), c: g, f: S, m: p, u: u != o.length || p && d.length != f, o: n, compression: h })), n += 30 + u + m + y, a += 76 + 2 * (u + m) + (f || 0) + y } for (var _ = new A(a + 22), b = n, x = a - n, w = 0; w < r.length; ++w) { var S = r[w]; Ar(_, S.o, S, S.f, S.u, S.c.length); var M = 30 + S.f.length + fr(S.extra); _.set(S.c, S.o + M), Ar(_, n, S, S.f, S.u, S.c.length, S.o, S.m), n += 16 + M + (S.m ? S.m.length : 0) } return ln(_, n, r.length, x, b), _ } var dn = function () { function e() { } return e.prototype.push = function (e, t) { this.ondata(null, e, t) }, e.compression = 0, e }(), ct = function () { function e() { var e = this; this.i = new J((function (t, i) { e.ondata(null, t, i) })) } return e.prototype.push = function (e, t) { try { this.i.push(e, t) } catch (i) { this.ondata(i, e, t) } }, e.compression = 8, e }(), pt = function () { function e(e, t) { var i = this; t < 32e4 ? this.i = new J((function (e, t) { i.ondata(null, e, t) })) : (this.i = new en((function (e, t, r) { i.ondata(e, t, r) })), this.terminate = this.i.terminate) } return e.prototype.push = function (e, t) { this.i.terminate && (e = $(e, 0)), this.i.push(e, t) }, e.compression = 8, e }(), gt = function () { function e(e) { this.onfile = e, this.k = [], this.o = { 0: dn }, this.p = er } return e.prototype.push = function (e, t) { var i = this; if (!this.onfile) throw "no callback"; if (this.c > 0) { var r = Math.min(this.c, e.length), n = e.subarray(0, r); if (this.c -= r, this.d ? this.d.push(n, !this.c) : this.k[0].push(n), (e = e.subarray(r)).length) return this.push(e, t) } else { var a = 0, o = 0, s = void 0, l = void 0; this.p.length ? e.length ? ((l = new A(this.p.length + e.length)).set(this.p), l.set(e, this.p.length)) : l = this.p : l = e; for (var c = l.length, h = this.c, u = h && this.d, d = function () { var e, t = P(l, o); if (67324752 == t) { a = 1, s = o, p.d = null, p.c = 0; var r = Y(l, o + 6), n = Y(l, o + 8), u = 2048 & r, d = 8 & r, f = Y(l, o + 26), m = Y(l, o + 28); if (c > o + 30 + f + m) { var g = []; p.k.unshift(g), a = 2; var y = P(l, o + 18), v = P(l, o + 22), _ = un(l.subarray(o + 30, o += 30 + f), !u); 4294967295 == y ? (e = d ? [-2] : Ln(l, o), y = e[0], v = e[1]) : d && (y = -1), o += m, p.c = y; var b = { name: _, compression: n, start: function () { if (!b.ondata) throw "no callback"; if (y) { var e = i.o[n]; if (!e) throw "unknown compression type " + n; var t = y < 0 ? new e(_) : new e(_, y, v); t.ondata = function (e, t, i) { b.ondata(e, t, i) }; for (var r = 0, a = g; r < a.length; r++) { var o = a[r]; t.push(o, !1) } i.k[0] == g ? i.d = t : t.push(er, !0) } else b.ondata(null, er, !0) }, terminate: function () { i.k[0] == g && i.d.terminate && i.d.terminate() } }; y >= 0 && (b.size = y, b.originalSize = v), p.onfile(b) } return "break" } if (h) { if (134695760 == t) return s = o += 12 + (-2 == h && 8), a = 2, p.c = 0, "break"; if (33639248 == t) return s = o -= 4, a = 2, p.c = 0, "break" } }, p = this; o < c - 4; ++o) { if ("break" === d()) break } if (this.p = er, h < 0) { var f = a ? l.subarray(0, s - 12 - (-2 == h && 8) - (134695760 == P(l, s - 16) && 4)) : l.subarray(0, o); u ? u.push(f, !!a) : this.k[+(2 == a)].push(f) } if (2 & a) return this.push(l.subarray(o), t); this.p = l.subarray(o) } if (t && this.c) throw "invalid zip file" }, e.prototype.register = function (e) { this.o[e.compression] = e }, e }(); function wt(e, t) { if ("function" != typeof t) throw "no callback"; for (var i = [], r = function () { for (var e = 0; e < i.length; ++e)i[e]() }, n = {}, a = e.length - 22; 101010256 != P(e, a); --a)if (!a || e.length - a > 65558) return void t("invalid zip file", null); var o = Y(e, a + 8); o || t(null, {}); var s = o, l = P(e, a + 16), c = 4294967295 == l; if (c) { if (a = P(e, a - 12), 101075792 != P(e, a)) return void t("invalid zip file", null); s = o = P(e, a + 32), l = P(e, a + 48) } for (var h = function (a) { var s = $n(e, l, c), h = s[0], u = s[1], d = s[2], p = s[3], f = s[4], m = s[5], g = Xn(e, m); l = f; var y = function (e, i) { e ? (r(), t(e, null)) : (n[p] = i, --o || t(null, n)) }; if (h) if (8 == h) { var v = e.subarray(g, g + u); if (u < 32e4) try { y(null, xr(v, new A(d))) } catch (e) { y(e, null) } else i.push(an(v, { size: d }, y)) } else y("unknown compression type " + h, null); else y(null, $(e, g, g + u)) }, u = 0; u < s; ++u)h(); return r } function yt(e) { for (var t = {}, i = e.length - 22; 101010256 != P(e, i); --i)if (!i || e.length - i > 65558) throw "invalid zip file"; var r = Y(e, i + 8); if (!r) return {}; var n = P(e, i + 16), a = 4294967295 == n; if (a) { if (i = P(e, i - 12), 101075792 != P(e, i)) throw "invalid zip file"; r = P(e, i + 32), n = P(e, i + 48) } for (var o = 0; o < r; ++o) { var s = $n(e, n, a), l = s[0], c = s[1], h = s[2], u = s[3], d = s[4], p = s[5], f = Xn(e, p); if (n = d, l) { if (8 != l) throw "unknown compression type " + l; t[u] = xr(e.subarray(f, f + c), new A(h)) } else t[u] = $(e, f, f + c) } return t } var fflate_module_min = null, fflate = Object.freeze({ __proto__: null, AsyncCompress: Rn, AsyncDecompress: et, AsyncDeflate: En, AsyncGunzip: Hn, AsyncGzip: Rn, AsyncInflate: en, AsyncUnzipInflate: pt, AsyncUnzlib: Yn, AsyncZipDeflate: ht, AsyncZlib: nt, Compress: qr, DecodeUTF8: ot, Decompress: Jn, Deflate: rr, EncodeUTF8: ft, Gunzip: Wr, Gzip: qr, Inflate: J, Unzip: gt, UnzipInflate: ct, UnzipPassThrough: dn, Unzlib: jr, Zip: ut, ZipDeflate: st, ZipPassThrough: Br, Zlib: on, compress: qn, compressSync: Hr, decompress: it, decompressSync: at, deflate: Pn, deflateSync: kr, gunzip: Wn, gunzipSync: Yr, gzip: qn, gzipSync: Hr, inflate: an, inflateSync: xr, strFromU8: un, strToU8: or, unzip: wt, unzipSync: yt, unzlib: jn, unzlibSync: Jr, zip: lt, zipSync: vt, zlib: tt, zlibSync: fn, default: fflate_module_min }); const NURBSUtils = { findSpan: function (e, t, i) { var r = i.length - e - 1; if (t >= i[r]) return r - 1; if (t <= i[e]) return e; for (var n = e, a = r, o = Math.floor((n + a) / 2); t < i[o] || t >= i[o + 1];)t < i[o] ? a = o : n = o, o = Math.floor((n + a) / 2); return o }, calcBasisFunctions: function (e, t, i, r) { var n = [], a = [], o = []; n[0] = 1; for (var s = 1; s <= i; ++s) { a[s] = t - r[e + 1 - s], o[s] = r[e + s] - t; for (var l = 0, c = 0; c < s; ++c) { var h = o[c + 1], u = a[s - c], d = n[c] / (h + u); n[c] = l + h * d, l = u * d } n[s] = l } return n }, calcBSplinePoint: function (e, t, i, r) { for (var n = this.findSpan(e, r, t), a = this.calcBasisFunctions(n, r, e, t), o = new Vector4(0, 0, 0, 0), s = 0; s <= e; ++s) { var l = i[n - e + s], c = a[s], h = l.w * c; o.x += l.x * h, o.y += l.y * h, o.z += l.z * h, o.w += l.w * c } return o }, calcBasisFunctionDerivatives: function (e, t, i, r, n) { for (var a = [], o = 0; o <= i; ++o)a[o] = 0; var s = []; for (o = 0; o <= r; ++o)s[o] = a.slice(0); var l = []; for (o = 0; o <= i; ++o)l[o] = a.slice(0); l[0][0] = 1; for (var c = a.slice(0), h = a.slice(0), u = 1; u <= i; ++u) { c[u] = t - n[e + 1 - u], h[u] = n[e + u] - t; for (var d = 0, p = 0; p < u; ++p) { var f = h[p + 1], m = c[u - p]; l[u][p] = f + m; var g = l[p][u - 1] / l[u][p]; l[p][u] = d + f * g, d = m * g } l[u][u] = d } for (u = 0; u <= i; ++u)s[0][u] = l[u][i]; for (p = 0; p <= i; ++p) { var y = 0, v = 1, _ = []; for (o = 0; o <= i; ++o)_[o] = a.slice(0); _[0][0] = 1; for (var b = 1; b <= r; ++b) { var x = 0, w = p - b, S = i - b; p >= b && (_[v][0] = _[y][0] / l[S + 1][w], x = _[v][0] * l[w][S]); var M = p - 1 <= S ? b - 1 : i - p; for (u = w >= -1 ? 1 : -w; u <= M; ++u)_[v][u] = (_[y][u] - _[y][u - 1]) / l[S + 1][w + u], x += _[v][u] * l[w + u][S]; p <= S && (_[v][b] = -_[y][b - 1] / l[S + 1][p], x += _[v][b] * l[p][S]), s[b][p] = x; u = y; y = v, v = u } } for (p = i, b = 1; b <= r; ++b) { for (u = 0; u <= i; ++u)s[b][u] *= p; p *= i - b } return s }, calcBSplineDerivatives: function (e, t, i, r, n) { for (var a = n < e ? n : e, o = [], s = this.findSpan(e, r, t), l = this.calcBasisFunctionDerivatives(s, r, e, a, t), c = [], h = 0; h < i.length; ++h) { var u = (p = i[h].clone()).w; p.x *= u, p.y *= u, p.z *= u, c[h] = p } for (var d = 0; d <= a; ++d) { for (var p = c[s - e].clone().multiplyScalar(l[d][0]), f = 1; f <= e; ++f)p.add(c[s - e + f].clone().multiplyScalar(l[d][f])); o[d] = p } for (d = a + 1; d <= n + 1; ++d)o[d] = new Vector4(0, 0, 0); return o }, calcKoverI: function (e, t) { for (var i = 1, r = 2; r <= e; ++r)i *= r; var n = 1; for (r = 2; r <= t; ++r)n *= r; for (r = 2; r <= e - t; ++r)n *= r; return i / n }, calcRationalCurveDerivatives: function (e) { for (var t = e.length, i = [], r = [], n = 0; n < t; ++n) { var a = e[n]; i[n] = new Vector3(a.x, a.y, a.z), r[n] = a.w } for (var o = [], s = 0; s < t; ++s) { var l = i[s].clone(); for (n = 1; n <= s; ++n)l.sub(o[s - n].clone().multiplyScalar(this.calcKoverI(s, n) * r[n])); o[s] = l.divideScalar(r[0]) } return o }, calcNURBSDerivatives: function (e, t, i, r, n) { var a = this.calcBSplineDerivatives(e, t, i, r, n); return this.calcRationalCurveDerivatives(a) }, calcSurfacePoint: function (e, t, i, r, n, a, o, s) { for (var l = this.findSpan(e, a, i), c = this.findSpan(t, o, r), h = this.calcBasisFunctions(l, a, e, i), u = this.calcBasisFunctions(c, o, t, r), d = [], p = 0; p <= t; ++p) { d[p] = new Vector4(0, 0, 0, 0); for (var f = 0; f <= e; ++f) { var m = n[l - e + f][c - t + p].clone(), g = m.w; m.x *= g, m.y *= g, m.z *= g, d[p].add(m.multiplyScalar(h[f])) } } var y = new Vector4(0, 0, 0, 0); for (p = 0; p <= t; ++p)y.add(d[p].multiplyScalar(u[p])); y.divideScalar(y.w), s.set(y.x, y.y, y.z) } }, NURBSCurve = function (e, t, i, r, n) { Curve.call(this), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = r || 0, this.endKnot = n || this.knots.length - 1; for (var a = 0; a < i.length; ++a) { var o = i[a]; this.controlPoints[a] = new Vector4(o.x, o.y, o.z, o.w) } }; NURBSCurve.prototype = Object.create(Curve.prototype), NURBSCurve.prototype.constructor = NURBSCurve, NURBSCurve.prototype.getPoint = function (e, t) { var i = t || new Vector3, r = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), n = NURBSUtils.calcBSplinePoint(this.degree, this.knots, this.controlPoints, r); return 1 != n.w && n.divideScalar(n.w), i.set(n.x, n.y, n.z) }, NURBSCurve.prototype.getTangent = function (e, t) { var i = t || new Vector3, r = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), n = NURBSUtils.calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, r, 1); return i.copy(n[1]).normalize(), i }; var DHFBXLoader = function () { var e, t, i; function r(e) { Loader.call(this, e), this.dbPromise = openDB(INDEXED_DB_NAME, INDEXED_DB_VERSION, { upgrade(e, t, i, r) { e.createObjectStore(INDEXED_DB_OBJECT_STORE) }, blocked() { logger.warn("indexeddb request blocked.") }, blocking() { logger.warn("indexeddb blocking another request.") }, terminated() { logger.warn("indexeddb request terminated.") } }) } function n(e) { window._textureMap[e.name] = e } function a(e, t) { this.textureLoader = e, this.manager = t } function o() { } function s() { } function l() { } function c() { } function h(e, t) { this.dv = new DataView(e), this.offset = 0, this.littleEndian = void 0 === t || t } function u() { } function d(e) { var t = e.match(/FBXVersion: (\d+)/); if (t) return parseInt(t[1]); throw new Error("THREE.DHFBXLoader: Cannot find the version number for the file given.") } function p(e) { return e / 46186158e3 } r.prototype = Object.assign(Object.create(Loader.prototype), { constructor: r, load: function (e, t, i, r) { var n = this, a = "" === n.path ? LoaderUtils.extractUrlBase(e) : n.path, o = function (t) { r ? r(t) : logger.error(t), n.manager.itemError(e), n.manager.itemEnd(e) }, s = new FileLoader(this.manager); s.setPath(n.path), s.setResponseType("arraybuffer"), s.setRequestHeader(n.requestHeader), s.setWithCredentials(n.withCredentials); let l = []; for (let e in this.requestHeader) l.push({ key: e, value: this.requestHeader[e] }); let c = util$1.fetchContentLastModified(e, l), h = md5(e); c.then((l => { "0" === l && s.load(e, (function (i) { try { t(n.parse(i, a)) } catch (t) { r ? r(t) : console.error(t), n.manager.itemError(e) } }), i, r); let c = md5(l); this.dbPromise.then((r => { r.getAllKeys(INDEXED_DB_OBJECT_STORE).then((l => { let u = !1; for (let s of l) if (0 === s.indexOf(h)) { s === `${h}:${c}` ? (u = !0, r.get(INDEXED_DB_OBJECT_STORE, s).then((r => { let s = r.byteLength; i && i({ type: "progress", total: s, loaded: s / 2 }); try { t(n.parse(r, a)), i && i({ type: "progress", total: s, loaded: s }), n.manager.itemEnd(e) } catch (e) { o(e) } }))) : r.delete(INDEXED_DB_OBJECT_STORE, s).then((() => { })); break } u || s.load(e, (function (i) { try { t(n.parse(i, a)), n.manager.itemEnd(e), r.put(INDEXED_DB_OBJECT_STORE, i, `${h}:${c}`).then((() => { logger.debug("db.put(CONST.INDEXED_DB_OBJECT_STORE, data, `${urlKey}:${lastModifiedKey}`)") })) } catch (e) { o(e) } }), i, o) })) })) })).catch((o => { s.load(e, (function (i) { try { t(n.parse(i, a)) } catch (t) { r ? r(t) : console.error(t), n.manager.itemError(e) } }), i, r) })) }, parse: function (t, i) { if (o = "Kaydara FBX Binary  \0", (n = t).byteLength >= o.length && o === x(n, 0, o.length)) e = (new c).parse(t); else { var r = x(t); if (!function (e) { var t = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"], i = 0; function r(t) { var r = e[t - 1]; return e = e.slice(i + t), i++, r } for (var n = 0; n < t.length; ++n) { if (r(1) === t[n]) return !1 } return !0 }(r)) throw new Error("THREE.DHFBXLoader: Unknown format."); if (d(r) < 7e3) throw new Error("THREE.DHFBXLoader: FBX version not supported, FileVersion: " + d(r)); e = (new l).parse(r) } var n, o; return new a(new TextureLoader(this.manager).setPath(this.resourcePath || i).setCrossOrigin(this.crossOrigin), this.manager).parse(e) } }), a.prototype = { constructor: a, parse: function () { t = this.parseConnections(); var e = this.parseImages(), r = this.parseTextures(e), n = this.parseMaterials(r), a = this.parseDeformers(), s = (new o).parse(a); return this.parseScene(a, s, n), i }, parseConnections: function () { var t = new Map; "Connections" in e && e.Connections.connections.forEach((function (e) { var i = e[0], r = e[1], n = e[2]; t.has(i) || t.set(i, { parents: [], children: [] }); var a = { ID: r, relationship: n }; t.get(i).parents.push(a), t.has(r) || t.set(r, { parents: [], children: [] }); var o = { ID: i, relationship: n }; t.get(r).children.push(o) })); return t }, parseImages: function () { var t = {}, i = {}; if ("Video" in e.Objects) { var r = e.Objects.Video; for (var n in r) { var a = r[n]; if (t[c = parseInt(n)] = a.RelativeFilename || a.Filename, "Content" in a) { var o = a.Content instanceof ArrayBuffer && a.Content.byteLength > 0, s = "string" == typeof a.Content && "" !== a.Content; if (o || s) { var l = this.parseImage(r[n]); i[a.RelativeFilename || a.Filename] = l } } } } for (var c in t) { var h = t[c]; void 0 !== i[h] ? t[c] = i[h] : t[c] = t[c].split("\\").pop() } return t }, parseImage: function (e) { var t, i = e.Content, r = e.RelativeFilename || e.Filename, n = r.slice(r.lastIndexOf(".") + 1).toLowerCase(); switch (n) { case "bmp": t = "image/bmp"; break; case "jpg": case "jpeg": t = "image/jpeg"; break; case "png": t = "image/png"; break; case "tif": t = "image/tiff"; break; case "tga": null === this.manager.getHandler(".tga") && console.warn("DHFBXLoader: TGA loader not found, skipping ", r), t = "image/tga"; break; default: return void console.warn('DHFBXLoader: Image type "' + n + '" is not supported.') }if ("string" == typeof i) return "data:" + t + ";base64," + i; var a = new Uint8Array(i); return window.URL.createObjectURL(new Blob([a], { type: t })) }, parseTextures: function (t) { var i = new Map; if ("Texture" in e.Objects) { var r = e.Objects.Texture; for (var n in r) { var a = this.parseTexture(r[n], t); i.set(parseInt(n), a) } } return i }, parseTexture: function (e, t) { var i = this.loadTexture(e, t); i.ID = e.id, i.name = e.attrName; var r = e.WrapModeU, n = e.WrapModeV, a = void 0 !== r ? r.value : 0, o = void 0 !== n ? n.value : 0; if (i.wrapS = 0 === a ? RepeatWrapping : ClampToEdgeWrapping, i.wrapT = 0 === o ? RepeatWrapping : ClampToEdgeWrapping, "Scaling" in e) { var s = e.Scaling.value; i.repeat.x = s[0], i.repeat.y = s[1] } return i }, loadTexture: function (e, i) { var r, a, o = this.textureLoader.path, s = t.get(e.id).children; void 0 !== s && s.length > 0 && void 0 !== i[s[0].ID] && (0 !== (r = i[s[0].ID]).indexOf("blob:") && 0 !== r.indexOf("data:") || this.textureLoader.setPath(void 0)); var l = e.FileName.slice(-3).toLowerCase(); if ("tga" === l) { var c = this.manager.getHandler(".tga"); null === c ? (console.warn("DHFBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), a = new Texture$1) : a = c.load(r) } else "psd" === l ? (console.warn("DHFBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), a = new Texture$1) : a = this.textureLoader.load(r, n); return this.textureLoader.setPath(o), a }, parseMaterials: function (t) { var i = new Map; if ("Material" in e.Objects) { var r = e.Objects.Material; for (var n in r) { var a = this.parseMaterial(r[n], t); null !== a && i.set(parseInt(n), a) } } return i }, parseMaterial: function (e, i) { var r = e.id, n = e.attrName, a = e.ShadingModel; if ("object" == typeof a && (a = a.value), !t.has(r)) return null; var o, s = this.parseParameters(e, i, r); switch (a.toLowerCase()) { case "phong": o = new MeshPhongMaterial; break; case "lambert": o = new MeshLambertMaterial; break; default: console.warn('THREE.DHFBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', a), o = new MeshPhongMaterial }return o.setValues(s), o.name = n, o }, parseParameters: function (e, i, r) { var n = {}; e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = (new Color$1).fromArray(e.Diffuse.value) : !e.DiffuseColor || "Color" !== e.DiffuseColor.type && "ColorRGB" !== e.DiffuseColor.type || (n.color = (new Color$1).fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = (new Color$1).fromArray(e.Emissive.value) : !e.EmissiveColor || "Color" !== e.EmissiveColor.type && "ColorRGB" !== e.EmissiveColor.type || (n.emissive = (new Color$1).fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (n.opacity = parseFloat(e.Opacity.value)), n.opacity < 1 && (n.transparent = !0), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = (new Color$1).fromArray(e.Specular.value) : e.SpecularColor && "Color" === e.SpecularColor.type && (n.specular = (new Color$1).fromArray(e.SpecularColor.value)); var a = this; return t.get(r).children.forEach((function (e) { var t = e.relationship; switch (t) { case "Bump": n.bumpMap = a.getTexture(i, e.ID); break; case "Maya|TEX_ao_map": n.aoMap = a.getTexture(i, e.ID); break; case "DiffuseColor": case "Maya|TEX_color_map": n.map = a.getTexture(i, e.ID), n.map.encoding = sRGBEncoding; break; case "DisplacementColor": n.displacementMap = a.getTexture(i, e.ID); break; case "EmissiveColor": n.emissiveMap = a.getTexture(i, e.ID), n.emissiveMap.encoding = sRGBEncoding; break; case "NormalMap": case "Maya|TEX_normal_map": n.normalMap = a.getTexture(i, e.ID); break; case "ReflectionColor": n.envMap = a.getTexture(i, e.ID), n.envMap.mapping = EquirectangularReflectionMapping, n.envMap.encoding = sRGBEncoding; break; case "SpecularColor": n.specularMap = a.getTexture(i, e.ID), n.specularMap.encoding = sRGBEncoding; break; case "TransparentColor": case "TransparencyFactor": n.alphaMap = a.getTexture(i, e.ID), n.transparent = !0; break; case "AmbientColor": case "ShininessExponent": case "SpecularFactor": case "VectorDisplacementColor": default: console.warn("THREE.DHFBXLoader: %s map is not supported in three.js, skipping texture.", t) } })), n }, getTexture: function (i, r) { return "LayeredTexture" in e.Objects && r in e.Objects.LayeredTexture && (console.warn("THREE.DHFBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), r = t.get(r).children[0].ID), i.get(r) }, parseDeformers: function () { var i = {}, r = {}; if ("Deformer" in e.Objects) { var n = e.Objects.Deformer; for (var a in n) { var o = n[a], s = t.get(parseInt(a)); if ("Skin" === o.attrType) { var l = this.parseSkeleton(s, n); l.ID = a, s.parents.length > 1 && console.warn("THREE.DHFBXLoader: skeleton attached to more than one geometry is not supported."), l.geometryID = s.parents[0].ID, i[a] = l } else if ("BlendShape" === o.attrType) { var c = { id: a }; c.rawTargets = this.parseMorphTargets(s, n), c.id = a, s.parents.length > 1 && console.warn("THREE.DHFBXLoader: morph target attached to more than one geometry is not supported."), r[a] = c } } } return { skeletons: i, morphTargets: r } }, parseSkeleton: function (e, t) { var i = []; return e.children.forEach((function (e) { var r = t[e.ID]; if ("Cluster" === r.attrType) { var n = { ID: e.ID, indices: [], weights: [], transformLink: (new Matrix4).fromArray(r.TransformLink.a) }; "Indexes" in r && (n.indices = r.Indexes.a, n.weights = r.Weights.a), i.push(n) } })), { rawBones: i, bones: [] } }, parseMorphTargets: function (e, i) { for (var r = [], n = 0; n < e.children.length; n++) { var a = e.children[n], o = i[a.ID], s = { name: o.attrName, initialWeight: o.DeformPercent, id: o.id, fullWeights: o.FullWeights.a }; if ("BlendShapeChannel" !== o.attrType) return; s.geoID = t.get(parseInt(a.ID)).children.filter((function (e) { return void 0 === e.relationship }))[0].ID, r.push(s) } return r }, parseScene: function (r, n, a) { i = new Group; var o = this.parseModels(r.skeletons, n, a), l = e.Objects.Model, c = this; o.forEach((function (e) { var r = l[e.ID]; c.setLookAtProperties(e, r), t.get(e.ID).parents.forEach((function (t) { var i = o.get(t.ID); void 0 !== i && i.add(e) })), null === e.parent && i.add(e) })), this.bindSkeleton(r.skeletons, n, o), this.createAmbientLight(), this.setupMorphMaterials(), i.traverse((function (e) { if (e.userData.transformData) { e.parent && (e.userData.transformData.parentMatrix = e.parent.matrix, e.userData.transformData.parentMatrixWorld = e.parent.matrixWorld); var t = v(e.userData.transformData); e.applyMatrix4(t), e.updateWorldMatrix() } })); var h = (new s).parse(); 1 === i.children.length && i.children[0].isGroup && (i.children[0].animations = h, i = i.children[0]), i.animations = h }, parseModels: function (i, r, n) { var a = new Map, o = e.Objects.Model; for (var s in o) { var l = parseInt(s), c = o[s], h = t.get(l), u = this.buildSkeleton(h, i, l, c.attrName); if (!u) { switch (c.attrType) { case "Camera": u = this.createCamera(h); break; case "Light": u = this.createLight(h); break; case "Mesh": u = this.createMesh(h, r, n); break; case "NurbsCurve": u = this.createCurve(h, r); break; case "LimbNode": case "Root": u = new Bone; break; case "Null": default: u = new Group }u.name = c.attrName ? PropertyBinding.sanitizeNodeName(c.attrName) : "", u.ID = l } this.getTransformData(u, c), a.set(l, u) } return a }, buildSkeleton: function (e, t, i, r) { var n = null; return e.parents.forEach((function (e) { for (var a in t) { var o = t[a]; o.rawBones.forEach((function (t, a) { if (t.ID === e.ID) { var s = n; (n = new Bone).matrixWorld.copy(t.transformLink), n.name = r ? PropertyBinding.sanitizeNodeName(r) : "", n.ID = i, o.bones[a] = n, null !== s && n.add(s) } })) } })), n }, createCamera: function (t) { var i, r; if (t.children.forEach((function (t) { var i = e.Objects.NodeAttribute[t.ID]; void 0 !== i && (r = i) })), void 0 === r) i = new Object3D; else { var n = 0; void 0 !== r.CameraProjectionType && 1 === r.CameraProjectionType.value && (n = 1); var a = 1; void 0 !== r.NearPlane && (a = r.NearPlane.value / 1e3); var o = 1e3; void 0 !== r.FarPlane && (o = r.FarPlane.value / 1e3); var s = window.innerWidth, l = window.innerHeight; void 0 !== r.AspectWidth && void 0 !== r.AspectHeight && (s = r.AspectWidth.value, l = r.AspectHeight.value); var c = s / l, h = 45; void 0 !== r.FieldOfView && (h = r.FieldOfView.value); var u = r.FocalLength ? r.FocalLength.value : null; switch (n) { case 0: i = new PerspectiveCamera(h, c, a, o), null !== u && i.setFocalLength(u); break; case 1: i = new OrthographicCamera(-s / 2, s / 2, l / 2, -l / 2, a, o); break; default: console.warn("THREE.DHFBXLoader: Unknown camera type " + n + "."), i = new Object3D } } return i }, createLight: function (t) { var i, r; if (t.children.forEach((function (t) { var i = e.Objects.NodeAttribute[t.ID]; void 0 !== i && (r = i) })), void 0 === r) i = new Object3D; else { var n; n = void 0 === r.LightType ? 0 : r.LightType.value; var a = 16777215; void 0 !== r.Color && (a = (new Color$1).fromArray(r.Color.value)); var o = void 0 === r.Intensity ? 1 : r.Intensity.value / 100; void 0 !== r.CastLightOnObject && 0 === r.CastLightOnObject.value && (o = 0); var s = 0; void 0 !== r.FarAttenuationEnd && (s = void 0 !== r.EnableFarAttenuation && 0 === r.EnableFarAttenuation.value ? 0 : r.FarAttenuationEnd.value); switch (n) { case 0: i = new PointLight(a, o, s, 1); break; case 1: i = new DirectionalLight(a, o); break; case 2: var l = Math.PI / 3; void 0 !== r.InnerAngle && (l = MathUtils.degToRad(r.InnerAngle.value)); var c = 0; void 0 !== r.OuterAngle && (c = MathUtils.degToRad(r.OuterAngle.value), c = Math.max(c, 1)), i = new SpotLight(a, o, s, l, c, 1); break; default: console.warn("THREE.DHFBXLoader: Unknown light type " + r.LightType.value + ", defaulting to a PointLight."), i = new PointLight(a, o) }void 0 !== r.CastShadows && 1 === r.CastShadows.value && (i.castShadow = !0) } return i }, createMesh: function (e, t, i) { var r, n = null, a = null, o = []; return e.children.forEach((function (e) { t.has(e.ID) && (n = t.get(e.ID)), i.has(e.ID) && o.push(i.get(e.ID)) })), o.length > 1 ? a = o : o.length > 0 ? a = o[0] : (a = new MeshPhongMaterial({ color: 13421772 }), o.push(a)), "color" in n.attributes && o.forEach((function (e) { e.vertexColors = !0 })), n.FBX_Deformer ? (o.forEach((function (e) { e.skinning = !0 })), (r = new SkinnedMesh(n, a)).normalizeSkinWeights()) : r = new Mesh(n, a), r }, createCurve: function (e, t) { return new Line(e.children.reduce((function (e, i) { return t.has(i.ID) && (e = t.get(i.ID)), e }), null), new LineBasicMaterial({ color: 3342591, linewidth: 1 })) }, getTransformData: function (e, t) { var i = {}; "InheritType" in t && (i.inheritType = parseInt(t.InheritType.value)), i.eulerOrder = "RotationOrder" in t ? _(t.RotationOrder.value) : "ZYX", "Lcl_Translation" in t && (i.translation = t.Lcl_Translation.value), "PreRotation" in t && (i.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (i.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (i.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (i.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (i.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (i.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (i.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (i.rotationPivot = t.RotationPivot.value), e.userData.transformData = i }, setLookAtProperties: function (r, n) { "LookAtProperty" in n && t.get(r.ID).children.forEach((function (t) { if ("LookAtProperty" === t.relationship) { var n = e.Objects.Model[t.ID]; if ("Lcl_Translation" in n) { var a = n.Lcl_Translation.value; void 0 !== r.target ? (r.target.position.fromArray(a), i.add(r.target)) : r.lookAt((new Vector3).fromArray(a)) } } })) }, bindSkeleton: function (e, i, r) { var n = this.parsePoseNodes(); for (var a in e) { var o = e[a]; t.get(parseInt(o.ID)).parents.forEach((function (e) { if (i.has(e.ID)) { var a = e.ID; t.get(a).parents.forEach((function (e) { r.has(e.ID) && r.get(e.ID).bind(new Skeleton(o.bones), n[e.ID]) })) } })) } }, parsePoseNodes: function () { var t = {}; if ("Pose" in e.Objects) { var i = e.Objects.Pose; for (var r in i) if ("BindPose" === i[r].attrType) { var n = i[r].PoseNode; Array.isArray(n) ? n.forEach((function (e) { t[e.Node] = (new Matrix4).fromArray(e.Matrix.a) })) : t[n.Node] = (new Matrix4).fromArray(n.Matrix.a) } } return t }, createAmbientLight: function () { if ("GlobalSettings" in e && "AmbientColor" in e.GlobalSettings) { var t = e.GlobalSettings.AmbientColor.value, r = t[0], n = t[1], a = t[2]; if (0 !== r || 0 !== n || 0 !== a) { var o = new Color$1(r, n, a); i.add(new AmbientLight(o, 1)) } } }, setupMorphMaterials: function () { var e = this; i.traverse((function (t) { t.isMesh && t.geometry.morphAttributes.position && t.geometry.morphAttributes.position.length && (Array.isArray(t.material) ? t.material.forEach((function (i, r) { e.setupMorphMaterial(t, i, r) })) : e.setupMorphMaterial(t, t.material)) })) }, setupMorphMaterial: function (e, t, r) { var n = e.uuid, a = t.uuid, o = !1; if (i.traverse((function (e) { e.isMesh && (Array.isArray(e.material) ? e.material.forEach((function (t) { t.uuid === a && e.uuid !== n && (o = !0) })) : e.material.uuid === a && e.uuid !== n && (o = !0)) })), !0 === o) { var s = t.clone(); s.morphTargets = !0, void 0 === r ? e.material = s : e.material[r] = s } else t.morphTargets = !0 } }, o.prototype = { constructor: o, parse: function (i) { var r = new Map; if ("Geometry" in e.Objects) { var n = e.Objects.Geometry; for (var a in n) { var o = t.get(parseInt(a)), s = this.parseGeometry(o, n[a], i); r.set(parseInt(a), s) } } return r }, parseGeometry: function (e, t, i) { switch (t.attrType) { case "Mesh": return this.parseMeshGeometry(e, t, i); case "NurbsCurve": return this.parseNurbsGeometry(t) } }, parseMeshGeometry: function (t, i, r) { var n = r.skeletons, a = [], o = t.parents.map((function (t) { return e.Objects.Model[t.ID] })); if (0 !== o.length) { var s = t.children.reduce((function (e, t) { return void 0 !== n[t.ID] && (e = n[t.ID]), e }), null); t.children.forEach((function (e) { void 0 !== r.morphTargets[e.ID] && a.push(r.morphTargets[e.ID]) })); var l = o[0], c = {}; "RotationOrder" in l && (c.eulerOrder = _(l.RotationOrder.value)), "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (c.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (c.scale = l.GeometricScaling.value); var h = v(c); return this.genGeometry(i, s, a, h) } }, genGeometry: function (e, t, i, r) { var n = new BufferGeometry; e.attrName && (n.name = e.attrName); var a = this.parseGeoNode(e, t), o = this.genBuffers(a), s = new Float32BufferAttribute(o.vertex, 3); if (s.applyMatrix4(r), n.setAttribute("position", s), o.colors.length > 0 && n.setAttribute("color", new Float32BufferAttribute(o.colors, 3)), t && (n.setAttribute("skinIndex", new Uint16BufferAttribute(o.weightsIndices, 4)), n.setAttribute("skinWeight", new Float32BufferAttribute(o.vertexWeights, 4)), n.FBX_Deformer = t), o.normal.length > 0) { var l = (new Matrix3).getNormalMatrix(r), c = new Float32BufferAttribute(o.normal, 3); c.applyNormalMatrix(l), n.setAttribute("normal", c) } if (o.uvs.forEach((function (e, t) { var i = "uv" + (t + 1).toString(); 0 === t && (i = "uv"), n.setAttribute(i, new Float32BufferAttribute(o.uvs[t], 2)) })), a.material && "AllSame" !== a.material.mappingType) { var h = o.materialIndex[0], u = 0; if (o.materialIndex.forEach((function (e, t) { e !== h && (n.addGroup(u, t - u, h), h = e, u = t) })), n.groups.length > 0) { var d = n.groups[n.groups.length - 1], p = d.start + d.count; p !== o.materialIndex.length && n.addGroup(p, o.materialIndex.length - p, h) } 0 === n.groups.length && n.addGroup(0, o.materialIndex.length, o.materialIndex[0]) } return this.addMorphTargets(n, e, i, r), n }, parseGeoNode: function (e, t) { var i = {}; if (i.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : [], i.vertexIndices = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (i.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (i.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (i.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) { i.uv = []; for (var r = 0; e.LayerElementUV[r];)e.LayerElementUV[r].UV && i.uv.push(this.parseUVs(e.LayerElementUV[r])), r++ } return i.weightTable = {}, null !== t && (i.skeleton = t, t.rawBones.forEach((function (e, t) { e.indices.forEach((function (r, n) { void 0 === i.weightTable[r] && (i.weightTable[r] = []), i.weightTable[r].push({ id: t, weight: e.weights[n] }) })) }))), i }, genBuffers: function (e) { var t = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [] }, i = 0, r = 0, n = !1, a = [], o = [], s = [], l = [], c = [], h = [], u = this; return e.vertexIndices.forEach((function (d, p) { var f = !1; d < 0 && (d ^= -1, f = !0); var g = [], y = []; if (a.push(3 * d, 3 * d + 1, 3 * d + 2), e.color) { var v = m(p, i, d, e.color); s.push(v[0], v[1], v[2]) } if (e.skeleton) { if (void 0 !== e.weightTable[d] && e.weightTable[d].forEach((function (e) { y.push(e.weight), g.push(e.id) })), y.length > 4) { n || (console.warn("THREE.DHFBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), n = !0); var _ = [0, 0, 0, 0], b = [0, 0, 0, 0]; y.forEach((function (e, t) { var i = e, r = g[t]; b.forEach((function (e, t, n) { if (i > e) { n[t] = i, i = e; var a = _[t]; _[t] = r, r = a } })) })), g = _, y = b } for (; y.length < 4;)y.push(0), g.push(0); for (var x = 0; x < 4; ++x)c.push(y[x]), h.push(g[x]) } if (e.normal) { v = m(p, i, d, e.normal); o.push(v[0], v[1], v[2]) } if (e.material && "AllSame" !== e.material.mappingType) var w = m(p, i, d, e.material)[0]; e.uv && e.uv.forEach((function (e, t) { var r = m(p, i, d, e); void 0 === l[t] && (l[t] = []), l[t].push(r[0]), l[t].push(r[1]) })), r++, f && (u.genFace(t, e, a, w, o, s, l, c, h, r), i++, r = 0, a = [], o = [], s = [], l = [], c = [], h = []) })), t }, genFace: function (e, t, i, r, n, a, o, s, l, c) { for (var h = 2; h < c; h++)e.vertex.push(t.vertexPositions[i[0]]), e.vertex.push(t.vertexPositions[i[1]]), e.vertex.push(t.vertexPositions[i[2]]), e.vertex.push(t.vertexPositions[i[3 * (h - 1)]]), e.vertex.push(t.vertexPositions[i[3 * (h - 1) + 1]]), e.vertex.push(t.vertexPositions[i[3 * (h - 1) + 2]]), e.vertex.push(t.vertexPositions[i[3 * h]]), e.vertex.push(t.vertexPositions[i[3 * h + 1]]), e.vertex.push(t.vertexPositions[i[3 * h + 2]]), t.skeleton && (e.vertexWeights.push(s[0]), e.vertexWeights.push(s[1]), e.vertexWeights.push(s[2]), e.vertexWeights.push(s[3]), e.vertexWeights.push(s[4 * (h - 1)]), e.vertexWeights.push(s[4 * (h - 1) + 1]), e.vertexWeights.push(s[4 * (h - 1) + 2]), e.vertexWeights.push(s[4 * (h - 1) + 3]), e.vertexWeights.push(s[4 * h]), e.vertexWeights.push(s[4 * h + 1]), e.vertexWeights.push(s[4 * h + 2]), e.vertexWeights.push(s[4 * h + 3]), e.weightsIndices.push(l[0]), e.weightsIndices.push(l[1]), e.weightsIndices.push(l[2]), e.weightsIndices.push(l[3]), e.weightsIndices.push(l[4 * (h - 1)]), e.weightsIndices.push(l[4 * (h - 1) + 1]), e.weightsIndices.push(l[4 * (h - 1) + 2]), e.weightsIndices.push(l[4 * (h - 1) + 3]), e.weightsIndices.push(l[4 * h]), e.weightsIndices.push(l[4 * h + 1]), e.weightsIndices.push(l[4 * h + 2]), e.weightsIndices.push(l[4 * h + 3])), t.color && (e.colors.push(a[0]), e.colors.push(a[1]), e.colors.push(a[2]), e.colors.push(a[3 * (h - 1)]), e.colors.push(a[3 * (h - 1) + 1]), e.colors.push(a[3 * (h - 1) + 2]), e.colors.push(a[3 * h]), e.colors.push(a[3 * h + 1]), e.colors.push(a[3 * h + 2])), t.material && "AllSame" !== t.material.mappingType && (e.materialIndex.push(r), e.materialIndex.push(r), e.materialIndex.push(r)), t.normal && (e.normal.push(n[0]), e.normal.push(n[1]), e.normal.push(n[2]), e.normal.push(n[3 * (h - 1)]), e.normal.push(n[3 * (h - 1) + 1]), e.normal.push(n[3 * (h - 1) + 2]), e.normal.push(n[3 * h]), e.normal.push(n[3 * h + 1]), e.normal.push(n[3 * h + 2])), t.uv && t.uv.forEach((function (t, i) { void 0 === e.uvs[i] && (e.uvs[i] = []), e.uvs[i].push(o[i][0]), e.uvs[i].push(o[i][1]), e.uvs[i].push(o[i][2 * (h - 1)]), e.uvs[i].push(o[i][2 * (h - 1) + 1]), e.uvs[i].push(o[i][2 * h]), e.uvs[i].push(o[i][2 * h + 1]) })) }, addMorphTargets: function (t, i, r, n) { if (0 !== r.length) { t.morphTargetsRelative = !0, t.morphAttributes.position = []; var a = this; r.forEach((function (r) { r.rawTargets.forEach((function (r) { var o = e.Objects.Geometry[r.geoID]; void 0 !== o && a.genMorphGeometry(t, i, o, n, r.name) })) })) } }, genMorphGeometry: function (e, t, i, r, n) { for (var a = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [], o = void 0 !== i.Vertices ? i.Vertices.a : [], s = void 0 !== i.Indexes ? i.Indexes.a : [], l = 3 * e.attributes.position.count, c = new Float32Array(l), h = 0; h < s.length; h++) { var u = 3 * s[h]; c[u] = o[3 * h], c[u + 1] = o[3 * h + 1], c[u + 2] = o[3 * h + 2] } var d = { vertexIndices: a, vertexPositions: c }, p = new Float32BufferAttribute(this.genBuffers(d).vertex, 3); p.name = n || i.attrName, p.applyMatrix4(r), e.morphAttributes.position.push(p) }, parseNormals: function (e) { var t = e.MappingInformationType, i = e.ReferenceInformationType, r = e.Normals.a, n = []; return "IndexToDirect" === i && ("NormalIndex" in e ? n = e.NormalIndex.a : "NormalsIndex" in e && (n = e.NormalsIndex.a)), { dataSize: 3, buffer: r, indices: n, mappingType: t, referenceType: i } }, parseUVs: function (e) { var t = e.MappingInformationType, i = e.ReferenceInformationType, r = e.UV.a, n = []; return "IndexToDirect" === i && (n = e.UVIndex.a), { dataSize: 2, buffer: r, indices: n, mappingType: t, referenceType: i } }, parseVertexColors: function (e) { var t = e.MappingInformationType, i = e.ReferenceInformationType, r = e.Colors.a, n = []; return "IndexToDirect" === i && (n = e.ColorIndex.a), { dataSize: 4, buffer: r, indices: n, mappingType: t, referenceType: i } }, parseMaterialIndices: function (e) { var t = e.MappingInformationType, i = e.ReferenceInformationType; if ("NoMappingInformation" === t) return { dataSize: 1, buffer: [0], indices: [0], mappingType: "AllSame", referenceType: i }; for (var r = e.Materials.a, n = [], a = 0; a < r.length; ++a)n.push(a); return { dataSize: 1, buffer: r, indices: n, mappingType: t, referenceType: i } }, parseNurbsGeometry: function (e) { if (void 0 === NURBSCurve) return console.error("THREE.DHFBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new BufferGeometry; var t = parseInt(e.Order); if (isNaN(t)) return console.error("THREE.DHFBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new BufferGeometry; for (var i, r, n = t - 1, a = e.KnotVector.a, o = [], s = e.Points.a, l = 0, c = s.length; l < c; l += 4)o.push((new Vector4).fromArray(s, l)); if ("Closed" === e.Form) o.push(o[0]); else if ("Periodic" === e.Form) { i = n, r = a.length - 1 - i; for (l = 0; l < n; ++l)o.push(o[l]) } var h = new NURBSCurve(n, a, o, i, r).getPoints(7 * o.length), u = new Float32Array(3 * h.length); h.forEach((function (e, t) { e.toArray(u, 3 * t) })); var d = new BufferGeometry; return d.setAttribute("position", new BufferAttribute(u, 3)), d } }, s.prototype = { constructor: s, parse: function () { var e = [], t = this.parseClips(); if (void 0 !== t) for (var i in t) { var r = t[i], n = this.addClip(r); e.push(n) } return e }, parseClips: function () { if (void 0 !== e.Objects.AnimationCurve) { var t = this.parseAnimationCurveNodes(); this.parseAnimationCurves(t); var i = this.parseAnimationLayers(t); return this.parseAnimStacks(i) } }, parseAnimationCurveNodes: function () { var t = e.Objects.AnimationCurveNode, i = new Map; for (var r in t) { var n = t[r]; if (null !== n.attrName.match(/S|R|T|DeformPercent/)) { var a = { id: n.id, attr: n.attrName, curves: {} }; i.set(a.id, a) } } return i }, parseAnimationCurves: function (i) { var r = e.Objects.AnimationCurve; for (var n in r) { var a = { id: r[n].id, times: r[n].KeyTime.a.map(p), values: r[n].KeyValueFloat.a }, o = t.get(a.id); if (void 0 !== o) { var s = o.parents[0].ID, l = o.parents[0].relationship; l.match(/X/) ? i.get(s).curves.x = a : l.match(/Y/) ? i.get(s).curves.y = a : l.match(/Z/) ? i.get(s).curves.z = a : l.match(/d|DeformPercent/) && i.has(s) && (i.get(s).curves.morph = a) } } }, parseAnimationLayers: function (r) { var n = e.Objects.AnimationLayer, a = new Map; for (var o in n) { var s = [], l = t.get(parseInt(o)); if (void 0 !== l) l.children.forEach((function (n, a) { if (r.has(n.ID)) { var o = r.get(n.ID); if (void 0 !== o.curves.x || void 0 !== o.curves.y || void 0 !== o.curves.z) { if (void 0 === s[a]) if (void 0 !== (p = t.get(n.ID).parents.filter((function (e) { return void 0 !== e.relationship }))[0].ID)) { if (void 0 === (c = e.Objects.Model[p.toString()])) return void console.warn("THREE.DHFBXLoader: Encountered a unused curve.", n); var l = { modelName: c.attrName ? PropertyBinding.sanitizeNodeName(c.attrName) : "", ID: c.id, initialPosition: [0, 0, 0], initialRotation: [0, 0, 0], initialScale: [1, 1, 1] }; i.traverse((function (e) { e.ID === c.id && (l.transform = e.matrix, e.userData.transformData && (l.eulerOrder = e.userData.transformData.eulerOrder)) })), l.transform || (l.transform = new Matrix4), "PreRotation" in c && (l.preRotation = c.PreRotation.value), "PostRotation" in c && (l.postRotation = c.PostRotation.value), s[a] = l } s[a] && (s[a][o.attr] = o) } else if (void 0 !== o.curves.morph) { if (void 0 === s[a]) { var c, h = t.get(n.ID).parents.filter((function (e) { return void 0 !== e.relationship }))[0].ID, u = t.get(h).parents[0].ID, d = t.get(u).parents[0].ID, p = t.get(d).parents[0].ID; l = { modelName: (c = e.Objects.Model[p]).attrName ? PropertyBinding.sanitizeNodeName(c.attrName) : "", morphName: e.Objects.Deformer[h].attrName }; s[a] = l } s[a][o.attr] = o } } })), a.set(parseInt(o), s) } return a }, parseAnimStacks: function (i) { var r = e.Objects.AnimationStack, n = {}; for (var a in r) { var o = t.get(parseInt(a)).children; o.length > 1 && console.warn("THREE.DHFBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."); var s = i.get(o[0].ID); n[a] = { name: r[a].attrName, layer: s } } return n }, addClip: function (e) { var t = [], i = this; return e.layer.forEach((function (e) { t = t.concat(i.generateTracks(e)) })), new AnimationClip(e.name, -1, t) }, generateTracks: function (e) { var t = [], i = new Vector3, r = new Quaternion, n = new Vector3; if (e.transform && e.transform.decompose(i, r, n), i = i.toArray(), r = (new Euler).setFromQuaternion(r, e.eulerOrder).toArray(), n = n.toArray(), void 0 !== e.T && Object.keys(e.T.curves).length > 0) { var a = this.generateVectorTrack(e.modelName, e.T.curves, i, "position"); void 0 !== a && t.push(a) } if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) { var o = this.generateRotationTrack(e.modelName, e.R.curves, r, e.preRotation, e.postRotation, e.eulerOrder); void 0 !== o && t.push(o) } if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) { var s = this.generateVectorTrack(e.modelName, e.S.curves, n, "scale"); void 0 !== s && t.push(s) } if (void 0 !== e.DeformPercent) { var l = this.generateMorphTrack(e); void 0 !== l && t.push(l) } return t }, generateVectorTrack: function (e, t, i, r) { var n = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(n, t, i); return new VectorKeyframeTrack(e + "." + r, n, a) }, generateRotationTrack: function (e, t, i, r, n, a) { void 0 !== t.x && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(MathUtils.degToRad)), void 0 !== t.y && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(MathUtils.degToRad)), void 0 !== t.z && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(MathUtils.degToRad)); var o = this.getTimesForAllAxes(t), s = this.getKeyframeTrackValues(o, t, i); void 0 !== r && ((r = r.map(MathUtils.degToRad)).push(a), r = (new Euler).fromArray(r), r = (new Quaternion).setFromEuler(r)), void 0 !== n && ((n = n.map(MathUtils.degToRad)).push(a), n = (new Euler).fromArray(n), n = (new Quaternion).setFromEuler(n).invert()); for (var l = new Quaternion, c = new Euler, h = [], u = 0; u < s.length; u += 3)c.set(s[u], s[u + 1], s[u + 2], a), l.setFromEuler(c), void 0 !== r && l.premultiply(r), void 0 !== n && l.multiply(n), l.toArray(h, u / 3 * 4); return new QuaternionKeyframeTrack(e + ".quaternion", o, h) }, generateMorphTrack: function (e) { var t = e.DeformPercent.curves.morph, r = t.values.map((function (e) { return e / 100 })), n = i.getObjectByName(e.modelName).morphTargetDictionary[e.morphName]; return new NumberKeyframeTrack(e.modelName + ".morphTargetInfluences[" + n + "]", t.times, r) }, getTimesForAllAxes: function (e) { var t = []; if (void 0 !== e.x && (t = t.concat(e.x.times)), void 0 !== e.y && (t = t.concat(e.y.times)), void 0 !== e.z && (t = t.concat(e.z.times)), (t = t.sort((function (e, t) { return e - t }))).length > 1) { for (var i = 1, r = t[0], n = 1; n < t.length; n++) { var a = t[n]; a !== r && (t[i] = a, r = a, i++) } t = t.slice(0, i) } return t }, getKeyframeTrackValues: function (e, t, i) { var r = i, n = [], a = -1, o = -1, s = -1; return e.forEach((function (e) { if (t.x && (a = t.x.times.indexOf(e)), t.y && (o = t.y.times.indexOf(e)), t.z && (s = t.z.times.indexOf(e)), -1 !== a) { var i = t.x.values[a]; n.push(i), r[0] = i } else n.push(r[0]); if (-1 !== o) { var l = t.y.values[o]; n.push(l), r[1] = l } else n.push(r[1]); if (-1 !== s) { var c = t.z.values[s]; n.push(c), r[2] = c } else n.push(r[2]) })), n }, interpolateRotations: function (e) { for (var t = 1; t < e.values.length; t++) { var i = e.values[t - 1], r = e.values[t] - i, n = Math.abs(r); if (n >= 180) { for (var a = n / 180, o = r / a, s = i + o, l = e.times[t - 1], c = (e.times[t] - l) / a, h = l + c, u = [], d = []; h < e.times[t];)u.push(h), h += c, d.push(s), s += o; e.times = w(e.times, t, u), e.values = w(e.values, t, d) } } } }, l.prototype = { constructor: l, getPrevNode: function () { return this.nodeStack[this.currentIndent - 2] }, getCurrentNode: function () { return this.nodeStack[this.currentIndent - 1] }, getCurrentProp: function () { return this.currentProp }, pushStack: function (e) { this.nodeStack.push(e), this.currentIndent += 1 }, popStack: function () { this.nodeStack.pop(), this.currentIndent -= 1 }, setCurrentProp: function (e, t) { this.currentProp = e, this.currentPropName = t }, parse: function (e) { this.currentIndent = 0, this.allNodes = new u, this.nodeStack = [], this.currentProp = [], this.currentPropName = ""; var t = this, i = e.split(/[\r\n]+/); return i.forEach((function (e, r) { var n = e.match(/^[\s\t]*;/), a = e.match(/^[\s\t]*$/); if (!n && !a) { var o = e.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), s = e.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), l = e.match("^\\t{" + (t.currentIndent - 1) + "}}"); o ? t.parseNodeBegin(e, o) : s ? t.parseNodeProperty(e, s, i[++r]) : l ? t.popStack() : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e) } })), this.allNodes }, parseNodeBegin: function (e, t) { var i = t[1].trim().replace(/^"/, "").replace(/"$/, ""), r = t[2].split(",").map((function (e) { return e.trim().replace(/^"/, "").replace(/"$/, "") })), n = { name: i }, a = this.parseNodeAttr(r), o = this.getCurrentNode(); 0 === this.currentIndent ? this.allNodes.add(i, n) : i in o ? ("PoseNode" === i ? o.PoseNode.push(n) : void 0 !== o[i].id && (o[i] = {}, o[i][o[i].id] = o[i]), "" !== a.id && (o[i][a.id] = n)) : "number" == typeof a.id ? (o[i] = {}, o[i][a.id] = n) : "Properties70" !== i && (o[i] = "PoseNode" === i ? [n] : n), "number" == typeof a.id && (n.id = a.id), "" !== a.name && (n.attrName = a.name), "" !== a.type && (n.attrType = a.type), this.pushStack(n) }, parseNodeAttr: function (e) { var t = e[0]; "" !== e[0] && (t = parseInt(e[0]), isNaN(t) && (t = e[0])); var i = "", r = ""; return e.length > 1 && (i = e[1].replace(/^(\w+)::/, ""), r = e[2]), { id: t, name: i, type: r } }, parseNodeProperty: function (e, t, i) { var r = t[1].replace(/^"/, "").replace(/"$/, "").trim(), n = t[2].replace(/^"/, "").replace(/"$/, "").trim(); "Content" === r && "," === n && (n = i.replace(/"/g, "").replace(/,$/, "").trim()); var a = this.getCurrentNode(); if ("Properties70" !== a.name) { if ("C" === r) { var o = n.split(",").slice(1), s = parseInt(o[0]), l = parseInt(o[1]), c = n.split(",").slice(3); r = "connections", function (e, t) { for (var i = 0, r = e.length, n = t.length; i < n; i++, r++)e[r] = t[i] }(n = [s, l], c = c.map((function (e) { return e.trim().replace(/^"/, "") }))), void 0 === a[r] && (a[r] = []) } "Node" === r && (a.id = n), r in a && Array.isArray(a[r]) ? a[r].push(n) : "a" !== r ? a[r] = n : a.a = n, this.setCurrentProp(a, r), "a" === r && "," !== n.slice(-1) && (a.a = b(n)) } else this.parseNodeSpecialProperty(e, r, n) }, parseNodePropertyContinued: function (e) { var t = this.getCurrentNode(); t.a += e, "," !== e.slice(-1) && (t.a = b(t.a)) }, parseNodeSpecialProperty: function (e, t, i) { var r = i.split('",').map((function (e) { return e.trim().replace(/^\"/, "").replace(/\s/, "_") })), n = r[0], a = r[1], o = r[2], s = r[3], l = r[4]; switch (a) { case "int": case "enum": case "bool": case "ULongLong": case "double": case "Number": case "FieldOfView": l = parseFloat(l); break; case "Color": case "ColorRGB": case "Vector3D": case "Lcl_Translation": case "Lcl_Rotation": case "Lcl_Scaling": l = b(l) }this.getPrevNode()[n] = { type: a, type2: o, flag: s, value: l }, this.setCurrentProp(this.getPrevNode(), n) } }, c.prototype = { constructor: c, parse: function (e) { var t = new h(e); t.skip(23); var i = t.getUint32(); if (i < 6400) throw new Error("THREE.DHFBXLoader: FBX version not supported, FileVersion: " + i); for (var r = new u; !this.endOfContent(t);) { var n = this.parseNode(t, i); null !== n && r.add(n.name, n) } return r }, endOfContent: function (e) { return e.size() % 16 == 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size() }, parseNode: function (e, t) { var i = {}, r = t >= 7500 ? e.getUint64() : e.getUint32(), n = t >= 7500 ? e.getUint64() : e.getUint32(); t >= 7500 ? e.getUint64() : e.getUint32(); var a = e.getUint8(), o = e.getString(a); if (0 === r) return null; for (var s = [], l = 0; l < n; l++)s.push(this.parseProperty(e)); var c = s.length > 0 ? s[0] : "", h = s.length > 1 ? s[1] : "", u = s.length > 2 ? s[2] : ""; for (i.singleProperty = 1 === n && e.getOffset() === r; r > e.getOffset();) { var d = this.parseNode(e, t); null !== d && this.parseSubNode(o, i, d) } return i.propertyList = s, "number" == typeof c && (i.id = c), "" !== h && (i.attrName = h), "" !== u && (i.attrType = u), "" !== o && (i.name = o), i }, parseSubNode: function (e, t, i) { if (!0 === i.singleProperty) { var r = i.propertyList[0]; Array.isArray(r) ? (t[i.name] = i, i.a = r) : t[i.name] = r } else if ("Connections" === e && "C" === i.name) { var n = []; i.propertyList.forEach((function (e, t) { 0 !== t && n.push(e) })), void 0 === t.connections && (t.connections = []), t.connections.push(n) } else if ("Properties70" === i.name) { Object.keys(i).forEach((function (e) { t[e] = i[e] })) } else if ("Properties70" === e && "P" === i.name) { var a, o = i.propertyList[0], s = i.propertyList[1], l = i.propertyList[2], c = i.propertyList[3]; 0 === o.indexOf("Lcl ") && (o = o.replace("Lcl ", "Lcl_")), 0 === s.indexOf("Lcl ") && (s = s.replace("Lcl ", "Lcl_")), a = "Color" === s || "ColorRGB" === s || "Vector" === s || "Vector3D" === s || 0 === s.indexOf("Lcl_") ? [i.propertyList[4], i.propertyList[5], i.propertyList[6]] : i.propertyList[4], t[o] = { type: s, type2: l, flag: c, value: a } } else void 0 === t[i.name] ? "number" == typeof i.id ? (t[i.name] = {}, t[i.name][i.id] = i) : t[i.name] = i : "PoseNode" === i.name ? (Array.isArray(t[i.name]) || (t[i.name] = [t[i.name]]), t[i.name].push(i)) : void 0 === t[i.name][i.id] && (t[i.name][i.id] = i) }, parseProperty: function (e) { var t = e.getString(1); switch (t) { case "C": return e.getBoolean(); case "D": return e.getFloat64(); case "F": return e.getFloat32(); case "I": return e.getInt32(); case "L": return e.getInt64(); case "R": var i = e.getUint32(); return e.getArrayBuffer(i); case "S": i = e.getUint32(); return e.getString(i); case "Y": return e.getInt16(); case "b": case "c": case "d": case "f": case "i": case "l": var r = e.getUint32(), n = e.getUint32(), a = e.getUint32(); if (0 === n) switch (t) { case "b": case "c": return e.getBooleanArray(r); case "d": return e.getFloat64Array(r); case "f": return e.getFloat32Array(r); case "i": return e.getInt32Array(r); case "l": return e.getInt64Array(r) }void 0 === fflate && console.error("THREE.DHFBXLoader: External library fflate.min.js required."); var o = new h(Jr(new Uint8Array(e.getArrayBuffer(a))).buffer); switch (t) { case "b": case "c": return o.getBooleanArray(r); case "d": return o.getFloat64Array(r); case "f": return o.getFloat32Array(r); case "i": return o.getInt32Array(r); case "l": return o.getInt64Array(r) }default: throw new Error("THREE.DHFBXLoader: Unknown property type " + t) } } }, h.prototype = { constructor: h, getOffset: function () { return this.offset }, size: function () { return this.dv.buffer.byteLength }, skip: function (e) { this.offset += e }, getBoolean: function () { return 1 == (1 & this.getUint8()) }, getBooleanArray: function (e) { for (var t = [], i = 0; i < e; i++)t.push(this.getBoolean()); return t }, getUint8: function () { var e = this.dv.getUint8(this.offset); return this.offset += 1, e }, getInt16: function () { var e = this.dv.getInt16(this.offset, this.littleEndian); return this.offset += 2, e }, getInt32: function () { var e = this.dv.getInt32(this.offset, this.littleEndian); return this.offset += 4, e }, getInt32Array: function (e) { for (var t = [], i = 0; i < e; i++)t.push(this.getInt32()); return t }, getUint32: function () { var e = this.dv.getUint32(this.offset, this.littleEndian); return this.offset += 4, e }, getInt64: function () { var e, t; return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 2147483648 & t ? (t = 4294967295 & ~t, 4294967295 === (e = 4294967295 & ~e) && (t = t + 1 & 4294967295), -(4294967296 * t + (e = e + 1 & 4294967295))) : 4294967296 * t + e }, getInt64Array: function (e) { for (var t = [], i = 0; i < e; i++)t.push(this.getInt64()); return t }, getUint64: function () { var e, t; return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 4294967296 * t + e }, getFloat32: function () { var e = this.dv.getFloat32(this.offset, this.littleEndian); return this.offset += 4, e }, getFloat32Array: function (e) { for (var t = [], i = 0; i < e; i++)t.push(this.getFloat32()); return t }, getFloat64: function () { var e = this.dv.getFloat64(this.offset, this.littleEndian); return this.offset += 8, e }, getFloat64Array: function (e) { for (var t = [], i = 0; i < e; i++)t.push(this.getFloat64()); return t }, getArrayBuffer: function (e) { var t = this.dv.buffer.slice(this.offset, this.offset + e); return this.offset += e, t }, getString: function (e) { for (var t = [], i = 0; i < e; i++)t[i] = this.getUint8(); var r = t.indexOf(0); return r >= 0 && (t = t.slice(0, r)), LoaderUtils.decodeText(new Uint8Array(t)) } }, u.prototype = { constructor: u, add: function (e, t) { this[e] = t } }; var f = []; function m(e, t, i, r) { var n; switch (r.mappingType) { case "ByPolygonVertex": n = e; break; case "ByPolygon": n = t; break; case "ByVertice": n = i; break; case "AllSame": n = r.indices[0]; break; default: console.warn("THREE.DHFBXLoader: unknown attribute mapping type " + r.mappingType) }"IndexToDirect" === r.referenceType && (n = r.indices[n]); var a = n * r.dataSize, o = a + r.dataSize; return function (e, t, i, r) { for (var n = i, a = 0; n < r; n++, a++)e[a] = t[n]; return e }(f, r.buffer, a, o) } var g = new Euler, y = new Vector3; function v(e) { var t, i = new Matrix4, r = new Matrix4, n = new Matrix4, a = new Matrix4, o = new Matrix4, s = new Matrix4, l = new Matrix4, c = new Matrix4, h = new Matrix4, u = new Matrix4, d = new Matrix4, p = new Matrix4, f = e.inheritType ? e.inheritType : 0; (e.translation && i.setPosition(y.fromArray(e.translation)), e.preRotation) && ((t = e.preRotation.map(MathUtils.degToRad)).push(e.eulerOrder), r.makeRotationFromEuler(g.fromArray(t))); e.rotation && ((t = e.rotation.map(MathUtils.degToRad)).push(e.eulerOrder), n.makeRotationFromEuler(g.fromArray(t))); e.postRotation && ((t = e.postRotation.map(MathUtils.degToRad)).push(e.eulerOrder), a.makeRotationFromEuler(g.fromArray(t)), a.invert()); e.scale && o.scale(y.fromArray(e.scale)), e.scalingOffset && l.setPosition(y.fromArray(e.scalingOffset)), e.scalingPivot && s.setPosition(y.fromArray(e.scalingPivot)), e.rotationOffset && c.setPosition(y.fromArray(e.rotationOffset)), e.rotationPivot && h.setPosition(y.fromArray(e.rotationPivot)), e.parentMatrixWorld && (d.copy(e.parentMatrix), u.copy(e.parentMatrixWorld)); var m = (new Matrix4).copy(r).multiply(n).multiply(a), v = new Matrix4; v.extractRotation(u); var _ = new Matrix4; _.copyPosition(u); var b = new Matrix4, x = (new Matrix4).copy(_).invert().multiply(u); b.copy(v).invert().multiply(x); var w = o, S = new Matrix4; if (0 === f) S.copy(v).multiply(m).multiply(b).multiply(w); else if (1 === f) S.copy(v).multiply(b).multiply(m).multiply(w); else { var M = (new Matrix4).scale((new Vector3).setFromMatrixScale(d)), T = (new Matrix4).copy(M).invert(), A = (new Matrix4).copy(b).multiply(T); S.copy(v).multiply(m).multiply(A).multiply(w) } var E = new Matrix4; E.copy(h).invert(); var C = new Matrix4; C.copy(s).invert(); var L = new Matrix4; L.copy(i).multiply(c).multiply(h).multiply(r).multiply(n).multiply(a).multiply(E).multiply(l).multiply(s).multiply(o).multiply(C); var R = (new Matrix4).copyPosition(L), D = (new Matrix4).copy(u).multiply(R); return p.copyPosition(D), (L = (new Matrix4).copy(p).multiply(S)).premultiply(u.invert()), L } function _(e) { var t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"]; return 6 === (e = e || 0) ? (console.warn("THREE.DHFBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t[0]) : t[e] } function b(e) { return e.split(",").map((function (e) { return parseFloat(e) })) } function x(e, t, i) { return void 0 === t && (t = 0), void 0 === i && (i = e.byteLength), LoaderUtils.decodeText(new Uint8Array(e, t, i)) } function w(e, t, i) { return e.slice(0, t).concat(i).concat(e.slice(t)) } return r }(), heatmap = createCommonjsModule((function (e) { var t, i; t = commonjsGlobal, i = function () { var e, t = { defaultRadius: 40, defaultRenderer: "canvas2d", defaultGradient: { .25: "rgb(0,0,255)", .55: "rgb(0,255,0)", .85: "yellow", 1: "rgb(255,0,0)" }, defaultMaxOpacity: 1, defaultMinOpacity: 0, defaultBlur: .85, defaultXField: "x", defaultYField: "y", defaultValueField: "value", plugins: {} }, i = function () { var e = function (e) { this._coordinator = {}, this._data = [], this._radi = [], this._min = 10, this._max = 1, this._xField = e.xField || e.defaultXField, this._yField = e.yField || e.defaultYField, this._valueField = e.valueField || e.defaultValueField, e.radius && (this._cfgRadius = e.radius) }, i = t.defaultRadius; return e.prototype = { _organiseData: function (e, t) { var r = e[this._xField], n = e[this._yField], a = this._radi, o = this._data, s = this._max, l = this._min, c = e[this._valueField] || 1, h = e.radius || this._cfgRadius || i; o[r] || (o[r] = [], a[r] = []), o[r][n] ? o[r][n] += c : (o[r][n] = c, a[r][n] = h); var u = o[r][n]; return u > s ? (t ? this.setDataMax(u) : this._max = u, !1) : u < l ? (t ? this.setDataMin(u) : this._min = u, !1) : { x: r, y: n, value: c, radius: h, min: l, max: s } }, _unOrganizeData: function () { var e = [], t = this._data, i = this._radi; for (var r in t) for (var n in t[r]) e.push({ x: r, y: n, radius: i[r][n], value: t[r][n] }); return { min: this._min, max: this._max, data: e } }, _onExtremaChange: function () { this._coordinator.emit("extremachange", { min: this._min, max: this._max }) }, addData: function () { if (arguments[0].length > 0) for (var e = arguments[0], t = e.length; t--;)this.addData.call(this, e[t]); else { var i = this._organiseData(arguments[0], !0); i && (0 === this._data.length && (this._min = this._max = i.value), this._coordinator.emit("renderpartial", { min: this._min, max: this._max, data: [i] })) } return this }, setData: function (e) { var t = e.data, i = t.length; this._data = [], this._radi = []; for (var r = 0; r < i; r++)this._organiseData(t[r], !1); return this._max = e.max, this._min = e.min || 0, this._onExtremaChange(), this._coordinator.emit("renderall", this._getInternalData()), this }, removeData: function () { }, setDataMax: function (e) { return this._max = e, this._onExtremaChange(), this._coordinator.emit("renderall", this._getInternalData()), this }, setDataMin: function (e) { return this._min = e, this._onExtremaChange(), this._coordinator.emit("renderall", this._getInternalData()), this }, setCoordinator: function (e) { this._coordinator = e }, _getInternalData: function () { return { max: this._max, min: this._min, data: this._data, radi: this._radi } }, getData: function () { return this._unOrganizeData() } }, e }(), r = function () { var e = function (e) { var t = e.gradient || e.defaultGradient, i = document.createElement("canvas"), r = i.getContext("2d"); i.width = 256, i.height = 1; var n = r.createLinearGradient(0, 0, 256, 1); for (var a in t) n.addColorStop(a, t[a]); return r.fillStyle = n, r.fillRect(0, 0, 256, 1), r.getImageData(0, 0, 256, 1).data }, t = function (e, t) { var i = document.createElement("canvas"), r = i.getContext("2d"), n = e, a = e; if (i.width = i.height = 2 * e, 1 == t) r.beginPath(), r.arc(n, a, e, 0, 2 * Math.PI, !1), r.fillStyle = "rgba(0,0,0,1)", r.fill(); else { var o = r.createRadialGradient(n, a, e * t, n, a, e); o.addColorStop(0, "rgba(0,0,0,1)"), o.addColorStop(1, "rgba(0,0,0,0)"), r.fillStyle = o, r.fillRect(0, 0, 2 * e, 2 * e) } return i }; function i(t) { var i = t.container, r = this.shadowCanvas = document.createElement("canvas"), n = this.canvas = t.canvas || document.createElement("canvas"); this._renderBoundaries = [1e4, 1e4, 0, 0]; var a = getComputedStyle(t.container) || {}; n.className = "heatmap-canvas", this._width = n.width = r.width = t.width || +a.width.replace(/px/, ""), this._height = n.height = r.height = t.height || +a.height.replace(/px/, ""), this.shadowCtx = r.getContext("2d"), this.ctx = n.getContext("2d"), n.style.cssText = r.style.cssText = "position:absolute;left:0;top:0;", i.style.position = "relative", i.appendChild(n), this._palette = e(t), this._templates = {}, this._setStyles(t) } return i.prototype = { renderPartial: function (e) { e.data.length > 0 && (this._drawAlpha(e), this._colorize()) }, renderAll: function (e) { this._clear(), e.data.length > 0 && (this._drawAlpha(function (e) { for (var t = [], i = e.min, r = e.max, n = e.radi, a = (e = e.data, Object.keys(e)), o = a.length; o--;)for (var s = a[o], l = Object.keys(e[s]), c = l.length; c--;) { var h = l[c], u = e[s][h], d = n[s][h]; t.push({ x: s, y: h, value: u, radius: d }) } return { min: i, max: r, data: t } }(e)), this._colorize()) }, _updateGradient: function (t) { this._palette = e(t) }, updateConfig: function (e) { e.gradient && this._updateGradient(e), this._setStyles(e) }, setDimensions: function (e, t) { this._width = e, this._height = t, this.canvas.width = this.shadowCanvas.width = e, this.canvas.height = this.shadowCanvas.height = t }, _clear: function () { this.shadowCtx.clearRect(0, 0, this._width, this._height), this.ctx.clearRect(0, 0, this._width, this._height) }, _setStyles: function (e) { this._blur = 0 == e.blur ? 0 : e.blur || e.defaultBlur, e.backgroundColor && (this.canvas.style.backgroundColor = e.backgroundColor), this._width = this.canvas.width = this.shadowCanvas.width = e.width || this._width, this._height = this.canvas.height = this.shadowCanvas.height = e.height || this._height, this._opacity = 255 * (e.opacity || 0), this._maxOpacity = 255 * (e.maxOpacity || e.defaultMaxOpacity), this._minOpacity = 255 * (e.minOpacity || e.defaultMinOpacity), this._useGradientOpacity = !!e.useGradientOpacity }, _drawAlpha: function (e) { for (var i = this._min = e.min, r = this._max = e.max, n = (e = e.data || []).length, a = 1 - this._blur; n--;) { var o, s = e[n], l = s.x, c = s.y, h = s.radius, u = Math.min(s.value, r), d = l - h, p = c - h, f = this.shadowCtx; this._templates[h] ? o = this._templates[h] : this._templates[h] = o = t(h, a); var m = (u - i) / (r - i); f.globalAlpha = m < .01 ? .01 : m, f.drawImage(o, d, p), d < this._renderBoundaries[0] && (this._renderBoundaries[0] = d), p < this._renderBoundaries[1] && (this._renderBoundaries[1] = p), d + 2 * h > this._renderBoundaries[2] && (this._renderBoundaries[2] = d + 2 * h), p + 2 * h > this._renderBoundaries[3] && (this._renderBoundaries[3] = p + 2 * h) } }, _colorize: function () { var e = this._renderBoundaries[0], t = this._renderBoundaries[1], i = this._renderBoundaries[2] - e, r = this._renderBoundaries[3] - t, n = this._width, a = this._height, o = this._opacity, s = this._maxOpacity, l = this._minOpacity, c = this._useGradientOpacity; e < 0 && (e = 0), t < 0 && (t = 0), e + i > n && (i = n - e), t + r > a && (r = a - t); for (var h = this.shadowCtx.getImageData(e, t, i, r), u = h.data, d = u.length, p = this._palette, f = 3; f < d; f += 4) { var m, g = u[f], y = 4 * g; y && (m = o > 0 ? o : g < s ? g < l ? l : g : s, u[f - 3] = p[y], u[f - 2] = p[y + 1], u[f - 1] = p[y + 2], u[f] = c ? p[y + 3] : m) } this.ctx.putImageData(h, e, t), this._renderBoundaries = [1e3, 1e3, 0, 0] }, getValueAt: function (e) { var t = this.shadowCtx.getImageData(e.x, e.y, 1, 1).data[3], i = this._max, r = this._min; return Math.abs(i - r) * (t / 255) >> 0 }, getDataURL: function () { return this.canvas.toDataURL() } }, i }(), n = (e = !1, "canvas2d" === t.defaultRenderer && (e = r), e), a = function () { for (var e = {}, t = arguments.length, i = 0; i < t; i++) { var r = arguments[i]; for (var n in r) e[n] = r[n] } return e }, o = function () { var e = function () { function e() { this.cStore = {} } return e.prototype = { on: function (e, t, i) { var r = this.cStore; r[e] || (r[e] = []), r[e].push((function (e) { return t.call(i, e) })) }, emit: function (e, t) { var i = this.cStore; if (i[e]) for (var r = i[e].length, n = 0; n < r; n++)(0, i[e][n])(t) } }, e }(), r = function (e) { var t = e._renderer, i = e._coordinator, r = e._store; i.on("renderpartial", t.renderPartial, t), i.on("renderall", t.renderAll, t), i.on("extremachange", (function (t) { e._config.onExtremaChange && e._config.onExtremaChange({ min: t.min, max: t.max, gradient: e._config.gradient || e._config.defaultGradient }) })), r.setCoordinator(i) }; function o() { var o = this._config = a(t, arguments[0] || {}); if (this._coordinator = new e, o.plugin) { var s = o.plugin; if (!t.plugins[s]) throw new Error("Plugin '" + s + "' not found. Maybe it was not registered."); var l = t.plugins[s]; this._renderer = new l.renderer(o), this._store = new l.store(o) } else this._renderer = new n(o), this._store = new i(o); r(this) } return o.prototype = { addData: function () { return this._store.addData.apply(this._store, arguments), this }, removeData: function () { return this._store.removeData && this._store.removeData.apply(this._store, arguments), this }, setData: function () { return this._store.setData.apply(this._store, arguments), this }, setDataMax: function () { return this._store.setDataMax.apply(this._store, arguments), this }, setDataMin: function () { return this._store.setDataMin.apply(this._store, arguments), this }, configure: function (e) { return this._config = a(this._config, e), this._renderer.updateConfig(this._config), this._coordinator.emit("renderall", this._store._getInternalData()), this }, repaint: function () { return this._coordinator.emit("renderall", this._store._getInternalData()), this }, getData: function () { return this._store.getData() }, getDataURL: function () { return this._renderer.getDataURL() }, getValueAt: function (e) { return this._store.getValueAt ? this._store.getValueAt(e) : this._renderer.getValueAt ? this._renderer.getValueAt(e) : null } }, o }(); return { create: function (e) { return new o(e) }, register: function (e, i) { t.plugins[e] = i } } }, e.exports ? e.exports = i() : t.h337 = i() })); class AnimationStore { constructor() { var e = [], t = !1; this.add = t => { e.push(t) }, this.findMaterialAnimation = (t, i) => { let r = e.find((e => e.material ? e.material === t : e._material === t)); if (r && r.type === i) return r }, this.findNodeAnimation = (t, i) => { for (let r = 0; r < e.length; r++) { if (e[r].animationObject === t && e[r] && e[r].type === i) return e[r]; const n = e[r]; if (n.object && n.object.name === t && n.type === i) return n } }, this.findInstancedAnimation = (t, i, r) => { for (let n = 0; n < e.length; n++)if (e[n].instancedMesh === t && e[n] && e[n].type === r && e[n] && e[n].instanceId === i) return e[n] }, this.findDrawableAnimation = (t, i) => { let r = e.find((e => e.object === t)); if (r && r.type === i) return r }, this.findLayerAnimation = (t, i) => { let r = e.find((e => e.name === t && e._type === i)); if (r) return r }, this.findAnimation = (t, i) => { let r = e.find((e => i ? e.name === t && e._type === i : e.name === t)); if (r) return r }, this.findAnimationByPathId = (t, i) => e.filter((e => t && e.pathId === t && e._type === i)), this.pause = () => { t = !0 }, this.remove = t => { for (let i = e.length - 1; i >= 0; i--)e[i] === t && (e[i].dispose(), e[i] = null, e.splice(i, 1)) }, this.resume = () => { t = !1 }, this.update = i => { if (!t) for (let t of e) t.needsRemove ? this.remove(t) : t.update(i) }, this.addDistance = (e, t, i, r, n) => { let a = this.findLayerAnimation(e, t.type); a && (this.remove(a), a = null), a = new t(i, r, e, n), this.add(a) }, this.getAnimations = () => e, this.dispose = () => { e.forEach((e => { e.dispose && e.dispose() })), e = [] } } } class CacheStore { constructor() { this._cache || (this._cache = new Map), this._loadQueue || (this._loadQueue = new Map), this.helper = new CacheStoreHelper, this.preloadResourceStore = !0 } load({ path: e, type: t, secretKey: i, onLoad: r, onProgress: n, onError: a, needExport: o = !1, newImport: s = !1 } = {}) { if (!e || "" === e) return; let l, c = e; if (e instanceof Array) { let t = ""; for (let i of e) t += i; l = md5(t) } else l = md5(e); if (-1 != e.indexOf("[[origin]]") && (e = e.replace("[[origin]]", _context.origin)), !this._cache) return; let h = this._cache ? this._cache.get(l) : null; if (h) { if (h.loadState) return void h.onLoadList.push(r); if (s && (o && (h.needExport = o, h.refCount += 1), this._cache && this._cache.set(l, h)), "function" == typeof r) { let e = null; e = this.helper.cloneNode(h.resource), r(e), _context.sceneBufferCacheExpired = !0 } else switch (t.toLowerCase()) { case "texture": case "cubetexture": return this.helper.cloneNode(h.resource) } } else switch (this._cache && this._cache.set(l, { loadState: !0, onLoadList: [r] }), t.toLowerCase()) { case "avws": _context.loaders.gltfLoaderAVWS.load(e, (e => { if ("20220602-NEW-AVWS" === e.scene.children[0].userData.dhExtension.VERSION) { if (this._loadQueue && this._loadQueue.delete(l), !this._cache) return; let i = this._cache ? this._cache.get(l) : null, n = i.onLoadList, a = i.size; if (0 === e.animations.length) { let i = this.helper.autoMerge(e.scene), r = [], n = null, s = null; e.scene.traverse((e => { if (e.userData && e.userData.isModelSource && (s = e), e.userData && e.userData.needExport) { let { type: t, resourcePath: i, needExport: n, refCount: a } = e.userData; this._cache && this._cache.set(md5(e.userData.resourcePath), { type: t, resourcePath: i, needExport: n, refCount: a, resource: e }), r.push({ parent: e.parent, child: e }) } e.userData && e.userData.customTexture && (n = e) })), r.forEach((e => { e.parent.remove(e.child) })); let h = []; s && s.traverse((e => { e.userData && e.userData.modelPath && (this._cache && this._cache.set(md5(e.userData.modelPath), { type: "glb", resourcePath: e.userData.modelPath, needExport: !1, refCount: 1, resource: e }), h.push({ parent: e.parent, child: e })) })), h.forEach((e => { e.parent.remove(e.child) })), n && (n.traverse((e => { e.material && e.material.map && (_context.textureStore.add(e.material.map.name || `${e.material.name}#map`, e.material.map), this._cache && this._cache.set(md5(e.material.map.name), { resource: e.material.map })) })), n.parent.remove(n)), this._cache && this._cache.set(l, { type: t, resourcePath: c, needExport: o, refCount: 1, resource: i, size: a }) } else { let i = [], r = null, n = null; e.scene.traverse((e => { if (e.userData && e.userData.isModelSource && (n = e), e.userData && e.userData.needExport) { let { type: t, resourcePath: r, needExport: n, refCount: a } = e.userData; this._cache && this._cache.set(md5(e.userData.resourcePath), { type: t, resourcePath: r, needExport: n, refCount: a, resource: e }), i.push({ parent: e.parent, child: e }) } e.userData && e.userData.customTexture && (r = e) })), i.forEach((e => { e.parent.remove(e.child) })); let s = []; n && n.traverse((e => { e.userData && e.userData.modelPath && (this._cache && this._cache.set(md5(e.userData.modelPath), { type: "glb", resourcePath: e.userData.modelPath, needExport: !1, refCount: 1, resource: e }), s.push({ parent: e.parent, child: e })) })), s.forEach((e => { e.parent.remove(e.child) })), r && (r.traverse((e => { e.material && e.material.map && (_context.textureStore.add(e.material.map.name || `${e.material.name}#map`, e.material.map), this._cache && this._cache.set(md5(e.material.map.name), { resource: e.material.map })) })), r.parent.remove(r)), this._cache && this._cache.set(l, { type: t, resourcePath: c, needExport: o, refCount: 1, resource: e.scene, size: a }) } n instanceof Array ? n.forEach((e => { e(this.helper.cloneNode(this._cache ? this._cache.get(l).resource : null)), _context.sceneBufferCacheExpired = !0 })) : "function" == typeof r && (r(this.helper.cloneNode(this._cache ? this._cache.get(l).resource : null)), _context.sceneBufferCacheExpired = !0) } else { if (this._loadQueue && this._loadQueue.delete(l), !this._cache) return; let i = this._cache ? this._cache.get(l) : null, n = i.onLoadList, a = i.size; if (0 === e.animations.length) { let i = [], r = null; e.scene.traverse((e => { if (e.userData && e.userData.needExport) { let { type: t, resourcePath: r, needExport: n, refCount: a } = e.userData; this._cache && this._cache.set(md5(e.userData.resourcePath), { type: t, resourcePath: r, needExport: n, refCount: a, resource: e }), i.push({ parent: e.parent, child: e }) } e.userData && e.userData.customTexture && (r = e) })), i.forEach((e => { e.parent.remove(e.child) })), r && (r.traverse((e => { e.material && e.material.map && (_context.textureStore.add(e.material.map.name || `${e.material.name}#map`, e.material.map), this._cache && this._cache.set(md5(e.material.map.name), { resource: e.material.map })) })), r.parent.remove(r)); let n = this.helper.autoMerge(e.scene); this._cache && this._cache.set(l, { type: t, resourcePath: c, needExport: o, refCount: 1, resource: n, size: a }) } else this._cache && this._cache.set(l, { type: t, resourcePath: c, needExport: o, refCount: 1, resource: e.scene, size: a }); n instanceof Array ? n.forEach((e => { e(this.helper.cloneNode(this._cache ? this._cache.get(l).resource : null)), _context.sceneBufferCacheExpired = !0 })) : "function" == typeof r && (r(this.helper.cloneNode(this._cache ? this._cache.get(l).resource : null)), _context.sceneBufferCacheExpired = !0) } }), (e => { if (1 !== e.total && 0 !== e.total) { let t = this._cache ? this._cache.get(l) : null; t && void 0 === t.size && (t.size = e.total, this._cache && this._cache.set(l, t)) } n && n(e) }), (e => { this._loadQueue && this._loadQueue.delete(l), this._cache && this._cache.delete(l), a && a(e) }), (e => { this._loadQueue ? this._loadQueue.set(l, e) : e.abort() }), i); break; case "glb": case "gltf": _context.loaders.gltfLoader.load(e, (e => { if (this._loadQueue && this._loadQueue.delete(l), !this._cache) return; let i = this._cache ? this._cache.get(l) : null, n = i.onLoadList, a = i.size; if (0 === e.animations.length) { let i = this.helper.autoMerge(e.scene); i.needExport = o, this._cache && this._cache.set(l, { type: t, resourcePath: c, needExport: o, refCount: 1, resource: i, size: a }) } else e.scene.needExport = o, this._cache && this._cache.set(l, { type: t, resourcePath: c, needExport: o, refCount: 1, resource: e.scene, size: a }); n instanceof Array ? n.forEach((e => { e(this.helper.cloneNode(this._cache ? this._cache.get(l).resource : null)), _context.sceneBufferCacheExpired = !0 })) : "function" == typeof r && (r(this.helper.cloneNode(this._cache ? this._cache.get(l).resource : null)), _context.sceneBufferCacheExpired = !0) }), (e => { if (1 !== e.total && 0 !== e.total) { let t = this._cache ? this._cache.get(l) : null; t && void 0 === t.size && (t.size = e.total, this._cache && this._cache.set(l, t)) } n && n(e) }), (e => { this._loadQueue && this._loadQueue.delete(l), this._cache && this._cache.delete(l), a && a(e) }), (e => { this._loadQueue ? this._loadQueue.set(l, e) : e.abort() })); break; case "avwa": _context.loaders.gltfLoader.load(e, (e => { if (this._loadQueue && this._loadQueue.delete(l), !this._cache) return; let i = this._cache ? this._cache.get(l) : null, n = i.onLoadList, a = i.size, s = null; e.scene.traverse((e => { if (e.userData && e.userData.dhAsset && !s) { for (var t in e.userData.dhAsset.materials) "specular" !== e.userData.dhAsset.materials[t].type && (e.userData.dhAsset.materials[t].side = 2); s = e.userData.dhAsset } })), e.scene.needExport = o, this._cache && this._cache.set(l, { type: t, resourcePath: c, needExport: o, refCount: 1, resource: e.scene, size: a }), n instanceof Array ? n.forEach((e => { e(this.helper.cloneNode(this._cache ? this._cache.get(l).resource : null)), _context.sceneBufferCacheExpired = !0 })) : "function" == typeof r && (r(this.helper.cloneNode(this._cache ? this._cache.get(l).resource : null)), _context.sceneBufferCacheExpired = !0) }), (e => { if (1 !== e.total && 0 !== e.total) { let t = this._cache ? this._cache.get(l) : null; t && void 0 === t.size && (t.size = e.total, this._cache && this._cache.set(l, t)) } n && n(e) }), (e => { this._loadQueue && this._loadQueue.delete(l), this._cache && this._cache.delete(l), a && a(e) }), (e => { this._loadQueue ? this._loadQueue.set(l, e) : e.abort() })); break; case "fbx": _context.loaders.fbxLoader.load(e, (e => { if (this._loadQueue && this._loadQueue.delete(l), !this._cache) return; let i = this._cache ? this._cache.get(l) : null, n = i.onLoadList, a = i.size; if (0 === e.animations.length) { let i = this.helper.autoMerge(e); i.needExport = o, this._cache && this._cache.set(l, { type: t, resourcePath: c, needExport: o, refCount: 1, resource: i, size: a }) } else e.scene.needExport = o, this._cache && this._cache.set(l, { type: t, resourcePath: c, needExport: o, refCount: 1, resource: e.scene, size: a }); n instanceof Array ? n.forEach((e => { e(this.helper.cloneNode(this._cache ? this._cache.get(l).resource : null)), _context.sceneBufferCacheExpired = !0 })) : "function" == typeof r && (r(this.helper.cloneNode(this._cache ? this._cache.get(l).resource : null)), _context.sceneBufferCacheExpired = !0) }), (e => { if (1 !== e.total && 0 !== e.total) { let t = this._cache ? this._cache.get(l) : null; t && void 0 === t.size && (t.size = e.total, this._cache && this._cache.set(l, t)) } n && n(e) }), (e => { this._loadQueue && this._loadQueue.delete(l), this._cache && this._cache.delete(l), a && a(e) }), (e => { this._loadQueue ? this._loadQueue.set(l, e) : e.abort() })); break; case "texture": return _context.loaders.textureLoader.load(e, (e => { if (this._loadQueue && this._loadQueue.delete(l), !this._cache) return; let t = this._cache ? this._cache.get(l) : null, i = t.onLoadList, n = t.size; this._cache && this._cache.set(l, { resource: e, size: n }), i instanceof Array ? i.forEach((e => { e(this._cache ? this._cache.get(l).resource : null), _context.sceneBufferCacheExpired = !0 })) : "function" == typeof r && (r(this._cache ? this._cache.get(l).resource : null), _context.sceneBufferCacheExpired = !0) }), (e => { if (1 !== e.total && 0 !== e.total) { let t = this._cache ? this._cache.get(l) : null; t && void 0 === t.size && (t.size = e.total, this._cache && this._cache.set(l, t)) } n && n(e) }), (e => { this._loadQueue && this._loadQueue.delete(l), this._cache && this._cache.delete(l), a && a(e) }), (e => { this._loadQueue ? this._loadQueue.set(l, e) : e.abort() })); case "cubetexture": return _context.loaders.cubeTextureLoader.load(e, (e => { if (this._loadQueue && this._loadQueue.delete(l), !this._cache) return; let t = this._cache ? this._cache.get(l) : null, i = t.onLoadList, n = t.size; this._cache && this._cache.set(l, { resource: e, size: n }), i instanceof Array ? i.forEach((e => { e(this._cache ? this._cache.get(l).resource : null), _context.sceneBufferCacheExpired = !0 })) : "function" == typeof r && (r(this._cache ? this._cache.get(l).resource : null), _context.sceneBufferCacheExpired = !0) }), (e => { if (1 !== e.total && 0 !== e.total) { let t = this._cache ? this._cache.get(l) : null; t && void 0 === t.size && (t.size = e.total, this._cache && this._cache.set(l, t)) } n && n(e) }), (e => { this._loadQueue && this._loadQueue.delete(l), this._cache && this._cache.delete(l), a && a(e) }), (e => { this._loadQueue ? this._loadQueue.set(l, e) : e.abort() })); case "imagebitmap": return _context.loaders.imageBitmapLoader.load(e, (e => { let t = new CanvasTexture(e); if (this._loadQueue && this._loadQueue.delete(l), !this._cache) return; let i = (this._cache ? this._cache.get(l) : null).onLoadList, n = ImageBitMapCache.get(e).size; this._cache && this._cache.set(l, { resource: t, size: n }), i instanceof Array ? i.forEach((e => { e(this._cache ? this._cache.get(l).resource : null), _context.sceneBufferCacheExpired = !0 })) : "function" == typeof r && (r(this._cache ? this._cache.get(l).resource : null), _context.sceneBufferCacheExpired = !0) }), void 0, (e => { this._loadQueue && this._loadQueue.delete(l), this._cache && this._cache.delete(l), a && a(e) }), (e => { this._loadQueue ? this._loadQueue.set(l, e) : e.abort() })) } } clear() { this._scene } destroy() { this._loadQueue.forEach((e => { e && e.abort && e.abort() })), this._loadQueue = null, this._cache.forEach((e => { e && util$1.disposeThreeObject(e.resource) })), this._cache = null } find(e) { if (e) return this._cache ? this._cache.get(md5(e)) : null } remove(e, t) { this._scene } copy(e, t) { } applySettings(e) { return new Promise((t => { if (!e || e.length <= 0) return this.preloadResourceStore = !0, logger.debug("cacheStore.applySettings() loadMaterial end。"), void t(); let i = []; e.forEach((e => { e.refCount <= 1 || i.push(new Promise((t => { _context.instance.preloadResource(e.resourcePath, e.type, (() => { let i = this._cache ? this._cache.get(md5(e.resourcePath)) : null; i && e && (i.refCount = e.refCount, this._cache && this._cache.set(md5(e.resourcePath), i)), t() }), (() => { }), { needExport: e.needExport }) }))) })), i.length > 0 ? (this.preloadResourceStore = !1, Promise.all(i).then((() => { this.preloadResourceStore = !0, logger.debug("cacheStore.applySettings() loadMaterial end。"), t() })).catch((() => { this.preloadResourceStore = !1, logger.error("cacheStore.applySettings() loadMaterial end error。"), t() }))) : (this.preloadResourceStore = !0, logger.debug("cacheStore.applySettings() loadMaterial end。"), t()) })) } getSettings() { let e = [], t = _context.instance.defaultObjectTree.getSettings(); return this._cache.forEach(((i, r) => { let n = !1; t.children.forEach((e => { if (!n) if ("ModelItem" === e.type) { if (e.materials) for (var t in e.materials) e.materials[t].replacePath && md5(e.materials[t].replacePath) === r && (n = !0) } else "GroupItem" === e.type ? e.children.forEach((e => { if ("ModelAsset" === e.type && e.materials) for (var t in e.materials) e.materials[t].replacePath && md5(e.materials[t].replacePath) === r && (n = !0) })) : "PaintItem" === e.type ? (e.children.forEach((e => { if (("ModelAsset" === e.type || "ModelItem" === e.type) && e.materials) for (var t in e.materials) e.materials[t].replacePath && md5(e.materials[t].replacePath) === r && (n = !0) })), e.modelInstanced && e.modelInstanced.forEach((e => { if (("ModelAsset" === e.type || "ModelItem" === e.type) && e.materials) for (var t in e.materials) e.materials[t].replacePath && md5(e.materials[t].replacePath) === r && (n = !0) }))) : "BuildingItem" === e.type && e.children.forEach((e => { if ("ModelItem" === e.type) { if (e.materials) for (var t in e.materials) e.materials[t].replacePath && md5(e.materials[t].replacePath) === r && (n = !0) } else "BuildingFloorItem" === e.type && e.children.forEach((e => { if ("ModelItem" === e.type && e.materials) for (var t in e.materials) e.materials[t].replacePath && md5(e.materials[t].replacePath) === r && (n = !0) })) })) })), n && e.push({ needExport: i.needExport, refCount: 2, resourcePath: i.resourcePath, type: i.type }) })), e } getPublishSceneObject3D(e) { let t = new Set; e.objectTree.children.forEach((e => { "ModelItem" === e.type ? t.add(e.modelPath) : "GroupItem" === e.type ? e.children.forEach((e => { "ModelAsset" === e.type && t.add(e.path) })) : "PaintItem" === e.type ? (e.children.forEach((e => { "ModelAsset" !== e.type && "ModelItem" !== e.type || t.add(e.modelPath) })), e.modelInstanced && e.modelInstanced.forEach((e => { "ModelAsset" !== e.type && "ModelItem" !== e.type || t.add(e.path) }))) : "BuildingItem" === e.type && e.children.forEach((e => { "ModelItem" === e.type ? t.add(e.modelPath) : "BuildingFloorItem" === e.type && e.children.forEach((e => { "ModelItem" === e.type && t.add(e.modelPath) })) })) })); let i = new Group; return i.userData = { isModelSource: !0 }, t.forEach((e => { let t = md5(e), r = this._cache.get(t); r && (r.resource.userData = { modelPath: e }, i.add(r.resource)) })), i } } class CacheStoreHelper { constructor() { this.cloneNode = e => { let t = e.clone(); return e instanceof Texture$1 || e instanceof CubeTexture || t.traverse((e => { if (e.isMesh) if (e.material instanceof Array) { let t = []; for (let i of e.material) { let e = i.clone(); for (let t in e) e[t] instanceof Texture$1 && (e[t] = e[t].clone()); t.push(e) } e.material = t } else if (e.material instanceof Material$1) { e.material = e.material.clone(); for (let t in e.material) e.material[t] instanceof Texture$1 && (e.material[t] = e.material[t].clone()) } })), t }, this.autoMerge = e => { if (e.isGroup) return this.recurse(e), e }, this.recurse = e => { if (this.checkCapableToMerge(e)) this.doMerge(e); else if (this.checkGroupCapableToMerge(e)) this.doGroupMerge(e); else for (let t = e.children.length - 1; t >= 0; t--)this.recurse(e.children[t]) }, this.doMerge = e => { let t = [], i = [], r = []; for (let n of e.children) if (isNaN(Number(n.name.replace(e.name + "_", "")))) t.push(n); else if (n.isMesh) { i.push(n.geometry); let e = n.material.clone(); e.vertexColors = !1, r.push(e) } let n = 0; if (i.forEach((e => { e.attributes.uv2 && n++ })), n > 0 && n != i.length && i.forEach((e => { e && e.attributes && e.attributes.uv && !e.attributes.uv2 && e.setAttribute("uv2", new BufferAttribute(e.attributes.uv.array, 2)) })), !i.length) return; let a = BufferGeometryUtils.mergeBufferGeometries(i), o = 0, s = 0; for (let e of i) a.addGroup(o, e.index.count, s), o += e.index.count, s++; let l = new Mesh(a, r); l.name = e.name, l.visible = e.visible, l.castShadow = !0, l.receiveShadow = !0, l.position.copy(e.position), l.rotation.copy(e.rotation), l.scale.copy(e.scale); for (let e of t) l.add(e); this.recurse(l), util$1.disposeThreeObject(e), e.parent.add(l), e.parent.remove(e) }, this.doGroupMerge = e => { let t = [], i = [], r = [], n = []; for (let a of e.children) if (a.name.indexOf("_water_") < 0) if (isNaN(Number(a.name.replace("mesh_", "")))) t.push(a); else if (a.isMesh) { r.push(a.geometry.index), i.push(a.geometry.toNonIndexed()); let e = a.material.clone(); e.vertexColors = !1, n.push(e) } if (!i.length) return; let a = BufferGeometryUtils.mergeBufferGeometries(i), o = 0, s = 0; for (let e of r) a.addGroup(o, e.count, s), o += e.count, s++; let l = new Mesh(a, n); l.name = e.name, l.visible = e.visible, l.castShadow = !0, l.receiveShadow = !0, l.position.copy(e.position), l.rotation.copy(e.rotation), l.scale.copy(e.scale); for (let e of t) l.add(e); this.recurse(l), util$1.disposeThreeObject(e), e.parent.add(l), e.parent.remove(e) }, this.checkCapableToMerge = e => { if (!e.isGroup || "" === e.name) return !1; if (!(e.children instanceof Array) || e.children.length < 2) return !1; let t = 0; for (let i of e.children) i.name.indexOf(e.name + "_") > -1 && (t += 1); return t >= 2 || void 0 }, this.checkGroupCapableToMerge = e => { if (!e.isGroup || "" === e.name) return !1; if (!(e.children instanceof Array) || e.children.length < 2) return !1; e.children[0].name; let t = 0; for (let i of e.children) i.name.indexOf("mesh_") > -1 && (t += 1); return t >= 2 || void 0 } } } class ClippingStore { constructor() { var e = []; this.add = (t, i, r, n, a, o) => { let s; this.findCutBulidingByUUID(t) && this.remove(t), _context.scene.models.traverse((e => { e.uuid === t && (s = e) })), s || (s = _context.scene.getObjectByName(t)); var l = { uuid: t, clippingController: new ClippingController({ meshes: [s], clippingPlanes: [{ nx: i, ny: r, nz: n, d: a }] }) }; e.push(l), o && o(1, "成功") }, this.remove = (t, i) => { let r = this.findCutBulidingByUUID(t); if (r) { r.clippingController.clear(); for (let i = 0; i < e.length; i++)e[i].uuid === t && (delete e[i].clippingController, e.splice(i, 1), i--); i && i(1, "删除成功") } else i && i(0, "不存在的裁剪建筑") }, this.findCutBulidingByUUID = (t, i) => { var r = e.find((e => e.uuid === t)); if (r) return i && i(1, "成功"), r; i && i(0, "不存在的裁剪建筑") }, this.dispose = () => { e.forEach((e => { e.clippingController instanceof ClippingController && e.clippingController.dispose && e.clippingController.dispose() })), e = [] } } } class CacheBufferPass extends Pass { constructor(e = !0) { super("CacheBufferPass"), this.setFullscreenMaterial(new ShaderMaterial({ type: "CacheBufferMaterial", uniforms: { inputBuffer: new Uniform(null), opacity: new Uniform(1) }, fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\n\n        uniform mediump sampler2D inputBuffer;\n    \n    #else\n    \n        uniform lowp sampler2D inputBuffer;\n    \n    #endif\n    \n    uniform float opacity;\n    \n    varying vec2 vUv;\n    \n    void main() {\n    \n        vec4 texel = texture2D(inputBuffer, vUv);\n        gl_FragColor = opacity * texel;\n    \n        #include <encodings_fragment>\n    \n    }", vertexShader: "varying vec2 vUv;\n\n        void main() {\n        \n            vUv = position.xy * 0.5 + 0.5;\n            gl_Position = vec4(position.xy, 1.0, 1.0);\n        \n        }", blending: NoBlending, depthWrite: !1, depthTest: !1 })), this.needsSwap = !0, this.cacheBuffer = new WebGLRenderTarget(1, 1, { minFilter: LinearFilter, magFilter: LinearFilter, stencilBuffer: !1, depthBuffer: !1 }), this.cacheBuffer.texture.name = "CacheBuffer.Target", this.cacheExpired = !0, this.resize = e } render(e, t, i, r, n) { if (!this.cacheEnabled) return this.cacheExpired = !0, this.getFullscreenMaterial().uniforms.inputBuffer.value = t.texture, e.setRenderTarget(this.renderToScreen ? null : i), void e.render(this.scene, this.camera); this.cacheExpired && (this.getFullscreenMaterial().uniforms.inputBuffer.value = t.texture, e.setRenderTarget(this.renderToScreen ? null : this.cacheBuffer), e.render(this.scene, this.camera), this.cacheExpired = !1), this.getFullscreenMaterial().uniforms.inputBuffer.value = this.cacheBuffer.texture, e.setRenderTarget(this.renderToScreen ? null : i), e.render(this.scene, this.camera) } setSize(e, t) { if (this.resize) { const i = Math.max(e, 1), r = Math.max(t, 1); this.cacheBuffer.setSize(i, r) } } } let InstancedIconTypes = ["IconAsset", "IconBackground", "IconGroup", "InstancedGroup", "Sprite"]; class EffectStore { constructor() { this._effects = {}, this._lutPassEnabled = !1, _context.composer = new EffectComposer(_context.renderer, { frameBufferType: HalfFloatType }), _context.composer.render = function (e, r) { const n = this.renderer, a = this.copyPass; let o, s, l, c = this.inputBuffer, h = this.outputBuffer, u = !1; for (let d = 0; d < this.passes.length; d++) { const p = this.passes[d]; p.enabled && (r ? d < i.cachedPasses ? t.cacheExpired && p.render(n, c, h, e, u) : (p instanceof CacheBufferPass && (p.cacheEnabled = !0), p.render(n, c, h, e, u)) : (p.render(n, c, h, e, u), t.cacheExpired = !0, t.cacheEnabled = !1), p.needsSwap && (u && (a.renderToScreen = p.renderToScreen, o = n.getContext(), s = n.state.buffers.stencil, s.setFunc(o.NOTEQUAL, 1, 4294967295), a.render(n, c, h, e, u), s.setFunc(o.EQUAL, 1, 4294967295)), l = c, c = h, h = l), p instanceof MaskPass ? u = !0 : p instanceof ClearMaskPass && (u = !1)) } }, _context.composer.autoRenderToScreen = !0, void 0 !== _context.renderer.getContext().MAX_SAMPLES ? _context.composer.multisampling = Math.min(4, _context.renderer.getContext().getParameter(_context.renderer.getContext().MAX_SAMPLES)) : _context.composer.multisampling = 0; let e = new RenderPass(_context.scene, _context.camera); e.name = "RenderPass", _context.composer.addPass(e); let t = new CacheBufferPass; t.name = "CacheBufferPass", this.visualEffect = new VisualEffect; const i = this.visualEffect; this.spaceEffect = new SpaceEffect, this.visualEffect.addPass(t), this.changeScene = t => { e.scene = t, this.spaceEffect = new SpaceEffect; const i = this.visualEffect._passes.outlinePass.outlineEffect; i.scene = _context.scene, i.depthPass.scene = _context.scene, i.depthPass.renderPass.scene = _context.scene, i.maskPass.scene = _context.scene; const r = this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect; r.scene = _context.scene, r.depthPass.scene = _context.scene, r.depthPass.renderPass.scene = _context.scene, r.maskPass.scene = _context.scene } } setSize(e, t) { _context.composer.setSize(e, t) } setLut(e = "disabled") { this.lutMap[e] ? (this.lutPass.enabled = !0, this.lutPass.intensity = 1, this.lutPass.lut = this.lutMap[e].texture3D) : (this.lutPass.enabled = !1, this.lutPass.lut = null) } enableLut() { return this._lutPassEnabled = !0, this.lutPass && (this.lutPass.enabled = !0), !!this.lutPass && this.lutPass.enabled } disableLut() { return this._lutPassEnabled = !1, this.lutPass && (this.lutPass.enabled = !1), !!this.lutPass && this.lutPass.enabled } nextLut() { this.lutPass.enabled || this.enableLut(), this.lutSelected = ""; for (let e in this.lutMap) { if ("" !== this.lutSelected) { this.lutSelected = e, this.lutPass.lut = this.lutMap[this.lutSelected].texture3D; break } if (this.lutMap[e].texture3D === this.lutPass.lut && (this.lutSelected = e, "Zeke 39.CUBE" === this.lutSelected)) { this.lutSelected = "Arabica 12.CUBE", this.lutPass.lut = this.lutMap[this.lutSelected].texture3D; break } } return this.lutSelected } render(e) { _context.composer.render(e) } takeSnapshot({ targetWidth: e = 258, targetHeight: t = 160, targetEncoder: i = .65 } = {}) { let r = _context.renderer.getSize(), n = _context.camera.fov, a = _context.camera.aspect; e / t > _context.camera.aspect ? _context.camera.aspect = e / t : (_context.camera.aspect = e / t, _context.camera.fov = Math.atan(a / _context.camera.aspect * Math.tan(n / 180 * Math.PI / 2)) / Math.PI * 180 * 2), _context.camera.updateProjectionMatrix(), _context.composer.setSize(2 * e, 2 * t), _context.composer.render(); let o = _context.renderer.domElement.toDataURL("image/jpeg", i); return _context.camera.aspect = a, _context.camera.fov = n, _context.camera.updateProjectionMatrix(), _context.composer.setSize(r.width, r.height), o } highlightObject(e, t) { if (!this.visualEffect._passes.outlinePass || !this.visualEffect._passes.outlinePass.outlineEffect) return; if (e && t || this.cancelLayerHelper(), !e) { if (this.visualEffect._passes.outlinePass.outlineEffect.selection.clear(), this.visualEffect._passes.outlinePass.outlineEffect.time = 1e4, !_context.composer.passes.find((e => "ArticulationOutlineEffect" == e.name))) { let e = _context.composer.passes.findIndex((e => "OutlinePass" == e.name)), t = Array.from(this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.selection); this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.selection.clear(), _context.composer.addPass(this.visualEffect._passes.articulationOutlinePass, e + 1), t.forEach((e => { this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.selection.add(e) })) } return } var i = this; let r = _context.composer.passes.find((e => "ArticulationOutlineEffect" == e.name)); if (r && _context.effectStore.visualEffect.removePass(r), e instanceof InstancedHelper) { let { key: t } = e.userData; e.visible = e.instanced.settings[t].isVisible } else e.children.length > 0 ? (t || (this.visualEffect._passes.outlinePass.outlineEffect.selection.clear(), this.visualEffect._passes.outlinePass.outlineEffect.time = 1e4), e.traverse((function (e) { InstancedIconTypes.includes(e.type) || i.visualEffect._passes.outlinePass.outlineEffect.selection.add(e) }))) : t ? (this.visualEffect._passes.outlinePass.outlineEffect.selection.add(e), InstancedIconTypes.includes(e.type) || i.visualEffect._passes.outlinePass.outlineEffect.selection.add(e)) : (this.visualEffect._passes.outlinePass.outlineEffect.selection.clear(), this.visualEffect._passes.outlinePass.outlineEffect.time = 1e4, InstancedIconTypes.includes(e.type) || i.visualEffect._passes.outlinePass.outlineEffect.selection.add(e)) } cancleHighlightObject(e) { if (!this.visualEffect._passes.outlinePass || !this.visualEffect._passes.outlinePass.outlineEffect) return; if (!_context.composer.passes.find((e => "ArticulationOutlineEffect" == e.name))) { let e = _context.composer.passes.findIndex((e => "OutlinePass" == e.name)); _context.composer.addPass(this.visualEffect._passes.articulationOutlinePass, e + 1) } var t = this; if (e instanceof InstancedHelper) e.visible = !1; else if (e.children.length > 0 ? e.traverse((function (e) { t.visualEffect._passes.outlinePass.outlineEffect.selection.delete(e) })) : this.visualEffect._passes.outlinePass.outlineEffect.selection.delete(e), this.visualEffect._passes.outlinePass.outlineEffect.selection.size <= 0) { if (!_context.composer.passes.find((e => "ArticulationOutlineEffect" == e.name))) { let e = _context.composer.passes.findIndex((e => "OutlinePass" == e.name)), t = Array.from(this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.selection); this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.selection.clear(), _context.composer.addPass(this.visualEffect._passes.articulationOutlinePass, e + 1), t.forEach((e => { this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.selection.add(e) })) } } } cancelLayerHelper() { _context.defaultObjectTree.children.forEach((e => { "GroupItem" !== e.type && "PaintItem" !== e.type || e.resetHelper() })) } initOutlinePass(e, t, i) { if (!this.visualEffect._passes.articulationOutlinePass || !this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect) return; if (!e) return this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.selection.clear(), void (this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.time = 1e4); if (!_context.composer.passes.find((e => "ArticulationOutlineEffect" == e.name)) && this.visualEffect._passes.outlinePass.outlineEffect.selection.size <= 0) { let e = _context.composer.passes.findIndex((e => "OutlinePass" == e.name)); _context.composer.addPass(this.visualEffect._passes.articulationOutlinePass, e + 1) } this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.uniforms.get("hiddenEdgeColor").value = i.color, this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.uniforms.get("visibleEdgeColor").value = i.color, this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.blendMode.opacity.value = void 0 === i.alpha ? 1 : i.alpha, t || (this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.selection.clear(), this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.time = 1e4); var r = this; e.children.length > 0 ? e.traverse((function (e) { r.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.selection.add(e) })) : this.visualEffect._passes.articulationOutlinePass.articulationOutlineEffect.selection.add(e) } applySettings(e) { e ? (this.visualEffect.applySettings(e.visualEffect), this.spaceEffect.applySettings(e.spaceEffect)) : logger.error("无效的特效设置。") } } EffectStore.TYPE = { SSAO: Symbol("SSAO"), SMAA: Symbol("SMAA") }; class EventHandlerStore { constructor(e, t, i) { this._renderer = e, this._scene = t, this._camera = i, this._debounceTimer = 0, this._debounceDelay = 1e3, this._cameraStopTimeout = void 0, this._handlers = { lodchange: { default: [] }, cameramove: { default: [] }, camerazoom: { default: [] }, camerazoomstop: { default: [] }, click: { default: [], byType: { sprite: [], billboard: [], landmark: [], bubble: [], bar: [], odLine: [], trail: [], area: [], drawable: [], model: [], building: [], scene: [] } }, dblclick: { default: [], byType: { sprite: [], billboard: [], model: [] } }, mousedown: { default: [], byType: { sprite: [], billboard: [], model: [] } }, mousehover: { default: [], byType: { sprite: [], billboard: [], landmark: [], bubble: [], bar: [], odLine: [], trail: [], area: [], drawable: [], model: [], building: [], scene: [] } }, unmousehover: { default: [], byType: { sprite: [], billboard: [], landmark: [], bubble: [], bar: [], odLine: [], trail: [], area: [], drawable: [], model: [], building: [], scene: [] } }, mouseup: { default: [], byType: { sprite: [], billboard: [], model: [] } }, trailmove: { default: [] } }, this._raycaster = new Raycaster, this._mouse = new Vector2, this._lastMouseHoverDrawable = null, this._lastMouseHoverModel = null } get handlers() { return this._handlers } set handlers(e) { this._handlers = e } update() { } cameraMove(e) { this._handlers.cameramove.default.length > 0 && this._handlers.cameramove.default.map((t => { t.handler(e) })) } add(e, t, i, r) { e && i && ("" == (t = t || "") ? this._handlers[e].default.push({ handler: i, options: r }) : this._handlers[e].byType[t].push({ handler: i, options: r })) } remove(e, t, i) { t && "" !== t ? ("" !== i && i || (this._handlers[e].byType[t] = []), this._handlers[e].byType[t].map(((r, n) => { r.handler === i && this._handlers[e].byType[t].splice(n, 1) }))) : "" !== i && i ? this._handlers[e].default.map(((t, r) => { t.handler === i && this._handlers[e].default.splice(r, 1) })) : this._handlers[e].default = [] } onClick(e, t, i) { this._mouse.set(e.offsetX / this._renderer.domElement.clientWidth * 2 - 1, -e.offsetY / this._renderer.domElement.clientHeight * 2 + 1), this._raycaster.setFromCamera(this._mouse, this._camera); var r = []; t._scene.children.map(((e, t) => { "__models" === e.name && e.traverse((function (e) { e.isMesh ? r.push(e) : "IconGroup" === e.type && e.children.map((e => { r.push(e) })) })) })), t._sceneObjects.traverse((function (e) { r.push(e) })); const n = _context.scene.getObjectByName("__tilesGroup"); n && n.children[0] && r.push(n.children[0]); var a = this._raycaster.intersectObjects(r); if (r = null, _context.scene.getObjectByName("__pgl") && _context.pgl.terrain) { let t = _context.pgl.terrain.pickTerrain({ x: e.offsetX, y: e.offsetY }); if (t && t.hit) { for (let e = 0; e < a.length; e++)if (a[e].distance > t.distance) { a.splice(e, 0, t); break } (0 === a.length || t.distance > a[a.length - 1].distance) && a.push(t) } } var o = null, s = []; if (a.length > 0) { for (let t = 0; t < a.length; t++) { if (!1 === (o = a[t]).object.visible || !1 === util$1.judegParentIsVisible(o.object)) continue; let r = util$1.findObjectToBuilding(o.object.uuid); if (r) { let e = _context.clippingStore.findCutBulidingByUUID(r.getGroup().uuid); if (e && e.clippingController.pointClipTest(o.point)) continue } if (util$1.isDepthTestDisabled(o.object.material)) { (s = []).push(this._xyzToLLA(e, o, i)); break } if (o) s.push(this._xyzToLLA(e, o, i)); else if (this._handlers.click.byType.scene.length > 0) { var l = { type: "background" }; this._handlers.click.byType.scene.map(((t, i) => { t.handler(e, l, i) })) } if (this._handlers.click.default.length > 0) { let t = this._raycaster.intersectObjects(this._scene.children, !0); if (t.length > 0) (o = t[0]).point && (e.clickX = o.point.x, e.clickY = o.point.y, e.clickZ = o.point.z), o.object.position, this._invoke(this._handlers.background.default, e), o.object && o.object.material instanceof Array && (e.materialIndex = o.face.materialIndex), this._invoke(this._handlers.click.default, e, o.object); else this._invoke(this._handlers.background.default, e) } } 0 === s.length && this._handlers.click.byType.model.length > 0 && this._handlers.click.byType.model.map((e => { e.handler(null) })); let t = [], r = [], n = [], c = [], h = [], u = [], d = [], p = [], f = []; if (s.forEach((e => { "landmark" !== this._getType(e) && "landmark图标" !== this._getType(e) && "landmark底图" !== this._getType(e) && "landmark文字" !== this._getType(e) || t.push(e), "bubble" !== this._getType(e) && "instancedbubble" !== this._getType(e) || r.push(e), "bar" === this._getType(e) && n.push(e), "odLine" === this._getType(e) && c.push(e), "trail" === this._getType(e) && h.push(e), "area" === this._getType(e) && u.push(e), this._judegDrawable(e) && d.push(e), this._judegDrawable(e) && "IconAsset" !== e.type || p.push(e), f.push(e) })), this._handlers.click.byType.landmark.length > 0 && this._handlers.click.byType.landmark.map(((i, r) => { t[0] && (this._coordinatePass(t[0], e), i.handler(e, t[0].object, r)) })), this._handlers.click.byType.bubble.length > 0 && this._handlers.click.byType.bubble.map(((t, i) => { r[0] && (this._coordinatePass(r[0], e), t.handler(e, r[0].object, i)) })), this._handlers.click.byType.bar.length > 0 && this._handlers.click.byType.bar.map(((t, i) => { n[0] && (this._coordinatePass(n[0], e), t.handler(e, n[0].object, i)) })), this._handlers.click.byType.odLine.length > 0 && this._handlers.click.byType.odLine.map(((t, i) => { c[0] && (this._coordinatePass(c[0], e), t.handler(e, c[0].object, i)) })), this._handlers.click.byType.trail.length > 0 && this._handlers.click.byType.trail.map(((t, i) => { h[0] && (this._coordinatePass(h[0], e), t.handler(e, h[0].object, i)) })), this._handlers.click.byType.area.length > 0 && this._handlers.click.byType.area.map(((t, i) => { u[0] && (this._coordinatePass(u[0], e), t.handler(e, u[0].object, i)) })), this._handlers.click.byType.drawable.length > 0 && this._handlers.click.byType.drawable.map(((t, i) => { d[0] && (this._coordinatePass(d[0], e), "number" == typeof d[0].instanceId && (d[0].object.instanceId = d[0].instanceId), t.handler(e, d[0].object, i)) })), this._handlers.click.byType.model.length > 0 && this._handlers.click.byType.model.map(((t, i) => { if (p.length > 0) { let n; this._coordinatePass(p[0], e); let a = _context.defaultObjectTree.findItemByObject3D(p[0].object) || {}; if ("ModelItem" === a.type || "IconAsset" === a.type || "ModelAsset" === a.type || "GroupItem" === a.type || "PaintItem" === a.type) { var r = a; n = a } else if ("BuildingItem" === a.type) { r = util$1.getNodelFromModelItem(p[0].object); n = util$1.findObjectToBuilding(p[0].object.uuid) } let o = p[0].object || {}; p[0].object && p[0].object.material instanceof Array && (e.materialIndex = p[0].face.materialIndex), r && t.handler(e, { name: o.name, node: o, position: o.position ? { x: o.position.x, y: o.position.y, z: o.position.z } : void 0, model: { name: null != r.name ? r.name : o.name, position: null != r.name && r.getSettings ? r.getSettings().transform.position ? { x: r.getSettings().transform.position.x, y: r.getSettings().transform.position.y, z: r.getSettings().transform.position.z } : void 0 : null, uuid: null != r.getGroup ? r.getGroup().uuid : r.id }, parentModel: { name: null != a.name ? a.name : r.name, uuid: a.getGroup && null != a.getGroup().uuid ? a.getGroup().uuid : r.uuid, position: null != a.name ? a.getSettings().transform.position ? { x: a.getSettings().transform.position.x, y: a.getSettings().transform.position.y, z: a.getSettings().transform.position.z } : void 0 : null }, _name: n.name, _model: { name: n.name, uuid: null != n.getGroup ? n.getGroup().uuid : r.id } }, i) } })), this._handlers.click.byType.building.length > 0 && p.length > 0) { let t; if (this._coordinatePass(p[0], e), "BuildingItem" === (_context.defaultObjectTree.findItemByObject3D(p[0].object) || {}).type) { let i = _context.defaultObjectTree.getParentIds(p[0].object) || {}; t = util$1.findObjectToFloor(i), t ? this._handlers.click.byType.building.map(((i, r) => { let n = t; i.handler(e, { name: n.name, model: { name: null != t.name ? t.name : n.name, uuid: null != t.getGroup ? t.getGroup().uuid : t.id }, selectedType: "BuildingFloorItem" }, r) })) : (t = util$1.findObjectToBuilding(p[0].object.uuid), this._handlers.click.byType.building.map(((i, r) => { let n = t; i.handler(e, { name: n.name, model: { name: null != t.name ? t.name : n.name, uuid: null != t.getGroup ? t.getGroup().uuid : t.id }, selectedType: "BuildingItem" }, r) }))) } } this._handlers.click.byType.scene.length > 0 && f[0] && this._handlers.click.byType.scene.map(((t, i) => { f[0].object && f[0].object.material instanceof Array && (e.materialIndex = f[0].face.materialIndex), this._coordinatePass(f[0], e), t.handler(e, f[0].object, i) })) } else this._handlers.click.byType.model.length > 0 && this._handlers.click.byType.model.map((e => { e.handler(null) })) } mouseHoverTest() { let e = this._handlers.mousehover.default.length > 0; if (!1 === e && (e = this._handlers.unmousehover.default.length > 0), !1 === e) for (const t in this._handlers.mousehover.byType) if (e = this._handlers.mousehover.byType[t].length > 0, !0 === e) break; if (!1 === e) for (const t in this._handlers.unmousehover.byType) if (e = this._handlers.unmousehover.byType[t].length > 0, !0 === e) break; !1 !== e && (clearTimeout(this._mouseHoverTimeout), this._mouseHoverTimeout = setTimeout((() => { this._mouseHoverTest(...arguments) }), 60)) } _mouseHoverTest(e, t, i) { this._mouse.set(e.offsetX / this._renderer.domElement.clientWidth * 2 - 1, -e.offsetY / this._renderer.domElement.clientHeight * 2 + 1), this._raycaster.setFromCamera(this._mouse, this._camera); var r = []; t._scene.children.map(((e, t) => { "__models" === e.name && e.traverse((function (e) { e.isMesh ? r.push(e) : "IconGroup" === e.type && e.children.map((e => { r.push(e) })) })) })), t._sceneObjects.traverse((function (e) { r.push(e) })); var n = this._raycaster.intersectObjects(r, !0); r = null; var a = null, o = []; if (n.length > 0) { for (let t = 0; t < n.length; t++)if (!1 !== n[t].object.visible && !1 !== util$1.judegParentIsVisible(n[t].object)) { if (a = n[t]) o.push(this._xyzToLLA(e, a, i)); else if (this._handlers.mousehover.byType.scene.length > 0) { var s = { type: "background" }; this._handlers.mousehover.byType.scene.map(((t, i) => { t.handler(e, s, i) })) } if (this._handlers.mousehover.default.length > 0) { let t = this._raycaster.intersectObjects(this._scene.children, !0); if (t.length > 0) (a = t[0]).point && (e.clickX = a.point.x, e.clickY = a.point.y, e.clickZ = a.point.z), a.object.position, this._invoke(this._handlers.background.default, e), this._invoke(this._handlers.mousehover.default, e, a.object); else this._invoke(this._handlers.background.default, e) } } let t = [], r = [], l = [], c = [], h = [], u = [], d = [], p = [], f = []; o.forEach((e => { "landmark" !== this._getType(e) && "landmark图标" !== this._getType(e) && "landmark底图" !== this._getType(e) && "landmark文字" !== this._getType(e) || t.push(e), "bubble" !== this._getType(e) && "instancedbubble" !== this._getType(e) || r.push(e), "bar" === this._getType(e) && l.push(e), "odLine" === this._getType(e) && c.push(e), "trail" === this._getType(e) && h.push(e), "area" === this._getType(e) && u.push(e), this._judegDrawable(e) && d.push(e), this._judegDrawable(e) && "IconAsset" !== e.type || p.push(e), f.push(e) })); let m = null; if (d[0] && (m = d[0].object, m.instanceId = d[0].instanceId), !this._lastMouseHoverDrawable && m) this._handlers.mousehover.byType.drawable.map(((t, i) => { t.handler(e, m, i) })), this._lastMouseHoverDrawable = m; else if (this._lastMouseHoverDrawable && !m) this._handlers.unmousehover.byType.drawable.map(((t, i) => { t.handler(e, this._lastMouseHoverDrawable, i) })), this._lastMouseHoverDrawable = m; else if (this._lastMouseHoverDrawable && m && this._lastMouseHoverDrawable !== m) { let t = this._lastMouseHoverDrawable; this._lastMouseHoverDrawable = m, this._handlers.unmousehover.byType.drawable.map(((i, r) => { i.handler(e, t, r) })), this._handlers.mousehover.byType.drawable.map(((t, i) => { t.handler(e, m, i) })) } if (p.length > 0) { let t, i = _context.defaultObjectTree.findItemByObject3D(p[0].object) || {}; if ("ModelItem" === i.type) t = i; else if ("BuildingItem" === i.type) { let e = _context.defaultObjectTree.getParentIds(p[0].object) || {}; t = util$1.findObjectToFloor(e), t ? t.selectedType = "BuildingFloorItem" : (t = util$1.findObjectToBuilding(p[0].object.uuid), t.selectedType = "BuildingItem") } t && (this._handlers.unmousehover.byType.model.length > 0 && this._lastMouseHoverModel && t.name != this._lastMouseHoverModel.name && (this._handlers.unmousehover.byType.model.map(((t, i) => { t.handler(e, this._lastMouseHoverModel, i) })), this._handlers.unmousehover.byType.building.length <= 0 && (this._lastMouseHoverModel = null)), !this._lastMouseHoverModel || "BuildingItem" !== this._lastMouseHoverModel.type && "BuildingFloorItem" !== this._lastMouseHoverModel.type || this._handlers.unmousehover.byType.building.length > 0 && this._lastMouseHoverModel && t.name != this._lastMouseHoverModel.name && (this._handlers.unmousehover.byType.building.map(((t, i) => { t.handler(e, this._lastMouseHoverModel, i) })), this._lastMouseHoverModel = null), (null == this._lastMouseHoverModel || this._lastMouseHoverModel && this._lastMouseHoverModel.name != t.name) && (this._handlers.mousehover.byType.model.length > 0 && this._handlers.mousehover.byType.model.map(((i, r) => { i.handler(e, t, r) })), "BuildingItem" !== i.type && "BuildingFloorItem" !== t.type || this._handlers.mousehover.byType.building.length > 0 && this._handlers.mousehover.byType.building.map(((i, r) => { i.handler(e, t, r) }))), this._lastMouseHoverModel = t) } else this._lastMouseHoverModel && this._handlers.unmousehover.byType.model.length > 0 && this._handlers.unmousehover.byType.model.map(((t, i) => { t.handler(e, this._lastMouseHoverModel, i) })), this._lastMouseHoverModel && this._handlers.unmousehover.byType.building.length > 0 && this._handlers.unmousehover.byType.building.map(((t, i) => { t.handler(e, this._lastMouseHoverModel, i) })), this._lastMouseHoverModel = null; this._handlers.mousehover.byType.landmark.length > 0 && this._handlers.mousehover.byType.landmark.map(((i, r) => { t[0] && i.handler(e, t[0].object, r) })), this._handlers.mousehover.byType.bubble.length > 0 && this._handlers.mousehover.byType.bubble.map(((t, i) => { r[0] && t.handler(e, r[0].object, i) })), this._handlers.mousehover.byType.bar.length > 0 && this._handlers.mousehover.byType.bar.map(((t, i) => { l[0] && t.handler(e, l[0].object, i) })), this._handlers.mousehover.byType.odLine.length > 0 && this._handlers.mousehover.byType.odLine.map(((t, i) => { c[0] && t.handler(e, c[0].object, i) })), this._handlers.mousehover.byType.trail.length > 0 && this._handlers.mousehover.byType.trail.map(((t, i) => { h[0] && t.handler(e, h[0].object, i) })), this._handlers.mousehover.byType.area.length > 0 && this._handlers.mousehover.byType.area.map(((t, i) => { u[0] && t.handler(e, u[0].object, i) })), this._handlers.mousehover.byType.scene.length > 0 && this._handlers.mousehover.byType.scene.map(((t, i) => { t.handler(e, f[0].object, i) })) } else this._handlers.mousehover.byType.model.length > 0 && this._handlers.mousehover.byType.model.map((e => { e.handler(null) })), this._lastMouseHoverModel && this._handlers.unmousehover.byType.model.length > 0 && this._handlers.unmousehover.byType.model.map(((t, i) => { t.handler(e, this._lastMouseHoverModel, i) })), this._lastMouseHoverModel && this._handlers.unmousehover.byType.building.length > 0 && this._handlers.unmousehover.byType.building.map(((t, i) => { t.handler(e, this._lastMouseHoverModel, i) })), this._lastMouseHoverModel = null } onWheel(e) { this._handlers.camerazoom.default.length > 0 && this._invoke(this._handlers.camerazoom.default, e), this._handlers.camerazoomstop.default.length > 0 && (this._cameraStopTimeout && clearTimeout(this._cameraStopTimeout), this._cameraStopTimeout = setTimeout((() => { this._invoke(this._handlers.camerazoomstop.default, e) }), this._debounceDelay)), this._handlers.cameramove.default.length > 0 && this._handlers.cameramove.default.map((t => { t.handler(e) })) } trailmove(e) { this._handlers.trailmove.default.length > 0 && this._handlers.trailmove.default.map(((t, i) => { t.handler(e, i) })) } _invoke(e, t, i) { if (e.length > 0) for (let r of e) r.handler(t, i) } _xyzToLLA(e, t, i) { if (t.point) { let r = i.XYZToLLA({ x: t.point.x, y: t.point.y, z: t.point.z }, void 0); r && (e.clickX = t.point.x, e.clickY = t.point.y, e.clickZ = t.point.z, e.longitude = r.x, e.latitude = r.y, e.altitude = r.z, t.point.longitude = r.x, t.point.latitude = r.y, t.point.altitude = r.z) } if (t.object.position) { let e = i.XYZToLLA({ x: t.object.position.x, y: t.object.position.y, z: t.object.position.z }, void 0); e && (t.object.positionLla = { lon: e.x, lat: e.y, alt: e.z }) } return t } _coordinatePass(e, t) { t.clickX = e.point.x, t.clickY = e.point.y, t.clickZ = e.point.z, t.longitude = e.point.longitude, t.latitude = e.point.latitude, t.altitude = e.point.altitude } _getType(e) { let t = e.object.name, i = t.lastIndexOf("/"); if (-1 == i) { if (!(e.object.parent && e.object.parent.parent && e.object.parent.parent.name)) return t; if (t = e.object.parent.parent.name, i = t.lastIndexOf("/"), -1 == i) return t } return t.substring(i + 1) } _judegDrawable(e) { return "landmark图标" === this._getType(e) || "landmark底图" === this._getType(e) || "landmark文字" === this._getType(e) || "landmark" === this._getType(e) || "bubble" === this._getType(e) || "instancedbubble" === this._getType(e) || "bar" === this._getType(e) || "odline" === this._getType(e) || "trail" === this._getType(e) || "area" === this._getType(e) || "path" === this._getType(e) || "heatmap" === this._getType(e) || "3dmarker" === this._getType(e) || "modellandmark" === this._getType(e) || "modeltrail" === this._getType(e) || "markerlandmark" === this._getType(e) } dispose() { this._renderer && (this._renderer.renderLists && this._renderer.renderLists.dispose && this._renderer.renderLists.dispose(), this._renderer.renderLists = null, this._renderer.dispose && this._renderer.dispose()), this._renderer = null, this._scene = null, this._camera = null, this._raycaster = null, this._mouse = null, this._lastMouseHoverDrawable = null, this._lastMouseHoverModel = null } } var d2r = Math.PI / 180, r2d = 180 / Math.PI; function tileToBBOX(e) { var t = tile2lon(e[0] + 1, e[2]); return [tile2lon(e[0], e[2]), tile2lat(e[1] + 1, e[2]), t, tile2lat(e[1], e[2])] } function tileToGeoJSON(e) { var t = tileToBBOX(e); return { type: "Polygon", coordinates: [[[t[0], t[3]], [t[0], t[1]], [t[2], t[1]], [t[2], t[3]], [t[0], t[3]]]] } } function tile2lon(e, t) { return e / Math.pow(2, t) * 360 - 180 } function tile2lat(e, t) { var i = Math.PI - 2 * Math.PI * e / Math.pow(2, t); return r2d * Math.atan(.5 * (Math.exp(i) - Math.exp(-i))) } function pointToTile(e, t, i) { var r = pointToTileFraction(e, t, i); return r[0] = Math.floor(r[0]), r[1] = Math.floor(r[1]), r } function getChildren(e) { return [[2 * e[0], 2 * e[1], e[2] + 1], [2 * e[0] + 1, 2 * e[1], e[2] + 1], [2 * e[0] + 1, 2 * e[1] + 1, e[2] + 1], [2 * e[0], 2 * e[1] + 1, e[2] + 1]] } function getParent(e) { return [e[0] >> 1, e[1] >> 1, e[2] - 1] } function getSiblings(e) { return getChildren(getParent(e)) } function hasSiblings(e, t) { for (var i = getSiblings(e), r = 0; r < i.length; r++)if (!hasTile(t, i[r])) return !1; return !0 } function hasTile(e, t) { for (var i = 0; i < e.length; i++)if (tilesEqual(e[i], t)) return !0; return !1 } function tilesEqual(e, t) { return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] } function tileToQuadkey(e) { for (var t = "", i = e[2]; i > 0; i--) { var r = 0, n = 1 << i - 1; 0 != (e[0] & n) && r++, 0 != (e[1] & n) && (r += 2), t += r.toString() } return t } function quadkeyToTile(e) { for (var t = 0, i = 0, r = e.length, n = r; n > 0; n--) { var a = 1 << n - 1, o = +e[r - n]; 1 === o && (t |= a), 2 === o && (i |= a), 3 === o && (t |= a, i |= a) } return [t, i, r] } function bboxToTile(e) { var t = pointToTile(e[0], e[1], 32), i = pointToTile(e[2], e[3], 32), r = [t[0], t[1], i[0], i[1]], n = getBboxZoom(r); return 0 === n ? [0, 0, 0] : [r[0] >>> 32 - n, r[1] >>> 32 - n, n] } function getBboxZoom(e) { for (var t = 0; t < 28; t++) { var i = 1 << 32 - (t + 1); if ((e[0] & i) != (e[2] & i) || (e[1] & i) != (e[3] & i)) return t } return 28 } function pointToTileFraction(e, t, i) { var r = Math.sin(t * d2r), n = Math.pow(2, i), a = n * (e / 360 + .5); return (a %= n) < 0 && (a += n), [a, n * (.5 - .25 * Math.log((1 + r) / (1 - r)) / Math.PI), i] } var tilebelt = { tileToGeoJSON: tileToGeoJSON, tileToBBOX: tileToBBOX, getChildren: getChildren, getParent: getParent, getSiblings: getSiblings, hasTile: hasTile, hasSiblings: hasSiblings, tilesEqual: tilesEqual, tileToQuadkey: tileToQuadkey, quadkeyToTile: quadkeyToTile, pointToTile: pointToTile, bboxToTile: bboxToTile, pointToTileFraction: pointToTileFraction }; proj4.defs([["EPSG:3035", "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs"]]); class Geoproject { constructor() { this.projection = null, this.location = null, this.globalOffset = new Vector2, this.sceneScale = 1, this.center = new Vector2(0, 0), this.center3035 = new Vector2(0, 0), this.projector = null } setCurrentPlace(e) { this.location = [e.longitude, e.latitude], this.projection = "EPSG:3857"; const t = this.location[0], i = this.location[1]; this.projector = proj4(this.projection), this.center = this.project([t, i], !0), this.projector3035 = proj4("EPSG:3035"); var r = this.projector3035.forward([t, i]); this.center3035 = { x: r[0], y: r[1] }, this.sceneScale = this.calculateSceneScale(t, i), this.globalOffset = this.calculateGlobalOffset(t, i), _context.pgl.heightUniforms && _context.pgl.heightUniforms.update({ sceneScale: this.sceneScale, globalOffset: this.globalOffset }) } positionToTileFraction(e, t) { const i = e.clone(); return i.x -= this.globalOffset.x, i.y += this.globalOffset.y, i.divideScalar(this.sceneScale * Math.pow(2, 15 - t)), [i.x, i.y, t] } calculateGlobalOffset(e, t) { const [i, r, n] = tilebelt.pointToTileFraction(e, t, 7), a = Math.pow(2, 15 - n) * this.calculateSceneScale(e, t); return new Vector2(-i, r).multiplyScalar(a) } calculateSceneScale(e, t) { var i = tilebelt.pointToTile(e, t, 15), r = tilebelt.tileToBBOX(i); return this.project([r[2], r[3]]).sub(this.project([r[0], r[1]])).x } project(e, t) { if ("number" != typeof e[0]) return e.map((e => this.project(e, t))); var i = this.projector.forward(e); return t || (i[0] -= this.center.x, i[1] -= this.center.y), new Vector3(i[0], i[1], e[2]) } unproject(e, t) { if (Array.isArray(e)) return e.map((e => this.unproject(e, t))); var i = [e.x, e.y]; t || (i[0] += this.center.x, i[1] += this.center.y); var r = this.projector.inverse(i); return [r[0], r[1], e.z] } unproject3035(e, t) { if (Array.isArray(e[0])) return e.map((e => this.unproject3035(e, t))); var i = [e[0], e[1]]; t || (i[0] += this.center3035.x, i[1] += this.center3035.y); var r = this.projector3035.inverse(i); return [r[0], r[1], e.z] } vectorize(e) { if ("number" != typeof e[0]) { for (var t = new Array(e.length), i = 0, r = e.length; i < r; i++)t[i] = this.vectorize(e[i]); return t } return new Vector3(e[0], e[1], e[2]) } vectorizeFeature(e) { return e.projected ? this.vectorize(e.geometry.coordinates) : this.project(e.geometry.coordinates) } } let params$1 = new URLSearchParams(window.location.search.slice(1)), elevationPoolSize = 64, imageryPoolSize = 256; params$1.has("elevationPoolSize") && (elevationPoolSize = Number.parseInt(params$1.get("elevationPoolSize"))), params$1.has("imageryPoolSize") && (imageryPoolSize = Number.parseInt(params$1.get("imageryPoolSize"))); const ELEVATION_POOL_SIZE = elevationPoolSize, ELEVATION_TILE_SIZE = 512, IMAGERY_POOL_SIZE = imageryPoolSize, IMAGERY_TILE_SIZE = 256, INTERPOLATE_FLOAT = params$1.has("interpolateFloat"), PIXEL_ENCODING_NASADEM = "nasadem", PIXEL_ENCODING_TERRARIUM = "terrarium", PIXEL_ENCODING_TERRAIN_RGB = "terrain-rgb", PIXEL_ENCODING_GREYSCALE_RGBA$1 = "greyscale-rgba"; class IntegerPool { constructor(e) { this.capacity = e, this.index = 0, this.items = [] } next() { let e; return e = this.index >= this.capacity ? this.items.splice(0, 1)[0] : this.index++, this.items.push(e), e } tap(e) { let t = this.items.indexOf(e); -1 !== t && (this.items.splice(t, 1), this.items.push(e)) } } class RGBABuffer { constructor(e) { this.size = e, this.data = new Float32Array(4 * e * e) } set(e, t, i, r, n) { this.data[4 * e] = t, this.data[4 * e + 1] = i, this.data[4 * e + 2] = r, this.data[4 * e + 3] = n } fillRect(e, t, i, r, n, a, o) { if (t <= 0 || i <= 0) return; if (t === this.size || i === this.size) return void this.fill(r, n, a, o); this.set(e, r, n, a, o); for (let i = 1; i < t; i *= 2) { let r = e + i, n = Math.min(i, t - i); this.data.set(this.data.subarray(4 * e, 4 * (e + n)), 4 * r) } const s = this.data.subarray(4 * e, 4 * (e + t)); for (let t = 1; t < i; t++) { let i = e + this.size * t; this.data.set(s, 4 * i) } } fill(e, t, i, r) { this.set(0, e, t, i, r); for (let e = 1, t = this.size * this.size; e < t; e *= 2)this.data.set(this.data.subarray(0, 4 * e), 4 * e) } } const ImageLoader = "undefined" == typeof createImageBitmap ? ImageLoader$2 : ImageBitmapLoader; var ImageLoader$1 = new ImageLoader; const canvas = document.createElement("canvas"), width = ELEVATION_TILE_SIZE, height = ELEVATION_TILE_SIZE; canvas.width = width, canvas.height = height; const ctx = canvas.getContext("2d"), N = width * height, insertIntoTextureArray = (e, t, i) => { const r = e.image.width / e.__blocks, n = e.image.height / e.__blocks, a = r * (Math.floor(t) % e.__blocks), o = n * Math.floor(Math.floor(t) / e.__blocks); if (e.useFloat) { ctx.drawImage(i, 0, 0); let t = ctx.getImageData(0, 0, width, height).data, r = new Float32Array(N); if (e.pixelEncoding === PIXEL_ENCODING_NASADEM) { const e = -32768; let i = new DataView(t.buffer); for (let t = 0; t < N; ++t) { let n = i.getUint16(4 * t, !1) + e; r[t] = n === e ? 0 : n } } else { let i; e.pixelEncoding === PIXEL_ENCODING_TERRARIUM ? i = [256, 1, 1 / 256, -32768] : e.pixelEncoding === PIXEL_ENCODING_TERRAIN_RGB ? i = [6553.6, 25.6, .1, -1e4] : e.pixelEncoding === PIXEL_ENCODING_GREYSCALE_RGBA$1 && (i = [0, 0, 1e4 / 255 * 1, -1]); for (let e = 0; e < N; ++e) { let n = i[0] * t[4 * e] + i[1] * t[4 * e + 1] + i[2] * t[4 * e + 2] + i[3]; r[e] = n === i[3] ? 0 : n } } _context.renderer.copyTextureToTexture({ x: a, y: o }, { image: { data: r, width: width, height: height }, isDataTexture: !0 }, e) } else _context.renderer.copyTextureToTexture({ x: a, y: o }, { image: i }, e) }, drawOverlayTexture = (e, t, i) => { let r = handleGL(e), n = handleGL(t), a = new browser.PNG({ width: e.width, height: e.height, filterType: 4 }); for (let e = 0; e < a.data.length; e += 4)if (n[e + 3] > 0) { const t = n[e + 3] / 255; a.data[e + 0] = Math.round(r[e + 0] * (1 - t) + n[e + 0] * t), a.data[e + 1] = Math.round(r[e + 1] * (1 - t) + n[e + 1] * t), a.data[e + 2] = Math.round(r[e + 2] * (1 - t) + n[e + 2] * t), a.data[e + 3] = r[e + 3] } else a.data[e + 0] = r[e + 0], a.data[e + 1] = r[e + 1], a.data[e + 2] = r[e + 2], a.data[e + 3] = r[e + 3]; a.pack(); var o = browser.PNG.sync.write(a, { colorType: 6 }); const s = new Blob([o]); createImageBitmap(s).then(i) }; let canvas2 = document.createElement("canvas"), gl = canvas2.getContext("webgl2"); gl.activeTexture(gl.TEXTURE0); let texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); const framebuffer = gl.createFramebuffer(); function handleGL(e) { gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0), gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, e), gl.drawBuffers([gl.COLOR_ATTACHMENT0]); let t = new Uint8Array(e.width * e.height * 4); return gl.readPixels(0, 0, e.width, e.height, gl.RGBA, gl.UNSIGNED_BYTE, t), t } gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); class BaseDatasource { constructor({ apiKey: e, maxZoom: t, pixelEncoding: i, poolSize: r, textureSize: n, useFloat: a, urlFormat: o, disabled: s, flipY: l }) { this.apiKey = e, this.maxZoom = t, this.urlFormat = o, this.pixelEncoding = i, this.useFloat = !!a, this.hasUpdates = !1, this.listeners = [], this.lookup = {}, this.fetching = {}, this.overlayFetching = {}, this.imgCache = {}, this.imgOverlayCache = [], this.indexPool = new IntegerPool(r), this.disabled = s, this.flipY = l; let c = Math.sqrt(r); c % 1 && console.error("poolSize needs to be a power of 2"); let h = n * c; const u = this.useFloat && !INTERPOLATE_FLOAT ? NearestFilter : LinearFilter; this.textureArray = new DataTexture(null, h, h, this.useFloat ? RedFormat : RGBAFormat, this.useFloat ? FloatType : UnsignedByteType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, u, u, _context.renderer.capabilities.getMaxAnisotropy()), this.textureArray.__blocks = c; for (let e of ["pixelEncoding", "useFloat"]) Object.defineProperty(this.textureArray, e, { get: () => this[e] }); if (this.useFloat) { const e = 1024; this.indirectionData = new RGBABuffer(e), this.indirectionTexture = new DataTexture(null, e, e, RGBAFormat, FloatType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, NearestFilter, NearestFilter, 1) } } urlForTile(e, t, i) { if (this.urlFormat instanceof Array) { const r = []; for (let n of this.urlFormat) r.push(n.replace("{x}", e).replace("{y}", this.flipY ? Math.pow(2, i) - 1 - t : t).replace("{z}", i).replace("{apiKey}", this.apiKey)); return r } return this.urlFormat.replace("{x}", e).replace("{y}", this.flipY ? Math.pow(2, i) - 1 - t : t).replace("{z}", i).replace("{apiKey}", this.apiKey) } fetchIfNeeded(e) { if (void 0 !== this.lookup[e] || void 0 !== this.fetching[e]) return; if (Object.values(this.fetching).length > 32) return; let t = this.findNewIndex(e); if (this.fetching[e] = t, this.disabled) return void delete this.fetching[e]; let i = this.urlForTile(...tilebelt.quadkeyToTile(e)); i instanceof Array ? (_context.gisStore.checkAddress(i[0]), ImageLoader$1.load(i.shift(), (r => { this.imgCache[e] = r, insertIntoTextureArray(this.textureArray, t, r), delete this.fetching[e], this.lookup[e] = t, this.updateIndirectionTexture(), this.notifyUpdate(); for (let r in i) ImageLoader$1.load(i[r], (i => { this.imgOverlayCache[r] = this.imgOverlayCache[r] || {}, this.imgOverlayCache[r][e] = i, drawOverlayTexture(this.imgCache[e], this.imgOverlayCache[r][e], (i => { this.imgCache[e] = i, insertIntoTextureArray(this.textureArray, t, this.imgCache[e]), this.notifyUpdate() })) }), (() => { console.error("Failed to get image", e), delete this.fetching[e] })) }), (() => { console.error("Failed to get image", e), delete this.fetching[e] }))) : (_context.gisStore.checkAddress(i), ImageLoader$1.load(i, (i => { this.imgCache[e] = i, insertIntoTextureArray(this.textureArray, t, i), delete this.fetching[e], this.lookup[e] = t, this.updateIndirectionTexture(), this.notifyUpdate() }), (() => { console.error("Failed to get image", e), delete this.fetching[e] }))) } findNewIndex(e) { let t, i, r = Object.values(this.fetching), n = !0; for (let a = 32; a > 0; a--) { t = this.indexPool.next(); let a = -1 === r.indexOf(t), o = Object.values(this.lookup).indexOf(t); i = Object.keys(this.lookup)[o]; let s = void 0 !== i && e.slice(0, i.length - 1) === i.slice(0, -1); if (a && !s) { n = !1; break } } return n && (i = Object.keys(this.lookup).sort(((e, t) => e.length - t.length))[0], t = this.lookup[i]), void 0 !== i && delete this.lookup[i], t } updateIndirectionTexture() { if (this.indirectionTexture) { const e = this.indirectionData.size; let t, i = Object.keys(this.lookup); i.sort(((e, t) => Math.sign(e.length - t.length))); let r = { startX: e, endX: 0, startY: e, endY: 0 }; t = this.lastQuadkeys ? [...i.filter((e => !this.lastQuadkeys.includes(e))), ...this.lastQuadkeys.filter((e => !i.includes(e)))] : i, this.lastQuadkeys = [...i]; for (let i of t) { let [t, n, a] = tilebelt.quadkeyToTile(i), o = Math.pow(2, this.maxZoom - a); t *= o, n *= o; let s = t % e, l = n % e, c = s + o, h = l + o; r.startX = Math.min(r.startX, s), r.endX = Math.max(r.endX, c), r.startY = Math.min(r.startY, l), r.endY = Math.max(r.endY, h) } for (let t of i) { let [i, n, a] = tilebelt.quadkeyToTile(t), o = this.lookup[t], s = Math.pow(2, this.maxZoom - a); i *= s, n *= s; let l = this.maxZoom - 10, c = Math.pow(2, a - l), h = -c / e, u = i % e, d = n % e, p = u + s, f = d + s; u = Math.max(u, r.startX), d = Math.max(d, r.startY), p = Math.min(p, r.endX), f = Math.min(f, r.endY); let m = u + e * d, g = p - u, y = f - d; this.indirectionData.fillRect(m, g, y, o, c, i * h, n * h) } const n = r.endY - r.startY; let a = this.indirectionData.data.subarray(4 * e * r.startY, 4 * e * r.endY); _context.renderer.copyTextureToTexture({ x: 0, y: r.startY }, { image: { data: a, width: e, height: n }, isDataTexture: !0 }, this.indirectionTexture) } } findBestAvailableData(e, t) { for (let t = 0; t < 20; t++) { let i = this.lookup[e]; if (void 0 !== i) return { index: i, downsample: t, quadkey: e }; if (0 === (e = e.slice(0, -1)).length) break } return { index: null, downsample: 20, quadkey: null } } dataAtPoint(e) { let t; t = e.longitude ? tilebelt.pointToTileFraction(e.longitude, e.latitude, 10) : _context.pgl.geoproject.positionToTileFraction(e, 10); const i = tilebelt.tileToQuadkey(t), { quadkey: r } = this.findBestAvailableData(i); if (!r) return null; const n = Math.pow(2, r.length - t[2]); t[0] *= n, t[1] *= n; const a = this.imgCache[r], o = document.createElement("canvas"); o.width = 1, o.height = 1, t[0] = t[0] % 1 * a.width, t[1] = t[1] % 1 * a.height; const s = o.getContext("2d"); return s.drawImage(a, t[0], t[1], 1, 1, 0, 0, 1, 1), s.getImageData(0, 0, 1, 1).data } addListener(e) { this.listeners.push(e) } removeListener(e) { let t = this.listeners.indexOf(e); -1 !== t && this.listeners.splice(t, 1) } notifyUpdate() { this.hasUpdates = !0 } broadcastUpdate() { this.listeners.forEach((e => e())), this.hasUpdates = !1 } }
/**
   * @license
   * lodash 3.10.1 (Custom Build) <https://lodash.com/>
   * Build: `lodash modern -d -o ./index.js`
   * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   * Available under MIT license <https://lodash.com/license>
   */var lodash = createCommonjsModule((function (e, t) { (function () { var i, r, n, a = 32, o = 64, s = 128, l = 256, c = 200, h = "Expected a function", u = "__lodash_placeholder__", d = "[object Arguments]", p = "[object Array]", f = "[object Boolean]", m = "[object Date]", g = "[object Error]", y = "[object Function]", v = "[object Map]", _ = "[object Number]", b = "[object Object]", x = "[object RegExp]", w = "[object Set]", S = "[object String]", M = "[object WeakMap]", T = "[object ArrayBuffer]", A = "[object Float32Array]", E = "[object Float64Array]", C = "[object Int8Array]", L = "[object Int16Array]", R = "[object Int32Array]", D = "[object Uint8Array]", P = "[object Uint8ClampedArray]", O = "[object Uint16Array]", I = "[object Uint32Array]", k = /\b__p \+= '';/g, B = /\b(__p \+=) '' \+/g, N = /(__e\(.*?\)|\b__t\)) \+\n'';/g, F = /&(?:amp|lt|gt|quot|#39|#96);/g, U = /[&<>"'`]/g, z = RegExp(F.source), G = RegExp(U.source), H = /<%-([\s\S]+?)%>/g, V = /<%([\s\S]+?)%>/g, j = /<%=([\s\S]+?)%>/g, W = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/, $ = /^\w*$/, Y = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g, X = /^[:!,]|[\\^$.*+?()[\]{}|\/]|(^[0-9a-fA-Fnrtuvx])|([\n\r\u2028\u2029])/g, Z = RegExp(X.source), q = /[\u0300-\u036f\ufe20-\ufe23]/g, J = /\\(\\)?/g, K = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Q = /\w*$/, ee = /^0[xX]/, te = /^\[object .+?Constructor\]$/, ie = /^\d+$/, re = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g, ne = /($^)/, ae = /['\n\r\u2028\u2029\\]/g, oe = (r = "[A-Z\\xc0-\\xd6\\xd8-\\xde]", n = "[a-z\\xdf-\\xf6\\xf8-\\xff]+", RegExp(r + "+(?=" + r + n + ")|" + r + "?" + n + "|" + r + "+|[0-9]+", "g")), se = ["Array", "ArrayBuffer", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Math", "Number", "Object", "RegExp", "Set", "String", "_", "clearTimeout", "isFinite", "parseFloat", "parseInt", "setTimeout", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap"], le = -1, ce = {}; ce[A] = ce[E] = ce[C] = ce[L] = ce[R] = ce[D] = ce[P] = ce[O] = ce[I] = !0, ce[d] = ce[p] = ce[T] = ce[f] = ce[m] = ce[g] = ce[y] = ce[v] = ce[_] = ce[b] = ce[x] = ce[w] = ce[S] = ce[M] = !1; var he = {}; he[d] = he[p] = he[T] = he[f] = he[m] = he[A] = he[E] = he[C] = he[L] = he[R] = he[_] = he[b] = he[x] = he[S] = he[D] = he[P] = he[O] = he[I] = !0, he[g] = he[y] = he[v] = he[w] = he[M] = !1; var ue = { "À": "A", "Á": "A", "Â": "A", "Ã": "A", "Ä": "A", "Å": "A", "à": "a", "á": "a", "â": "a", "ã": "a", "ä": "a", "å": "a", "Ç": "C", "ç": "c", "Ð": "D", "ð": "d", "È": "E", "É": "E", "Ê": "E", "Ë": "E", "è": "e", "é": "e", "ê": "e", "ë": "e", "Ì": "I", "Í": "I", "Î": "I", "Ï": "I", "ì": "i", "í": "i", "î": "i", "ï": "i", "Ñ": "N", "ñ": "n", "Ò": "O", "Ó": "O", "Ô": "O", "Õ": "O", "Ö": "O", "Ø": "O", "ò": "o", "ó": "o", "ô": "o", "õ": "o", "ö": "o", "ø": "o", "Ù": "U", "Ú": "U", "Û": "U", "Ü": "U", "ù": "u", "ú": "u", "û": "u", "ü": "u", "Ý": "Y", "ý": "y", "ÿ": "y", "Æ": "Ae", "æ": "ae", "Þ": "Th", "þ": "th", "ß": "ss" }, de = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "`": "&#96;" }, pe = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'", "&#96;": "`" }, fe = { function: !0, object: !0 }, me = { 0: "x30", 1: "x31", 2: "x32", 3: "x33", 4: "x34", 5: "x35", 6: "x36", 7: "x37", 8: "x38", 9: "x39", A: "x41", B: "x42", C: "x43", D: "x44", E: "x45", F: "x46", a: "x61", b: "x62", c: "x63", d: "x64", e: "x65", f: "x66", n: "x6e", r: "x72", t: "x74", u: "x75", v: "x76", x: "x78" }, ge = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, ye = t && !t.nodeType && t, ve = e && !e.nodeType && e, _e = ye && ve && "object" == typeof commonjsGlobal && commonjsGlobal && commonjsGlobal.Object && commonjsGlobal, be = fe[typeof self] && self && self.Object && self, xe = fe[typeof window] && window && window.Object && window, we = ve && ve.exports === ye && ye, Se = _e || xe !== (this && this.window) && xe || be || this; function Me(e, t) { if (e !== t) { var r = null === e, n = e === i, a = e == e, o = null === t, s = t === i, l = t == t; if (e > t && !o || !a || r && !s && l || n && l) return 1; if (e < t && !r || !l || o && !n && a || s && a) return -1 } return 0 } function Te(e, t, i) { for (var r = e.length, n = i ? r : -1; i ? n-- : ++n < r;)if (t(e[n], n, e)) return n; return -1 } function Ae(e, t, i) { if (t != t) return Be(e, i); for (var r = i - 1, n = e.length; ++r < n;)if (e[r] === t) return r; return -1 } function Ee(e) { return "function" == typeof e || !1 } function Ce(e) { return null == e ? "" : e + "" } function Le(e, t) { for (var i = -1, r = e.length; ++i < r && t.indexOf(e.charAt(i)) > -1;); return i } function Re(e, t) { for (var i = e.length; i-- && t.indexOf(e.charAt(i)) > -1;); return i } function De(e, t) { return Me(e.criteria, t.criteria) || e.index - t.index } function Pe(e) { return ue[e] } function Oe(e) { return de[e] } function Ie(e, t, i) { return t ? e = me[e] : i && (e = ge[e]), "\\" + e } function ke(e) { return "\\" + ge[e] } function Be(e, t, i) { for (var r = e.length, n = t + (i ? 0 : -1); i ? n-- : ++n < r;) { var a = e[n]; if (a != a) return n } return -1 } function Ne(e) { return !!e && "object" == typeof e } function Fe(e) { return e <= 160 && e >= 9 && e <= 13 || 32 == e || 160 == e || 5760 == e || 6158 == e || e >= 8192 && (e <= 8202 || 8232 == e || 8233 == e || 8239 == e || 8287 == e || 12288 == e || 65279 == e) } function Ue(e, t) { for (var i = -1, r = e.length, n = -1, a = []; ++i < r;)e[i] === t && (e[i] = u, a[++n] = i); return a } function ze(e) { for (var t = -1, i = e.length; ++t < i && Fe(e.charCodeAt(t));); return t } function Ge(e) { for (var t = e.length; t-- && Fe(e.charCodeAt(t));); return t } function He(e) { return pe[e] } var Ve = function e(t) { var r = (t = t ? Ve.defaults(Se.Object(), t, Ve.pick(Se, se)) : Se).Array, n = t.Date, v = t.Error, w = t.Function, M = t.Math, ue = t.Number, de = t.Object, pe = t.RegExp, fe = t.String, me = t.TypeError, ge = r.prototype, ye = de.prototype, ve = fe.prototype, _e = w.prototype.toString, be = ye.hasOwnProperty, xe = 0, we = ye.toString, Fe = Se._, je = pe("^" + _e.call(be).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), We = t.ArrayBuffer, $e = t.clearTimeout, Ye = t.parseFloat, Xe = M.pow, Ze = ye.propertyIsEnumerable, qe = sr(t, "Set"), Je = t.setTimeout, Ke = ge.splice, Qe = t.Uint8Array, et = sr(t, "WeakMap"), tt = M.ceil, it = sr(de, "create"), rt = M.floor, nt = sr(r, "isArray"), at = t.isFinite, ot = sr(de, "keys"), st = M.max, lt = M.min, ct = sr(n, "now"), ht = t.parseInt, ut = M.random, dt = ue.NEGATIVE_INFINITY, pt = ue.POSITIVE_INFINITY, ft = 4294967295, mt = 9007199254740991, gt = et && new et, yt = {}; function vt(e) { if (Ne(e) && !Nn(e) && !(e instanceof xt)) { if (e instanceof bt) return e; if (be.call(e, "__chain__") && be.call(e, "__wrapped__")) return Ar(e) } return new bt(e) } function _t() { } function bt(e, t, i) { this.__wrapped__ = e, this.__actions__ = i || [], this.__chain__ = !!t } function xt(e) { this.__wrapped__ = e, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = pt, this.__views__ = [] } function wt() { this.__data__ = {} } function St(e) { var t = e ? e.length : 0; for (this.data = { hash: it(null), set: new qe }; t--;)this.push(e[t]) } function Mt(e, t) { var i = e.data; return ("string" == typeof t || Gn(t) ? i.set.has(t) : i.hash[t]) ? 0 : -1 } function Tt(e, t) { var i = -1, n = e.length; for (t || (t = r(n)); ++i < n;)t[i] = e[i]; return t } function At(e, t) { for (var i = -1, r = e.length; ++i < r && !1 !== t(e[i], i, e);); return e } function Et(e, t) { for (var i = -1, r = e.length; ++i < r;)if (!t(e[i], i, e)) return !1; return !0 } function Ct(e, t) { for (var i = -1, r = e.length, n = -1, a = []; ++i < r;) { var o = e[i]; t(o, i, e) && (a[++n] = o) } return a } function Lt(e, t) { for (var i = -1, n = e.length, a = r(n); ++i < n;)a[i] = t(e[i], i, e); return a } function Rt(e, t) { for (var i = -1, r = t.length, n = e.length; ++i < r;)e[n + i] = t[i]; return e } function Dt(e, t, i, r) { var n = -1, a = e.length; for (r && a && (i = e[++n]); ++n < a;)i = t(i, e[n], n, e); return i } function Pt(e, t) { for (var i = -1, r = e.length; ++i < r;)if (t(e[i], i, e)) return !0; return !1 } function Ot(e, t, r, n) { return e !== i && be.call(n, r) ? e : t } function It(e, t, r) { for (var n = -1, a = la(t), o = a.length; ++n < o;) { var s = a[n], l = e[s], c = r(l, t[s], s, e, t); ((c == c ? c !== l : l == l) || l === i && !(s in e)) && (e[s] = c) } return e } function kt(e, t) { return null == t ? e : Nt(t, la(t), e) } function Bt(e, t) { for (var n = -1, a = null == e, o = !a && cr(e), s = o ? e.length : 0, l = t.length, c = r(l); ++n < l;) { var h = t[n]; c[n] = o ? hr(h, s) ? e[h] : i : a ? i : e[h] } return c } function Nt(e, t, i) { i || (i = {}); for (var r = -1, n = t.length; ++r < n;) { var a = t[r]; i[a] = e[a] } return i } function Ft(e, t, r) { var n = typeof e; return "function" == n ? t === i ? e : wi(e, t, r) : null == e ? Ca : "object" == n ? ai(e) : t === i ? Ia(e) : oi(e, t) } function Ut(e, t, r, n, a, o, s) { var l; if (r && (l = a ? r(e, n, a) : r(e)), l !== i) return l; if (!Gn(e)) return e; var c = Nn(e); if (c) { if (l = function (e) { var t = e.length, i = new e.constructor(t); t && "string" == typeof e[0] && be.call(e, "index") && (i.index = e.index, i.input = e.input); return i }(e), !t) return Tt(e, l) } else { var h = we.call(e), u = h == y; if (h != b && h != d && (!u || a)) return he[h] ? function (e, t, i) { var r = e.constructor; switch (t) { case T: return Si(e); case f: case m: return new r(+e); case A: case E: case C: case L: case R: case D: case P: case O: case I: var n = e.buffer; return new r(i ? Si(n) : n, e.byteOffset, e.length); case _: case S: return new r(e); case x: var a = new r(e.source, Q.exec(e)); a.lastIndex = e.lastIndex }return a }(e, h, t) : a ? e : {}; if (l = function (e) { var t = e.constructor; "function" == typeof t && t instanceof t || (t = de); return new t }(u ? {} : e), !t) return kt(l, e) } o || (o = []), s || (s = []); for (var p = o.length; p--;)if (o[p] == e) return s[p]; return o.push(e), s.push(l), (c ? At : Kt)(e, (function (i, n) { l[n] = Ut(i, t, r, n, e, o, s) })), l } vt.support = {}, vt.templateSettings = { escape: H, evaluate: V, interpolate: j, variable: "", imports: { _: vt } }; var zt = function () { function e() { } return function (t) { if (Gn(t)) { e.prototype = t; var r = new e; e.prototype = i } return r || {} } }(); function Gt(e, t, r) { if ("function" != typeof e) throw new me(h); return Je((function () { e.apply(i, r) }), t) } function Ht(e, t) { var i = e ? e.length : 0, r = []; if (!i) return r; var n = -1, a = nr(), o = a == Ae, s = o && t.length >= c ? Ri(t) : null, l = t.length; s && (a = Mt, o = !1, t = s); e: for (; ++n < i;) { var h = e[n]; if (o && h == h) { for (var u = l; u--;)if (t[u] === h) continue e; r.push(h) } else a(t, h, 0) < 0 && r.push(h) } return r } var Vt = Ci(Kt), jt = Ci(Qt, !0); function Wt(e, t) { var i = !0; return Vt(e, (function (e, r, n) { return i = !!t(e, r, n) })), i } function $t(e, t) { var i = []; return Vt(e, (function (e, r, n) { t(e, r, n) && i.push(e) })), i } function Yt(e, t, i, r) { var n; return i(e, (function (e, i, a) { if (t(e, i, a)) return n = r ? i : e, !1 })), n } function Xt(e, t, i, r) { r || (r = []); for (var n = -1, a = e.length; ++n < a;) { var o = e[n]; Ne(o) && cr(o) && (i || Nn(o) || Bn(o)) ? t ? Xt(o, t, i, r) : Rt(r, o) : i || (r[r.length] = o) } return r } var Zt = Li(), qt = Li(!0); function Jt(e, t) { return Zt(e, t, ca) } function Kt(e, t) { return Zt(e, t, la) } function Qt(e, t) { return qt(e, t, la) } function ei(e, t) { for (var i = -1, r = t.length, n = -1, a = []; ++i < r;) { var o = t[i]; zn(e[o]) && (a[++n] = o) } return a } function ti(e, t, r) { if (null != e) { r !== i && r in Mr(e) && (t = [r]); for (var n = 0, a = t.length; null != e && n < a;)e = e[t[n++]]; return n && n == a ? e : i } } function ii(e, t, i, r, n, a) { return e === t || (null == e || null == t || !Gn(e) && !Ne(t) ? e != e && t != t : function (e, t, i, r, n, a, o) { var s = Nn(e), l = Nn(t), c = p, h = p; s || ((c = we.call(e)) == d ? c = b : c != b && (s = Yn(e))); l || ((h = we.call(t)) == d ? h = b : h != b && (l = Yn(t))); var u = c == b, y = h == b, v = c == h; if (v && !s && !u) return function (e, t, i) { switch (i) { case f: case m: return +e == +t; case g: return e.name == t.name && e.message == t.message; case _: return e != +e ? t != +t : e == +t; case x: case S: return e == t + "" }return !1 }(e, t, c); if (!n) { var w = u && be.call(e, "__wrapped__"), M = y && be.call(t, "__wrapped__"); if (w || M) return i(w ? e.value() : e, M ? t.value() : t, r, n, a, o) } if (!v) return !1; a || (a = []), o || (o = []); var T = a.length; for (; T--;)if (a[T] == e) return o[T] == t; a.push(e), o.push(t); var A = (s ? Qi : er)(e, t, i, r, n, a, o); return a.pop(), o.pop(), A }(e, t, ii, i, r, n, a)) } function ri(e, t, r) { var n = t.length, a = n, o = !r; if (null == e) return !a; for (e = Mr(e); n--;) { var s = t[n]; if (o && s[2] ? s[1] !== e[s[0]] : !(s[0] in e)) return !1 } for (; ++n < a;) { var l = (s = t[n])[0], c = e[l], h = s[1]; if (o && s[2]) { if (c === i && !(l in e)) return !1 } else { var u = r ? r(c, h, l) : i; if (!(u === i ? ii(h, c, r, !0) : u)) return !1 } } return !0 } function ni(e, t) { var i = -1, n = cr(e) ? r(e.length) : []; return Vt(e, (function (e, r, a) { n[++i] = t(e, r, a) })), n } function ai(e) { var t = or(e); if (1 == t.length && t[0][2]) { var r = t[0][0], n = t[0][1]; return function (e) { return null != e && (e[r] === n && (n !== i || r in Mr(e))) } } return function (e) { return ri(e, t) } } function oi(e, t) { var r = Nn(e), n = dr(e) && mr(t), a = e + ""; return e = Tr(e), function (o) { if (null == o) return !1; var s = a; if (o = Mr(o), (r || !n) && !(s in o)) { if (null == (o = 1 == e.length ? o : ti(o, di(e, 0, -1)))) return !1; s = kr(e), o = Mr(o) } return o[s] === t ? t !== i || s in o : ii(t, o[s], i, !0) } } function si(e) { return function (t) { return null == t ? i : t[e] } } function li(e, t) { for (var i = e ? t.length : 0; i--;) { var r = t[i]; if (r != n && hr(r)) { var n = r; Ke.call(e, r, 1) } } return e } function ci(e, t) { return e + rt(ut() * (t - e + 1)) } function hi(e, t, i, r, n) { return n(e, (function (e, n, a) { i = r ? (r = !1, e) : t(i, e, n, a) })), i } var ui = gt ? function (e, t) { return gt.set(e, t), e } : Ca; function di(e, t, n) { var a = -1, o = e.length; (t = null == t ? 0 : +t || 0) < 0 && (t = -t > o ? 0 : o + t), (n = n === i || n > o ? o : +n || 0) < 0 && (n += o), o = t > n ? 0 : n - t >>> 0, t >>>= 0; for (var s = r(o); ++a < o;)s[a] = e[a + t]; return s } function pi(e, t) { var i; return Vt(e, (function (e, r, n) { return !(i = t(e, r, n)) })), !!i } function fi(e, t) { var i = e.length; for (e.sort(t); i--;)e[i] = e[i].value; return e } function mi(e, t, i) { var r = tr(), n = -1; return t = Lt(t, (function (e) { return r(e) })), fi(ni(e, (function (e) { return { criteria: Lt(t, (function (t) { return t(e) })), index: ++n, value: e } })), (function (e, t) { return function (e, t, i) { for (var r = -1, n = e.criteria, a = t.criteria, o = n.length, s = i.length; ++r < o;) { var l = Me(n[r], a[r]); if (l) { if (r >= s) return l; var c = i[r]; return l * ("asc" === c || !0 === c ? 1 : -1) } } return e.index - t.index }(e, t, i) })) } function gi(e, t) { var i = -1, r = nr(), n = e.length, a = r == Ae, o = a && n >= c, s = o ? Ri() : null, l = []; s ? (r = Mt, a = !1) : (o = !1, s = t ? [] : l); e: for (; ++i < n;) { var h = e[i], u = t ? t(h, i, e) : h; if (a && h == h) { for (var d = s.length; d--;)if (s[d] === u) continue e; t && s.push(u), l.push(h) } else r(s, u, 0) < 0 && ((t || o) && s.push(u), l.push(h)) } return l } function yi(e, t) { for (var i = -1, n = t.length, a = r(n); ++i < n;)a[i] = e[t[i]]; return a } function vi(e, t, i, r) { for (var n = e.length, a = r ? n : -1; (r ? a-- : ++a < n) && t(e[a], a, e);); return i ? di(e, r ? 0 : a, r ? a + 1 : n) : di(e, r ? a + 1 : 0, r ? n : a) } function _i(e, t) { var i = e; i instanceof xt && (i = i.value()); for (var r = -1, n = t.length; ++r < n;) { var a = t[r]; i = a.func.apply(a.thisArg, Rt([i], a.args)) } return i } function bi(e, t, i) { var r = 0, n = e ? e.length : r; if ("number" == typeof t && t == t && n <= 2147483647) { for (; r < n;) { var a = r + n >>> 1, o = e[a]; (i ? o <= t : o < t) && null !== o ? r = a + 1 : n = a } return n } return xi(e, t, Ca, i) } function xi(e, t, r, n) { t = r(t); for (var a = 0, o = e ? e.length : 0, s = t != t, l = null === t, c = t === i; a < o;) { var h = rt((a + o) / 2), u = r(e[h]), d = u !== i, p = u == u; if (s) var f = p || n; else f = l ? p && d && (n || null != u) : c ? p && (n || d) : null != u && (n ? u <= t : u < t); f ? a = h + 1 : o = h } return lt(o, 4294967294) } function wi(e, t, r) { if ("function" != typeof e) return Ca; if (t === i) return e; switch (r) { case 1: return function (i) { return e.call(t, i) }; case 3: return function (i, r, n) { return e.call(t, i, r, n) }; case 4: return function (i, r, n, a) { return e.call(t, i, r, n, a) }; case 5: return function (i, r, n, a, o) { return e.call(t, i, r, n, a, o) } }return function () { return e.apply(t, arguments) } } function Si(e) { var t = new We(e.byteLength); return new Qe(t).set(new Qe(e)), t } function Mi(e, t, i) { for (var n = i.length, a = -1, o = st(e.length - n, 0), s = -1, l = t.length, c = r(l + o); ++s < l;)c[s] = t[s]; for (; ++a < n;)c[i[a]] = e[a]; for (; o--;)c[s++] = e[a++]; return c } function Ti(e, t, i) { for (var n = -1, a = i.length, o = -1, s = st(e.length - a, 0), l = -1, c = t.length, h = r(s + c); ++o < s;)h[o] = e[o]; for (var u = o; ++l < c;)h[u + l] = t[l]; for (; ++n < a;)h[u + i[n]] = e[o++]; return h } function Ai(e, t) { return function (i, r, n) { var a = t ? t() : {}; if (r = tr(r, n, 3), Nn(i)) for (var o = -1, s = i.length; ++o < s;) { var l = i[o]; e(a, l, r(l, o, i), i) } else Vt(i, (function (t, i, n) { e(a, t, r(t, i, n), n) })); return a } } function Ei(e) { return In((function (t, r) { var n = -1, a = null == t ? 0 : r.length, o = a > 2 ? r[a - 2] : i, s = a > 2 ? r[2] : i, l = a > 1 ? r[a - 1] : i; for ("function" == typeof o ? (o = wi(o, l, 5), a -= 2) : a -= (o = "function" == typeof l ? l : i) ? 1 : 0, s && ur(r[0], r[1], s) && (o = a < 3 ? i : o, a = 1); ++n < a;) { var c = r[n]; c && e(t, c, o) } return t })) } function Ci(e, t) { return function (i, r) { var n = i ? ar(i) : 0; if (!fr(n)) return e(i, r); for (var a = t ? n : -1, o = Mr(i); (t ? a-- : ++a < n) && !1 !== r(o[a], a, o);); return i } } function Li(e) { return function (t, i, r) { for (var n = Mr(t), a = r(t), o = a.length, s = e ? o : -1; e ? s-- : ++s < o;) { var l = a[s]; if (!1 === i(n[l], l, n)) break } return t } } function Ri(e) { return it && qe ? new St(e) : null } function Di(e) { return function (t) { for (var i = -1, r = Ta(ya(t)), n = r.length, a = ""; ++i < n;)a = e(a, r[i], i); return a } } function Pi(e) { return function () { var t = arguments; switch (t.length) { case 0: return new e; case 1: return new e(t[0]); case 2: return new e(t[0], t[1]); case 3: return new e(t[0], t[1], t[2]); case 4: return new e(t[0], t[1], t[2], t[3]); case 5: return new e(t[0], t[1], t[2], t[3], t[4]); case 6: return new e(t[0], t[1], t[2], t[3], t[4], t[5]); case 7: return new e(t[0], t[1], t[2], t[3], t[4], t[5], t[6]) }var i = zt(e.prototype), r = e.apply(i, t); return Gn(r) ? r : i } } function Oi(e) { return function t(r, n, a) { a && ur(r, n, a) && (n = i); var o = Ki(r, e, i, i, i, i, i, n); return o.placeholder = t.placeholder, o } } function Ii(e, t) { return In((function (r) { var n = r[0]; return null == n ? n : (r.push(t), e.apply(i, r)) })) } function ki(e, t) { return function (r, n, a) { if (a && ur(r, n, a) && (n = i), 1 == (n = tr(n, a, 3)).length) { var o = function (e, t, i, r) { for (var n = -1, a = e.length, o = r, s = o; ++n < a;) { var l = e[n], c = +t(l); i(c, o) && (o = c, s = l) } return s }(r = Nn(r) ? r : Sr(r), n, e, t); if (!r.length || o !== t) return o } return function (e, t, i, r) { var n = r, a = n; return Vt(e, (function (e, o, s) { var l = +t(e, o, s); (i(l, n) || l === r && l === a) && (n = l, a = e) })), a }(r, n, e, t) } } function Bi(e, t) { return function (r, n, a) { if (n = tr(n, a, 3), Nn(r)) { var o = Te(r, n, t); return o > -1 ? r[o] : i } return Yt(r, n, e) } } function Ni(e) { return function (t, i, r) { return t && t.length ? Te(t, i = tr(i, r, 3), e) : -1 } } function Fi(e) { return function (t, i, r) { return Yt(t, i = tr(i, r, 3), e, !0) } } function Ui(e) { return function () { for (var t, n = arguments.length, a = e ? n : -1, o = 0, s = r(n); e ? a-- : ++a < n;) { var l = s[o++] = arguments[a]; if ("function" != typeof l) throw new me(h); !t && bt.prototype.thru && "wrapper" == rr(l) && (t = new bt([], !0)) } for (a = t ? -1 : n; ++a < n;) { var u = rr(l = s[a]), d = "wrapper" == u ? ir(l) : i; t = d && pr(d[0]) && 424 == d[1] && !d[4].length && 1 == d[9] ? t[rr(d[0])].apply(t, d[3]) : 1 == l.length && pr(l) ? t[u]() : t.thru(l) } return function () { var e = arguments, i = e[0]; if (t && 1 == e.length && Nn(i) && i.length >= c) return t.plant(i).value(); for (var r = 0, a = n ? s[r].apply(this, e) : i; ++r < n;)a = s[r].call(this, a); return a } } } function zi(e, t) { return function (r, n, a) { return "function" == typeof n && a === i && Nn(r) ? e(r, n) : t(r, wi(n, a, 3)) } } function Gi(e) { return function (t, r, n) { return "function" == typeof r && n === i || (r = wi(r, n, 3)), e(t, r, ca) } } function Hi(e) { return function (t, r, n) { return "function" == typeof r && n === i || (r = wi(r, n, 3)), e(t, r) } } function Vi(e) { return function (t, i, r) { var n = {}; return i = tr(i, r, 3), Kt(t, (function (t, r, a) { var o = i(t, r, a); t = e ? t : o, n[r = e ? o : r] = t })), n } } function ji(e) { return function (t, i, r) { return t = Ce(t), (e ? t : "") + Xi(t, i, r) + (e ? "" : t) } } function Wi(e) { var t = In((function (r, n) { var a = Ue(n, t.placeholder); return Ki(r, e, i, n, a) })); return t } function $i(e, t) { return function (r, n, a, o) { var s = arguments.length < 3; return "function" == typeof n && o === i && Nn(r) ? e(r, n, a, s) : hi(r, tr(n, o, 4), a, s, t) } } function Yi(e, t, n, l, c, h, u, d, p, f) { var m = t & s, g = 1 & t, y = 2 & t, v = 8 & t, _ = 4 & t, b = 16 & t, x = y ? i : Pi(e); return function s() { for (var w = arguments.length, S = w, M = r(w); S--;)M[S] = arguments[S]; if (l && (M = Mi(M, l, c)), h && (M = Ti(M, h, u)), v || b) { var T = s.placeholder, A = Ue(M, T); if ((w -= A.length) < f) { var E = d ? Tt(d) : i, C = st(f - w, 0), L = v ? A : i, R = v ? i : A, D = v ? M : i, P = v ? i : M; t |= v ? a : o, t &= ~(v ? o : a), _ || (t &= -4); var O = [e, t, n, D, L, P, R, E, p, C], I = Yi.apply(i, O); return pr(e) && xr(I, O), I.placeholder = T, I } } var k = g ? n : this, B = y ? k[e] : e; return d && (M = vr(M, d)), m && p < M.length && (M.length = p), this && this !== Se && this instanceof s && (B = x || Pi(e)), B.apply(k, M) } } function Xi(e, t, i) { var r = e.length; if (r >= (t = +t) || !at(t)) return ""; var n = t - r; return xa(i = null == i ? " " : i + "", tt(n / i.length)).slice(0, n) } function Zi(e, t, i, n) { var a = 1 & t, o = Pi(e); return function t() { for (var s = -1, l = arguments.length, c = -1, h = n.length, u = r(h + l); ++c < h;)u[c] = n[c]; for (; l--;)u[c++] = arguments[++s]; var d = this && this !== Se && this instanceof t ? o : e; return d.apply(a ? i : this, u) } } function qi(e) { var t = M[e]; return function (e, r) { return (r = r === i ? 0 : +r || 0) ? (r = Xe(10, r), t(e * r) / r) : t(e) } } function Ji(e) { return function (t, i, r, n) { var a = tr(r); return null == r && a === Ft ? bi(t, i, e) : xi(t, i, a(r, n, 1), e) } } function Ki(e, t, r, n, c, d, p, f) { var m = 2 & t; if (!m && "function" != typeof e) throw new me(h); var g = n ? n.length : 0; if (g || (t &= -97, n = c = i), g -= c ? c.length : 0, t & o) { var y = n, v = c; n = c = i } var _ = m ? i : ir(e), b = [e, t, r, n, c, y, v, d, p, f]; if (_ && (!function (e, t) { var i = e[1], r = t[1], n = i | r, a = n < s, o = r == s && 8 == i || r == s && i == l && e[7].length <= t[8] || 384 == r && 8 == i; if (!a && !o) return e; 1 & r && (e[2] = t[2], n |= 1 & i ? 0 : 4); var c = t[3]; if (c) { var h = e[3]; e[3] = h ? Mi(h, c, t[4]) : Tt(c), e[4] = h ? Ue(e[3], u) : Tt(t[4]) } (c = t[5]) && (h = e[5], e[5] = h ? Ti(h, c, t[6]) : Tt(c), e[6] = h ? Ue(e[5], u) : Tt(t[6])); (c = t[7]) && (e[7] = Tt(c)); r & s && (e[8] = null == e[8] ? t[8] : lt(e[8], t[8])); null == e[9] && (e[9] = t[9]); e[0] = t[0], e[1] = n }(b, _), t = b[1], f = b[9]), b[9] = null == f ? m ? 0 : e.length : st(f - g, 0) || 0, 1 == t) var x = function (e, t) { var i = Pi(e); return function r() { return (this && this !== Se && this instanceof r ? i : e).apply(t, arguments) } }(b[0], b[2]); else x = t != a && 33 != t || b[4].length ? Yi.apply(i, b) : Zi.apply(i, b); return (_ ? ui : xr)(x, b) } function Qi(e, t, r, n, a, o, s) { var l = -1, c = e.length, h = t.length; if (c != h && !(a && h > c)) return !1; for (; ++l < c;) { var u = e[l], d = t[l], p = n ? n(a ? d : u, a ? u : d, l) : i; if (p !== i) { if (p) continue; return !1 } if (a) { if (!Pt(t, (function (e) { return u === e || r(u, e, n, a, o, s) }))) return !1 } else if (u !== d && !r(u, d, n, a, o, s)) return !1 } return !0 } function er(e, t, r, n, a, o, s) { var l = la(e), c = l.length; if (c != la(t).length && !a) return !1; for (var h = c; h--;) { var u = l[h]; if (!(a ? u in t : be.call(t, u))) return !1 } for (var d = a; ++h < c;) { var p = e[u = l[h]], f = t[u], m = n ? n(a ? f : p, a ? p : f, u) : i; if (!(m === i ? r(p, f, n, a, o, s) : m)) return !1; d || (d = "constructor" == u) } if (!d) { var g = e.constructor, y = t.constructor; if (g != y && "constructor" in e && "constructor" in t && !("function" == typeof g && g instanceof g && "function" == typeof y && y instanceof y)) return !1 } return !0 } function tr(e, t, i) { var r = vt.callback || Ea; return r = r === Ea ? Ft : r, i ? r(e, t, i) : r } var ir = gt ? function (e) { return gt.get(e) } : Oa; function rr(e) { for (var t = e.name, i = yt[t], r = i ? i.length : 0; r--;) { var n = i[r], a = n.func; if (null == a || a == e) return n.name } return t } function nr(e, t, i) { var r = vt.indexOf || Or; return r = r === Or ? Ae : r, e ? r(e, t, i) : r } var ar = si("length"); function or(e) { for (var t = pa(e), i = t.length; i--;)t[i][2] = mr(t[i][1]); return t } function sr(e, t) { var r = null == e ? i : e[t]; return Hn(r) ? r : i } function lr(e, t, r) { null == e || dr(t, e) || (e = 1 == (t = Tr(t)).length ? e : ti(e, di(t, 0, -1)), t = kr(t)); var n = null == e ? e : e[t]; return null == n ? i : n.apply(e, r) } function cr(e) { return null != e && fr(ar(e)) } function hr(e, t) { return e = "number" == typeof e || ie.test(e) ? +e : -1, t = null == t ? mt : t, e > -1 && e % 1 == 0 && e < t } function ur(e, t, i) { if (!Gn(i)) return !1; var r = typeof t; if ("number" == r ? cr(i) && hr(t, i.length) : "string" == r && t in i) { var n = i[t]; return e == e ? e === n : n != n } return !1 } function dr(e, t) { var i = typeof e; return !!("string" == i && $.test(e) || "number" == i) || !Nn(e) && (!W.test(e) || null != t && e in Mr(t)) } function pr(e) { var t = rr(e); if (!(t in xt.prototype)) return !1; var i = vt[t]; if (e === i) return !0; var r = ir(i); return !!r && e === r[0] } function fr(e) { return "number" == typeof e && e > -1 && e % 1 == 0 && e <= mt } function mr(e) { return e == e && !Gn(e) } function gr(e, t) { e = Mr(e); for (var i = -1, r = t.length, n = {}; ++i < r;) { var a = t[i]; a in e && (n[a] = e[a]) } return n } function yr(e, t) { var i = {}; return Jt(e, (function (e, r, n) { t(e, r, n) && (i[r] = e) })), i } function vr(e, t) { for (var r = e.length, n = lt(t.length, r), a = Tt(e); n--;) { var o = t[n]; e[n] = hr(o, r) ? a[o] : i } return e } var _r, br, xr = (_r = 0, br = 0, function (e, t) { var i = yn(), r = 16 - (i - br); if (br = i, r > 0) { if (++_r >= 150) return e } else _r = 0; return ui(e, t) }); function wr(e) { for (var t = ca(e), i = t.length, r = i && e.length, n = !!r && fr(r) && (Nn(e) || Bn(e)), a = -1, o = []; ++a < i;) { var s = t[a]; (n && hr(s, r) || be.call(e, s)) && o.push(s) } return o } function Sr(e) { return null == e ? [] : cr(e) ? Gn(e) ? e : de(e) : ma(e) } function Mr(e) { return Gn(e) ? e : de(e) } function Tr(e) { if (Nn(e)) return e; var t = []; return Ce(e).replace(Y, (function (e, i, r, n) { t.push(r ? n.replace(J, "$1") : i || e) })), t } function Ar(e) { return e instanceof xt ? e.clone() : new bt(e.__wrapped__, e.__chain__, Tt(e.__actions__)) } var Er = In((function (e, t) { return Ne(e) && cr(e) ? Ht(e, Xt(t, !1, !0)) : [] })); function Cr(e, t, i) { return (e ? e.length : 0) ? ((i ? ur(e, t, i) : null == t) && (t = 1), di(e, t < 0 ? 0 : t)) : [] } function Lr(e, t, i) { var r = e ? e.length : 0; return r ? ((i ? ur(e, t, i) : null == t) && (t = 1), di(e, 0, (t = r - (+t || 0)) < 0 ? 0 : t)) : [] } var Rr = Ni(), Dr = Ni(!0); function Pr(e) { return e ? e[0] : i } function Or(e, t, i) { var r = e ? e.length : 0; if (!r) return -1; if ("number" == typeof i) i = i < 0 ? st(r + i, 0) : i; else if (i) { var n = bi(e, t); return n < r && (t == t ? t === e[n] : e[n] != e[n]) ? n : -1 } return Ae(e, t, i || 0) } var Ir = In((function (e) { for (var t = e.length, i = t, n = r(u), a = nr(), o = a == Ae, s = []; i--;) { var l = e[i] = cr(l = e[i]) ? l : []; n[i] = o && l.length >= 120 ? Ri(i && l) : null } var c = e[0], h = -1, u = c ? c.length : 0, d = n[0]; e: for (; ++h < u;)if (l = c[h], (d ? Mt(d, l) : a(s, l, 0)) < 0) { for (i = t; --i;) { var p = n[i]; if ((p ? Mt(p, l) : a(e[i], l, 0)) < 0) continue e } d && d.push(l), s.push(l) } return s })); function kr(e) { var t = e ? e.length : 0; return t ? e[t - 1] : i } var Br = In((function (e, t) { var i = Bt(e, t = Xt(t)); return li(e, t.sort(Me)), i })); function Nr(e) { return Cr(e, 1) } var Fr = Ji(), Ur = Ji(!0), zr = In((function (e) { return gi(Xt(e, !1, !0)) })); function Gr(e, t, r, n) { if (!(e ? e.length : 0)) return []; null != t && "boolean" != typeof t && (r = ur(e, t, n = r) ? i : t, t = !1); var a = tr(); return null == r && a === Ft || (r = a(r, n, 3)), t && nr() == Ae ? function (e, t) { for (var i, r = -1, n = e.length, a = -1, o = []; ++r < n;) { var s = e[r], l = t ? t(s, r, e) : s; r && i === l || (i = l, o[++a] = s) } return o }(e, r) : gi(e, r) } function Hr(e) { if (!e || !e.length) return []; var t = -1, i = 0; e = Ct(e, (function (e) { if (cr(e)) return i = st(e.length, i), !0 })); for (var n = r(i); ++t < i;)n[t] = Lt(e, si(t)); return n } function Vr(e, t, r) { if (!(e ? e.length : 0)) return []; var n = Hr(e); return null == t ? n : (t = wi(t, r, 4), Lt(n, (function (e) { return Dt(e, t, i, !0) }))) } var jr = In((function (e, t) { return cr(e) ? Ht(e, t) : [] })), Wr = In(Hr); function $r(e, t) { var i = -1, r = e ? e.length : 0, n = {}; for (!r || t || Nn(e[0]) || (t = []); ++i < r;) { var a = e[i]; t ? n[a] = t[i] : a && (n[a[0]] = a[1]) } return n } var Yr = In((function (e) { var t = e.length, r = t > 2 ? e[t - 2] : i, n = t > 1 ? e[t - 1] : i; return t > 2 && "function" == typeof r ? t -= 2 : (r = t > 1 && "function" == typeof n ? (--t, n) : i, n = i), e.length = t, Vr(e, r, n) })); function Xr(e) { var t = vt(e); return t.__chain__ = !0, t } function Zr(e, t, i) { return t.call(i, e) } var qr = In((function (e) { return e = Xt(e), this.thru((function (t) { return function (e, t) { for (var i = -1, n = e.length, a = -1, o = t.length, s = r(n + o); ++i < n;)s[i] = e[i]; for (; ++a < o;)s[i++] = t[a]; return s }(Nn(t) ? t : [Mr(t)], e) })) })), Jr = In((function (e, t) { return Bt(e, Xt(t)) })), Kr = Ai((function (e, t, i) { be.call(e, i) ? ++e[i] : e[i] = 1 })); function Qr(e, t, r) { var n = Nn(e) ? Et : Wt; return r && ur(e, t, r) && (t = i), "function" == typeof t && r === i || (t = tr(t, r, 3)), n(e, t) } function en(e, t, i) { return (Nn(e) ? Ct : $t)(e, t = tr(t, i, 3)) } var tn = Bi(Vt), rn = Bi(jt, !0), nn = zi(At, Vt), an = zi((function (e, t) { for (var i = e.length; i-- && !1 !== t(e[i], i, e);); return e }), jt), on = Ai((function (e, t, i) { be.call(e, i) ? e[i].push(t) : e[i] = [t] })); function sn(e, t, i, r) { var n = e ? ar(e) : 0; return fr(n) || (n = (e = ma(e)).length), i = "number" != typeof i || r && ur(t, i, r) ? 0 : i < 0 ? st(n + i, 0) : i || 0, "string" == typeof e || !Nn(e) && $n(e) ? i <= n && e.indexOf(t, i) > -1 : !!n && nr(e, t, i) > -1 } var ln = Ai((function (e, t, i) { e[i] = t })), cn = In((function (e, t, n) { var a = -1, o = "function" == typeof t, s = dr(t), l = cr(e) ? r(e.length) : []; return Vt(e, (function (e) { var r = o ? t : s && null != e ? e[t] : i; l[++a] = r ? r.apply(e, n) : lr(e, t, n) })), l })); function hn(e, t, i) { return (Nn(e) ? Lt : ni)(e, t = tr(t, i, 3)) } var un = Ai((function (e, t, i) { e[i ? 0 : 1].push(t) }), (function () { return [[], []] })), dn = $i(Dt, Vt), pn = $i((function (e, t, i, r) { var n = e.length; for (r && n && (i = e[--n]); n--;)i = t(i, e[n], n, e); return i }), jt); function fn(e, t, r) { if (r ? ur(e, t, r) : null == t) return (n = (e = Sr(e)).length) > 0 ? e[ci(0, n - 1)] : i; var n, a = -1, o = Zn(e), s = (n = o.length) - 1; for (t = lt(t < 0 ? 0 : +t || 0, n); ++a < t;) { var l = ci(a, s), c = o[l]; o[l] = o[a], o[a] = c } return o.length = t, o } function mn(e, t, r) { var n = Nn(e) ? Pt : pi; return r && ur(e, t, r) && (t = i), "function" == typeof t && r === i || (t = tr(t, r, 3)), n(e, t) } var gn = In((function (e, t) { if (null == e) return []; var i = t[2]; return i && ur(t[0], t[1], i) && (t.length = 1), mi(e, Xt(t), []) })), yn = ct || function () { return (new n).getTime() }; function vn(e, t) { var r; if ("function" != typeof t) { if ("function" != typeof e) throw new me(h); var n = e; e = t, t = n } return function () { return --e > 0 && (r = t.apply(this, arguments)), e <= 1 && (t = i), r } } var _n = In((function (e, t, i) { var r = 1; if (i.length) { var n = Ue(i, _n.placeholder); r |= a } return Ki(e, r, t, i, n) })), bn = In((function (e, t) { for (var i = -1, r = (t = t.length ? Xt(t) : sa(e)).length; ++i < r;) { var n = t[i]; e[n] = Ki(e[n], 1, e) } return e })), xn = In((function (e, t, i) { var r = 3; if (i.length) { var n = Ue(i, xn.placeholder); r |= a } return Ki(t, r, e, i, n) })), wn = Oi(8), Sn = Oi(16); function Mn(e, t, r) { var n, a, o, s, l, c, u, d = 0, p = !1, f = !0; if ("function" != typeof e) throw new me(h); if (t = t < 0 ? 0 : +t || 0, !0 === r) { var m = !0; f = !1 } else Gn(r) && (m = !!r.leading, p = "maxWait" in r && st(+r.maxWait || 0, t), f = "trailing" in r ? !!r.trailing : f); function g(t, r) { r && $e(r), a = c = u = i, t && (d = yn(), o = e.apply(l, n), c || a || (n = l = i)) } function y() { var e = t - (yn() - s); e <= 0 || e > t ? g(u, a) : c = Je(y, e) } function v() { g(f, c) } function _() { if (n = arguments, s = yn(), l = this, u = f && (c || !m), !1 === p) var r = m && !c; else { a || m || (d = s); var h = p - (s - d), g = h <= 0 || h > p; g ? (a && (a = $e(a)), d = s, o = e.apply(l, n)) : a || (a = Je(v, h)) } return g && c ? c = $e(c) : c || t === p || (c = Je(y, t)), r && (g = !0, o = e.apply(l, n)), !g || c || a || (n = l = i), o } return _.cancel = function () { c && $e(c), a && $e(a), d = 0, a = c = u = i }, _ } var Tn = In((function (e, t) { return Gt(e, 1, t) })), An = In((function (e, t, i) { return Gt(e, t, i) })), En = Ui(), Cn = Ui(!0); function Ln(e, t) { if ("function" != typeof e || t && "function" != typeof t) throw new me(h); var i = function () { var r = arguments, n = t ? t.apply(this, r) : r[0], a = i.cache; if (a.has(n)) return a.get(n); var o = e.apply(this, r); return i.cache = a.set(n, o), o }; return i.cache = new Ln.Cache, i } var Rn = In((function (e, t) { if (t = Xt(t), "function" != typeof e || !Et(t, Ee)) throw new me(h); var i = t.length; return In((function (r) { for (var n = lt(r.length, i); n--;)r[n] = t[n](r[n]); return e.apply(this, r) })) })), Dn = Wi(a), Pn = Wi(o), On = In((function (e, t) { return Ki(e, l, i, i, i, Xt(t)) })); function In(e, t) { if ("function" != typeof e) throw new me(h); return t = st(t === i ? e.length - 1 : +t || 0, 0), function () { for (var i = arguments, n = -1, a = st(i.length - t, 0), o = r(a); ++n < a;)o[n] = i[t + n]; switch (t) { case 0: return e.call(this, o); case 1: return e.call(this, i[0], o); case 2: return e.call(this, i[0], i[1], o) }var s = r(t + 1); for (n = -1; ++n < t;)s[n] = i[n]; return s[t] = o, e.apply(this, s) } } function kn(e, t) { return e > t } function Bn(e) { return Ne(e) && cr(e) && be.call(e, "callee") && !Ze.call(e, "callee") } var Nn = nt || function (e) { return Ne(e) && fr(e.length) && we.call(e) == p }; function Fn(e, t, r, n) { var a = (r = "function" == typeof r ? wi(r, n, 3) : i) ? r(e, t) : i; return a === i ? ii(e, t, r) : !!a } function Un(e) { return Ne(e) && "string" == typeof e.message && we.call(e) == g } function zn(e) { return Gn(e) && we.call(e) == y } function Gn(e) { var t = typeof e; return !!e && ("object" == t || "function" == t) } function Hn(e) { return null != e && (zn(e) ? je.test(_e.call(e)) : Ne(e) && te.test(e)) } function Vn(e) { return "number" == typeof e || Ne(e) && we.call(e) == _ } function jn(e) { var t, r; return !(!Ne(e) || we.call(e) != b || Bn(e) || !(be.call(e, "constructor") || "function" != typeof (t = e.constructor) || t instanceof t)) && (Jt(e, (function (e, t) { r = t })), r === i || be.call(e, r)) } function Wn(e) { return Gn(e) && we.call(e) == x } function $n(e) { return "string" == typeof e || Ne(e) && we.call(e) == S } function Yn(e) { return Ne(e) && fr(e.length) && !!ce[we.call(e)] } function Xn(e, t) { return e < t } function Zn(e) { var t = e ? ar(e) : 0; return fr(t) ? t ? Tt(e) : [] : ma(e) } function qn(e) { return Nt(e, ca(e)) } var Jn = Ei((function e(t, r, n, a, o) { if (!Gn(t)) return t; var s = cr(r) && (Nn(r) || Yn(r)), l = s ? i : la(r); return At(l || r, (function (c, h) { if (l && (c = r[h = c]), Ne(c)) a || (a = []), o || (o = []), function (e, t, r, n, a, o, s) { var l = o.length, c = t[r]; for (; l--;)if (o[l] == c) return void (e[r] = s[l]); var h = e[r], u = a ? a(h, c, r, e, t) : i, d = u === i; d && (u = c, cr(c) && (Nn(c) || Yn(c)) ? u = Nn(h) ? h : cr(h) ? Tt(h) : [] : jn(c) || Bn(c) ? u = Bn(h) ? qn(h) : jn(h) ? h : {} : d = !1); o.push(c), s.push(u), d ? e[r] = n(u, c, a, o, s) : (u == u ? u !== h : h == h) && (e[r] = u) }(t, r, h, e, n, a, o); else { var u = t[h], d = n ? n(u, c, h, t, r) : i, p = d === i; p && (d = c), d === i && (!s || h in t) || !p && (d == d ? d === u : u != u) || (t[h] = d) } })), t })), Kn = Ei((function (e, t, i) { return i ? It(e, t, i) : kt(e, t) })), Qn = Ii(Kn, (function (e, t) { return e === i ? t : e })), ea = Ii(Jn, (function e(t, r) { return t === i ? r : Jn(t, r, e) })), ta = Fi(Kt), ia = Fi(Qt), ra = Gi(Zt), na = Gi(qt), aa = Hi(Kt), oa = Hi(Qt); function sa(e) { return ei(e, ca(e)) } var la = ot ? function (e) { var t = null == e ? i : e.constructor; return "function" == typeof t && t.prototype === e || "function" != typeof e && cr(e) ? wr(e) : Gn(e) ? ot(e) : [] } : wr; function ca(e) { if (null == e) return []; Gn(e) || (e = de(e)); var t = e.length; t = t && fr(t) && (Nn(e) || Bn(e)) && t || 0; for (var i = e.constructor, n = -1, a = "function" == typeof i && i.prototype === e, o = r(t), s = t > 0; ++n < t;)o[n] = n + ""; for (var l in e) s && hr(l, t) || "constructor" == l && (a || !be.call(e, l)) || o.push(l); return o } var ha = Vi(!0), ua = Vi(), da = In((function (e, t) { if (null == e) return {}; if ("function" != typeof t[0]) { t = Lt(Xt(t), fe); return gr(e, Ht(ca(e), t)) } var i = wi(t[0], t[1], 3); return yr(e, (function (e, t, r) { return !i(e, t, r) })) })); function pa(e) { e = Mr(e); for (var t = -1, i = la(e), n = i.length, a = r(n); ++t < n;) { var o = i[t]; a[t] = [o, e[o]] } return a } var fa = In((function (e, t) { return null == e ? {} : "function" == typeof t[0] ? yr(e, wi(t[0], t[1], 3)) : gr(e, Xt(t)) })); function ma(e) { return yi(e, la(e)) } var ga = Di((function (e, t, i) { return t = t.toLowerCase(), e + (i ? t.charAt(0).toUpperCase() + t.slice(1) : t) })); function ya(e) { return (e = Ce(e)) && e.replace(re, Pe).replace(q, "") } var va = Di((function (e, t, i) { return e + (i ? "-" : "") + t.toLowerCase() })), _a = ji(), ba = ji(!0); function xa(e, t) { var i = ""; if (e = Ce(e), (t = +t) < 1 || !e || !at(t)) return i; do { t % 2 && (i += e), t = rt(t / 2), e += e } while (t); return i } var wa = Di((function (e, t, i) { return e + (i ? "_" : "") + t.toLowerCase() })), Sa = Di((function (e, t, i) { return e + (i ? " " : "") + (t.charAt(0).toUpperCase() + t.slice(1)) })); function Ma(e, t, i) { var r = e; return (e = Ce(e)) ? (i ? ur(r, t, i) : null == t) ? e.slice(ze(e), Ge(e) + 1) : (t += "", e.slice(Le(e, t), Re(e, t) + 1)) : e } function Ta(e, t, r) { return r && ur(e, t, r) && (t = i), (e = Ce(e)).match(t || oe) || [] } var Aa = In((function (e, t) { try { return e.apply(i, t) } catch (e) { return Un(e) ? e : new v(e) } })); function Ea(e, t, r) { return r && ur(e, t, r) && (t = i), Ne(e) ? La(e) : Ft(e, t) } function Ca(e) { return e } function La(e) { return ai(Ut(e, !0)) } var Ra = In((function (e, t) { return function (i) { return lr(i, e, t) } })), Da = In((function (e, t) { return function (i) { return lr(e, i, t) } })); function Pa(e, t, r) { if (null == r) { var n = Gn(t), a = n ? la(t) : i, o = a && a.length ? ei(t, a) : i; (o ? o.length : n) || (o = !1, r = t, t = e, e = this) } o || (o = ei(t, la(t))); var s = !0, l = -1, c = zn(e), h = o.length; !1 === r ? s = !1 : Gn(r) && "chain" in r && (s = r.chain); for (; ++l < h;) { var u = o[l], d = t[u]; e[u] = d, c && (e.prototype[u] = function (t) { return function () { var i = this.__chain__; if (s || i) { var r = e(this.__wrapped__), n = r.__actions__ = Tt(this.__actions__); return n.push({ func: t, args: arguments, thisArg: e }), r.__chain__ = i, r } return t.apply(e, Rt([this.value()], arguments)) } }(d)) } return e } function Oa() { } function Ia(e) { return dr(e) ? si(e) : function (e) { var t = e + ""; return e = Tr(e), function (i) { return ti(i, e, t) } }(e) } var ka, Ba = qi("ceil"), Na = qi("floor"), Fa = ki(kn, dt), Ua = ki(Xn, pt), za = qi("round"); return vt.prototype = _t.prototype, bt.prototype = zt(_t.prototype), bt.prototype.constructor = bt, xt.prototype = zt(_t.prototype), xt.prototype.constructor = xt, wt.prototype.delete = function (e) { return this.has(e) && delete this.__data__[e] }, wt.prototype.get = function (e) { return "__proto__" == e ? i : this.__data__[e] }, wt.prototype.has = function (e) { return "__proto__" != e && be.call(this.__data__, e) }, wt.prototype.set = function (e, t) { return "__proto__" != e && (this.__data__[e] = t), this }, St.prototype.push = function (e) { var t = this.data; "string" == typeof e || Gn(e) ? t.set.add(e) : t.hash[e] = !0 }, Ln.Cache = wt, vt.after = function (e, t) { if ("function" != typeof t) { if ("function" != typeof e) throw new me(h); var i = e; e = t, t = i } return e = at(e = +e) ? e : 0, function () { if (--e < 1) return t.apply(this, arguments) } }, vt.ary = function (e, t, r) { return r && ur(e, t, r) && (t = i), t = e && null == t ? e.length : st(+t || 0, 0), Ki(e, s, i, i, i, i, t) }, vt.assign = Kn, vt.at = Jr, vt.before = vn, vt.bind = _n, vt.bindAll = bn, vt.bindKey = xn, vt.callback = Ea, vt.chain = Xr, vt.chunk = function (e, t, i) { t = (i ? ur(e, t, i) : null == t) ? 1 : st(rt(t) || 1, 1); for (var n = 0, a = e ? e.length : 0, o = -1, s = r(tt(a / t)); n < a;)s[++o] = di(e, n, n += t); return s }, vt.compact = function (e) { for (var t = -1, i = e ? e.length : 0, r = -1, n = []; ++t < i;) { var a = e[t]; a && (n[++r] = a) } return n }, vt.constant = function (e) { return function () { return e } }, vt.countBy = Kr, vt.create = function (e, t, r) { var n = zt(e); return r && ur(e, t, r) && (t = i), t ? kt(n, t) : n }, vt.curry = wn, vt.curryRight = Sn, vt.debounce = Mn, vt.defaults = Qn, vt.defaultsDeep = ea, vt.defer = Tn, vt.delay = An, vt.difference = Er, vt.drop = Cr, vt.dropRight = Lr, vt.dropRightWhile = function (e, t, i) { return e && e.length ? vi(e, tr(t, i, 3), !0, !0) : [] }, vt.dropWhile = function (e, t, i) { return e && e.length ? vi(e, tr(t, i, 3), !0) : [] }, vt.fill = function (e, t, r, n) { var a = e ? e.length : 0; return a ? (r && "number" != typeof r && ur(e, t, r) && (r = 0, n = a), function (e, t, r, n) { var a = e.length; for ((r = null == r ? 0 : +r || 0) < 0 && (r = -r > a ? 0 : a + r), (n = n === i || n > a ? a : +n || 0) < 0 && (n += a), a = r > n ? 0 : n >>> 0, r >>>= 0; r < a;)e[r++] = t; return e }(e, t, r, n)) : [] }, vt.filter = en, vt.flatten = function (e, t, i) { var r = e ? e.length : 0; return i && ur(e, t, i) && (t = !1), r ? Xt(e, t) : [] }, vt.flattenDeep = function (e) { return (e ? e.length : 0) ? Xt(e, !0) : [] }, vt.flow = En, vt.flowRight = Cn, vt.forEach = nn, vt.forEachRight = an, vt.forIn = ra, vt.forInRight = na, vt.forOwn = aa, vt.forOwnRight = oa, vt.functions = sa, vt.groupBy = on, vt.indexBy = ln, vt.initial = function (e) { return Lr(e, 1) }, vt.intersection = Ir, vt.invert = function (e, t, r) { r && ur(e, t, r) && (t = i); for (var n = -1, a = la(e), o = a.length, s = {}; ++n < o;) { var l = a[n], c = e[l]; t ? be.call(s, c) ? s[c].push(l) : s[c] = [l] : s[c] = l } return s }, vt.invoke = cn, vt.keys = la, vt.keysIn = ca, vt.map = hn, vt.mapKeys = ha, vt.mapValues = ua, vt.matches = La, vt.matchesProperty = function (e, t) { return oi(e, Ut(t, !0)) }, vt.memoize = Ln, vt.merge = Jn, vt.method = Ra, vt.methodOf = Da, vt.mixin = Pa, vt.modArgs = Rn, vt.negate = function (e) { if ("function" != typeof e) throw new me(h); return function () { return !e.apply(this, arguments) } }, vt.omit = da, vt.once = function (e) { return vn(2, e) }, vt.pairs = pa, vt.partial = Dn, vt.partialRight = Pn, vt.partition = un, vt.pick = fa, vt.pluck = function (e, t) { return hn(e, Ia(t)) }, vt.property = Ia, vt.propertyOf = function (e) { return function (t) { return ti(e, Tr(t), t + "") } }, vt.pull = function () { var e = arguments, t = e[0]; if (!t || !t.length) return t; for (var i = 0, r = nr(), n = e.length; ++i < n;)for (var a = 0, o = e[i]; (a = r(t, o, a)) > -1;)Ke.call(t, a, 1); return t }, vt.pullAt = Br, vt.range = function (e, t, n) { n && ur(e, t, n) && (t = n = i), e = +e || 0, null == t ? (t = e, e = 0) : t = +t || 0; for (var a = -1, o = st(tt((t - e) / ((n = null == n ? 1 : +n || 0) || 1)), 0), s = r(o); ++a < o;)s[a] = e, e += n; return s }, vt.rearg = On, vt.reject = function (e, t, i) { var r = Nn(e) ? Ct : $t; return t = tr(t, i, 3), r(e, (function (e, i, r) { return !t(e, i, r) })) }, vt.remove = function (e, t, i) { var r = []; if (!e || !e.length) return r; var n = -1, a = [], o = e.length; for (t = tr(t, i, 3); ++n < o;) { var s = e[n]; t(s, n, e) && (r.push(s), a.push(n)) } return li(e, a), r }, vt.rest = Nr, vt.restParam = In, vt.set = function (e, t, i) { if (null == e) return e; for (var r = t + "", n = -1, a = (t = null != e[r] || dr(t, e) ? [r] : Tr(t)).length, o = a - 1, s = e; null != s && ++n < a;) { var l = t[n]; Gn(s) && (n == o ? s[l] = i : null == s[l] && (s[l] = hr(t[n + 1]) ? [] : {})), s = s[l] } return e }, vt.shuffle = function (e) { return fn(e, pt) }, vt.slice = function (e, t, i) { var r = e ? e.length : 0; return r ? (i && "number" != typeof i && ur(e, t, i) && (t = 0, i = r), di(e, t, i)) : [] }, vt.sortBy = function (e, t, r) { if (null == e) return []; r && ur(e, t, r) && (t = i); var n = -1; return t = tr(t, r, 3), fi(ni(e, (function (e, i, r) { return { criteria: t(e, i, r), index: ++n, value: e } })), De) }, vt.sortByAll = gn, vt.sortByOrder = function (e, t, r, n) { return null == e ? [] : (n && ur(t, r, n) && (r = i), Nn(t) || (t = null == t ? [] : [t]), Nn(r) || (r = null == r ? [] : [r]), mi(e, t, r)) }, vt.spread = function (e) { if ("function" != typeof e) throw new me(h); return function (t) { return e.apply(this, t) } }, vt.take = function (e, t, i) { return (e ? e.length : 0) ? ((i ? ur(e, t, i) : null == t) && (t = 1), di(e, 0, t < 0 ? 0 : t)) : [] }, vt.takeRight = function (e, t, i) { var r = e ? e.length : 0; return r ? ((i ? ur(e, t, i) : null == t) && (t = 1), di(e, (t = r - (+t || 0)) < 0 ? 0 : t)) : [] }, vt.takeRightWhile = function (e, t, i) { return e && e.length ? vi(e, tr(t, i, 3), !1, !0) : [] }, vt.takeWhile = function (e, t, i) { return e && e.length ? vi(e, tr(t, i, 3)) : [] }, vt.tap = function (e, t, i) { return t.call(i, e), e }, vt.throttle = function (e, t, i) { var r = !0, n = !0; if ("function" != typeof e) throw new me(h); return !1 === i ? r = !1 : Gn(i) && (r = "leading" in i ? !!i.leading : r, n = "trailing" in i ? !!i.trailing : n), Mn(e, t, { leading: r, maxWait: +t, trailing: n }) }, vt.thru = Zr, vt.times = function (e, t, i) { if ((e = rt(e)) < 1 || !at(e)) return []; var n = -1, a = r(lt(e, ft)); for (t = wi(t, i, 1); ++n < e;)n < ft ? a[n] = t(n) : t(n); return a }, vt.toArray = Zn, vt.toPlainObject = qn, vt.transform = function (e, t, r, n) { var a = Nn(e) || Yn(e); if (t = tr(t, n, 4), null == r) if (a || Gn(e)) { var o = e.constructor; r = a ? Nn(e) ? new o : [] : zt(zn(o) ? o.prototype : i) } else r = {}; return (a ? At : Kt)(e, (function (e, i, n) { return t(r, e, i, n) })), r }, vt.union = zr, vt.uniq = Gr, vt.unzip = Hr, vt.unzipWith = Vr, vt.values = ma, vt.valuesIn = function (e) { return yi(e, ca(e)) }, vt.where = function (e, t) { return en(e, ai(t)) }, vt.without = jr, vt.wrap = function (e, t) { return Ki(t = null == t ? Ca : t, a, i, [e], []) }, vt.xor = function () { for (var e = -1, t = arguments.length; ++e < t;) { var i = arguments[e]; if (cr(i)) var r = r ? Rt(Ht(r, i), Ht(i, r)) : i } return r ? gi(r) : [] }, vt.zip = Wr, vt.zipObject = $r, vt.zipWith = Yr, vt.backflow = Cn, vt.collect = hn, vt.compose = Cn, vt.each = nn, vt.eachRight = an, vt.extend = Kn, vt.iteratee = Ea, vt.methods = sa, vt.object = $r, vt.select = en, vt.tail = Nr, vt.unique = Gr, Pa(vt, vt), vt.add = function (e, t) { return (+e || 0) + (+t || 0) }, vt.attempt = Aa, vt.camelCase = ga, vt.capitalize = function (e) { return (e = Ce(e)) && e.charAt(0).toUpperCase() + e.slice(1) }, vt.ceil = Ba, vt.clone = function (e, t, i, r) { return t && "boolean" != typeof t && ur(e, t, i) ? t = !1 : "function" == typeof t && (r = i, i = t, t = !1), "function" == typeof i ? Ut(e, t, wi(i, r, 1)) : Ut(e, t) }, vt.cloneDeep = function (e, t, i) { return "function" == typeof t ? Ut(e, !0, wi(t, i, 1)) : Ut(e, !0) }, vt.deburr = ya, vt.endsWith = function (e, t, r) { t += ""; var n = (e = Ce(e)).length; return r = r === i ? n : lt(r < 0 ? 0 : +r || 0, n), (r -= t.length) >= 0 && e.indexOf(t, r) == r }, vt.escape = function (e) { return (e = Ce(e)) && G.test(e) ? e.replace(U, Oe) : e }, vt.escapeRegExp = function (e) { return (e = Ce(e)) && Z.test(e) ? e.replace(X, Ie) : e || "(?:)" }, vt.every = Qr, vt.find = tn, vt.findIndex = Rr, vt.findKey = ta, vt.findLast = rn, vt.findLastIndex = Dr, vt.findLastKey = ia, vt.findWhere = function (e, t) { return tn(e, ai(t)) }, vt.first = Pr, vt.floor = Na, vt.get = function (e, t, r) { var n = null == e ? i : ti(e, Tr(t), t + ""); return n === i ? r : n }, vt.gt = kn, vt.gte = function (e, t) { return e >= t }, vt.has = function (e, t) { if (null == e) return !1; var i = be.call(e, t); if (!i && !dr(t)) { if (null == (e = 1 == (t = Tr(t)).length ? e : ti(e, di(t, 0, -1)))) return !1; t = kr(t), i = be.call(e, t) } return i || fr(e.length) && hr(t, e.length) && (Nn(e) || Bn(e)) }, vt.identity = Ca, vt.includes = sn, vt.indexOf = Or, vt.inRange = function (e, t, r) { return t = +t || 0, r === i ? (r = t, t = 0) : r = +r || 0, e >= lt(t, r) && e < st(t, r) }, vt.isArguments = Bn, vt.isArray = Nn, vt.isBoolean = function (e) { return !0 === e || !1 === e || Ne(e) && we.call(e) == f }, vt.isDate = function (e) { return Ne(e) && we.call(e) == m }, vt.isElement = function (e) { return !!e && 1 === e.nodeType && Ne(e) && !jn(e) }, vt.isEmpty = function (e) { return null == e || (cr(e) && (Nn(e) || $n(e) || Bn(e) || Ne(e) && zn(e.splice)) ? !e.length : !la(e).length) }, vt.isEqual = Fn, vt.isError = Un, vt.isFinite = function (e) { return "number" == typeof e && at(e) }, vt.isFunction = zn, vt.isMatch = function (e, t, r, n) { return r = "function" == typeof r ? wi(r, n, 3) : i, ri(e, or(t), r) }, vt.isNaN = function (e) { return Vn(e) && e != +e }, vt.isNative = Hn, vt.isNull = function (e) { return null === e }, vt.isNumber = Vn, vt.isObject = Gn, vt.isPlainObject = jn, vt.isRegExp = Wn, vt.isString = $n, vt.isTypedArray = Yn, vt.isUndefined = function (e) { return e === i }, vt.kebabCase = va, vt.last = kr, vt.lastIndexOf = function (e, t, i) { var r = e ? e.length : 0; if (!r) return -1; var n = r; if ("number" == typeof i) n = (i < 0 ? st(r + i, 0) : lt(i || 0, r - 1)) + 1; else if (i) { var a = e[n = bi(e, t, !0) - 1]; return (t == t ? t === a : a != a) ? n : -1 } if (t != t) return Be(e, n, !0); for (; n--;)if (e[n] === t) return n; return -1 }, vt.lt = Xn, vt.lte = function (e, t) { return e <= t }, vt.max = Fa, vt.min = Ua, vt.noConflict = function () { return Se._ = Fe, this }, vt.noop = Oa, vt.now = yn, vt.pad = function (e, t, i) { t = +t; var r = (e = Ce(e)).length; if (r >= t || !at(t)) return e; var n = (t - r) / 2, a = rt(n); return (i = Xi("", tt(n), i)).slice(0, a) + e + i }, vt.padLeft = _a, vt.padRight = ba, vt.parseInt = function (e, t, i) { return (i ? ur(e, t, i) : null == t) ? t = 0 : t && (t = +t), e = Ma(e), ht(e, t || (ee.test(e) ? 16 : 10)) }, vt.random = function (e, t, r) { r && ur(e, t, r) && (t = r = i); var n = null == e, a = null == t; if (null == r && (a && "boolean" == typeof e ? (r = e, e = 1) : "boolean" == typeof t && (r = t, a = !0)), n && a && (t = 1, a = !1), e = +e || 0, a ? (t = e, e = 0) : t = +t || 0, r || e % 1 || t % 1) { var o = ut(); return lt(e + o * (t - e + Ye("1e-" + ((o + "").length - 1))), t) } return ci(e, t) }, vt.reduce = dn, vt.reduceRight = pn, vt.repeat = xa, vt.result = function (e, t, r) { var n = null == e ? i : e[t]; return n === i && (null == e || dr(t, e) || (n = null == (e = 1 == (t = Tr(t)).length ? e : ti(e, di(t, 0, -1))) ? i : e[kr(t)]), n = n === i ? r : n), zn(n) ? n.call(e) : n }, vt.round = za, vt.runInContext = e, vt.size = function (e) { var t = e ? ar(e) : 0; return fr(t) ? t : la(e).length }, vt.snakeCase = wa, vt.some = mn, vt.sortedIndex = Fr, vt.sortedLastIndex = Ur, vt.startCase = Sa, vt.startsWith = function (e, t, i) { return e = Ce(e), i = null == i ? 0 : lt(i < 0 ? 0 : +i || 0, e.length), e.lastIndexOf(t, i) == i }, vt.sum = function (e, t, r) { return r && ur(e, t, r) && (t = i), 1 == (t = tr(t, r, 3)).length ? function (e, t) { for (var i = e.length, r = 0; i--;)r += +t(e[i]) || 0; return r }(Nn(e) ? e : Sr(e), t) : function (e, t) { var i = 0; return Vt(e, (function (e, r, n) { i += +t(e, r, n) || 0 })), i }(e, t) }, vt.template = function (e, t, r) { var n = vt.templateSettings; r && ur(e, t, r) && (t = r = i), e = Ce(e), t = It(kt({}, r || t), n, Ot); var a, o, s = It(kt({}, t.imports), n.imports, Ot), l = la(s), c = yi(s, l), h = 0, u = t.interpolate || ne, d = "__p += '", p = pe((t.escape || ne).source + "|" + u.source + "|" + (u === j ? K : ne).source + "|" + (t.evaluate || ne).source + "|$", "g"), f = "//# sourceURL=" + ("sourceURL" in t ? t.sourceURL : "lodash.templateSources[" + ++le + "]") + "\n"; e.replace(p, (function (t, i, r, n, s, l) { return r || (r = n), d += e.slice(h, l).replace(ae, ke), i && (a = !0, d += "' +\n__e(" + i + ") +\n'"), s && (o = !0, d += "';\n" + s + ";\n__p += '"), r && (d += "' +\n((__t = (" + r + ")) == null ? '' : __t) +\n'"), h = l + t.length, t })), d += "';\n"; var m = t.variable; m || (d = "with (obj) {\n" + d + "\n}\n"), d = (o ? d.replace(k, "") : d).replace(B, "$1").replace(N, "$1;"), d = "function(" + (m || "obj") + ") {\n" + (m ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (a ? ", __e = _.escape" : "") + (o ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + d + "return __p\n}"; var g = Aa((function () { return w(l, f + "return " + d).apply(i, c) })); if (g.source = d, Un(g)) throw g; return g }, vt.trim = Ma, vt.trimLeft = function (e, t, i) { var r = e; return (e = Ce(e)) ? (i ? ur(r, t, i) : null == t) ? e.slice(ze(e)) : e.slice(Le(e, t + "")) : e }, vt.trimRight = function (e, t, i) { var r = e; return (e = Ce(e)) ? (i ? ur(r, t, i) : null == t) ? e.slice(0, Ge(e) + 1) : e.slice(0, Re(e, t + "") + 1) : e }, vt.trunc = function (e, t, r) { r && ur(e, t, r) && (t = i); var n = 30, a = "..."; if (null != t) if (Gn(t)) { var o = "separator" in t ? t.separator : o; n = "length" in t ? +t.length || 0 : n, a = "omission" in t ? Ce(t.omission) : a } else n = +t || 0; if (n >= (e = Ce(e)).length) return e; var s = n - a.length; if (s < 1) return a; var l = e.slice(0, s); if (null == o) return l + a; if (Wn(o)) { if (e.slice(s).search(o)) { var c, h, u = e.slice(0, s); for (o.global || (o = pe(o.source, (Q.exec(o) || "") + "g")), o.lastIndex = 0; c = o.exec(u);)h = c.index; l = l.slice(0, null == h ? s : h) } } else if (e.indexOf(o, s) != s) { var d = l.lastIndexOf(o); d > -1 && (l = l.slice(0, d)) } return l + a }, vt.unescape = function (e) { return (e = Ce(e)) && z.test(e) ? e.replace(F, He) : e }, vt.uniqueId = function (e) { var t = ++xe; return Ce(e) + t }, vt.words = Ta, vt.all = Qr, vt.any = mn, vt.contains = sn, vt.eq = Fn, vt.detect = tn, vt.foldl = dn, vt.foldr = pn, vt.head = Pr, vt.include = sn, vt.inject = dn, Pa(vt, (ka = {}, Kt(vt, (function (e, t) { vt.prototype[t] || (ka[t] = e) })), ka), !1), vt.sample = fn, vt.prototype.sample = function (e) { return this.__chain__ || null != e ? this.thru((function (t) { return fn(t, e) })) : fn(this.value()) }, vt.VERSION = "3.10.1", At(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], (function (e) { vt[e].placeholder = vt })), At(["drop", "take"], (function (e, t) { xt.prototype[e] = function (i) { var r = this.__filtered__; if (r && !t) return new xt(this); i = null == i ? 1 : st(rt(i) || 0, 0); var n = this.clone(); return r ? n.__takeCount__ = lt(n.__takeCount__, i) : n.__views__.push({ size: i, type: e + (n.__dir__ < 0 ? "Right" : "") }), n }, xt.prototype[e + "Right"] = function (t) { return this.reverse()[e](t).reverse() } })), At(["filter", "map", "takeWhile"], (function (e, t) { var i = t + 1, r = 2 != i; xt.prototype[e] = function (e, t) { var n = this.clone(); return n.__iteratees__.push({ iteratee: tr(e, t, 1), type: i }), n.__filtered__ = n.__filtered__ || r, n } })), At(["first", "last"], (function (e, t) { var i = "take" + (t ? "Right" : ""); xt.prototype[e] = function () { return this[i](1).value()[0] } })), At(["initial", "rest"], (function (e, t) { var i = "drop" + (t ? "" : "Right"); xt.prototype[e] = function () { return this.__filtered__ ? new xt(this) : this[i](1) } })), At(["pluck", "where"], (function (e, t) { var i = t ? "filter" : "map", r = t ? ai : Ia; xt.prototype[e] = function (e) { return this[i](r(e)) } })), xt.prototype.compact = function () { return this.filter(Ca) }, xt.prototype.reject = function (e, t) { return e = tr(e, t, 1), this.filter((function (t) { return !e(t) })) }, xt.prototype.slice = function (e, t) { e = null == e ? 0 : +e || 0; var r = this; return r.__filtered__ && (e > 0 || t < 0) ? new xt(r) : (e < 0 ? r = r.takeRight(-e) : e && (r = r.drop(e)), t !== i && (r = (t = +t || 0) < 0 ? r.dropRight(-t) : r.take(t - e)), r) }, xt.prototype.takeRightWhile = function (e, t) { return this.reverse().takeWhile(e, t).reverse() }, xt.prototype.toArray = function () { return this.take(pt) }, Kt(xt.prototype, (function (e, t) { var r = /^(?:filter|map|reject)|While$/.test(t), n = /^(?:first|last)$/.test(t), a = vt[n ? "take" + ("last" == t ? "Right" : "") : t]; a && (vt.prototype[t] = function () { var t = n ? [1] : arguments, o = this.__chain__, s = this.__wrapped__, l = !!this.__actions__.length, c = s instanceof xt, h = t[0], u = c || Nn(s); u && r && "function" == typeof h && 1 != h.length && (c = u = !1); var d = function (e) { return n && o ? a(e, 1)[0] : a.apply(i, Rt([e], t)) }, p = { func: Zr, args: [d], thisArg: i }, f = c && !l; if (n && !o) return f ? ((s = s.clone()).__actions__.push(p), e.call(s)) : a.call(i, this.value())[0]; if (!n && u) { s = f ? s : new xt(this); var m = e.apply(s, t); return m.__actions__.push(p), new bt(m, o) } return this.thru(d) }) })), At(["join", "pop", "push", "replace", "shift", "sort", "splice", "split", "unshift"], (function (e) { var t = (/^(?:replace|split)$/.test(e) ? ve : ge)[e], i = /^(?:push|sort|unshift)$/.test(e) ? "tap" : "thru", r = /^(?:join|pop|replace|shift)$/.test(e); vt.prototype[e] = function () { var e = arguments; return r && !this.__chain__ ? t.apply(this.value(), e) : this[i]((function (i) { return t.apply(i, e) })) } })), Kt(xt.prototype, (function (e, t) { var i = vt[t]; if (i) { var r = i.name; (yt[r] || (yt[r] = [])).push({ name: t, func: i }) } })), yt[Yi(i, 2).name] = [{ name: "wrapper", func: i }], xt.prototype.clone = function () { var e = new xt(this.__wrapped__); return e.__actions__ = Tt(this.__actions__), e.__dir__ = this.__dir__, e.__filtered__ = this.__filtered__, e.__iteratees__ = Tt(this.__iteratees__), e.__takeCount__ = this.__takeCount__, e.__views__ = Tt(this.__views__), e }, xt.prototype.reverse = function () { if (this.__filtered__) { var e = new xt(this); e.__dir__ = -1, e.__filtered__ = !0 } else (e = this.clone()).__dir__ *= -1; return e }, xt.prototype.value = function () { var e = this.__wrapped__.value(), t = this.__dir__, i = Nn(e), r = t < 0, n = i ? e.length : 0, a = function (e, t, i) { var r = -1, n = i.length; for (; ++r < n;) { var a = i[r], o = a.size; switch (a.type) { case "drop": e += o; break; case "dropRight": t -= o; break; case "take": t = lt(t, e + o); break; case "takeRight": e = st(e, t - o) } } return { start: e, end: t } }(0, n, this.__views__), o = a.start, s = a.end, l = s - o, h = r ? s : o - 1, u = this.__iteratees__, d = u.length, p = 0, f = lt(l, this.__takeCount__); if (!i || n < c || n == l && f == l) return _i(r && i ? e.reverse() : e, this.__actions__); var m = []; e: for (; l-- && p < f;) { for (var g = -1, y = e[h += t]; ++g < d;) { var v = u[g], _ = v.iteratee, b = v.type, x = _(y); if (2 == b) y = x; else if (!x) { if (1 == b) continue e; break e } } m[p++] = y } return m }, vt.prototype.chain = function () { return Xr(this) }, vt.prototype.commit = function () { return new bt(this.value(), this.__chain__) }, vt.prototype.concat = qr, vt.prototype.plant = function (e) { for (var t, i = this; i instanceof _t;) { var r = Ar(i); t ? n.__wrapped__ = r : t = r; var n = r; i = i.__wrapped__ } return n.__wrapped__ = e, t }, vt.prototype.reverse = function () { var e = this.__wrapped__, t = function (e) { return r && r.__dir__ < 0 ? e : e.reverse() }; if (e instanceof xt) { var r = e; return this.__actions__.length && (r = new xt(this)), (r = r.reverse()).__actions__.push({ func: Zr, args: [t], thisArg: i }), new bt(r, this.__chain__) } return this.thru(t) }, vt.prototype.toString = function () { return this.value() + "" }, vt.prototype.run = vt.prototype.toJSON = vt.prototype.valueOf = vt.prototype.value = function () { return _i(this.__wrapped__, this.__actions__) }, vt.prototype.collect = vt.prototype.map, vt.prototype.head = vt.prototype.first, vt.prototype.select = vt.prototype.filter, vt.prototype.tail = vt.prototype.rest, vt }(); ye && ve ? we ? (ve.exports = Ve)._ = Ve : ye._ = Ve : Se._ = Ve }).call(commonjsGlobal) })), terrainVertex = "precision highp float;\n#define GLSLIFY 1\nuniform mat4 modelMatrix;uniform mat4 viewMatrix;uniform mat4 projectionMatrix;uniform vec3 cameraPosition;attribute vec4 position;uniform vec4 uOffset;uniform vec4 uImageryUvOffset;varying vec4 vUV;varying float D;\n#ifdef USE_SHADOWMAP\nuniform bool receiveShadow;\n#if NUM_DIR_LIGHT_SHADOWS > 0\nuniform mat4 directionalShadowMatrix[NUM_DIR_LIGHT_SHADOWS];varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];struct DirectionalLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nuniform mat4 spotShadowMatrix[NUM_SPOT_LIGHT_SHADOWS];varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];struct SpotLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nuniform mat4 pointShadowMatrix[NUM_POINT_LIGHT_SHADOWS];varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];struct PointLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;float shadowCameraNear;float shadowCameraFar;};uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];\n#endif\n#endif\n#define VIRTUAL_TEXTURE_ARRAY_BLOCKS 4.0\n#define VIRTUAL_TEXTURE_ARRAY_SIZE 512.0\n#define TEX_SIZE (VIRTUAL_TEXTURE_ARRAY_SIZE * VIRTUAL_TEXTURE_ARRAY_BLOCKS)\nconst vec2 texelSize=vec2(1.0/TEX_SIZE,0.0);vec4 texture2D_bilinear(const in sampler2D t,in vec2 uv){uv-=0.5*texelSize.xx;vec2 f=fract(uv*TEX_SIZE);vec2 uvSnapped=uv-texelSize.xx*f+0.5*texelSize.xx;\n#ifdef HEIGHT_LOOKUP_BIAS\nvec4 tl=texture2D(t,uvSnapped,-10.0);vec4 tr=texture2D(t,uvSnapped+texelSize,-10.0);vec4 bl=texture2D(t,uvSnapped+texelSize.yx,-10.0);vec4 br=texture2D(t,uvSnapped+texelSize.xx,-10.0);\n#else\nvec4 tl=texture2D(t,uvSnapped);vec4 tr=texture2D(t,uvSnapped+texelSize);vec4 bl=texture2D(t,uvSnapped+texelSize.yx);vec4 br=texture2D(t,uvSnapped+texelSize.xx);\n#endif\nvec4 tA=mix(tl,tr,f.x);vec4 tB=mix(bl,br,f.x);return mix(tA,tB,f.y);}vec4 readTex(in sampler2D tex,in vec2 uv,in float index){vec2 offset=vec2(mod(float(index),VIRTUAL_TEXTURE_ARRAY_BLOCKS),floor(float(index)/VIRTUAL_TEXTURE_ARRAY_BLOCKS));const float padding=0.5;vec2 limits=vec2(padding,VIRTUAL_TEXTURE_ARRAY_SIZE-padding)/VIRTUAL_TEXTURE_ARRAY_SIZE;vec2 scaledUv=(clamp(uv,limits.x,limits.y)+offset)/VIRTUAL_TEXTURE_ARRAY_BLOCKS;\n#ifdef MANUAL_TEXTURE_BILINEAR\nreturn texture2D_bilinear(tex,scaledUv);\n#else\nreturn texture2D(tex,scaledUv);\n#endif\n}uniform highp sampler2D indirectionTexture;uniform vec2 uGlobalOffset;uniform vec3 uSceneScale;float heightScale(in float tileY){float n=3.141592653589793+uSceneScale.x*tileY;float cosh_n=dot(vec2(0.5),exp(vec2(n,-n)));return uSceneScale.y*cosh_n;}uniform lowp sampler2D elevationArray;float getHeight(in vec2 p){const float indirectionSize=1024.0;vec2 tile=p.xy-uGlobalOffset;tile*=uSceneScale.z;tile*=vec2(1.0,-1.0);vec2 indirectionUv=tile/indirectionSize;const vec2 halfTexel=vec2(0.5);vec2 snapped=(floor(tile-halfTexel)+halfTexel);snapped+=step(halfTexel,tile-snapped);vec2 indirectionUvRounded=snapped/indirectionSize;vec4 indirection=texture2D(indirectionTexture,fract(indirectionUvRounded));float index=indirection.r;float tileSize=indirection.g;vec2 tileOrigin=indirection.ba;vec2 scaledUv=indirectionUv*tileSize+tileOrigin;return heightScale(tile.y)*readTex(elevationArray,scaledUv,index).r;}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}vec3 packNormalToRGB(const in vec3 normal){return normalize(normal)*0.5+0.5;}vec3 unpackRGBToNormal(const in vec3 rgb){return 2.0*rgb.xyz-1.0;}const float PackUpscale=256./255.;const float UnpackDownscale=255./256.;const vec3 PackFactors=vec3(256.*256.*256.,256.*256.,256.);const vec4 UnpackFactors=UnpackDownscale/vec4(PackFactors,1.);const float ShiftRight8=1./256.;vec4 packDepthToRGBA(const in float v){vec4 r=vec4(fract(v*PackFactors),v);r.yzw-=r.xyz*ShiftRight8;return r*PackUpscale;}float unpackRGBAToDepth(const in vec4 v){return dot(v,UnpackFactors);}vec4 pack2HalfToRGBA(vec2 v){vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}vec2 unpackRGBATo2Half(vec4 v){return vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));}float viewZToOrthographicDepth(const in float viewZ,const in float near,const in float far){return(viewZ+near)/(near-far);}float orthographicDepthToViewZ(const in float linearClipZ,const in float near,const in float far){return linearClipZ*(near-far)-near;}float viewZToPerspectiveDepth(const in float viewZ,const in float near,const in float far){return((near+viewZ)*far)/((far-near)*viewZ);}float perspectiveDepthToViewZ(const in float invClipZ,const in float near,const in float far){return(near*far)/((far-near)*invClipZ-far);}void main(){vec4 p=vec4(position.xy,0.0,1.0);p.xy*=uOffset.z;p.xy+=uOffset.xy;vec2 skirt=10.0*floor(position.zw/10.0);vec2 uv=position.zw-skirt;p.z=getHeight(p.xy);p.z-=0.01*uOffset.z*skirt.x;vUV.xy=uImageryUvOffset.z*uv.xy+uImageryUvOffset.xy;vUV.zw=uv.xy;vec4 worldPosition=modelMatrix*p;vec4 mvPosition=viewMatrix*worldPosition;D=-mvPosition.z;gl_Position=projectionMatrix*viewMatrix*worldPosition;\n#ifdef USE_SHADOWMAP\nif(receiveShadow){\n#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\nvec3 shadowWorldNormal=inverseTransformDirection(vec3(0.0,1.0,0.0),viewMatrix);vec4 shadowWorldPosition;\n#endif\n#if NUM_DIR_LIGHT_SHADOWS > 0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*directionalLightShadows[i].shadowNormalBias,0);vDirectionalShadowCoord[i]=directionalShadowMatrix[i]*shadowWorldPosition;}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*spotLightShadows[i].shadowNormalBias,0);vSpotShadowCoord[i]=spotShadowMatrix[i]*shadowWorldPosition;}\n#pragma unroll_loop_end\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){shadowWorldPosition=worldPosition+vec4(shadowWorldNormal*pointLightShadows[i].shadowNormalBias,0);vPointShadowCoord[i]=pointShadowMatrix[i]*shadowWorldPosition;}\n#pragma unroll_loop_end\n#endif\n}\n#endif\n}", terrainFragment = "precision highp float;\n#define GLSLIFY 1\nuniform vec4 uImageryUvOffset;varying vec4 vUV;varying float D;uniform lowp sampler2D imageryArray;uniform float uStyle;uniform vec3 uMaskColor;uniform vec3 fogColor;uniform float fogNear;uniform float fogFar;uniform float opacity;uniform vec3 ambientLightColor;uniform vec3 lightProbe[9];\n#if NUM_DIR_LIGHTS > 0\nstruct DirectionalLight{vec3 direction;vec3 color;};uniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];\n#endif\n#if NUM_POINT_LIGHTS > 0\nstruct PointLight{vec3 position;vec3 color;float distance;float decay;};uniform PointLight pointLights[NUM_POINT_LIGHTS];\n#endif\n#if NUM_SPOT_LIGHTS > 0\nstruct SpotLight{vec3 position;vec3 direction;vec3 color;float distance;float decay;float coneCos;float penumbraCos;};uniform SpotLight spotLights[NUM_SPOT_LIGHTS];\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\nstruct RectAreaLight{vec3 color;vec3 position;vec3 halfWidth;vec3 halfHeight;};uniform sampler2D ltc_1;uniform sampler2D ltc_2;uniform RectAreaLight rectAreaLights[NUM_RECT_AREA_LIGHTS];\n#endif\n#if NUM_HEMI_LIGHTS > 0\nstruct HemisphereLight{vec3 direction;vec3 skyColor;vec3 groundColor;};uniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];\n#endif\nvec3 packNormalToRGB(const in vec3 normal){return normalize(normal)*0.5+0.5;}vec3 unpackRGBToNormal(const in vec3 rgb){return 2.0*rgb.xyz-1.0;}const float PackUpscale=256./255.;const float UnpackDownscale=255./256.;const vec3 PackFactors=vec3(256.*256.*256.,256.*256.,256.);const vec4 UnpackFactors=UnpackDownscale/vec4(PackFactors,1.);const float ShiftRight8=1./256.;vec4 packDepthToRGBA(const in float v){vec4 r=vec4(fract(v*PackFactors),v);r.yzw-=r.xyz*ShiftRight8;return r*PackUpscale;}float unpackRGBAToDepth(const in vec4 v){return dot(v,UnpackFactors);}vec4 pack2HalfToRGBA(vec2 v){vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}vec2 unpackRGBATo2Half(vec4 v){return vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));}float viewZToOrthographicDepth(const in float viewZ,const in float near,const in float far){return(viewZ+near)/(near-far);}float orthographicDepthToViewZ(const in float linearClipZ,const in float near,const in float far){return linearClipZ*(near-far)-near;}float viewZToPerspectiveDepth(const in float viewZ,const in float near,const in float far){return((near+viewZ)*far)/((far-near)*viewZ);}float perspectiveDepthToViewZ(const in float invClipZ,const in float near,const in float far){return(near*far)/((far-near)*invClipZ-far);}\n#ifdef USE_SHADOWMAP\nuniform bool receiveShadow;\n#if NUM_DIR_LIGHT_SHADOWS > 0\nuniform sampler2D directionalShadowMap[NUM_DIR_LIGHT_SHADOWS];varying vec4 vDirectionalShadowCoord[NUM_DIR_LIGHT_SHADOWS];struct DirectionalLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform DirectionalLightShadow directionalLightShadows[NUM_DIR_LIGHT_SHADOWS];\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nuniform sampler2D spotShadowMap[NUM_SPOT_LIGHT_SHADOWS];varying vec4 vSpotShadowCoord[NUM_SPOT_LIGHT_SHADOWS];struct SpotLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;};uniform SpotLightShadow spotLightShadows[NUM_SPOT_LIGHT_SHADOWS];\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nuniform sampler2D pointShadowMap[NUM_POINT_LIGHT_SHADOWS];varying vec4 vPointShadowCoord[NUM_POINT_LIGHT_SHADOWS];struct PointLightShadow{float shadowBias;float shadowNormalBias;float shadowRadius;vec2 shadowMapSize;float shadowCameraNear;float shadowCameraFar;};uniform PointLightShadow pointLightShadows[NUM_POINT_LIGHT_SHADOWS];\n#endif\nfloat texture2DCompare(sampler2D depths,vec2 uv,float compare){return step(compare,unpackRGBAToDepth(texture2D(depths,uv)));}vec2 texture2DDistribution(sampler2D shadow,vec2 uv){return unpackRGBATo2Half(texture2D(shadow,uv));}float VSMShadow(sampler2D shadow,vec2 uv,float compare){float occlusion=1.0;vec2 distribution=texture2DDistribution(shadow,uv);float hard_shadow=step(compare,distribution.x);if(hard_shadow!=1.0){float distance=compare-distribution.x;float variance=max(0.00000,distribution.y*distribution.y);float softness_probability=variance/(variance+distance*distance);softness_probability=clamp((softness_probability-0.3)/(0.95-0.3),0.0,1.0);occlusion=clamp(max(hard_shadow,softness_probability),0.0,1.0);}return occlusion;}float getShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowBias,float shadowRadius,vec4 shadowCoord){float shadow=1.0;shadowCoord.xyz/=shadowCoord.w;shadowCoord.z+=shadowBias;bvec4 inFrustumVec=bvec4(shadowCoord.x>=0.0,shadowCoord.x<=1.0,shadowCoord.y>=0.0,shadowCoord.y<=1.0);bool inFrustum=all(inFrustumVec);bvec2 frustumTestVec=bvec2(inFrustum,shadowCoord.z<=1.0);bool frustumTest=all(frustumTestVec);if(frustumTest){\n#if defined( SHADOWMAP_TYPE_PCF )\nvec2 texelSize=vec2(1.0)/shadowMapSize;float dx0=-texelSize.x*shadowRadius;float dy0=-texelSize.y*shadowRadius;float dx1=+texelSize.x*shadowRadius;float dy1=+texelSize.y*shadowRadius;float dx2=dx0/2.0;float dy2=dy0/2.0;float dx3=dx1/2.0;float dy3=dy1/2.0;shadow=(texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,dy0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,dy2),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,0.0),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx2,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx3,dy3),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx0,dy1),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(0.0,dy1),shadowCoord.z)+texture2DCompare(shadowMap,shadowCoord.xy+vec2(dx1,dy1),shadowCoord.z))*(1.0/17.0);\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\nvec2 texelSize=vec2(1.0)/shadowMapSize;float dx=texelSize.x;float dy=texelSize.y;vec2 uv=shadowCoord.xy;vec2 f=fract(uv*shadowMapSize+0.5);uv-=f*texelSize;shadow=(texture2DCompare(shadowMap,uv,shadowCoord.z)+texture2DCompare(shadowMap,uv+vec2(dx,0.0),shadowCoord.z)+texture2DCompare(shadowMap,uv+vec2(0.0,dy),shadowCoord.z)+texture2DCompare(shadowMap,uv+texelSize,shadowCoord.z)+mix(texture2DCompare(shadowMap,uv+vec2(-dx,0.0),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,0.0),shadowCoord.z),f.x)+mix(texture2DCompare(shadowMap,uv+vec2(-dx,dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,dy),shadowCoord.z),f.x)+mix(texture2DCompare(shadowMap,uv+vec2(0.0,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(0.0,2.0*dy),shadowCoord.z),f.y)+mix(texture2DCompare(shadowMap,uv+vec2(dx,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(dx,2.0*dy),shadowCoord.z),f.y)+mix(mix(texture2DCompare(shadowMap,uv+vec2(-dx,-dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,-dy),shadowCoord.z),f.x),mix(texture2DCompare(shadowMap,uv+vec2(-dx,2.0*dy),shadowCoord.z),texture2DCompare(shadowMap,uv+vec2(2.0*dx,2.0*dy),shadowCoord.z),f.x),f.y))*(1.0/9.0);\n#elif defined( SHADOWMAP_TYPE_VSM )\nshadow=VSMShadow(shadowMap,shadowCoord.xy,shadowCoord.z);\n#else\nshadow=texture2DCompare(shadowMap,shadowCoord.xy,shadowCoord.z);\n#endif\n}return shadow;}vec2 cubeToUV(vec3 v,float texelSizeY){vec3 absV=abs(v);float scaleToCube=1.0/max(absV.x,max(absV.y,absV.z));absV*=scaleToCube;v*=scaleToCube*(1.0-2.0*texelSizeY);vec2 planar=v.xy;float almostATexel=1.5*texelSizeY;float almostOne=1.0-almostATexel;if(absV.z>=almostOne){if(v.z>0.0)planar.x=4.0-v.x;}else if(absV.x>=almostOne){float signX=sign(v.x);planar.x=v.z*signX+2.0*signX;}else if(absV.y>=almostOne){float signY=sign(v.y);planar.x=v.x+2.0*signY+2.0;planar.y=v.z*signY-2.0;}return vec2(0.125,0.25)*planar+vec2(0.375,0.75);}float getPointShadow(sampler2D shadowMap,vec2 shadowMapSize,float shadowBias,float shadowRadius,vec4 shadowCoord,float shadowCameraNear,float shadowCameraFar){vec2 texelSize=vec2(1.0)/(shadowMapSize*vec2(4.0,2.0));vec3 lightToPosition=shadowCoord.xyz;float dp=(length(lightToPosition)-shadowCameraNear)/(shadowCameraFar-shadowCameraNear);dp+=shadowBias;vec3 bd3D=normalize(lightToPosition);\n#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\nvec2 offset=vec2(-1,1)*shadowRadius*texelSize.y;return(texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xyy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yyy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xyx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yyx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xxy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yxy,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.xxx,texelSize.y),dp)+texture2DCompare(shadowMap,cubeToUV(bd3D+offset.yxx,texelSize.y),dp))*(1.0/9.0);\n#else\nreturn texture2DCompare(shadowMap,cubeToUV(bd3D,texelSize.y),dp);\n#endif\n}\n#endif\nfloat fogFactor(in float dist){float fog=smoothstep(fogNear,fogFar,dist);return clamp(fog,0.0,1.0);}float fogFactor(in vec3 camera,in vec3 pos){float dist=distance(camera,pos);return fogFactor(dist);}\n#define VIRTUAL_TEXTURE_ARRAY_BLOCKS 16.0\n#define VIRTUAL_TEXTURE_ARRAY_SIZE 256.0\n#define TEX_SIZE (VIRTUAL_TEXTURE_ARRAY_SIZE * VIRTUAL_TEXTURE_ARRAY_BLOCKS)\nconst vec2 texelSize=vec2(1.0/TEX_SIZE,0.0);vec4 texture2D_bilinear(const in sampler2D t,in vec2 uv){uv-=0.5*texelSize.xx;vec2 f=fract(uv*TEX_SIZE);vec2 uvSnapped=uv-texelSize.xx*f+0.5*texelSize.xx;\n#ifdef HEIGHT_LOOKUP_BIAS\nvec4 tl=texture2D(t,uvSnapped,-10.0);vec4 tr=texture2D(t,uvSnapped+texelSize,-10.0);vec4 bl=texture2D(t,uvSnapped+texelSize.yx,-10.0);vec4 br=texture2D(t,uvSnapped+texelSize.xx,-10.0);\n#else\nvec4 tl=texture2D(t,uvSnapped);vec4 tr=texture2D(t,uvSnapped+texelSize);vec4 bl=texture2D(t,uvSnapped+texelSize.yx);vec4 br=texture2D(t,uvSnapped+texelSize.xx);\n#endif\nvec4 tA=mix(tl,tr,f.x);vec4 tB=mix(bl,br,f.x);return mix(tA,tB,f.y);}vec4 readTex(in sampler2D tex,in vec2 uv,in float index){vec2 offset=vec2(mod(float(index),VIRTUAL_TEXTURE_ARRAY_BLOCKS),floor(float(index)/VIRTUAL_TEXTURE_ARRAY_BLOCKS));const float padding=0.5;vec2 limits=vec2(padding,VIRTUAL_TEXTURE_ARRAY_SIZE-padding)/VIRTUAL_TEXTURE_ARRAY_SIZE;vec2 scaledUv=(clamp(uv,limits.x,limits.y)+offset)/VIRTUAL_TEXTURE_ARRAY_BLOCKS;\n#ifdef MANUAL_TEXTURE_BILINEAR\nreturn texture2D_bilinear(tex,scaledUv);\n#else\nreturn texture2D(tex,scaledUv);\n#endif\n}float getShadowMask(){float shadow=1.0;\n#ifdef USE_SHADOWMAP\n#if NUM_DIR_LIGHT_SHADOWS > 0\nDirectionalLightShadow directionalLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_DIR_LIGHT_SHADOWS;i++){directionalLight=directionalLightShadows[i];shadow*=receiveShadow ? getShadow(directionalShadowMap[i],directionalLight.shadowMapSize,directionalLight.shadowBias,directionalLight.shadowRadius,vDirectionalShadowCoord[i]): 1.0;}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHT_SHADOWS > 0\nSpotLightShadow spotLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_SPOT_LIGHT_SHADOWS;i++){spotLight=spotLightShadows[i];shadow*=receiveShadow ? getShadow(spotShadowMap[i],spotLight.shadowMapSize,spotLight.shadowBias,spotLight.shadowRadius,vSpotShadowCoord[i]): 1.0;}\n#pragma unroll_loop_end\n#endif\n#if NUM_POINT_LIGHT_SHADOWS > 0\nPointLightShadow pointLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_POINT_LIGHT_SHADOWS;i++){pointLight=pointLightShadows[i];shadow*=receiveShadow ? getPointShadow(pointShadowMap[i],pointLight.shadowMapSize,pointLight.shadowBias,pointLight.shadowRadius,vPointShadowCoord[i],pointLight.shadowCameraNear,pointLight.shadowCameraFar): 1.0;}\n#pragma unroll_loop_end\n#endif\n#endif\nreturn shadow;}vec3 shGetIrradianceAt(in vec3 normal,in vec3 shCoefficients[9]){float x=normal.x,y=normal.y,z=normal.z;vec3 result=shCoefficients[0]*0.886227;result+=shCoefficients[1]*2.0*0.511664*y;result+=shCoefficients[2]*2.0*0.511664*z;result+=shCoefficients[3]*2.0*0.511664*x;result+=shCoefficients[4]*2.0*0.429043*x*y;result+=shCoefficients[5]*2.0*0.429043*y*z;result+=shCoefficients[6]*(0.743125*z*z-0.247708);result+=shCoefficients[7]*2.0*0.429043*x*z;result+=shCoefficients[8]*0.429043*(x*x-y*y);return result;}void main(){vec3 color=readTex(imageryArray,vUV.xy,uImageryUvOffset.w).rgb;vec3 irradiance=shGetIrradianceAt(vec3(0.0,1.0,0.0),lightProbe)+ambientLightColor;vec3 shadowLightsIrradiance=vec3(0.0);\n#if NUM_DIR_LIGHTS > 0\nDirectionalLight directionalLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_DIR_LIGHTS;i++){directionalLight=directionalLights[i];shadowLightsIrradiance+=directionalLight.color;}\n#pragma unroll_loop_end\n#endif\n#if NUM_POINT_LIGHTS > 0\nPointLight pointLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_POINT_LIGHTS;i++){pointLight=pointLights[i];shadowLightsIrradiance+=pointLight.color;}\n#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\nSpotLight spotLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_SPOT_LIGHTS;i++){spotLight=spotLights[i];shadowLightsIrradiance+=spotLight.color;}\n#pragma unroll_loop_end\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\nRectAreaLight rectAreaLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_RECT_AREA_LIGHTS;i++){rectAreaLight=rectAreaLights[i];shadowLightsIrradiance+=rectAreaLight.color;}\n#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\nHemisphereLight hemisphereLight;\n#pragma unroll_loop_start\nfor(int i=0;i<NUM_HEMI_LIGHTS;i++){hemisphereLight=hemisphereLights[i];shadowLightsIrradiance+=hemisphereLight.color;}\n#pragma unroll_loop_end\n#endif\nvec3 shadowStep=step(irradiance,shadowLightsIrradiance);color*=(irradiance+(shadowLightsIrradiance)*shadowStep*getShadowMask());if(uStyle>0.0){float grey=color.r*0.2989+color.g*0.587+color.b*0.114;if(uStyle==1.0){color=vec3(1.0-color.r,1.0*color.g,1.0-color.b);}if(uStyle==2.0){color=vec3(grey);color*=uMaskColor;}if(uStyle==3.0){vec3 maskColor=clamp(uMaskColor,vec3(0.004,0.004,0.004),vec3(1.0,1.0,1.0));color=vec3(1.0-(1.0-grey)/maskColor.r,1.0-(1.0-grey)/maskColor.g,1.0-(1.0-grey)/maskColor.b);}if(uStyle==4.0){color=vec3(grey+uMaskColor.r-1.0,grey+uMaskColor.g-1.0,grey+uMaskColor.b-1.0);}}float fogAmount=fogFactor(D);color=mix(color,fogColor,fogAmount);gl_FragColor=vec4(color,opacity);}", terrainVertexCoord = "precision highp float;\n#define GLSLIFY 1\nuniform mat4 modelMatrix;uniform mat4 viewMatrix;uniform mat4 projectionMatrix;uniform vec3 cameraPosition;attribute vec4 position;uniform vec4 uOffset;uniform vec4 uImageryUvOffset;varying vec4 vUV;varying float D;varying vec4 coord;\n#define VIRTUAL_TEXTURE_ARRAY_BLOCKS 4.0\n#define VIRTUAL_TEXTURE_ARRAY_SIZE 512.0\n#define TEX_SIZE (VIRTUAL_TEXTURE_ARRAY_SIZE * VIRTUAL_TEXTURE_ARRAY_BLOCKS)\nconst vec2 texelSize=vec2(1.0/TEX_SIZE,0.0);vec4 texture2D_bilinear(const in sampler2D t,in vec2 uv){uv-=0.5*texelSize.xx;vec2 f=fract(uv*TEX_SIZE);vec2 uvSnapped=uv-texelSize.xx*f+0.5*texelSize.xx;\n#ifdef HEIGHT_LOOKUP_BIAS\nvec4 tl=texture2D(t,uvSnapped,-10.0);vec4 tr=texture2D(t,uvSnapped+texelSize,-10.0);vec4 bl=texture2D(t,uvSnapped+texelSize.yx,-10.0);vec4 br=texture2D(t,uvSnapped+texelSize.xx,-10.0);\n#else\nvec4 tl=texture2D(t,uvSnapped);vec4 tr=texture2D(t,uvSnapped+texelSize);vec4 bl=texture2D(t,uvSnapped+texelSize.yx);vec4 br=texture2D(t,uvSnapped+texelSize.xx);\n#endif\nvec4 tA=mix(tl,tr,f.x);vec4 tB=mix(bl,br,f.x);return mix(tA,tB,f.y);}vec4 readTex(in sampler2D tex,in vec2 uv,in float index){vec2 offset=vec2(mod(float(index),VIRTUAL_TEXTURE_ARRAY_BLOCKS),floor(float(index)/VIRTUAL_TEXTURE_ARRAY_BLOCKS));const float padding=0.5;vec2 limits=vec2(padding,VIRTUAL_TEXTURE_ARRAY_SIZE-padding)/VIRTUAL_TEXTURE_ARRAY_SIZE;vec2 scaledUv=(clamp(uv,limits.x,limits.y)+offset)/VIRTUAL_TEXTURE_ARRAY_BLOCKS;\n#ifdef MANUAL_TEXTURE_BILINEAR\nreturn texture2D_bilinear(tex,scaledUv);\n#else\nreturn texture2D(tex,scaledUv);\n#endif\n}uniform highp sampler2D indirectionTexture;uniform vec2 uGlobalOffset;uniform vec3 uSceneScale;float heightScale(in float tileY){float n=3.141592653589793+uSceneScale.x*tileY;float cosh_n=dot(vec2(0.5),exp(vec2(n,-n)));return uSceneScale.y*cosh_n;}uniform lowp sampler2D elevationArray;float getHeight(in vec2 p){const float indirectionSize=1024.0;vec2 tile=p.xy-uGlobalOffset;tile*=uSceneScale.z;tile*=vec2(1.0,-1.0);vec2 indirectionUv=tile/indirectionSize;const vec2 halfTexel=vec2(0.5);vec2 snapped=(floor(tile-halfTexel)+halfTexel);snapped+=step(halfTexel,tile-snapped);vec2 indirectionUvRounded=snapped/indirectionSize;vec4 indirection=texture2D(indirectionTexture,fract(indirectionUvRounded));float index=indirection.r;float tileSize=indirection.g;vec2 tileOrigin=indirection.ba;vec2 scaledUv=indirectionUv*tileSize+tileOrigin;return heightScale(tile.y)*readTex(elevationArray,scaledUv,index).r;}vec3 inverseTransformDirection(in vec3 dir,in mat4 matrix){return normalize((vec4(dir,0.0)*matrix).xyz);}vec3 packNormalToRGB(const in vec3 normal){return normalize(normal)*0.5+0.5;}vec3 unpackRGBToNormal(const in vec3 rgb){return 2.0*rgb.xyz-1.0;}const float PackUpscale=256./255.;const float UnpackDownscale=255./256.;const vec3 PackFactors=vec3(256.*256.*256.,256.*256.,256.);const vec4 UnpackFactors=UnpackDownscale/vec4(PackFactors,1.);const float ShiftRight8=1./256.;vec4 packDepthToRGBA(const in float v){vec4 r=vec4(fract(v*PackFactors),v);r.yzw-=r.xyz*ShiftRight8;return r*PackUpscale;}float unpackRGBAToDepth(const in vec4 v){return dot(v,UnpackFactors);}vec4 pack2HalfToRGBA(vec2 v){vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}vec2 unpackRGBATo2Half(vec4 v){return vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));}float viewZToOrthographicDepth(const in float viewZ,const in float near,const in float far){return(viewZ+near)/(near-far);}float orthographicDepthToViewZ(const in float linearClipZ,const in float near,const in float far){return linearClipZ*(near-far)-near;}float viewZToPerspectiveDepth(const in float viewZ,const in float near,const in float far){return((near+viewZ)*far)/((far-near)*viewZ);}float perspectiveDepthToViewZ(const in float invClipZ,const in float near,const in float far){return(near*far)/((far-near)*invClipZ-far);}void main(){vec4 p=vec4(position.xy,0.0,1.0);p.xy*=uOffset.z;p.xy+=uOffset.xy;vec2 skirt=10.0*floor(position.zw/10.0);vec2 uv=position.zw-skirt;p.z=getHeight(p.xy);vUV.xy=uImageryUvOffset.z*uv.xy+uImageryUvOffset.xy;vUV.zw=uv.xy;vec4 worldPosition=modelMatrix*p;vec4 mvPosition=viewMatrix*worldPosition;D=-mvPosition.z;coord=worldPosition;gl_Position=projectionMatrix*viewMatrix*worldPosition;}", terrainFragmentCoord = "precision highp float;\n#define GLSLIFY 1\nuniform int uPass;varying vec4 vUV;varying vec4 coord;const float PackUpscale=256./255.;const vec3 PackFactors=vec3(256.*256.*256.,256.*256.,256.);const float ShiftRight8=1./256.;vec4 packDepthToRGBA(const in float v){vec4 r=vec4(fract(v*PackFactors),v);r.yzw-=r.xyz*ShiftRight8;return r*PackUpscale;}vec4 packToRGBA(const in float v){if(v>8388608.||v<-8388608.){return vec4(0.0,0.0,0.0,0.0);}float a=v;a+=8388608.;float r=floor(a/65536.);a-=r*65536.;float g=floor(a/256.);a-=g*256.;float b=floor(a);a-=b;a=255.-floor(0.5+a*10.);return vec4(1.,1.,1.,0.5);return vec4(r/255.,g/255.,b/255.,0.5);return vec4(r/255.,g/255.,b/255.,a/255.);}vec4 packToRGBAFloat(const in float v){return vec4(vec3(v),1.);}vec4 packToRGBA2000(const in float v){float a=v;a+=1000.;return vec4(a/2000.,1.,1.,1.);}vec4 packToRGBADEC(float v){float r=floor(abs(v)/1000000.);float g=floor((abs(v)-r*1000000.)/10000.);float b=floor((abs(v)-r*1000000.-g*10000.)/100.);float a=abs(v)-r*1000000.-g*10000.-b*100.;if(v<0.){r+=100.;}return vec4(r/255.,g/255.,b/255.,a/255.);}vec4 packToRGBAFract(const in float v){return vec4(v/65536.,v-floor(v/256.)*256.,1.,1.);}vec4 packToRGBAFloor(const in float v){float sign=v/abs(v);return vec4(floor(abs(v)/256.)/255.0,fract(abs(v)/256.),(sign+1.0)/2.0,fract(abs(v))+0.5);}void main(){gl_FragColor=vec4(coord.xyz,1.);}", terrainPickerVertex = "#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nuniform mat4 viewMatrix;uniform mat4 projectionMatrix;in vec4 position;uniform vec4 uOffset;uniform vec4 uImageryUvOffset;uniform vec3 uScaling;out vec4 vUV;\n#define MANUAL_TEXTURE_BILINEAR 1\n#define VIRTUAL_TEXTURE_ARRAY_BLOCKS 4.0\n#define VIRTUAL_TEXTURE_ARRAY_SIZE 512.0\n#define TEX_SIZE (VIRTUAL_TEXTURE_ARRAY_SIZE * VIRTUAL_TEXTURE_ARRAY_BLOCKS)\nconst vec2 texelSize=vec2(1.0/TEX_SIZE,0.0);vec4 texture2D_bilinear(const in sampler2D t,in vec2 uv){uv-=0.5*texelSize.xx;vec2 f=fract(uv*TEX_SIZE);vec2 uvSnapped=uv-texelSize.xx*f+0.5*texelSize.xx;\n#ifdef HEIGHT_LOOKUP_BIAS\nvec4 tl=texture(t,uvSnapped,-10.0);vec4 tr=texture(t,uvSnapped+texelSize,-10.0);vec4 bl=texture(t,uvSnapped+texelSize.yx,-10.0);vec4 br=texture(t,uvSnapped+texelSize.xx,-10.0);\n#else\nvec4 tl=texture(t,uvSnapped);vec4 tr=texture(t,uvSnapped+texelSize);vec4 bl=texture(t,uvSnapped+texelSize.yx);vec4 br=texture(t,uvSnapped+texelSize.xx);\n#endif\nvec4 tA=mix(tl,tr,f.x);vec4 tB=mix(bl,br,f.x);return mix(tA,tB,f.y);}vec4 readTex(in sampler2D tex,in vec2 uv,in float index){vec2 offset=vec2(mod(float(index),VIRTUAL_TEXTURE_ARRAY_BLOCKS),floor(float(index)/VIRTUAL_TEXTURE_ARRAY_BLOCKS));const float padding=0.5;vec2 limits=vec2(padding,VIRTUAL_TEXTURE_ARRAY_SIZE-padding)/VIRTUAL_TEXTURE_ARRAY_SIZE;vec2 scaledUv=(clamp(uv,limits.x,limits.y)+offset)/VIRTUAL_TEXTURE_ARRAY_BLOCKS;\n#ifdef MANUAL_TEXTURE_BILINEAR\nreturn texture2D_bilinear(tex,scaledUv);\n#else\nreturn texture(tex,scaledUv);\n#endif\n}uniform highp sampler2D indirectionTexture;uniform vec2 uGlobalOffset;uniform vec3 uSceneScale;float heightScale(in float tileY){float n=3.141592653589793+uSceneScale.x*tileY;float cosh_n=dot(vec2(0.5),exp(vec2(n,-n)));return uSceneScale.y*cosh_n;}uniform lowp sampler2D elevationArray;float getHeight(in vec2 p){const float indirectionSize=1024.0;vec2 tile=p.xy-uGlobalOffset;tile*=uSceneScale.z;tile*=vec2(1.0,-1.0);vec2 indirectionUv=tile/indirectionSize;const vec2 halfTexel=vec2(0.5);vec2 snapped=(floor(tile-halfTexel)+halfTexel);snapped+=step(halfTexel,tile-snapped);vec2 indirectionUvRounded=snapped/indirectionSize;vec4 indirection=texture(indirectionTexture,fract(indirectionUvRounded));float index=indirection.r;float tileSize=indirection.g;vec2 tileOrigin=indirection.ba;vec2 scaledUv=indirectionUv*tileSize+tileOrigin;return heightScale(tile.y)*readTex(elevationArray,scaledUv,index).r;}void main(){vec4 p=vec4(position.xy,0.0,1.0);p.xy*=uOffset.z;p.xy+=uOffset.xy;vec2 skirt=10.0*floor(position.zw/10.0);vec2 uv=position.zw-skirt;p.z=getHeight(p.xy);p.z-=0.01*uOffset.z*skirt.x;float tileId=uOffset.w;vec2 encodedTileId=vec2(floor(tileId/256.0)/256.0,fract(tileId/256.0))*(256.0/255.0);vUV.xy=uv.xy*uScaling.z;vUV.zw=encodedTileId;vec4 pYUp=vec4(p.x,p.z,-p.y,p.w);gl_Position=projectionMatrix*viewMatrix*pYUp;}", terrainPickerFragment = "#version 300 es\nprecision highp float;\n#define GLSLIFY 1\nuniform vec3 uScaling;in vec4 vUV;out highp vec4 pc_fragColor;void main(){vec2 deltaUV=dFdx(vUV.xy);float err=log2(length(deltaUV));vec2 encodedTileId=vUV.zw;float encodedError=0.1*err+0.5;float scaledZ=256.0*255.0*gl_FragCoord.z;vec2 encodedZ=vec2(floor(scaledZ/256.0),mod(scaledZ,256.0))/255.0;float isCenter=step(distance(gl_FragCoord.xy,uScaling.xy),4.0);vec4 standard=vec4(encodedTileId,0.0,encodedError);vec4 centerPixels=vec4(0.0,0.0,encodedZ);pc_fragColor=mix(standard,centerPixels,isCenter);}"; const tilepickerUniforms = { uScaling: { value: new Vector3 } }; class MapTileGeometry { constructor(e, t, i = !0) { let r = [0, 0]; t = t || 1; let n, a, o = r[0], s = r[1], l = (e = e || [1, 1])[0], c = e[1], h = t + 1, u = new Array(h * h); for (n = 0; n < h; n++)for (a = 0; a < h; a++) { u[n * h + a] = { x: o + n * (l / t), y: s - a * (c / t), uvx: n / t, uvy: a / t } } let d = 6 * t * t; i && (d += 24 * t), this.positions = new Float32Array(4 * d), this.index = new Array(d); let p = 0, f = (e, t, i, r, n) => { let a = u[t], o = u[i], s = u[r], l = u[n]; let c = e => [e.x, e.y, e.uvx, e.uvy]; this.positions.set(c(a), 4 * (e + 0)), this.positions.set(c(o), 4 * (e + 1)), this.positions.set(c(s), 4 * (e + 2)), this.positions.set(c(s), 4 * (e + 3)), this.positions.set(c(o), 4 * (e + 4)), this.positions.set(c(l), 4 * (e + 5)), this.index[e + 0] = t, this.index[e + 1] = i, this.index[e + 2] = r, this.index[e + 3] = r, this.index[e + 4] = i, this.index[e + 5] = n }; for (n = 0; n < t; n++)for (a = 0; a < t; a++, p++) { f(6 * p, n * h + a, n * h + a + 1, (n + 1) * h + a, (n + 1) * h + a + 1) } if (i) for (let e = 0; e < 4; e++)for (let i = 0; i < t; i++, p++) { let r, o; 0 === e ? (n = 0, a = i) : 1 === e ? (n = t, a = i) : 2 === e ? (n = i, a = 0) : 3 === e && (n = i, a = t), e < 2 ? (r = u[n * h + a], o = u[n * h + a + 1]) : (r = u[n * h + a], o = u[(n + 1) * h + a]), 0 !== e && 3 !== e || ([r, o] = [o, r]); let s = r, l = o; this.positions[24 * p] = r.x, this.positions[24 * p + 1] = r.y, this.positions[4 * (6 * p + 1)] = o.x, this.positions[4 * (6 * p + 1) + 1] = o.y, this.positions[4 * (6 * p + 2)] = s.x, this.positions[4 * (6 * p + 2) + 1] = s.y, this.positions[4 * (6 * p + 3)] = s.x, this.positions[4 * (6 * p + 3) + 1] = s.y, this.positions[4 * (6 * p + 4)] = o.x, this.positions[4 * (6 * p + 4) + 1] = o.y, this.positions[4 * (6 * p + 5)] = l.x, this.positions[4 * (6 * p + 5) + 1] = l.y, this.positions[24 * p + 2] = r.uvx, this.positions[24 * p + 3] = r.uvy, this.positions[4 * (6 * p + 1) + 2] = o.uvx, this.positions[4 * (6 * p + 1) + 3] = o.uvy, this.positions[4 * (6 * p + 2) + 2] = s.uvx + 10, this.positions[4 * (6 * p + 2) + 3] = s.uvy + 10, this.positions[4 * (6 * p + 3) + 2] = s.uvx + 10, this.positions[4 * (6 * p + 3) + 3] = s.uvy + 10, this.positions[4 * (6 * p + 4) + 2] = o.uvx, this.positions[4 * (6 * p + 4) + 3] = o.uvy, this.positions[4 * (6 * p + 5) + 2] = l.uvx + 10, this.positions[4 * (6 * p + 5) + 3] = l.uvy + 10 } for (d = u.length, this.grid = new Float32Array(4 * d), n = 0; n < d; n++) { let e = u[n]; this.grid[4 * n + 0] = e.x, this.grid[4 * n + 1] = e.y, this.grid[4 * n + 2] = e.uvx, this.grid[4 * n + 3] = e.uvy } } } const Shader = function (e) { this.value = e }; Shader.prototype.define = function (e, t) { var i = new RegExp("#define " + e + " .*", "g"), r = "#define " + e + (t ? " " + t : ""); this.value.match(i) ? this.value = this.value.replace(i, r) : this.value = r + "\n" + this.value }, Shader.prototype.clone = function () { return new Shader(this.value) }; let terrainVertex2 = new Shader(terrainVertex), terrainVertexCoord2 = new Shader(terrainVertexCoord), terrainFragment2 = new Shader(terrainFragment), terrainFragmentCoord2 = new Shader(terrainFragmentCoord), terrainPickerVertex2 = new Shader(terrainPickerVertex), terrainPickerFragment2 = new Shader(terrainPickerFragment);[terrainVertex2, terrainVertexCoord2, terrainPickerVertex2].forEach((e => { INTERPOLATE_FLOAT || e.define("MANUAL_TEXTURE_BILINEAR", "1"), e.define("VIRTUAL_TEXTURE_ARRAY_BLOCKS", Math.sqrt(ELEVATION_POOL_SIZE).toExponential()), e.define("VIRTUAL_TEXTURE_ARRAY_SIZE", ELEVATION_TILE_SIZE.toExponential()) })), terrainFragment2.define("VIRTUAL_TEXTURE_ARRAY_BLOCKS", Math.sqrt(IMAGERY_POOL_SIZE).toExponential()), terrainFragment2.define("VIRTUAL_TEXTURE_ARRAY_SIZE", IMAGERY_TILE_SIZE.toExponential()), terrainFragmentCoord2.define("VIRTUAL_TEXTURE_ARRAY_BLOCKS", Math.sqrt(IMAGERY_POOL_SIZE).toExponential()), terrainFragmentCoord2.define("VIRTUAL_TEXTURE_ARRAY_SIZE", IMAGERY_TILE_SIZE.toExponential()); const exponent = 2; let tilePool = [], idCounter = 1; class Tile { constructor() { this.id = idCounter++; const e = this.refreshIndices.bind(this); Tile.imageryDatasource && Tile.imageryDatasource.addListener(e), Tile.elevationDatasource && Tile.elevationDatasource.addListener(e); let t = Tile.geometry[64]; t = t.getGeometry(), this.offset = new Vector4(0, 0, 1, 1), this.imageryUvOffset = new Vector4, this.terrainMaterial = new RawShaderMaterial({ uniforms: lodash.assign({ uOffset: { value: this.offset }, uImageryUvOffset: { value: this.imageryUvOffset }, receiveShadow: { value: !!Tile.receiveShadow }, ambientLightColor: { value: null }, lightProbe: { value: null }, directionalLights: { value: null }, directionalLightShadows: { value: null }, spotLights: { value: null }, spotLightShadows: { value: null }, rectAreaLights: { value: null }, ltc_1: { value: null }, ltc_2: { value: null }, pointLights: { value: null }, pointLightShadows: { value: null }, hemisphereLights: { value: null }, directionalShadowMap: { value: null }, directionalShadowMatrix: { value: null }, spotShadowMap: { value: null }, spotShadowMatrix: { value: null }, pointShadowMap: { value: null }, pointShadowMatrix: { value: null }, shadowMapType: { value: null }, imageryArray: { value: Tile.imageryDatasource.textureArray }, opacity: { type: "f", value: Tile.opacity } }, Tile.fogUniforms, Tile.styleUniforms, _context.pgl.heightUniforms), vertexShader: terrainVertex2.value, fragmentShader: terrainFragment2.value, transparent: !0 }), this.terrainMaterial.name = "TerrainMaterialImagery", this.terrainMaterial.fog = !0, this.terrainMaterial.polygonOffset = !0, this.terrainMaterial.polygonOffsetFactor = 1, this.terrainMaterial.polygonOffsetUnits = 1, this.terrainMaterial.lights = !0, this.terrainCoordMaterial = new RawShaderMaterial({ uniforms: lodash.assign({ uOffset: { value: this.offset }, uImageryUvOffset: { value: this.imageryUvOffset }, uPass: { value: 0 } }, _context.pgl.heightUniforms), vertexShader: terrainVertexCoord2.value, fragmentShader: terrainFragmentCoord2.value, transparent: !0 }), this.terrainPickerMaterial = new RawShaderMaterial({ uniforms: lodash.assign({ uOffset: { value: this.offset }, uImageryUvOffset: { value: this.imageryUvOffset }, receiveShadow: { value: !!Tile.receiveShadow }, ambientLightColor: { value: null }, lightProbe: { value: null }, directionalLights: { value: null }, directionalLightShadows: { value: null }, spotLights: { value: null }, spotLightShadows: { value: null }, rectAreaLights: { value: null }, ltc_1: { value: null }, ltc_2: { value: null }, pointLights: { value: null }, pointLightShadows: { value: null }, hemisphereLights: { value: null }, directionalShadowMap: { value: null }, directionalShadowMatrix: { value: null }, spotShadowMap: { value: null }, spotShadowMatrix: { value: null }, pointShadowMap: { value: null }, pointShadowMatrix: { value: null }, shadowMapType: { value: null } }, _context.pgl.heightUniforms, tilepickerUniforms), vertexShader: terrainPickerVertex2.value, fragmentShader: terrainPickerFragment2.value }), this.mesh = new Mesh(t, this.terrainMaterial), this.mesh.receiveShadow = !0, this.mesh.raycast = function (e, t) { }, this.terrainPickerMaterial.name = "TerrainMaterialPicker", this.pickerMesh = new Mesh(t, this.terrainPickerMaterial), this.init(...arguments) } init(e, t, i) { if (isNaN(e) || isNaN(t) || isNaN(i)) throw Error("Invalid tile initialization"); this.wasSeen = !1, this.wasRendered = !1, _context.scene.pgl.add(this.mesh), _context.scene.tilepickerScene.add(this.pickerMesh), this.x = e, this.y = t, this.z = i; let r = Math.max(exponent, this.z - (Tile.elevationDatasource ? Tile.elevationDatasource.maxZoom : 0)); this.x2 = Math.floor(this.x / Math.pow(2, r)), this.y2 = Math.floor(this.y / Math.pow(2, r)), this.z2 = this.z - r; let n = 1024 / Math.pow(2, r); n = Math.min(64, Math.max(1, n)); let a = Tile.geometry[n].clone(); a = a.getGeometry(); let o = Tile.geometry[Math.max(1, n / 8)].clone(); o = o.getGeometry(), this.mesh.geometry = a, this.pickerMesh.geometry = o, this.calculateOffset(), this.imageryKey = tilebelt.tileToQuadkey([this.x, this.y, this.z]), this.elevationKey = tilebelt.tileToQuadkey([this.x2, this.y2, this.z2]), this.imageryIndex = 0, this.elevationIndex = 0; let s = new Vector3(this.offset.x + .5 * this.offset.z, this.offset.y - .5 * this.offset.z, .5 * this.offset.w * 3800), l = Math.max(.5 * this.offset.w * 4200, .5 * this.offset.z); l *= Math.sqrt(3); let c = new Sphere(s, l); return this.mesh.geometry.boundingSphere = c, this.pickerMesh.geometry.boundingSphere = c, this } calculateOffset() { const e = _context.pgl.geoproject.sceneScale, t = _context.pgl.geoproject.globalOffset; let i = Math.pow(2, 15 - this.z) * e; this.offset.set(this.x * i + t.x, -this.y * i + t.y, i, this.id) } split() { let e = tilebelt.getChildren([this.x, this.y, this.z]); return e = [this.init(...e[0]), Tile.next(...e[1]), Tile.next(...e[2]), Tile.next(...e[3])], e } grow() { return this.init(...tilebelt.getParent([this.x, this.y, this.z])), this } shift(e, t, i) { i > this.z && console.error("Cannot shift at zoom level bigger than this.z"); const r = Math.round(this.x + e * Math.pow(2, this.z - i)), n = Math.round(this.y + t * Math.pow(2, this.z - i)); return this.init(r, n, this.z), this } recycle() { tilePool.push(this), _context.scene.pgl.remove(this.mesh), _context.scene.tilepickerScene.remove(this.pickerMesh) } fetchData() { this.wasSeen || this.z < 8 ? (Tile.elevationDatasource && Tile.elevationDatasource.fetchIfNeeded(this.elevationKey), Tile.imageryDatasource && Tile.imageryDatasource.fetchIfNeeded(this.imageryKey)) : this.wasRendered && this.z > 10 ? Tile.imageryDatasource && Tile.imageryDatasource.fetchIfNeeded(this.imageryKey.slice(0, -2)) : (Tile.imageryDatasource && Tile.imageryDatasource.fetchIfNeeded(this.imageryKey.slice(0, 5)), Tile.elevationDatasource && Tile.elevationDatasource.fetchIfNeeded(this.elevationKey.slice(0, 5))), this.refreshIndices() } calculateImageryOffset(e) { let t = e.quadkey ? this.imageryKey.length - e.quadkey.length : 0, i = Math.pow(2, -t), [r, n] = e.quadkey ? tilebelt.quadkeyToTile(e.quadkey) : [this.x, this.y, this.z]; this.imageryUvOffset.set(this.x * i - r, this.y * i - n, i, this.imageryIndex) } refreshIndices() { let e = tilebelt.quadkeyToTile(this.imageryKey), t = tilebelt.tileToQuadkey(e); Tile.elevationDatasource && (this.elevationIndex = Tile.elevationDatasource.findBestAvailableData(t, !0).index), Tile.imageryDatasource && (this.bestImagery = Tile.imageryDatasource.findBestAvailableData(this.imageryKey)), this.imageryIndex = this.bestImagery.index, this.calculateImageryOffset(this.bestImagery) } onSeen() { Tile.elevationDatasource && Tile.elevationDatasource.indexPool.tap(this.elevationIndex), Tile.imageryDatasource && Tile.imageryDatasource.indexPool.tap(this.imageryIndex) } } Tile.next = function () { return tilePool.length > 0 ? tilePool.splice(0, 1)[0].init(...arguments) : new Tile(...arguments) }, Tile.clear = function () { const e = tilePool; tilePool = [], idCounter = 1; for (const t of e) util$1.disposeThreeObject(t.mesh), util$1.disposeThreeObject(t.pickerMesh) }, Tile.tilePool = function () { return tilePool }, Tile.opacity = 1, Tile.fogUniforms || (Tile.fogUniforms = { fogColor: { type: "c", value: new Color$1(16777215) }, fogNear: { type: "f", value: 0 }, fogFar: { type: "f", value: 0 } }), Tile.styleUniforms || (Tile.styleUniforms = { uStyle: { type: "f", value: 0 }, uMaskColor: { type: "c", value: new Color$1(16777215) } }), BufferGeometry.prototype.getGeometry = function () { return this }; let segments = 64; for (Tile.geometry = []; segments >= 1;) { let e = new MapTileGeometry([1, 1], segments), t = new BufferGeometry; t.setAttribute("position", new Float32BufferAttribute(e.positions, 4)), Tile.geometry[segments] = t; let i = new MapTileGeometry([1, 1], segments, !1), r = new BufferGeometry; r.setAttribute("position", new Float32BufferAttribute(i.positions, 4)), t.other = r, r.other = t, t.getGeometry = o.bind(t, !0), r.getGeometry = o.bind(r, !1); const n = t.clone.bind(t); t.clone = function (e = !0) { const t = n(); if (t.getGeometry = o.bind(t, !0), !0 === e) { const e = this.other.clone(!1); t.other = e, e.other = t } return t }; const a = r.clone.bind(r); function o(e) { return e ? Tile.opacity >= 1 ? this : this.other : Tile.opacity >= 1 ? this.other : this } r.clone = function (e = !0) { const t = a(); if (t.getGeometry = o.bind(t, !1), !0 === e) { const e = this.other.clone(!1); t.other = e, e.other = t } return t }, segments /= 2 } class Terrain$1 { constructor({ scene: e, renderer: t, camera: i, imageryDatasource: r, elevationDatasource: n, minError: a = -1.5, maxError: o = 0, receiveShadow: s = !1 }) { this.scene = e, this.renderer = t, this.shiftThreshold = 1 / 0, this.x = 0, this.y = 0, this.z = 0, this.baseZ = 5, this.tileDelta = new Vector2, this.minError = a, this.maxError = o, this._receiveShadow = s, Tile.receiveShadow = s, r && (this.imageryDatasource = new BaseDatasource({ urlFormat: r.urlFormat, maxZoom: r.maxZoom || 18, textureSize: r.textureSize || IMAGERY_TILE_SIZE, poolSize: r.poolSize || IMAGERY_POOL_SIZE, apiKey: r.apiKey || "", flipY: "boolean" == typeof r.flipY && r.flipY }), n && (this.elevationDatasource = new BaseDatasource({ urlFormat: n.urlFormat, maxZoom: n.maxZoom || 12, textureSize: n.textureSize || ELEVATION_TILE_SIZE, pixelEncoding: n.pixelEncoding || PIXEL_ENCODING_GREYSCALE_RGBA$1, poolSize: n.poolSize || ELEVATION_POOL_SIZE, useFloat: "boolean" != typeof n.useFloat || n.useFloat, apiKey: n.apiKey || "", flipY: "boolean" == typeof n.flipY && n.flipY }))), this.updateImageryDatasource = ({ datasource: e }) => { if (e.imagery) for (let t of ["apiKey", "maxZoom", "urlFormat"]) { const i = e.imagery[t]; i && (this.imageryDatasource[t] = i) } }, this.updateElevationDatasource = ({ datasource: e }) => { if (e.elevation) for (let t of ["apiKey", "maxZoom", "pixelEncoding", "urlFormat"]) { const i = e.elevation[t]; i && (this.elevationDatasource[t] = i) } }, Tile.imageryDatasource = this.imageryDatasource, Tile.elevationDatasource = this.elevationDatasource; let l, c = [], h = {}, u = 0, d = null, p = !1; this.draw = () => { if (!1 === this.visible) return; if (0 === c.length) return; u++; let e = new Set, t = new Set, i = new Set, r = {}, n = 1; const a = 5 + 1 * n + 1; let o = u % a, s = 0 === o, f = (o - 1 - 4) % 1 == 0 && o > 4 && o < 5 + 1 * n, m = o === a - 1; if (p || (s = !0, f = !0, m = !0, n = 1), s && (this.renderer.setRenderTarget(_context.pgl.tilePicker.target), this.renderer.clear(!0, !0, !0), this.renderer.render(this.scene.tilepickerScene, _context.camera), this.renderer.setRenderTarget(null), l = _context.camera.projectionMatrix.elements), f) { let e = p ? (o - 1 - 4) / 1 : 0, t = 4 * _context.pgl.tilePicker.target.width * _context.pgl.tilePicker.target.height / n, i = new Uint8Array(_context.pgl.tilePicker.data.buffer, e * t, t); this.renderer.readRenderTargetPixels(_context.pgl.tilePicker.target, 0, e * _context.pgl.tilePicker.target.height / n, _context.pgl.tilePicker.target.width, _context.pgl.tilePicker.target.height / n, i), this.renderer.setRenderTarget(null) } if (m) { let n, a, o = 2 * (_context.pgl.tilePicker.target.width + _context.pgl.tilePicker.target.width * _context.pgl.tilePicker.target.height); o = Math.round(o); let s = 256 * _context.pgl.tilePicker.data[o + 2] + _context.pgl.tilePicker.data[o + 3]; s /= 65280, d = l[14] / (2 * s - 1 + l[10]), _context.orbitControls.setDistanceToTarget(d); let u = _context.pgl.tilePicker.data.length; for (o = 0; o < u; o += 4) { if (n = 256 * _context.pgl.tilePicker.data[o] + _context.pgl.tilePicker.data[o + 1], a = _context.pgl.tilePicker.data[o + 3] / 255, a = 10 * a - 5, 0 === n) continue; let r = c.find((e => e.id === n)); void 0 !== r && (a < this.minError && r.z < this.imageryDatasource.maxZoom ? (t.add(r), e.add(r)) : a > this.maxError && r.z > 7 ? i.add(r) : e.add(r)) } c.forEach((t => { if (void 0 === h[t.imageryKey] && (h[t.imageryKey] = 0), e.has(t)) h[t.imageryKey] = 0; else { h[t.imageryKey]++ > 5 && i.add(t) } })); let f = new Set([...i].filter((e => t.has(e)))); i = new Set([...i].filter((t => !f.has(t) && !e.has(t)))), t = new Set([...t].filter((e => !f.has(e)))), [...e].filter((e => !t.has(e))).forEach((e => e.wasSeen = !0)), [...c].filter((e => !t.has(e))).forEach((e => e.wasRendered = !0)), i.forEach((e => { let t = e.imageryKey.slice(0, -1); void 0 === r[t] ? r[t] = new Set([e]) : r[t].add(e) })), t.forEach((e => { if (window.noSplit) return; let t = e.split(); t.forEach((e => e.fetchData())), c.push(...t.splice(1, 3)) })), 0 === t.size && (p = !0), Object.values(r).forEach((e => { if (4 !== e.size) return; let t = [...e], i = t[0], r = t.splice(1, 3); delete h[i.imageryKey], i.grow().fetchData(), r.forEach((e => { let t = c.indexOf(e); c.splice(t, 1), delete h[e.imageryKey], e.recycle() })) })); const m = _context.orbitControls.target; c.forEach((e => { this.tileDelta.copy(e.mesh.geometry.boundingSphere.center), this.tileDelta.sub(m); const t = Math.abs(this.tileDelta.x) > this.shiftThreshold ? -Math.sign(this.tileDelta.x) : 0, i = Math.abs(this.tileDelta.y) > this.shiftThreshold ? Math.sign(this.tileDelta.y) : 0; (t || i) && (e.shift(t, i, this.baseZ), e.fetchData()) })), c.filter((e => e.bestImagery.downsample > 0)).forEach((e => e.fetchData())), c.forEach((e => { h[e.imageryKey] < 10 && e.onSeen() })) } return this.imageryDatasource && this.imageryDatasource.hasUpdates && this.imageryDatasource.broadcastUpdate(), this.elevationDatasource && this.elevationDatasource.hasUpdates && this.elevationDatasource.broadcastUpdate(), !!s || void 0 }, this.createScene = () => { c.forEach((e => e.recycle())), c = [], c.push(Tile.next(this.x, this.y, this.z)); let e = c[0].split(); c.push(...e.splice(1, 3)), c.forEach((e => e.fetchData())) }, this.getTiles = () => c, this.pickingTexture = new WebGLRenderTarget(1, 1), this.changeMaterial = e => { if ("number" == typeof e) for (const t of c) t.mesh.material = t.terrainCoordMaterial, 0 != e && 1 != e && 2 != e || (t.mesh.material.uniforms.uPass.value = e); else for (const e of c) e.mesh.material = e.terrainMaterial }, this.pickTerrain = e => { if (!(_context.camera instanceof PerspectiveCamera)) return; for (const e of c) e.mesh.material = e.terrainCoordMaterial; _context.camera.setViewOffset(_context.renderer.domElement.width, _context.renderer.domElement.height, e.x, e.y, 1, 1); const t = new Vector3, i = new WebGLRenderTarget(1, 1, { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat, type: FloatType }), r = new Float32Array(4); _context.renderer.setRenderTarget(i), _context.renderer.clear(), _context.renderer.render(_context.scene.pgl, _context.camera), _context.renderer.readRenderTargetPixels(i, 0, 0, 1, 1, r), t.set(r[0], r[1], r[2]), _context.renderer.setRenderTarget(null), i.dispose(), _context.camera.clearViewOffset(), console.log(t); for (const e of c) e.mesh.material = e.terrainMaterial; const n = { hit: 0 !== r[3], distance: -1, object: _context.scene.pgl, point: t }; return n.hit && (n.distance = t.distanceTo(_context.camera.position)), n }, this.unpackRGBAToFloat = e => { const t = e[3] / 255; let i = Math.round(e[0] / t), r = Math.round(e[1] / t), n = Math.round(e[2] / t); console.log(e, i, r, n, e[3]); const a = 65536 * i + 256 * r + n + (255 - e[3]) / 10 - 8388608; return console.log(a), a }, this.unpackRGBAToFloat2000 = e => { console.log("rgba", e); const t = e[0] / 255 * 2e3 - 1e3; return console.log(t), t }, this.unpackRGBAToFloatDec = e => { console.log("rgba", e); let t = 1; e[0] > 100 && (t = -1, e[0] -= 100); let i = 1e6 * e[0] + 1e4 * e[1] + 100 * e[2] + e[3]; return i *= t, console.log(i), i }, this.unpackRGBAToFloatFloor = e => { console.log(e); let t = (256 * e[0] + e[1]) / (e[3] / 255) + (e[3] / 255 - .5); return e[2] > 128 ? t : -t } } get receiveShadow() { return this._receiveShadow } set receiveShadow(e) { _context.scene.pgl && _context.scene.pgl.children instanceof Array && "boolean" == typeof e && (this._receiveShadow = e, Tile.receiveShadow = e, _context.scene.pgl.children.forEach((t => { t.material.uniforms.receiveShadow.value = e, t.material.shadowMapEnabled = e }))) } } class TilePicker { constructor() { this.data = new Uint8Array(4 * _context.renderer.domElement.width * _context.renderer.domElement.height), this.target = new WebGLRenderTarget(_context.renderer.domElement.width, _context.renderer.domElement.height) } updateSize({ width: e, height: t, renderRatio: i }) { let r = Math.sqrt(e * t / 500), n = 2 * Math.round(.5 * e / r), a = 2 * Math.round(.5 * t / r); this.target && n === this.target.width && a === this.target.height || (this.target = new WebGLRenderTarget(n, a), this.data = new Uint8Array(4 * this.target.width * this.target.height), tilepickerUniforms.uScaling.value.set(.5 * n, .5 * a, 256 / (i * r))) } } const MULTIPLIER_TERRARIUM = [256, 1, 1 / 256, -32768], MULTIPLIER_TERRAIN_RGB = [6553.6, 25.6, .1, -1e4], MULTIPLIER_GRAYSCALE_RGBA = [0, 0, 1e4 / 255 * 1, -1]; function dataToHeight(e, t) { if (!(e instanceof Uint8ClampedArray)) return 0; if (0 === e[0] && 0 === e[1]) return 0; let i; return t === PIXEL_ENCODING_TERRARIUM || t === PIXEL_ENCODING_NASADEM ? i = MULTIPLIER_TERRARIUM : t === PIXEL_ENCODING_TERRAIN_RGB ? i = MULTIPLIER_TERRAIN_RGB : t === PIXEL_ENCODING_GREYSCALE_RGBA && (i = MULTIPLIER_GRAYSCALE_RGBA), i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] } class GISStore { constructor() { this.terrainState = 0 } initTerrain({ id: e, place: t = { longitude: 116.39131, latitude: 39.90707 }, imagery: i, elevation: r, receiveShadow: n = !1 } = {}, a) { if (1 === this.terrainState) return; if (!i) return; const { alpha: o = 1 } = arguments[0]; Tile.opacity = o, _context.scene.hd = new Scene, _context.scene.tilepickerScene = new Scene, _context.scene.pickerScene = new Scene, _context.scene.pgl = new Group, _context.scene.pgl.name = "__pgl", _context.scene.pgl.rotateX(Math.PI / -2), _context.scene.add(_context.scene.pgl), _context.pgl.tilePicker = new TilePicker, _context.pgl.tilePicker.updateSize({ width: _context.renderer.domElement.width, height: _context.renderer.domElement.height, renderRatio: _context.renderer.getPixelRatio() }), _context.pgl.terrain = new Terrain$1({ scene: _context.scene, renderer: _context.renderer, camera: _context.camera, imageryDatasource: i, elevationDatasource: r, minError: -1.2, maxError: .3, receiveShadow: n }), _context.pgl.heightUniforms = { elevationArray: { value: _context.pgl.terrain.elevationDatasource ? _context.pgl.terrain.elevationDatasource.textureArray : [] }, indirectionTexture: { value: _context.pgl.terrain.elevationDatasource ? _context.pgl.terrain.elevationDatasource.indirectionTexture : [] }, uGlobalOffset: { type: "v2", value: new Vector2 }, uSceneScale: { type: "v3", value: new Vector3(1, 1, 1) }, updateSceneScale: e => { const t = _context.pgl.terrain.elevationDatasource ? _context.pgl.terrain.elevationDatasource.maxZoom : 12, i = Math.pow(2, 15 - t), r = 40075016.686 / (e * Math.pow(2, 15)), n = -6.283185307179586 / Math.pow(2, t), a = 1 / (e * i); _context.pgl.heightUniforms.uSceneScale.value.set(n, r, a) }, update: ({ globalOffset: e, sceneScale: t }) => { _context.pgl.heightUniforms.uGlobalOffset.value.copy(e), _context.pgl.heightUniforms.updateSceneScale(t) } }; var s = .05;[_context.pgl.terrain.x, _context.pgl.terrain.y, _context.pgl.terrain.z] = tilebelt.pointToTileFraction(Math.round(t.longitude / s) * s, Math.round(t.latitude / s) * s, _context.pgl.terrain.baseZ), _context.pgl.geoproject = new Geoproject, _context.pgl.geoproject.setCurrentPlace(t); const l = _context.pgl.geoproject.sceneScale; if (_context.pgl.terrain.shiftThreshold = .6 * l * Math.pow(2, 15 - _context.pgl.terrain.baseZ), _context.pgl.terrain.x = Math.floor(_context.pgl.terrain.x), _context.pgl.terrain.y = Math.floor(_context.pgl.terrain.y), _context.pgl.terrain.createScene(), this.valid = { callback: a }, i && i.urlFormat) { let e = ""; for (const t of i.urlFormat) { if ("{" === t) break; e += t } this.valid.imageryUrl = e } if (r && r.urlFormat) { let e = ""; for (const t of r.urlFormat) { if ("{" === t) break; e += t } this.valid.elevationUrl = e } this.terrainState = 1 } dataAtPoint(e) { if (_context.pgl.terrain && _context.pgl.terrain.elevationDatasource) return _context.pgl.terrain.elevationDatasource.dataAtPoint(e) } heightAtPoint(e) { if (_context.pgl.terrain && _context.pgl.terrain.elevationDatasource) return dataToHeight(_context.pgl.terrain.elevationDatasource.dataAtPoint(e), _context.pgl.terrain.elevationDatasource.pixelEncoding) } setStyle(e, t) { Tile.styleUniforms || (Tile.styleUniforms = { uStyle: { type: "f", value: 0 }, uMaskColor: { type: "c", value: new Color$1(16777215) } }), Tile.styleUniforms.uStyle.value = e, Tile.styleUniforms.uMaskColor.value.setStyle(t) } testGeoJSON({ url: e, batch: t, callback: i } = {}) { e && util$1.fetchJSON(e, "get").then((t => { const i = new Group; i.name = e; const r = []; JSON.parse(t).features.forEach((e => { var t = e.properties.height || 30; (new Group).data = e, e.geometry.coordinates.forEach((e => { e[0][0] instanceof Array ? e.forEach((e => { r.push(this.drawGeometry(e, t)) })) : r.push(this.drawGeometry(p, t)) })) })); const n = this.drawMaterial(); if (r.length > 128) { let e = this.chunk(r, 128); r.length = 0; for (let t of e) { const e = new Mesh(BufferGeometryUtils.mergeBufferGeometries(t), n); i.add(e) } } else { const e = new Mesh(BufferGeometryUtils.mergeBufferGeometries(r), n); i.add(e) } const a = new Group; a.add(i), a.name = "__geojson", _context.scene.add(a), a.rotateX(3 * Math.PI / 2) })) } drawModel(e, t) { const i = new Shape; e.forEach(((t, r) => { const [n, a] = t; let o, s, l = util$1.lonLatToWebMercator(n, a, 0), c = util$1.lonLatToWebMercator(_context.datumShiftModel.lon, _context.datumShiftModel.lat, 0); o = l.x - c.x, s = l.y - c.y, 0 === r ? i.moveTo(o, s) : r === e.length - 1 ? i.quadraticCurveTo(o, s, o, s) : i.lineTo(o, s, o, s) })); return new Mesh(new ExtrudeGeometry(i, { depth: t || -2, bevelEnabled: !1 }), new MeshLambertMaterial({ color: new Color$1(13421772), transparent: !0, opacity: .9, side: DoubleSide })) } drawMaterial(e) { return new MeshLambertMaterial({ color: new Color$1(13421772), transparent: !0, opacity: .9, side: DoubleSide }) } drawGeometry(e, t) { const i = new Shape; e.forEach(((t, r) => { const [n, a] = t; let o, s, l = util$1.lonLatToWebMercator(n, a, 0), c = util$1.lonLatToWebMercator(_context.datumShiftModel.lon, _context.datumShiftModel.lat, 0); o = l.x - c.x, s = l.y - c.y, 0 === r ? i.moveTo(o, s) : r === e.length - 1 ? i.quadraticCurveTo(o, s, o, s) : i.lineTo(o, s, o, s) })); return new ExtrudeGeometry(i, { depth: t || -2, bevelEnabled: !1 }) } chunk(e, t) { if (t <= 1) return e; let i = []; for (let r = 0; r < e.length; r += t) { let n = []; for (let i = 0; i < t && r + i < e.length; i++)n.push(e[r + i]); i.push(n) } return i } disposeTerrain() { if (_context.pgl = {}, _context.scene.remove(_context.scene.pgl), util$1.disposeThreeObject(_context.scene.pgl), _context.scene.hd && _context.scene.hd.children) for (const e of _context.scene.hd.children) util$1.disposeThreeObject(e), _context.scene.hd.remove(e); if (_context.scene.tilepickerScene && _context.scene.tilepickerScene.children) for (const e of _context.scene.tilepickerScene.children) util$1.disposeThreeObject(e), _context.scene.hd.remove(e); if (_context.scene.pickerScene && _context.scene.pickerScene.children) for (const e of _context.scene.pickerScene.children) util$1.disposeThreeObject(e), _context.scene.hd.remove(e); _context.scene.pgl = null, _context.scene.hd = null, _context.scene.tilepickerScene = null, _context.scene.pickerScene = null, Tile.clear(), this.terrainState = 0 } setVisibility(e) { _context.scene.pgl && (_context.scene.pgl.visible = e), _context.pgl.terrain && (_context.pgl.terrain.visible = !!e) } updateStyle(e, t) { const { alpha: i = 1 } = e; if (Tile.opacity = i, _context.pgl.terrain) { for (const e of _context.pgl.terrain.getTiles()) e.mesh.material.uniforms.opacity.value = Tile.opacity, e.mesh.geometry = e.mesh.geometry.getGeometry(); for (const e of Tile.tilePool()) e.mesh.material.uniforms.opacity.value = Tile.opacity, e.mesh.geometry = e.mesh.geometry.getGeometry() } t && t({ result: 1, message: "成功。" }) } getSettings() { } applySettings(e) { } checkAddress(e) { if (!this.valid) return; if (!this.valid.callback) return; if (this.valid.elevationUrl && void 0 === this.valid.elevationResult && -1 != e.indexOf(this.valid.elevationUrl)) { let i = new XMLHttpRequest; i.open("get", e, !0), i.timeout = 1e3, i.onreadystatechange = () => { 4 != i.readyState && (200 == i.status ? (this.valid.elevationResult = "success", t()) : (this.valid.elevationResult = "fail", t())) }, i.ontimeout = () => { this.valid.elevationResult = "timeout", t() }, i.onerror = () => { this.valid.elevationResult = "error", t() }, i.send() } if (this.valid.imageryUrl && void 0 === this.valid.imageryResult && -1 != e.indexOf(this.valid.imageryUrl)) { let i = new XMLHttpRequest; i.open("get", e, !0), i.timeout = 1e3, i.onreadystatechange = () => { 4 != i.readyState && (200 == i.status ? (this.valid.imageryResult = "success", t()) : (this.valid.imageryResult = "fail", t())) }, i.ontimeout = () => { this.valid.imageryResult = "timeout", t() }, i.onerror = () => { this.valid.imageryResult = "error", t() }, i.send() } const t = () => { if (void 0 === this.valid.imageryUrl && (this.valid.imageryResult = "complete"), void 0 === this.valid.elevationUrl && (this.valid.elevationResult = "complete"), void 0 === this.valid.imageryResult || void 0 === this.valid.elevationResult) return; const e = this.valid; this.valid = void 0; let t = ""; "timeout" === e.elevationUrl ? t = "高程数据请求超时" : "error" === e.elevationUrl ? t = "高程数据不支持跨域访问" : "fail" === e.elevationUrl && (t = "高程数据无资源文件"); let i = ""; if ("timeout" === e.imageryResult ? i = "瓦片数据请求超时" : "error" === e.imageryResult ? i = "瓦片数据不支持跨域访问" : "fail" === e.imageryResult && (i = "瓦片数据无资源文件"), t || i) { let r = "失败"; t && (r += "，" + t), i && (r += "，" + i), this.disposeTerrain(), e.callback({ result: 0, message: r + "。" }) } else e.callback({ result: 1, message: "成功。" }) } } } class InstancedObjectStore { constructor() { var e = []; this.add = t => { e.push(t) }, this.findInstancedObject = t => e.find((e => e.name === t)) || void 0, this.getInstancedObject = () => e, this.remove = t => { for (let i = e.length - 1; i >= 0; i--)e[i] === t && (e[i].dispose && e[i].dispose(), e[i] = null, e.splice(i, 1)) }, this.resume = () => { _isPaused = !1 }, this.update = t => { if (!_isPaused) for (let i of e) i.update(t) } } } const _v1 = new Vector3, _v2 = new Vector3, _v3 = new Vector3; class DirectionalLightHelper extends Object3D { constructor(e, t, i) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === t && (t = 1); let r = new BufferGeometry; r.setAttribute("position", new Float32BufferAttribute([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); const n = new LineBasicMaterial({ depthTest: !1, depthWrite: !1, transparent: !0, linewidth: 1, fog: !1, toneMapped: !1 }); this.lightPlane = new Line(r, n), this.add(this.lightPlane), r = new BufferGeometry, r.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Line(r, n), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { _v1.setFromMatrixPosition(this.light.matrixWorld), _v2.setFromMatrixPosition(this.light.target.matrixWorld), _v3.subVectors(_v2, _v1), this.lightPlane.lookAt(_v2), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(_v2), this.targetLine.scale.z = _v3.length() } } const _vector = new Vector3, _camera = new Camera$1$1; class CameraHelper extends LineSegments { constructor(e) { const t = new BufferGeometry, i = new LineBasicMaterial({ depthTest: !1, depthWrite: !1, color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], n = [], a = {}, o = new Color$1(16755200), s = new Color$1(16711680), l = new Color$1(43775), c = new Color$1(16777215), h = new Color$1(3355443); function u(e, t, i) { d(e, i), d(t, i) } function d(e, t) { r.push(0, 0, 0), n.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(r.length / 3 - 1) } u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u("f2", "f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2", o), u("n3", "f3", o), u("n4", "f4", o), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), t.setAttribute("position", new Float32BufferAttribute(r, 3)), t.setAttribute("color", new Float32BufferAttribute(n, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update() } update() { const e = this.geometry, t = this.pointMap; _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), setPoint("c", t, e, _camera, 0, 0, -1), setPoint("t", t, e, _camera, 0, 0, 1), setPoint("n1", t, e, _camera, -1, -1, -1), setPoint("n2", t, e, _camera, 1, -1, -1), setPoint("n3", t, e, _camera, -1, 1, -1), setPoint("n4", t, e, _camera, 1, 1, -1), setPoint("f1", t, e, _camera, -1, -1, 1), setPoint("f2", t, e, _camera, 1, -1, 1), setPoint("f3", t, e, _camera, -1, 1, 1), setPoint("f4", t, e, _camera, 1, 1, 1), setPoint("u1", t, e, _camera, .7, 1.1, -1), setPoint("u2", t, e, _camera, -.7, 1.1, -1), setPoint("u3", t, e, _camera, 0, 2, -1), setPoint("cf1", t, e, _camera, -1, 0, 1), setPoint("cf2", t, e, _camera, 1, 0, 1), setPoint("cf3", t, e, _camera, 0, -1, 1), setPoint("cf4", t, e, _camera, 0, 1, 1), setPoint("cn1", t, e, _camera, -1, 0, -1), setPoint("cn2", t, e, _camera, 1, 0, -1), setPoint("cn3", t, e, _camera, 0, -1, -1), setPoint("cn4", t, e, _camera, 0, 1, -1), e.getAttribute("position").needsUpdate = !0 } } function setPoint(e, t, i, r, n, a, o) { _vector.set(n, a, o).unproject(r); const s = t[e]; if (void 0 !== s) { const e = i.getAttribute("position"); for (let t = 0, i = s.length; t < i; t++)e.setXYZ(s[t], _vector.x, _vector.y, _vector.z) } } class LightStore { constructor(e, t) { this._scene = e, this._context = t, this._lightGroupId = "", this._showingHelpers = !1, this._azimuthAngleOffset = 0; let i = this._scene.getObjectByName("__lightGroup"); if (i && this._scene.remove(i), this._scene) { this._ambientLight = new AmbientLight(16777215, 1), this._ambientLight.intensity0 = 1, this._ambientLight.name = "__ambientLight", this._ambientLightProbe = new AmbientLightProbe(16777215, 0), this._ambientLightProbe.name = "__ambientLightProbe", this._ambientLightProbeEnabled = !1; let e = new Group; e.name = "__lightGroup", e.add(this._ambientLight), e.add(this._ambientLightProbe), this._lightGroupId = e.id, this._scene.add(e) } this._directionalLights = new Object; let r = this; this._transformDirectionalLightCallback = e => { if (!r.transformedLight) return; r.updateLightHelpers(), e.object.dummy.updateMatrixWorld(); let t = e.object.dummy.position.clone(); if (t.applyMatrix4(e.object.matrix), r.transformedLight.position.copy(t), "GlobalDirectionalLight" === r.transformedLight.name && r._syncDirectionalLights(), "function" == typeof r.transformCallback) { let t = { x: r.transformedLight.position.x, y: r.transformedLight.position.y, z: r.transformedLight.position.z }, i = r.transformedLight.position.distanceTo(e.object.position); r.transformCallback({ mode: r.transformMode, position: t, targetPosition: { x: e.object.position.x, y: e.object.position.y, z: e.object.position.z }, azimuthAngle: Math.atan2(-(t.z - e.object.position.z), t.x - e.object.position.x) / Math.PI * 180 + 90, inclinationAngle: Math.asin((t.y - e.object.position.y) / i) / Math.PI * -180 }) } } } enableLightProbe() { const e = this._scene.background instanceof CubeTexture && _context.background && "skybox" === _context.background.mode ? this._scene.background : this._scene.environment instanceof CubeTexture ? this._scene.environment : null; if (e) this._ambientLightProbe.copy(LightProbeGenerator.fromCubeTexture(e)), this._ambientLightProbe.intensity = this._ambientLight.intensity0 / 2, this._ambientLightProbeEnabled = !0, this._ambientLight.intensity = this._ambientLight.intensity0 / 2, this._ambientLight.visible = !1; else { const e = this._scene.background instanceof Texture$1 && _context.background && "skybox" === _context.background.mode ? this._scene.background : this._scene.environment instanceof Texture$1 ? this._scene.environment : null; if (e) { const t = new WebGLCubeRenderTarget(e.image.width); t.fromEquirectangularTexture(_context.renderer, e), this._ambientLightProbe.copy(LightProbeGenerator.fromCubeRenderTarget(_context.renderer, t)), this._ambientLightProbe.intensity = this._ambientLight.intensity0 / 2, this._ambientLightProbeEnabled = !0, this._ambientLight.intensity = this._ambientLight.intensity0 / 2 } } } disableLightProbe() { this._ambientLightProbe && (this._ambientLightProbe.visible = !1, this._ambientLightProbeEnabled = !1, this._ambientLight.visible = !0, this._ambientLight.intensity = this._ambientLight.intensity0) } showLightHelpers() { this._showingHelpers = !0, this._getLightGroup().traverse((e => { e instanceof DirectionalLightHelper && (e.visible = !e.getLight || e.getLight().visible), e instanceof CameraHelper && (e.visible = !e.getLight || e.getLight().visible && e.getLight().castShadow && e.getLight().shadow && e.getLight().shadow.camera) })) } hideLightHelpers() { this._showingHelpers = !1, this._getLightGroup().traverse((e => { (e instanceof DirectionalLightHelper || e instanceof CameraHelper) && (e.visible = !1) })) } updateLightHelpers(e = !0, t = !0) { this._getLightGroup().traverse((t => { e && t instanceof DirectionalLightHelper && (t.light.updateMatrixWorld(), t.light.target.updateMatrixWorld(), t.updateMatrixWorld(), t.update(), this._syncDirectionalLights()), e && t instanceof CameraHelper && t.update() })) } setAmbientLight(e, t) { this._scene && "number" == typeof t && (this._ambientLight.intensity0 = t, this._ambientLight.color = new Color$1(e) || this._ambientLight.color, this._ambientLightProbeEnabled ? this._ambientLight.intensity = t / 2 : this._ambientLight.intensity = t, this._ambientLightProbe && (this._ambientLightProbe.intensity = this._ambientLight.intensity + LIGHT_PROBE_INTENSITY_OFFSET)) } getAmbientLight() { if (this._scene) return this._ambientLight } setAmbientLightProbe(e, t) { this._scene && (this._ambientLight.color = new Color$1(e) || this._ambientLight.color, this._ambientLight.intensity = util$1.numberOrDefault(t + LIGHT_PROBE_INTENSITY_OFFSET, this._ambientLight.intensity + LIGHT_PROBE_INTENSITY_OFFSET)) } getAmbientLightProbe() { if (this._scene) return this._ambientLight } setDirectionalLight(e, t = 0) { if (logger.debug("TRACE: LightStore.setDirectionalLight() - Entering.", e), !this._scene || !e) return void logger.debug("TRACE: LightStore.setDirectionalLight() - Exiting."); let i = this.findDirectionalLight(e.name), r = !1; if (i) { for (let n in e) switch (n) { case "color": util$1.isCSSColor(e[n]) && i.color.setStyle(e[n]); break; case "position": if (e[n] instanceof Array && 3 === e[n].length) if (t < .05) i.position.set(e[n][0], e[n][1], e[n][2]); else { let r = _context.animationStore.findAnimation("LightTransformAnimation"); r && (logger.warn("Light transform animation has been interrupted by another animation."), _context.animationStore.remove(r)); let a = new SmoothTransformController(i, { position: new Vector3(e[n][0], e[n][1], e[n][2]) }, t); a.name = "LightTransformAnimation", _context.animationStore.add(a) } break; case "targetPosition": e[n] instanceof Array && 3 === e[n].length && i.target && i.target.position.set(e[n][0], e[n][1], e[n][2]); break; case "shadow": let a = e[n].camera; a && (i.shadow.camera.top = util$1.numberOrDefault(a.top, i.shadow.camera.top), i.shadow.camera.bottom = util$1.numberOrDefault(a.bottom, i.shadow.camera.bottom), i.shadow.camera.left = util$1.numberOrDefault(a.left, i.shadow.camera.left), i.shadow.camera.right = util$1.numberOrDefault(a.right, i.shadow.camera.right), i.shadow.camera.near = util$1.numberOrDefault(a.near, i.shadow.camera.near), i.shadow.camera.far = util$1.numberOrDefault(a.far, i.shadow.camera.far), i.shadow.camera.updateProjectionMatrix(), r = !0), e[n].mapSize && (e[n].mapSize instanceof Array ? (i.shadow.mapSize.width = util$1.numberOrDefault(e[n].mapSize[0], i.shadow.mapSize.width), i.shadow.mapSize.height = util$1.numberOrDefault(e[n].mapSize[1], i.shadow.mapSize.height), i.shadow.map && (i.shadow.map.dispose(), i.shadow.map = null)) : e[n].mapSize instanceof Object && (i.shadow.mapSize.width = util$1.numberOrDefault(e[n].mapSize.width || e[n].mapSize.x, i.shadow.mapSize.width), i.shadow.mapSize.height = util$1.numberOrDefault(e[n].mapSize.height || e[n].mapSize.y, i.shadow.mapSize.height), i.shadow.map && (i.shadow.map.dispose(), i.shadow.map = null))), i.shadow.bias = util$1.numberOrDefault(e[n].bias, 0); break; case "castShadow": case "visible": if (i[n] === e[n]) break; i[n] = e[n]; let o = this._showingHelpers && i.visible; o && !i.getDirectionalLightHelper && this._createDirectionalLightHelper(i), i.getDirectionalLightHelper && (this._getLightGroup().getObjectByName(e.name + ".helper").visible = o); let s = i.shadow && i.shadow.camera && i.castShadow && !i.getShadowCameraHelper, l = this._showingHelpers && i.visible && i.castShadow && i.shadow && i.shadow.camera; s && this._createShadowCameraHelper(i), i.getShadowCameraHelper && (i.getShadowCameraHelper().visible = l); break; case "rotation": case "scale": case "getShadowCameraHelper": case "getDirectionalLightHelper": break; case "intensity": i[n] = e[n] * LIGHT_INTENSITY_RATIO; break; default: i[n] = e[n] }i.target && i.target.dummy && (i.target.dummy.position.copy(i.position), i.target.dummy.position.sub(i.target.position)) } else i = this._createDirectionalLight(e), this._getLightGroup() && (i.target && (i.target.name = `${i.name}.target`, this._getLightGroup().add(i.target)), this._createDirectionalLightHelper(i), i.shadow && i.shadow.camera && i.castShadow && this._createShadowCameraHelper(i), this._getLightGroup().add(i), this._directionalLights[e.name] = i); this.updateLightHelpers(!0, r), "number" == typeof e.azimuthAngleOffset && (this._azimuthAngleOffset = e.azimuthAngleOffset), "number" == typeof e.azimuthAngle && (i.azimuthAngle = e.azimuthAngle), "number" == typeof e.inclinationAngle && (i.inclinationAngle = e.inclinationAngle), logger.debug("TRACE: LightStore.setDirectionalLight() - Exiting.") } updateDirectionalLight(e, t) { this._scene && e && t && (this.findDirectionalLight(e) ? logger.warn(`DirectionalLight with name "${e}" already exists.`) : (t.name = e, this._getLightGroup() && (this._getLightGroup().add(t), this._directionalLights[e] = t))) } clearDirectionalLight() { if (this._scene) for (let e in this._directionalLights) this._getLightGroup() && (this._getLightGroup().remove(this._directionalLights[e]), delete this._directionalLights[e]) } getDirectionalLights() { return this._directionalLights } findDirectionalLight(e) { if (this._scene && e) return this._directionalLights[e] } removeDirectionalLight(e) { this._scene && e && (this._getLightGroup().remove(this._getLightGroup().getObjectByName(e)), this._getLightGroup().remove(this._getLightGroup().getObjectByName(e + ".helper")), this._getLightGroup().remove(this._getLightGroup().getObjectByName(e + ".target")), delete this._directionalLights[e]) } hideDirectionalLight(e) { this._scene } showDirectionalLight(e) { this._scene } findDirectionalLightHelper(e) { if (this._scene && e) return this._directionalLights[e] && this._directionalLights[e].getDirectionalLightHelper ? this._directionalLights[e].getDirectionalLightHelper() : void 0 } transformDirectionalLight(e, t) { let i = this.findDirectionalLight(e); return !(!i || !i.target) && (this.transformControls || (this.transformControls = _context.transformControls), this.transformedLight = i, this.transformOffset = { translate: i.position.clone(), quaternion: i.quaternion.clone(), distance: 0 }, "function" == typeof t && (this.transformCallback = t), this.transformMode = "translate", this.transformOffset.translate.sub(i.target.position), this.transformOffset.distance = i.position.distanceTo(i.target.position), i.target.dummy || (i.target.dummy = new Object3D, i.target.dummy.name = "lightTargetDummy", i.target.add(i.target.dummy)), i.target.dummy.position.copy(i.position), i.target.dummy.position.sub(i.target.position), this.transformControls.attach(i.target), this.transformControls.setMode("translate"), this.transformControls.addEventListener("translate", this._transformDirectionalLightCallback), !0) } setTransformMode(e) { if (!this.transformMode || !this.transformControls) return !1; switch (e.toLowerCase()) { case "translate": return this.transformMode = e.toLowerCase(), this.transformControls.setMode(this.transformMode), !0; default: return !1 } } disableTransformDirectionalLight() { return !!this.transformControls && (this.transformedLight = void 0, this.transformOffset = { translate: 0, quaternion: 0, distance: 0 }, this.transformCallback = void 0, this.transformMode = void 0, this.transformControls.detach(), this.transformControls.removeEventListener("translate", this._transformDirectionalLightCallback), !0) } _syncDirectionalLights() { let e; for (let t in this._directionalLights) "GlobalDirectionalLight" === this._directionalLights[t].name && this._directionalLights[t].target && this._directionalLights[t].target.position && (e = this._directionalLights[t].target.position.clone()); if (e) for (let t in this._directionalLights) if ("GlobalDirectionalLight" !== this._directionalLights[t].name) { let i = this._directionalLights[t].position.clone(); i.sub(this._directionalLights[t].target.position), this._directionalLights[t].target.position.copy(e), this._directionalLights[t].position.addVectors(this._directionalLights[t].target.position, i) } } _getLightGroup() { return this._lightGroupId ? this._scene.getObjectById(this._lightGroupId) : void 0 } _createDirectionalLight({ name: e, visible: t, color: i = "#ffffff", position: r = [100, 100, 100], targetPosition: n, castShadow: a = !0, shadow: o = { camera: { top: 100, bottom: -100, left: -100, right: 100, far: 200 }, mapSize: { height: 1024, width: 1024, x: 1024, y: 1024 } }, intensity: s = 1 * LIGHT_INTENSITY_RATIO, type: l, distance: c, label: h }) { let u = new DirectionalLight(i); u.name = e, u.visible = "boolean" != typeof t || t, u.position.set(r[0], r[1], r[2]), u.castShadow = a, u.distance = c, u.label = h, o.camera && (u.shadow.camera.top = util$1.numberOrDefault(o.camera.top, 100), u.shadow.camera.bottom = util$1.numberOrDefault(o.camera.bottom, -100), u.shadow.camera.left = util$1.numberOrDefault(o.camera.left, -100), u.shadow.camera.right = util$1.numberOrDefault(o.camera.right, 100), u.shadow.camera.near = util$1.numberOrDefault(o.camera.near, .1), u.shadow.camera.far = util$1.numberOrDefault(o.camera.far, 200)), o.mapSize && (o.mapSize instanceof Array ? (u.shadow.mapSize.width = util$1.numberOrDefault(o.mapSize[0], 2048), u.shadow.mapSize.height = util$1.numberOrDefault(o.mapSize[1], 2048)) : o.mapSize instanceof Object && (u.shadow.mapSize.width = util$1.numberOrDefault(o.mapSize.width || o.mapSize.x, 2048), u.shadow.mapSize.height = util$1.numberOrDefault(o.mapSize.height || o.mapSize.y, 2048))), "number" == typeof o.bias && (u.shadow.bias = o.bias); let d = new Object3D; return u.target = d, "supplemental" === l ? d.position.set(0, r[1], 0) : d.position.set(0, -.01, 0), n instanceof Array && d.position.set(n[0], n[1], n[2]), u.intensity = s * LIGHT_INTENSITY_RATIO, u } _createDirectionalLightHelper(e, t = 5) { var i = new DirectionalLightHelper(e, t); i.name = `${e.name}.helper`, i.visible = e.visible && this._showingHelpers, i.getLight = function () { return e }, e.getDirectionalLightHelper = function () { return i }, this._getLightGroup().add(i) } _createShadowCameraHelper(e) { let t = new CameraHelper(e.shadow.camera); t.name = `${e.name}.shadowHelper`, t.visible = this._showingHelpers && e.castShadow, t.renderOrder = 1 / 0, t.getLight = function () { return e }, e.getShadowCameraHelper = function () { return t }, this._getLightGroup().add(t) } getSettings() { logger.debug("TRACE: LightStore.getSettings() - Entering."); let e = { ambientLight: {}, directionalLights: {}, azimuthAngleOffset: this._azimuthAngleOffset }; for (let t in this._ambientLight) "uuid" !== t && "parent" !== t && "quaternion" !== t && "matrix" !== t && "matrixWorld" !== t && "matrixAutoUpdate" !== t && "matrixWorldNeedsUpdate" !== t && "layers" !== t && "target" !== t && "layers" !== t && "userData" !== t && "isDirectionalLight" !== t && "isLight" !== t && "isObject3D" !== t && "animation" !== t && "function" != typeof this._ambientLight[t] && (this._ambientLight[t], e.ambientLight[t.replace("_", "")] = this._ambientLight[t]); e.ambientLight.intensity = "number" == typeof e.ambientLight.intensity0 ? e.ambientLight.intensity0 : e.ambientLight.intensity; for (let t in this._directionalLights) { let i = {}; for (let e in this._directionalLights[t]) if ("uuid" !== e && "parent" !== e && "quaternion" !== e && "matrix" !== e && "matrixWorld" !== e && "matrixAutoUpdate" !== e && "matrixWorldNeedsUpdate" !== e && "layers" !== e && "layers" !== e && "userData" !== e && "isDirectionalLight" !== e && "isLight" !== e && "isObject3D" !== e && "animation" !== e && "function" != typeof this._ambientLight[e]) switch (e) { case "color": i[e.replace("_", "")] = `#${this._directionalLights[t][e].getHexString()}`; break; case "position": i[e.replace("_", "")] = [this._directionalLights[t][e].x, this._directionalLights[t][e].y, this._directionalLights[t][e].z]; break; case "target": i.targetPosition = [this._directionalLights[t][e].position.x, this._directionalLights[t][e].position.y, this._directionalLights[t][e].position.z]; break; case "targetPosition": break; case "shadow": i[e.replace("_", "")] = JSON.parse(JSON.stringify(this._directionalLights[t][e])), i[e.replace("_", "")].mapSize = JSON.parse(JSON.stringify(this._directionalLights[t][e].mapSize)), i[e.replace("_", "")].camera && delete i[e.replace("_", "")].camera.uuid; break; default: i[e.replace("_", "")] = this._directionalLights[t][e] }e.directionalLights[t] = i } return logger.debug("TRACE: LightStore.getSettings() - Exiting.", e), e } applySettings(e, t, i) { if (logger.debug("TRACE: LightStore.getSettings() - Entering.", e), e) if (this._context) { for (let t in this._directionalLights) null == e.directionalLights[t] && (this.removeDirectionalLight(t), delete this._directionalLights[t]); e.directionalLights.GlobalDirectionalLight.duration = i; for (let t in e.directionalLights) "GlobalDirectionalLight" !== t && this.setDirectionalLight(e.directionalLights[t]); "number" == typeof e.azimuthAngleOffset && (this._azimuthAngleOffset = e.azimuthAngleOffset), this._context.setGlobalIllumination({ skybox: e.skybox, ambientLight: e.ambientLight, directionalLight: e.directionalLights.GlobalDirectionalLight }, (e => { t && t(e) })), this._syncDirectionalLights(), logger.debug("TRACE: LightStore.applySettings() - Exiting.") } else logger.error("无效的上下文设置。"); else logger.error("无效的灯光设置。") } dispose() { for (const e in this._directionalLights) Object.hasOwnProperty.call(this._directionalLights, e) && util$1.disposeThreeObject(this._directionalLights[e]); this._directionalLights = null } } class ModelStore { constructor(e) { this._scene = e, this._scene.models || (this._scene.models = new Group("__models"), this._scene.models.name = "__models", this._scene.add(this._scene.models)), this._models = new Object, this._nodeSelection = new NodeSelection(e), this._animationMixers = [], this._states = {} } add(e, t, i, r) { this._scene && e && r && (this.find(e) || (r.index = "number" == typeof i ? i : this._scene.models.children.length, r.name = e, r.url = t, this._scene.models.add(r), this._models[e] = r, this._animationMixers.push(new AnimationMixer(r)))) } clear() { if (this._scene) for (let e in this._models) this._scene.models.remove(this._models[e]), delete this._models[e] } find(e) { if (!this._scene || !e) return; return this.getModels().find((t => t.name === e)) } rename(e, t, i) { if (this._scene && e && t) { _context.modelStore.find(t).name = e; for (let r = 0; r < this._scene.models.children.length; r++)this._scene.models.children[r].name === t && (this._scene.models.children[r].name = e, i && i(1)); for (let i in this._models) i === t && (this._models[e] = this._models[i], delete this._models[i]) } } getModels() { let e = []; for (let t in this._models) { let i = new Model({ name: this._models[t].name, url: this._models[t].url, animations: this._models[t].animations, isVisible: this._models[t].visible, index: this._models[t].index }); i.children = Node._fromThreeObject(this._models[t]).children, e.push(i) } return e } loadScene(e, t) { if (t.inBackground) for (let i of e.children) e.userData.dhExtension && (i.userData.dhExtension = e.userData.dhExtension), t.translate instanceof Array && (i.translateX(t.translate[0] || 0), i.translateY(t.translate[1] || 0), i.translateZ(t.translate[2] || 0)), i.visible = !1, this._scene.models.add(i), this._models[i.name] = i; else { e.name = "__models", this._scene.remove(this._scene.models), this._scene.models = e, this._scene.add(e); for (let t of e.children) e.userData.dhExtension && (t.userData.dhExtension = e.userData.dhExtension), this._models[t.name] = t } } remove(e, t) { let i = null; if (this._scene && e) { for (let r in this._models) this._models[r].name == e && (i = this._models[r].index, this._scene.models.remove(this._models[r]), delete this._models[this._models[r].name], t && t(1)); for (let e in this._models) i < this._models[e].index && (this._models[e].index -= 1) } } copy(e, t) { if (this._scene && e) for (let n in this._models) if (this._models[n].name == e) { var i = this._models[n].clone(); i.url = this._models[n].url; var r = new Date; r.toLocaleDateString(), i.name = i.name + "_副本_" + (r.getMonth() + 1 < 10 ? "0" + (r.getMonth() + 1) : r.getMonth() + 1) + (r.getDate() < 10 ? "0" + r.getDate() : r.getDate()) + (r.getHours() < 10 ? "0" + r.getHours() : r.getHours()) + (r.getMinutes() < 10 ? "0" + r.getMinutes() : r.getMinutes()) + (r.getSeconds() < 10 ? "0" + r.getSeconds() : r.getSeconds()), this._scene.models.add(i), this._models[i.name] = i, t && t(1) } } hide(e, t = {}) { if (!this._scene || !e || !this.find(e)) return; let i = this._models[e]; if (i instanceof Object3D && (i.visible = !1, this._scene.children.map((t => { "__sysObjectsWater" === t.name && t.children.map((t => { t.userData.modelName === e && (t.visible = !1) })) })), "" !== _context.stateStore.getCurrentState())) { let t = _context.stateStore.findState(_context.stateStore.getCurrentState()); t.settings.models = t.settings.models || {}, t.settings.models[e] = t.settings.models[e] || {}, t.settings.models[e].visible = !1 } } show(e, t = {}) { if (!this._scene || !e || !this.find(e)) return; let i = this._models[e]; if (t.exlusively) for (let t in this._models) this._models[t].name !== e && (this._models[t].visible = !1); if (t.withSettings && i.userData.dhExtension && (_context.materialStore.applySettings(i.userData.dhExtension.materials), _context.lightStore.applySettings(i.userData.dhExtension.lights), i.userData.dhExtension.view.duration = t.duration || 0, _context.instance.defaultView.applySettings(i.userData.dhExtension.view), _context.instance.defaultEffectStore.applySettings(i.userData.dhExtension.effects)), i instanceof Object3D && (i.visible = !0, this._scene.children.map((t => { "__sysObjectsWater" === t.name && t.children.map((t => { t.userData.modelName === e && (t.visible = !0) })) })), "" !== _context.stateStore.getCurrentState())) { let t = _context.stateStore.findState(_context.stateStore.getCurrentState()); t.settings.models = t.settings.models || {}, t.settings.models[e] = t.settings.models[e] || {}, t.settings.models[e].visible = !0 } } hideNode(e, t) { if (!(this._scene && e && t && this.find(e))) return; let i = this._models[e]; if (i instanceof Object3D) { let e; i.traverse((function (i) { i.name === t && (e = i) })), e && (e.visible = !1, e.traverse((function (e) { typeof e.name === t && "boolean" == typeof e.visible && (e.visible = !1) }))) } } showNode(e, t) { if (!(this._scene && e && t && this.find(e))) return; let i = this._models[e]; if (i instanceof Object3D) { let e; i.traverse((function (i) { i.name === t && (e = i) })), e && (e.visible = !0, e.traverse((function (e) { typeof e.name === t && "boolean" == typeof e.visible && (e.visible = !0) }))) } } rankUp(e, t) { let i = this; this._scene.models.children.map(((r, n) => { r.name === e && (0 === r.index ? t && t(0, "已是第一名无法上移") : (r.index -= 1, i._scene.models.children.map((e => { e.index === r.index && e.name != r.name && (e.index += 1) })), t && t(1, "成功"))) })) } rankDown(e, t) { let i = this; this._scene.models.children.map(((r, n) => { r.name === e && (r.index === i._scene.models.children.length - 1 ? t && t(0, "已是最后一名无法下移") : (r.index += 1, i._scene.models.children.map((e => { e.index === r.index && e.name != r.name && (e.index -= 1) })), t && t(1, "成功"))) })) } findAnimationClipAction(e, t) { if (!this._models[e]) return; let i = this._animationMixers.find((t => t.getRoot().name === this._models[e].name)); if (!i) return; let r = this._models[e].animations.find((e => e.name === t)); return r ? i.clipAction(r) : void 0 } stopAnimation(e, t) { let i = this.findAnimationClipAction(e, t); i && i.stop() } playAnimation(e, t, i) { let r = this.findAnimationClipAction(e, t); "number" == typeof i && (r.timeScale = i), r && r.play() } updateAnimation(e) { for (let t = 0; t < this._animationMixers.length; t++)this._animationMixers[t].update(e) } applyState(e) { } getSettings() { let e = this.getModels(); return traverse_1(e).forEach((function () { this.node && this.node.id && delete this.node.id })), this.result = e.sort(((e, t) => e.index - t.index)), this.transformRecursion(e, this._models), e } transformRecursion(e, t) { for (let i = 0; i < e.length; i++)if (e[i].transform = {}, t instanceof Array) for (let r = 0; r < t.length; r++)e[i].name === t[r].name && (e[i].transform.position = t[r].position, e[i].transform.rotation = t[r].rotation, e[i].transform.scale = t[r].scale, e[i].children.length > 0 && this.transformRecursion(e[i].children, t[r].children)); else if (t instanceof Object) for (let r in t) t[r].name === e[i].name && (e[i].transform.position = t[r].position, e[i].transform.rotation = t[r].rotation, e[i].transform.scale = t[r].scale, e[i].children.length > 0 && this.transformRecursion(e[i].children, t[r].children)) } setTransformRecursion(e, t) { if (t instanceof Array) for (let i = 0; i < e.length; i++)for (let r = 0; r < t.length; r++)e[i].transform && t[r].name === e[i].name && (t[r].position.x = e[i].transform.position.x, t[r].position.y = e[i].transform.position.y, t[r].position.z = e[i].transform.position.z, t[r].rotation.order = e[i].transform.rotation._order, t[r].rotation.x = e[i].transform.rotation._x, t[r].rotation.y = e[i].transform.rotation._y, t[r].rotation.z = e[i].transform.rotation._z, t[r].scale.x = e[i].transform.scale.x, t[r].scale.y = e[i].transform.scale.y, t[r].scale.z = e[i].transform.scale.z, t[i].children.length > 0 && this.setTransformRecursion(e[i].children, t[r].children)); else if (t instanceof Object) for (let i = 0; i < e.length; i++)for (let r in t) e[i].transform && t[r].name === e[i].name && (t[r].position.x = e[i].transform.position.x, t[r].position.y = e[i].transform.position.y, t[r].position.z = e[i].transform.position.z, t[r].rotation.order = e[i].transform.rotation._order, t[r].rotation.x = e[i].transform.rotation._x, t[r].rotation.y = e[i].transform.rotation._y, t[r].rotation.z = e[i].transform.rotation._z, t[r].scale.x = e[i].transform.scale.x, t[r].scale.y = e[i].transform.scale.y, t[r].scale.z = e[i].transform.scale.z, t[r].children.length > 0 && this.setTransformRecursion(e[i].children, t[r].children)) } applySettings(e) { if (!e) return void logger.error("无效的模型设置。"); this.setTransformRecursion(e, this._models); let t = this._nodeSelection; for (let i of e) { let e = this.find(i.name); if (e) { if (i.animations instanceof Array) for (let e of i.animations) { let t = []; for (let i of e.tracks) { let e; switch (i.type) { case "bool": e = new BooleanKeyframeTrack(i.name, i.times, i.values); break; case "color": e = new ColorKeyframeTrack(i.name, i.times, i.values); break; case "number": e = new NumberKeyframeTrack(i.name, i.times, i.values); break; case "quaternion": e = new QuaternionKeyframeTrack(i.name, i.times, i.values); break; case "string": e = new StringKeyframeTrack(i.name, i.times, i.values); break; case "vector": e = new VectorKeyframeTrack(i.name, i.times, i.values); break; default: e = new KeyframeTrack(i.name, i.times, i.values) }t.push(e) } let r = new AnimationClip(e.name, e.duration, t); this._models[i.name].animations.push(r) } this._models[i.name].visible = i.isVisible, i.transform && (this._models[i.name].position.x = i.transform.position.x, this._models[i.name].position.y = i.transform.position.y, this._models[i.name].position.z = i.transform.position.z, this._models[i.name].rotation._order = i.transform.rotation._order, this._models[i.name].rotation._x = i.transform.rotation._x, this._models[i.name].rotation._y = i.transform.rotation._y, this._models[i.name].rotation._z = i.transform.rotation._z, this._models[i.name].scale.x = i.transform.scale.x, this._models[i.name].scale.y = i.transform.scale.y, this._models[i.name].scale.z = i.transform.scale.z), this._animationMixers.push(new AnimationMixer(this._models[i.name])), traverse_1(i.children).forEach((function () { if (this.node && this.node.isNode && e.findNode) { t.selectNodes([e.findNode(this.node.name)]); for (let e in this.node) "children" !== e && "isNode" !== e && "material" !== e && "name" !== e && t.setProperty(e, this.node[e]) } })) } } } dispose() { for (const e in this._models) Object.hasOwnProperty.call(this._models, e) && util$1.disposeThreeObject(this._models[e]); this._models = null, this._nodeSelection.dispose && this._nodeSelection.dispose(), this._nodeSelection = null, this._animationMixers.forEach((e => { e.uncacheRoot(e.getRoot()) })), this._animationMixers = null, this._states = null } } class ObjectStore { constructor(e) { this._scene = e, this._sceneObjects = new Group, this._sceneObjects.name = "__objects", this._scene.add(this._sceneObjects), this._objects = new Object } add(e, t) { this._sceneObjects && e && t && (this.find(e) || (t.name = e, this._sceneObjects.add(t), this._objects[e] = t)) } clear() { if (this._sceneObjects) for (let e in this._objects) this._sceneObjects.remove(this._objects[e]), delete this._objects[e] } find(e) { if (this._sceneObjects && e) return this._objects[e] } remove(e) { if (!this._sceneObjects || !e) return; let t = this.find(e); t && (t.userData.mesh && (t.userData.mesh.geometry.dispose(), t.userData.mesh.material.dispose()), t.traverse && t.traverse((e => { if (e instanceof Mesh) if (e.geometry.dispose(), e.material instanceof Array) for (let t = 0; t < e.material.length; t++) { if (!e.material[t]) return; for (let i in e.material[t]) e.material[t][i] instanceof Texture$1 && e.material[t][i].dispose(); e.material[t].dispose() } else { for (let t in e.material) e.material[t] instanceof Texture$1 && e.material[t].dispose(); e.material.dispose() } else if (e instanceof Sprite) { for (let t in e.material) e.material[t] instanceof Texture$1 && e.material[t].dispose(); e.material.dispose() } })), this._sceneObjects.remove(t), delete this._objects[t.name]) } hide(e) { this._sceneObjects && e && (this._objects[e].visible = !1, this._objects[e].activeVisible = !1) } show(e) { this._sceneObjects && e && (this._objects[e].visible = !0, this._objects[e].activeVisible = !0) } forEach(e) { if (!util$1.isFunction(e)) return !1; for (let t in this._objects) e(this._objects[t]) } dispose() { this._sceneObjects && this._sceneObjects.children && this._sceneObjects.children.forEach((e => { util$1.disposeThreeObject(e) })), this._sceneObjects = null, this._objects && util$1.disposeThreeObject(this._objects), this._objects = null } } class SysObjectStore { constructor(e) { this._scene = e, this.sysObjectStore = new Group, this.sysObjectStore.name = "__sysObjectsWater", this._scene.add(this.sysObjectStore) } add(e, t) { this.sysObjectStore && e && t && (this.find(e) || (t.name = e, this.sysObjectStore.add(t))) } clear() { this.sysObjectStore && this.sysObjectStore.traverse((e => { this.sysObjectStore.remove(e) })) } find(e) { if (this.sysObjectStore && e) { var t = null; return this.sysObjectStore.traverse((i => { i.name === e && (t = i) })), t } } remove(e) { if (!this.sysObjectStore || !e) return; let t = this.find(e); t && this.sysObjectStore.remove(t) } hide(e) { this.sysObjectStore && e && this.sysObjectStore.traverse((t => { t.name === e && (t.visible = !1, t.activeVisible = !1) })) } show(e) { this.sysObjectStore && e && this.sysObjectStore.traverse((t => { t.name === e && (t.visible = !0, t.activeVisible = !0) })) } dispose() { util$1.disposeThreeObject(this.sysObjectStore), this.sysObjectStore = null } } const version = "3.7.2", VERSION = version, _hasatob = "function" == typeof atob, _hasbtoa = "function" == typeof btoa, _hasBuffer = "function" == typeof Buffer, _TD = "function" == typeof TextDecoder ? new TextDecoder : void 0, _TE = "function" == typeof TextEncoder ? new TextEncoder : void 0, b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", b64chs = Array.prototype.slice.call(b64ch), b64tab = (e => { let t = {}; return e.forEach(((e, i) => t[e] = i)), t })(b64chs), b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, _fromCC = String.fromCharCode.bind(String), _U8Afrom = "function" == typeof Uint8Array.from ? Uint8Array.from.bind(Uint8Array) : (e, t = (e => e)) => new Uint8Array(Array.prototype.slice.call(e, 0).map(t)), _mkUriSafe = e => e.replace(/=/g, "").replace(/[+\/]/g, (e => "+" == e ? "-" : "_")), _tidyB64 = e => e.replace(/[^A-Za-z0-9\+\/]/g, ""), btoaPolyfill = e => { let t, i, r, n, a = ""; const o = e.length % 3; for (let o = 0; o < e.length;) { if ((i = e.charCodeAt(o++)) > 255 || (r = e.charCodeAt(o++)) > 255 || (n = e.charCodeAt(o++)) > 255) throw new TypeError("invalid character found"); t = i << 16 | r << 8 | n, a += b64chs[t >> 18 & 63] + b64chs[t >> 12 & 63] + b64chs[t >> 6 & 63] + b64chs[63 & t] } return o ? a.slice(0, o - 3) + "===".substring(o) : a }, _btoa = _hasbtoa ? e => btoa(e) : _hasBuffer ? e => Buffer.from(e, "binary").toString("base64") : btoaPolyfill, _fromUint8Array = _hasBuffer ? e => Buffer.from(e).toString("base64") : e => { let t = []; for (let i = 0, r = e.length; i < r; i += 4096)t.push(_fromCC.apply(null, e.subarray(i, i + 4096))); return _btoa(t.join("")) }, fromUint8Array = (e, t = !1) => t ? _mkUriSafe(_fromUint8Array(e)) : _fromUint8Array(e), cb_utob = e => { if (e.length < 2) return (t = e.charCodeAt(0)) < 128 ? e : t < 2048 ? _fromCC(192 | t >>> 6) + _fromCC(128 | 63 & t) : _fromCC(224 | t >>> 12 & 15) + _fromCC(128 | t >>> 6 & 63) + _fromCC(128 | 63 & t); var t = 65536 + 1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320); return _fromCC(240 | t >>> 18 & 7) + _fromCC(128 | t >>> 12 & 63) + _fromCC(128 | t >>> 6 & 63) + _fromCC(128 | 63 & t) }, re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, utob = e => e.replace(re_utob, cb_utob), _encode = _hasBuffer ? e => Buffer.from(e, "utf8").toString("base64") : _TE ? e => _fromUint8Array(_TE.encode(e)) : e => _btoa(utob(e)), encode = (e, t = !1) => t ? _mkUriSafe(_encode(e)) : _encode(e), encodeURI$1 = e => encode(e, !0), re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, cb_btou = e => { switch (e.length) { case 4: var t = ((7 & e.charCodeAt(0)) << 18 | (63 & e.charCodeAt(1)) << 12 | (63 & e.charCodeAt(2)) << 6 | 63 & e.charCodeAt(3)) - 65536; return _fromCC(55296 + (t >>> 10)) + _fromCC(56320 + (1023 & t)); case 3: return _fromCC((15 & e.charCodeAt(0)) << 12 | (63 & e.charCodeAt(1)) << 6 | 63 & e.charCodeAt(2)); default: return _fromCC((31 & e.charCodeAt(0)) << 6 | 63 & e.charCodeAt(1)) } }, btou = e => e.replace(re_btou, cb_btou), atobPolyfill = e => { if (e = e.replace(/\s+/g, ""), !b64re.test(e)) throw new TypeError("malformed base64."); e += "==".slice(2 - (3 & e.length)); let t, i, r, n = ""; for (let a = 0; a < e.length;)t = b64tab[e.charAt(a++)] << 18 | b64tab[e.charAt(a++)] << 12 | (i = b64tab[e.charAt(a++)]) << 6 | (r = b64tab[e.charAt(a++)]), n += 64 === i ? _fromCC(t >> 16 & 255) : 64 === r ? _fromCC(t >> 16 & 255, t >> 8 & 255) : _fromCC(t >> 16 & 255, t >> 8 & 255, 255 & t); return n }, _atob = _hasatob ? e => atob(_tidyB64(e)) : _hasBuffer ? e => Buffer.from(e, "base64").toString("binary") : atobPolyfill, _toUint8Array = _hasBuffer ? e => _U8Afrom(Buffer.from(e, "base64")) : e => _U8Afrom(_atob(e), (e => e.charCodeAt(0))), toUint8Array = e => _toUint8Array(_unURI(e)), _decode = _hasBuffer ? e => Buffer.from(e, "base64").toString("utf8") : _TD ? e => _TD.decode(_toUint8Array(e)) : e => btou(_atob(e)), _unURI = e => _tidyB64(e.replace(/[-_]/g, (e => "-" == e ? "+" : "/"))), decode = e => _decode(_unURI(e)), isValid = e => { if ("string" != typeof e) return !1; const t = e.replace(/\s+/g, "").replace(/={0,2}$/, ""); return !/[^\s0-9a-zA-Z\+/]/.test(t) || !/[^\s0-9a-zA-Z\-_]/.test(t) }, _noEnum = e => ({ value: e, enumerable: !1, writable: !0, configurable: !0 }), extendString = function () { const e = (e, t) => Object.defineProperty(String.prototype, e, _noEnum(t)); e("fromBase64", (function () { return decode(this) })), e("toBase64", (function (e) { return encode(this, e) })), e("toBase64URI", (function () { return encode(this, !0) })), e("toBase64URL", (function () { return encode(this, !0) })), e("toUint8Array", (function () { return toUint8Array(this) })) }, extendUint8Array = function () { const e = (e, t) => Object.defineProperty(Uint8Array.prototype, e, _noEnum(t)); e("toBase64", (function (e) { return fromUint8Array(this, e) })), e("toBase64URI", (function () { return fromUint8Array(this, !0) })), e("toBase64URL", (function () { return fromUint8Array(this, !0) })) }, extendBuiltins = () => { extendString(), extendUint8Array() }, gBase64 = { version: version, VERSION: VERSION, atob: _atob, atobPolyfill: atobPolyfill, btoa: _btoa, btoaPolyfill: btoaPolyfill, fromBase64: decode, toBase64: encode, encode: encode, encodeURI: encodeURI$1, encodeURL: encodeURI$1, utob: utob, btou: btou, decode: decode, isValid: isValid, fromUint8Array: fromUint8Array, toUint8Array: toUint8Array, extendString: extendString, extendUint8Array: extendUint8Array, extendBuiltins: extendBuiltins }; class TextureStore { constructor(e = "textureStore") { this._textures = new Object, this._type = e, this._glCanvas = document.createElement("canvas"), this._gl = this._glCanvas.getContext("webgl2") } handleGLBlobToDataURL(e) { const t = this._gl.createTexture(), i = this._gl.createFramebuffer(), r = new Uint8Array(e.width * e.height * 4); this._gl.activeTexture(this._gl.TEXTURE0), this._gl.bindTexture(this._gl.TEXTURE_2D, t), this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, i), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, t, 0), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, e), this._gl.drawBuffers([this._gl.COLOR_ATTACHMENT0]), this._gl.readPixels(0, 0, e.width, e.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, r); let n = new browser.PNG({ width: e.width, height: e.height, filterType: 4 }); for (let e = 0; e < n.data.length; e += 4)n.data[e + 0] = r[e + 0], n.data[e + 1] = r[e + 1], n.data[e + 2] = r[e + 2], n.data[e + 3] = r[e + 3]; n.pack(); const a = browser.PNG.sync.write(n, { colorType: 6 }); return gBase64.fromUint8Array(a) } loadTexture({ url: e, name: t, onLoad: i, onProgress: r } = {}) { e ? (t || (t = e, logger.debug("TextureStore.loadTexture() 参数name为空,使用url作为name。")), _context.cacheStore.load({ path: e, type: "imagebitmap", onLoad: t => { t.name = e, t.wrapT = RepeatWrapping, t.wrapS = RepeatWrapping, t.flipY = !1; let r = this.add(e, t); r.url = e, i && i(r), logger.debug("TextureStore.loadTexture() onLoad。") }, onProgress: e => { r && r(e), logger.debug("TextureStore.loadTexture() onProgress") }, onError: () => { i && i(0) } })) : logger.debug("TextureStore.loadTexture() 参数url为空。") } add(e, t, i) { if (e && t) return this.find(e) ? (t.name || (t.name = e), this.find(e)) : (t.name = e, this._textures[e] = Texture._fromThreeObject(t), this._textures[e].sourceModelKey = i, this._textures[e]) } clear() { for (let e in this._textures) delete this._textures[e] } find(e) { if (e) return this._textures[e] } remove(e) { if (!e) return; let t = this.find(e); t && delete this._textures[t.name] } textureSort(e) { e.sort(((e, t) => e.name.localeCompare(t.name))) } getAll() { if (!this._textures) return []; let e = []; for (let t in this._textures) e.push(this._textures[t]); return this.textureSort(e), e } dispose() { for (const e in this._textures) Object.hasOwnProperty.call(this._textures, e) && this._textures[e].destroyCanvas && this._textures[e].destroyCanvas(); this._textures = null } isTextureStore() { return "texturestore" === this._type.toLowerCase() } isCustomTextureStore() { return "customtexturestore" === this._type.toLowerCase() } getSettings() { if (this.isTextureStore()) { const e = []; for (const t in this._textures) { const i = this._textures[t].sourceModelKey; if ("string" == typeof i && "" !== i) { let r = !1; for (let e of _context.defaultObjectTree.children) if (e.getGroup().sourceModelKey === i) { r = !0; break } if (!r) { let r = !1; if (_context.scene.models.traverse((e => { if (e.material) if (e.material instanceof Array) e.material.forEach((e => { for (var i in e) e[i] && e[i].image && this._textures[t]._textureSource === e[i].image && (r = !0) })); else for (var i in e.material) e.material[i] && e.material[i].image && this._textures[t]._textureSource === e.material[i].image && (r = !0) })), !r) continue; const n = this._textures[t]._textureSource, a = this.handleGLBlobToDataURL(n); e.push({ key: t, sourceToBase64: a, sourceModelKey: i, width: n.width, height: n.height }) } } } return { orphanTextures: e } } if (this.isCustomTextureStore()) { let e = [], t = this.getAll(); return _context.scene.models.traverse((i => { if (i.material) if (i.material instanceof Array) i.material.forEach((i => { for (var r in i) i[r] && i[r].image && i[r].image && t.forEach((t => { if (t.rul && i[r].image === t.textureSource && !e.find((e => e.url === t.url))) { let i = { name: t.name, url: t.url }; e.push(i) } })) })); else for (var r in i.material) i.material[r] && i.material[r].image && i.material[r].image && t.forEach((t => { if (t.url && i.material[r].image === t.textureSource && !e.find((e => e.url === t.url))) { let i = { name: t.name, url: t.url }; e.push(i) } })) })), e } } applySettings(e) { return this.isTextureStore() ? new Promise((t => { let i = [], r = e.orphanTextures || []; for (const e of r) i.push(new Promise((t => { var i = gBase64.toUint8Array(e.sourceToBase64); new browser.PNG({ filterType: 4 }).parse(i, ((i, r) => { const n = browser.PNG.sync.write(r), a = new Blob([n], { type: "image/png" }), o = new FileReader; o.readAsDataURL(a), o.onload = i => { _context.loaders.textureLoader.load(i.target.result, (i => { i.wrapT = RepeatWrapping, i.wrapS = RepeatWrapping, this.add(e.key, i, e.sourceModelKey), t() })) } })) }))); i.length ? Promise.all(i).then((e => { logger.debug("TextureStore.applySettings() loadTexture end。"), t(1) })) : (logger.debug("TextureStore.applySettings() loadTexture end。"), t(1)) })) : this.isCustomTextureStore() ? new Promise((t => { let i = []; e.forEach((e => { i.push(new Promise((t => { this.loadTexture({ name: e.name, url: e.url, onLoad: () => { t() } }) }))) })), i.length ? Promise.all(i).then((e => { logger.debug("TextureStore.applySettings() loadTexture end。"), t(1) })) : (logger.debug("TextureStore.applySettings() loadTexture end。"), t(1)) })) : void 0 } getExportTextureGroup() { let e = this.getSettings(); if (!e.length) return; let t = new Group; return e.forEach((e => { let i = this.find(e.url), r = new Mesh(new PlaneGeometry(1.4, 1.4, 10, 10)); r.name = e.url, r.material = new Material$1, r.material.color = new Color$1, r.material.map = new Texture$1(i.textureSource), r.material.map.wrapS = RepeatWrapping, r.material.map.wrapT = RepeatWrapping, r.material.map.flipY = !1, r.material.map.name = i.name, t.add(r) })), t.userData = { customTexture: !0 }, t } } class StateStore { constructor(e) { this._defaultState = {}, this._states = [], this._currentState = "", this._nodeSelection = new NodeSelection(e), this._camera = {} } isDefaultState() { return "" === this._currentState } add(e) { if (!e || this.find(e)) return; let t = {}; return t.id = util$1.guid(), t.name = e, _context.instance.notState ? t.settings = JSON.parse(JSON.stringify(_context.instance.notState)) : (t.settings = JSON.parse(JSON.stringify(_context.instance.getSettings())), _context.instance._notView && (t.settings.view = _context.instance._notView)), delete t.settings.sceneModelTransform, delete t.settings.datumShiftModel, delete t.settings.states, delete t.settings.cache, delete t.settings.texture0, !window.firstLoadEnd && _context.sceneSettings && (t.settings.view.camera = _context.sceneSettings.view.camera), 0 === this._states.length ? t.defaultState = !0 : t.defaultState = !1, t.settings.objectTree.children.forEach((e => { "BuildingItem" === e.type ? e.children.forEach((e => { "ModelItem" === e.type ? e.articulationAnimations && e.articulationAnimations.forEach((e => { e.isEnable = !1 })) : "BuildingFloorItem" === e.type && e.children.forEach((e => { "ModelItem" === e.type && e.articulationAnimations && e.articulationAnimations.forEach((e => { e.isEnable = !1 })) })) })) : "ModelItem" === e.type || "ModelAsset" === e.type ? e.articulationAnimations && e.articulationAnimations.forEach((e => { e.isEnable = !1 })) : "PaintItem" === e.type && (e.children.forEach((e => { "ModelItem" === e.type && e.articulationAnimations && e.articulationAnimations.forEach((e => { e.isEnable = !1 })) })), e.modelInstanced.forEach((e => { e.articulationAnimations && e.articulationAnimations.forEach((e => { e.isEnable = !1 })) }))) })), this._states.push(t), t.name } clear() { this._states = [], this._currentState } find(e) { if (e && "" !== e) return this._states.find((t => t.name === e)) } getStates() { let e = []; this._states.length || this.add("默认状态"); for (let i of this._states) if (i.defaultState) { t = { name: i.name, default: i.defaultState }; e.unshift(t) } else { var t = { name: i.name, default: i.defaultState }; e.push(t) } return e } remove(e) { if (e) for (let t = 0; t < this._states.length; t++)if (this._states[t].name === e && !this._states[t].defaultState) { this._states.splice(t, 1); break } } update(e, t) { if (e && t) { for (let i = 0; i < this._states.length; i++)if (this._states[i].name === e) { this._states[i].name = t; break } this._currentState === e && (this._currentState = t) } } copyState(e, t) { let i = {}; i.id = util$1.guid(), i.name = t; let r = this._states.find((t => t.name == e)); return i.settings = r ? JSON.parse(JSON.stringify(r.settings)) : JSON.parse(JSON.stringify(_context.instance.getSettings())), delete i.settings.sceneModelTransform, delete i.settings.datumShiftModel, delete i.settings.states, delete i.settings.cache, delete i.settings.texture0, i.defaultState = !1, this._states.push(i), i } getCurrentState() { return this._currentState } saveCurrentStateSettings() { let e = this.find(this._currentState); e && (e.settings = JSON.parse(JSON.stringify(_context.instance.getSettings())), delete e.settings.sceneModelTransform, delete e.settings.datumShiftModel, delete e.settings.states, delete e.settings.cache, e.settings.view.camera.azimuth = this._camera.azimuthAngle, e.settings.view.camera.viewLimitRadius = this._camera.viewLimitRadius, e.settings.view.camera.inclination = this._camera.inclinationAngle, e.settings.view.camera.fov = this._camera.fov, e.settings.view.camera.distance = this._camera.viewDistance, e.settings.view.camera.distanceMax = this._camera.distanceMax, e.settings.view.camera.distanceMin = this._camera.distanceMin, e.settings.view.camera.viewDistanceMin = this._camera.near, e.settings.view.camera.viewDistanceMax = this._camera.far, e.settings.view.camera.targetX = this._camera.targetX, e.settings.view.camera.targetY = this._camera.targetY, e.settings.view.camera.targetZ = this._camera.targetZ, e.settings.view.camera.inclinationAngleMin = this._camera.inclinationAngleMin, e.settings.view.camera.inclinationAngleMax = this._camera.inclinationAngleMax, e.settings.view.camera.duration = null != this._camera.duration ? this._camera.duration : 1.5, e.settings.view.camera.autoRotate = this._camera.autoRotate, e.settings.view.camera.autoRotateSpeed = this._camera.autoRotateSpeed, e.settings.view.camera.autoRotateDirection = this._camera.autoRotateDirection, _context.instance.saveSceneSettings(JSON.parse(JSON.stringify(_context.instance.getSettings())))) } saveCameraParam(e, t) { _context.orbitControls.defaultTargetPosition = new Vector3(e.targetX, e.targetY, e.targetZ), _context.orbitControls.viewLimitRadius = e.viewLimitRadius, _context.instance.setAutoRotate(!1, 0), _context.instance.nextRender((() => { _context.instance.setAutoRotate(e.autoRotate, util$1.getAutoRotateTime(e.autoRotateSpeed, e.autoRotateDirection)) })), this._camera = JSON.parse(JSON.stringify(e)), this._camera.duration = t, this.saveCurrentStateSettings() } selectState(e = "", t, i) { if ("" !== e && !this.find(e)) return void (t && t(0, "名为" + e + "的状态不存在")); this._currentState = e; let r = this.find(e); return r ? (null != r.settings.view.camera.azimuth && (void 0 === r.settings.view.camera.duration && (r.settings.view.camera.duration = 1.5), this._camera.azimuthAngle = r.settings.view.camera.azimuth, 0 == r.settings.view.camera.viewLimitRadius || r.settings.view.camera.viewLimitRadius || (r.settings.view.camera.viewLimitRadius = 1e8), this._camera.viewLimitRadius = r.settings.view.camera.viewLimitRadius, this._camera.inclinationAngle = r.settings.view.camera.inclination, this._camera.fov = r.settings.view.camera.fov, this._camera.viewDistance = r.settings.view.camera.distance, this._camera.distanceMax = r.settings.view.camera.distanceMax, this._camera.distanceMin = r.settings.view.camera.distanceMin, this._camera.near = r.settings.view.camera.viewDistanceMin, this._camera.far = r.settings.view.camera.viewDistanceMax, this._camera.targetX = r.settings.view.camera.targetX, this._camera.targetY = r.settings.view.camera.targetY, this._camera.targetZ = r.settings.view.camera.targetZ, this._camera.inclinationAngleMin = r.settings.view.camera.inclinationAngleMin, this._camera.inclinationAngleMax = r.settings.view.camera.inclinationAngleMax, this._camera.duration = r.settings.view.camera.duration, this._camera.autoRotate = r.settings.view.camera.autoRotate, this._camera.duration = r.settings.view.camera.duration, this._camera.autoRotateSpeed = r.settings.view.camera.autoRotateSpeed, this._camera.autoRotateDirection = r.settings.view.camera.autoRotateDirection), _context.instance.applySceneSettings(r.settings, t), this._states.filter((t => t.name !== e)).forEach((e => { e.settings.objectTree.children && e.settings.objectTree.children.forEach && e.settings.objectTree.children.forEach((e => { let t = _context.instance.getDefaultObjectTree().getItemByName(e.name); t && (e.articulationAnimations && e.articulationAnimations.filter((e => e.isEnable)).forEach((e => { t.resetArticulationAnimation(e.animationName) })), e.articulations && e.articulations.forEach((e => { let i = t.articulations.find((t => t._name == e._name)); i && i.type == ArticulationTypes.text && i.deleteArticulation() })), e.articulations && e.articulations.filter((e => e.isEnable)).forEach((e => { let i = t.articulations.find((t => t._name == e._name)); i && i.set(e.value) })), _context.effectStore.initOutlinePass()) })) })), r.settings.objectTree.children && r.settings.objectTree.children.forEach && r.settings.objectTree.children.forEach((e => { let t = _context.instance.getDefaultObjectTree().getItemByName(e.name); t && (e.articulations && e.articulations.forEach((e => { let i = t.articulations.find((t => t._name == e._name)); i && i.type == ArticulationTypes.text && i.deleteArticulation() })), e.articulations && e.articulations.filter((e => e.isEnable)).forEach((e => { let i = t.articulations.find((t => t._name == e._name)); i && (i.type == ArticulationTypes.text ? i.addOrUpdateTextArticulation() : i.set(e.value)) })), e.articulationAnimationTimeOut && clearTimeout(e.articulationAnimationTimeOut), e.articulationAnimationTimeOut = setTimeout((() => { e.articulationAnimations && e.articulationAnimations.filter((e => e.isEnable)).forEach((e => { t.resetArticulationAnimation(e.animationName), t.playArticulationAnimation(e.animationName) })) }), 1e3)) })), i && i({ name: e, default: r.defaultState }), r.settings) : void 0 } setCamera(e) { this.find(this._currentState) && (this.find(this._currentState).camera = e) } setGlobalIlluminationInCurrentState(e) { this.find(this._currentState) && (this.find(this._currentState).globalIllumination = e) } getSettings() { let e = []; return this._states.map((t => { e.push(t) })), e } setNotState() { this._currentState = "" } setDefaultState(e) { this._states.forEach((e => { e.defaultState = !1 })), this._states.forEach((t => { t.name === e && (t.defaultState = !0) })) } applySettings(e) { e && e.map((e => { 0 === this._states.filter((t => t.name === e.name)).length && this._states.push(e) })) } synchronizaArticulation() { _context.instance.getSettings().objectTree.children.forEach((e => { this._states.forEach((t => { let i = t.settings.objectTree.children.find((t => t.name === e.name)); if (i && i.articulations) { let t = {}; i.articulations.forEach((e => { t[e._name] = {}, t[e._name].isEnable = e.isEnable })), i.articulations = [], i.articulations = JSON.parse(JSON.stringify(e.articulations)), i.articulations.forEach((e => { t[e._name] && (e.isEnable = t[e._name].isEnable) })) } })) })) } synchronizaAnimation() { _context.instance.getSettings().objectTree.children.forEach((e => { this._states.forEach((t => { let i = t.settings.objectTree.children.find((t => t.name === e.name)); if (i && i.articulationAnimations) { let t = {}; i.articulationAnimations.forEach((e => { t[e.animationName] = {}, t[e.animationName].isEnable = e.isEnable })), i.articulationAnimations = [], i.articulationAnimations = JSON.parse(JSON.stringify(e.articulationAnimations)), i.articulationAnimations.forEach((e => { t[e.animationName] && (e.isEnable = t[e.animationName].isEnable) })) } })) })) } getCurrentStateSetting() { return "" !== this._currentState && this._states.find((e => e.name == this._currentState)).settings } dispose() { this._defaultState = {}, this._states = [], this._currentState = "", this._nodeSelection.dispose && this._nodeSelection.dispose(), this._camera = null } } class SceneStore { constructor() { this.scenes = {} } createScene(e, t, i, r, n = !1) { const a = {}; a.serviceName = e, a.scenePath = t, a.token = r, a.defaultScene = n, a.cache = {}; const o = a.cache; void 0 !== i ? (o.scene = i, o.models = _context.models, o.sysObjects = _context.sysObjects, o.noneModels = _context.noneModels, o.axesHelper = _context.axesHelper, o.modelStore = _context.modelStore, o.objectStore = _context.objectStore, o.sysObjectStore = _context.sysObjectStore, o.lightStore = _context.lightStore, o.stateStore = _context.stateStore, o.animationStore = _context.animationStore, o.clippingStore = _context.clippingStore, o.eventHandlerStore = _context.eventHandlerStore, o.defaultObjectTree = _context.defaultObjectTree, o.defaultNodeSelection = _context.instance.defaultNodeSelection) : (o.scene = new Scene, o.scene.name = "__newAvwCore" + util$1.guid(), o.models = new Group, o.models.name = "__models", o.scene.models = o.models, o.scene.add(o.models), o.sysObjects = new Group, o.sysObjects.name = "__sysObjects", o.sysObjects.renderOrder = 1 / 0, o.scene.sysObjects = o.sysObjects, o.scene.add(o.sysObjects), o.noneModels = new Group, o.noneModels.name = "__noneModels", o.scene.noneModels = o.noneModels, o.scene.add(o.noneModels), o.axesHelper = new AxesHelper(50), o.axesHelper.name = "__axesHelper", o.axesHelper.visible = !1, o.scene.axesHelper = o.axesHelper, o.scene.add(o.axesHelper), _context.alpha || (o.scene.background = new Color$1(BACKGROUND_COLOR_DEFAULT)), o.scene.setNodeRotation = _context.instance.setNodeRotation, o.scene.setNodeRotating = _context.instance.setNodeRotating, o.scene.setNodeScaling = _context.instance.setNodeScaling, o.scene.setNodeBreathing = _context.instance.setNodeBreathing, o.modelStore = new ModelStore(o.scene), o.objectStore = new ObjectStore(o.scene), o.sysObjectStore = new SysObjectStore(o.scene), o.lightStore = new LightStore(o.scene, _context.instance), o.stateStore = new StateStore, o.animationStore = new AnimationStore, o.clippingStore = new ClippingStore, o.eventHandlerStore = new EventHandlerStore(_context.renderer, o.scene, _context.camera), o.defaultObjectTree = new ObjectTree(o.scene), o.eventHandlerStore.handlers = _context.eventHandlerStore.handlers), this.scenes[e] = a } updateSceneCache(e) { } findSceneCache(e) { return this.scenes[e] } addOrUpdateScene({ serviceName: e, scenePath: t, scene: i, token: r, defaultScene: n = !1 }) { const a = this.findSceneCache(e); a ? (i && (a.scene = i), t && (a.scenePath = t), r && (a.token = r)) : this.createScene(e, t, i, r, n) } findScene(e) { return this.findSceneCache(e) } getScenes() { const e = []; for (const t in this.scenes) { const i = this.scenes[t]; e.push({ name: i.serviceName, default: i.defaultScene ?? !1, url: i.scenePath, token: i.token ?? "" }) } return e } destroy() { for (const e in this.scenes) { const t = this.scenes[e].cache.scene; t && t.children && t.children.forEach((e => { util$1.disposeThreeObject(e) })) } this.scenes = {} } } var objectChangeEvent = { type: "objectChange" }, stateChangeEvent = { type: "stateChange" }, historyMoveEvent = { type: "historyMove" }; class TransformStore extends EventDispatcher { constructor(e) { super("TransformStore"); let t = this; this.mode = "model", this.transformControls = e, this.transformHistory = { model: [], node: [] }, this._historyState = { model: 0, node: 0 }, this._historyType = { model: "new", node: "new" }, this._selectionType = { model: "defaultModelSelection", node: "defaultNodeSelection" }; let i = []; this.controlState = { redo: !1, undo: !1 }, this._getHelperTransform = e => { let { key: t } = e.userData; return e.instanced.getTransform(t) }, this.mouseDown = e => { if (i = [], _context.instance[this._selectionType[this.mode]].getSelectionList().length) _context.instance[this._selectionType[this.mode]].getSelectionList().forEach((e => { let t = {}, r = _context.scene.getObjectByProperty("uuid", e), n = {}; if (r) { let e = r.position.clone(), t = r.rotation.clone(), i = r.scale.clone(); if (r instanceof InstancedHelper) { let n = this._getHelperTransform(r); e = n.position, t = n.rotation, i = n.scale } n.position = JSON.parse(JSON.stringify(e)), n.rotation = JSON.parse(JSON.stringify(t)), n.scale = JSON.parse(JSON.stringify(i)), n.rotation.x = n.rotation._x = MathUtils.radToDeg(t._x), n.rotation.y = n.rotation._y = MathUtils.radToDeg(t._y), n.rotation.z = n.rotation._z = MathUtils.radToDeg(t._z) } t.object = r, t.oldTransform = n, i.push(t) })); else { let t = {}, r = e.target.object; if (!r && e.uuid && (r = _context.scene.getObjectByProperty("uuid", e.uuid)), !_context.instance.defaultObjectTree.getItemByUUID(r.uuid)) return; let n = {}; if (r) { let e = r.position.clone(), t = r.rotation.clone(), i = r.scale.clone(); if (r instanceof InstancedHelper) { let n = this._getHelperTransform(r); e = n.position, t = n.rotation, i = n.scale } n.position = JSON.parse(JSON.stringify(e)), n.rotation = JSON.parse(JSON.stringify(t)), n.scale = JSON.parse(JSON.stringify(i)), n.rotation.x = n.rotation._x = MathUtils.radToDeg(t._x), n.rotation.y = n.rotation._y = MathUtils.radToDeg(t._y), n.rotation.z = n.rotation._z = MathUtils.radToDeg(t._z) } t.object = r, t.oldTransform = n, i.push(t) } }, this.mouseUp = e => { if (!i.length) return; let r = new Map; if (_context.instance[this._selectionType[this.mode]].getSelectionList().length) _context.instance[this._selectionType[this.mode]].getSelectionList().forEach((e => { let t = _context.scene.getObjectByProperty("uuid", e), i = {}; if (t) { let e = t.position.clone(), n = t.rotation.clone(), a = t.scale.clone(); if (t instanceof InstancedHelper) { let i = this._getHelperTransform(t); e = i.position, n = i.rotation, a = i.scale } i.position = JSON.parse(JSON.stringify(e)), i.rotation = JSON.parse(JSON.stringify(n)), i.scale = JSON.parse(JSON.stringify(a)), i.rotation.x = i.rotation._x = MathUtils.radToDeg(n._x), i.rotation.y = i.rotation._y = MathUtils.radToDeg(n._y), i.rotation.z = i.rotation._z = MathUtils.radToDeg(n._z), r.set(t, i) } })); else { let t = e.target.object; !t && e.uuid && (t = _context.scene.getObjectByProperty("uuid", e.uuid)); let i = {}; if (t) { let e = t.position.clone(), n = t.rotation.clone(), a = t.scale.clone(); if (t instanceof InstancedHelper) { let i = this._getHelperTransform(t); e = i.position, n = i.rotation, a = i.scale } i.position = JSON.parse(JSON.stringify(e)), i.rotation = JSON.parse(JSON.stringify(n)), i.scale = JSON.parse(JSON.stringify(a)), i.rotation.x = i.rotation._x = MathUtils.radToDeg(n._x), i.rotation.y = i.rotation._y = MathUtils.radToDeg(n._y), i.rotation.z = i.rotation._z = MathUtils.radToDeg(n._z), r.set(t, i) } } let n = i.map((e => e.oldTransform)), a = i.map((e => e.object)).map((e => r.get(e))); if (n.length === a.length && JSON.stringify(n) != JSON.stringify(a)) { let e; i.forEach((e => { e.newTransform = r.get(e.object) })), e = "new" == t.historyType[this.mode] ? t.historyState[this.mode] + 1 : t.historyState[this.mode], t.transformHistory[this.mode].splice(e), t.transformHistory[this.mode].push(i), t.historyState[this.mode] = t.transformHistory[this.mode].length - 1, t.historyType[this.mode] = "new", i = [], this.historyState = this.historyState, this.historyType = this.historyType } }, this.transformControls.addEventListener("mouseDown", this.mouseDown), this.transformControls.addEventListener("mouseUp", this.mouseUp) } onGoHistory(e, t) { if (e.length > 1) { let i = e.map((e => (_context.instance.setModelTransformByUUID(e.object.uuid, e[t]), e.object.uuid))); _context.instance[this._selectionType[this.mode]].selectObjectByUUID(i), _context.instance[this._selectionType[this.mode]].enableTransformControl(), historyMoveEvent.object = i, historyMoveEvent.eventType = "multiple", this.dispatchEvent(historyMoveEvent) } else e.forEach((e => { _context.instance.setModelTransformByUUID(e.object.uuid, e[t]), historyMoveEvent.object = e.object, historyMoveEvent.eventType = "radio", this.dispatchEvent(historyMoveEvent) })) } advance() { if (this.controlState.redo && !(this.transformHistory[this.mode].length <= 0)) { if (this.historyState[this.mode] < this.transformHistory[this.mode].length - 1) if ("new" == this.historyType[this.mode]) { let e = this.transformHistory[this.mode][this.historyState[this.mode] + 1]; this.onGoHistory(e, "newTransform"), this.historyState[this.mode] = this.historyState[this.mode] + 1, this.historyType[this.mode] = "new" } else { let e = this.transformHistory[this.mode][this.historyState[this.mode]]; this.onGoHistory(e, "newTransform"), this.historyType[this.mode] = "new" } if (this.historyState[this.mode] == this.transformHistory[this.mode].length - 1 && "old" == this.historyType[this.mode]) { let e = this.transformHistory[this.mode][this.historyState[this.mode]]; this.onGoHistory(e, "newTransform"), this.historyType[this.mode] = "new" } this.historyState = this.historyState, this.historyType = this.historyType, this.transformControls.object && this.transformControls.dispatchEvent(objectChangeEvent) } } backOff() { if (this.controlState.undo && !(this.transformHistory[this.mode].length <= 0)) { if (this.historyState[this.mode] > 0) if ("old" == this.historyType[this.mode]) { let e = this.transformHistory[this.mode][this.historyState[this.mode] - 1]; this.onGoHistory(e, "oldTransform"), this.historyState[this.mode] = this.historyState[this.mode] - 1, this.historyType[this.mode] = "old" } else { let e = this.transformHistory[this.mode][this.historyState[this.mode]]; this.onGoHistory(e, "oldTransform"), this.historyType[this.mode] = "old" } if (0 == this.historyState[this.mode] && "new" == this.historyType[this.mode]) { let e = this.transformHistory[this.mode][this.historyState[this.mode]]; this.onGoHistory(e, "oldTransform"), this.historyType[this.mode] = "old" } this.historyState = this.historyState, this.historyType = this.historyType, this.transformControls.object && this.transformControls.dispatchEvent(objectChangeEvent) } } clear() { this.transformHistory[this.mode] = [], this.historyState[this.mode] = 0, this.historyState = this.historyState, this.historyType[this.mode] = "new", this.historyType = this.historyType } destroy() { this.transformControls.removeEventListener("mouseDown", this.mouseDown), this.transformControls.removeEventListener("mouseUp", this.mouseUp), this.transformControls = null, this.transformHistory = null, this.historyState = null, this.historyType = null } returnChangeState() { if (!this.historyState) return; if (null === this.historyState[this.mode]) return; if (null === this.historyType[this.mode]) return; let e = { redo: !1, undo: !1 }; this.transformHistory[this.mode].length > 0 && ("old" == this.historyType[this.mode] ? (this.historyState[this.mode] > 0 && (e.undo = !0), this.historyState[this.mode] <= this.transformHistory[this.mode].length - 1 && (e.redo = !0)) : "new" == this.historyType[this.mode] && (this.historyState[this.mode] >= 0 && (e.undo = !0), this.historyState[this.mode] < this.transformHistory[this.mode].length - 1 && (e.redo = !0))), this.controlState = e, this.dispatchEvent(stateChangeEvent) } setMode(e) { this.mode = e, this.historyState = this.historyState, this.historyType = this.historyType } get historyState() { return this._historyState } set historyState(e) { this._historyState = e, this.returnChangeState() } get historyType() { return this._historyType } set historyType(e) { this._historyType = e, this.returnChangeState() } } function BespokeThenable() { var e, t = 0, i = [], r = 0, n = 0; var a = d((function (e) { n || s(1, e) })), o = d((function (e) { n || s(-1, e) })); function s(i, r) { n++; var a = 0; try { r === m && p(); var o = i > 0 && u(r); o ? o.call(r, d((function (e) { a++, s(1, e) })), d((function (e) { a++, s(-1, e) }))) : (t = i, e = r, l()) } catch (e) { t || a || s(-1, e) } } function l() { r || (setTimeout(c, 0), r = 1) } function c() { var e = i; r = 0, i = [], e.forEach(h) } function h(e) { e() } function u(e) { var t = e && (f(e) || "object" == typeof e) && e.then; return f(t) && t } function d(e) { var t = 0; return function () { for (var i = [], r = arguments.length; r--;)i[r] = arguments[r]; t++ || e.apply(this, i) } } function p() { throw new TypeError("Chaining cycle detected") } var f = function (e) { return "function" == typeof e }, m = { then: function (r, n) { var a = BespokeThenable(); return i.push((function () { var i = t > 0 ? r : n; if (f(i)) try { var o = i(e); o === a && p(); var s = u(o); s ? s.call(o, a.resolve, a.reject) : a.resolve(o) } catch (e) { a.reject(e) } else a[t > 0 ? "resolve" : "reject"](e) })), t && l(), a }, resolve: a, reject: o }; return m } function NativePromiseThenable() { var e, t, i = new Promise((function (i, r) { e = i, t = r })); return { then: i.then.bind(i), resolve: e, reject: t } } BespokeThenable.all = NativePromiseThenable.all = function (e) { var t = 0, i = [], r = DefaultThenable(); return 0 === e.length ? r.resolve([]) : e.forEach((function (n, a) { var o = DefaultThenable(); o.resolve(n), o.then((function (n) { t++, i[a] = n, t === e.length && r.resolve(i) }), r.reject) })), r }; var DefaultThenable = "function" == typeof Promise ? NativePromiseThenable : BespokeThenable; function workerBootstrap() { var e = Object.create(null); function t(r, n) { var a = r.id, o = r.name, s = r.dependencies; void 0 === s && (s = []); var l = r.init; void 0 === l && (l = function () { }); var c = r.getTransferables; if (void 0 === c && (c = null), !e[a]) try { s = s.map((function (i) { return i && i.isWorkerModule && (t(i, (function (e) { if (e instanceof Error) throw e })), i = e[i.id].value), i })), l = i("<" + o + ">.init", l), c && (c = i("<" + o + ">.getTransferables", c)); var h = null; "function" == typeof l ? h = l.apply(void 0, s) : console.error("worker module init function failed to rehydrate"), e[a] = { id: a, value: h, getTransferables: c }, n(h) } catch (e) { e && e.noLog || console.error(e), n(e) } } function i(e, t) { var i = void 0; self.troikaDefine = function (e) { return i = e }; var r = URL.createObjectURL(new Blob(["/** " + e.replace(/\*/g, "") + " **/\n\ntroikaDefine(\n" + t + "\n)"], { type: "application/javascript" })); try { importScripts(r) } catch (e) { console.error(e) } return URL.revokeObjectURL(r), delete self.troikaDefine, i } self.addEventListener("message", (function (i) { var r = i.data, n = r.messageId, a = r.action, o = r.data; try { "registerModule" === a && t(o, (function (e) { e instanceof Error ? postMessage({ messageId: n, success: !1, error: e.message }) : postMessage({ messageId: n, success: !0, result: { isCallable: "function" == typeof e } }) })), "callModule" === a && function (t, i) { var r, n = t.id, a = t.args; e[n] && "function" == typeof e[n].value || i(new Error("Worker module " + n + ": not found or its 'init' did not return a function")); try { var o = (r = e[n]).value.apply(r, a); o && "function" == typeof o.then ? o.then(s, (function (e) { return i(e instanceof Error ? e : new Error("" + e)) })) : s(o) } catch (e) { i(e) } function s(t) { try { var r = e[n].getTransferables && e[n].getTransferables(t); r && Array.isArray(r) && r.length || (r = void 0), i(t, r) } catch (e) { console.error(e), i(e) } } }(o, (function (e, t) { e instanceof Error ? postMessage({ messageId: n, success: !1, error: e.message }) : postMessage({ messageId: n, success: !0, result: e }, t || void 0) })) } catch (e) { postMessage({ messageId: n, success: !1, error: e.stack }) } })) } function defineMainThreadModule(e) { var t = function () { for (var e = [], i = arguments.length; i--;)e[i] = arguments[i]; return t._getInitResult().then((function (t) { if ("function" == typeof t) return t.apply(void 0, e); throw new Error("Worker module function was called but `init` did not return a callable function") })) }; return t._getInitResult = function () { var i = e.dependencies, r = e.init; i = Array.isArray(i) ? i.map((function (e) { return e && e._getInitResult ? e._getInitResult() : e })) : []; var n = DefaultThenable.all(i).then((function (e) { return r.apply(null, e) })); return t._getInitResult = function () { return n }, n }, t } var supportsWorkers = function () { var e = !1; if ("undefined" != typeof window && void 0 !== window.document) try { new Worker(URL.createObjectURL(new Blob([""], { type: "application/javascript" }))).terminate(), e = !0 } catch (e) { "undefined" != typeof process && "test" === process.env.NODE_ENV || console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + e.message + "]") } return supportsWorkers = function () { return e }, e }, _workerModuleId = 0, _messageId = 0, _allowInitAsString = !1, workers = Object.create(null), openRequests = function () { var e = Object.create(null); return e._count = 0, e }(); function defineWorkerModule(e) { if (!(e && "function" == typeof e.init || _allowInitAsString)) throw new Error("requires `options.init` function"); var t = e.dependencies, i = e.init, r = e.getTransferables, n = e.workerId; if (!supportsWorkers()) return defineMainThreadModule(e); null == n && (n = "#default"); var a = "workerModule" + ++_workerModuleId, o = e.name || a, s = null; function l() { for (var e = [], t = arguments.length; t--;)e[t] = arguments[t]; return s || (s = callWorker(n, "registerModule", l.workerModuleData)), s.then((function (t) { if (t.isCallable) return callWorker(n, "callModule", { id: a, args: e }); throw new Error("Worker module function was called but `init` did not return a callable function") })) } return t = t && t.map((function (e) { return "function" != typeof e || e.workerModuleData || (_allowInitAsString = !0, e = defineWorkerModule({ workerId: n, name: "<" + o + "> function dependency: " + e.name, init: "function(){return (\n" + stringifyFunction(e) + "\n)}" }), _allowInitAsString = !1), e && e.workerModuleData && (e = e.workerModuleData), e })), l.workerModuleData = { isWorkerModule: !0, id: a, name: o, dependencies: t, init: stringifyFunction(i), getTransferables: r && stringifyFunction(r) }, l } function stringifyFunction(e) { var t = e.toString(); return !/^function/.test(t) && /^\w+\s*\(/.test(t) && (t = "function " + t), t } function getWorker(e) { var t = workers[e]; if (!t) { var i = stringifyFunction(workerBootstrap); (t = workers[e] = new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: " + e.replace(/\*/g, "") + " **/\n\n;(" + i + ")()"], { type: "application/javascript" })))).onmessage = function (e) { var t = e.data, i = t.messageId, r = openRequests[i]; if (!r) throw new Error("WorkerModule response with empty or unknown messageId"); delete openRequests[i], openRequests._count--, r(t) } } return t } function callWorker(e, t, i) { var r = DefaultThenable(), n = ++_messageId; return openRequests[n] = function (e) { e.success ? r.resolve(e.result) : r.reject(new Error("Error in worker " + t + " call: " + e.error)) }, openRequests._count++, openRequests._count > 1e3 && console.warn("Large number of open WorkerModule requests, some may not be returning"), getWorker(e).postMessage({ messageId: n, action: t, data: i }), r } var ThenableWorkerModule = defineWorkerModule({ name: "Thenable", dependencies: [DefaultThenable], init: function (e) { return e } }); function bidiFactory() { return function (e) { var t = { R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73", EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9", ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2", ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj", AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u", CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b", B: "a,3,f+2,2v,690", S: "9,2,k", WS: "c,k,4f4,1vk+a,u,1j,335", ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i", BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1", NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n", AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d", LRO: "6ct", RLO: "6cu", LRE: "6cq", RLE: "6cr", PDF: "6cs", LRI: "6ee", RLI: "6ef", FSI: "6eg", PDI: "6eh" }, i = {}, r = {}; i.L = 1, r[1] = "L", Object.keys(t).forEach((function (e, t) { i[e] = 1 << t + 1, r[i[e]] = e })), Object.freeze(i); var n = i.LRI | i.RLI | i.FSI, a = i.L | i.R | i.AL, o = i.B | i.S | i.WS | i.ON | i.FSI | i.LRI | i.RLI | i.PDI, s = i.BN | i.RLE | i.LRE | i.RLO | i.LRO | i.PDF, l = i.S | i.WS | i.B | n | i.PDI | s, c = null; function h(e) { return function () { if (!c) { c = new Map; var e = function (e) { if (t.hasOwnProperty(e)) { var r = 0; t[e].split(",").forEach((function (t) { var n = t.split("+"), a = n[0], o = n[1]; a = parseInt(a, 36), o = o ? parseInt(o, 36) : 0, c.set(r += a, i[e]); for (var s = 0; s < o; s++)c.set(++r, i[e]) })) } }; for (var r in t) e(r) } }(), c.get(e.codePointAt(0)) || i.L } var u, d, p, f = "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1", m = "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"; function g(e, t) { var i, r = 0, n = new Map, a = t && new Map; return e.split(",").forEach((function e(o) { if (-1 !== o.indexOf("+")) for (var s = +o; s--;)e(i); else { i = o; var l = o.split(">"), c = l[0], h = l[1]; c = String.fromCodePoint(r += parseInt(c, 36)), h = String.fromCodePoint(r += parseInt(h, 36)), n.set(c, h), t && a.set(h, c) } })), { map: n, reverseMap: a } } function y() { if (!u) { var e = g(f, !0), t = e.map, i = e.reverseMap; u = t, d = i, p = g(m, !1).map } } function v(e) { return y(), u.get(e) || null } function _(e) { return y(), d.get(e) || null } function b(e) { return y(), p.get(e) || null } var x = i.L, w = i.R, S = i.EN, M = i.ES, T = i.ET, A = i.AN, E = i.CS, C = i.B, L = i.S, R = i.ON, D = i.BN, P = i.NSM, O = i.AL, I = i.LRO, k = i.RLO, B = i.LRE, N = i.RLE, F = i.PDF, U = i.LRI, z = i.RLI, G = i.FSI, H = i.PDI; var V; function j(e) { return function () { if (!V) { var e = g("14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", !0), t = e.map; e.reverseMap.forEach((function (e, i) { t.set(i, e) })), V = t } }(), V.get(e) || null } function W(e, t, i, r) { var n = e.length; i = Math.max(0, null == i ? 0 : +i), r = Math.min(n - 1, null == r ? n - 1 : +r); var a = []; return t.paragraphs.forEach((function (n) { var o = Math.max(i, n.start), s = Math.min(r, n.end); if (o < s) { for (var c = t.levels.slice(o, s + 1), u = s; u >= o && h(e[u]) & l; u--)c[u] = n.level; for (var d = n.level, p = 1 / 0, f = 0; f < c.length; f++) { var m = c[f]; m > d && (d = m), m < p && (p = 1 | m) } for (var g = d; g >= p; g--)for (var y = 0; y < c.length; y++)if (c[y] >= g) { for (var v = y; y + 1 < c.length && c[y + 1] >= g;)y++; y > v && a.push([v + i, y + i]) } } })), a } function $(e, t, i, r) { for (var n = W(e, t, i, r), a = [], o = 0; o < e.length; o++)a[o] = o; return n.forEach((function (e) { for (var t = e[0], i = e[1], r = a.slice(t, i + 1), n = r.length; n--;)a[i - n] = r[n] })), a } return e.closingToOpeningBracket = _, e.getBidiCharType = h, e.getBidiCharTypeName = function (e) { return r[h(e)] }, e.getCanonicalBracket = b, e.getEmbeddingLevels = function (e, t) { for (var i = new Uint32Array(e.length), r = 0; r < e.length; r++)i[r] = h(e[r]); var c = new Map; function u(e, t) { var r = i[e]; i[e] = t, c.set(r, c.get(r) - 1), r & o && c.set(o, c.get(o) - 1), c.set(t, (c.get(t) || 0) + 1), t & o && c.set(o, (c.get(o) || 0) + 1) } for (var d = new Uint8Array(e.length), p = new Map, f = [], m = null, g = 0; g < e.length; g++)m || f.push(m = { start: g, end: e.length - 1, level: "rtl" === t ? 1 : "ltr" === t ? 0 : Gt(g, !1) }), i[g] & C && (m.end = g, m = null); for (var y = N | B | k | I | n | H | F | C, V = function (e) { return e + (1 & e ? 1 : 2) }, j = function (e) { return e + (1 & e ? 2 : 1) }, W = 0; W < f.length; W++) { var $ = [{ _level: (m = f[W]).level, _override: 0, _isolate: 0 }], Y = void 0, X = 0, Z = 0, q = 0; c.clear(); for (var J = m.start; J <= m.end; J++) { var K = i[J]; if (Y = $[$.length - 1], c.set(K, (c.get(K) || 0) + 1), K & o && c.set(o, (c.get(o) || 0) + 1), K & y) if (K & (N | B)) { d[J] = Y._level; var Q = (K === N ? j : V)(Y._level); Q <= 125 && !X && !Z ? $.push({ _level: Q, _override: 0, _isolate: 0 }) : X || Z++ } else if (K & (k | I)) { d[J] = Y._level; var ee = (K === k ? j : V)(Y._level); ee <= 125 && !X && !Z ? $.push({ _level: ee, _override: K & k ? w : x, _isolate: 0 }) : X || Z++ } else if (K & n) { K & G && (K = 1 === Gt(J + 1, !0) ? z : U), d[J] = Y._level, Y._override && u(J, Y._override); var te = (K === z ? j : V)(Y._level); te <= 125 && 0 === X && 0 === Z ? (q++, $.push({ _level: te, _override: 0, _isolate: 1, _isolInitIndex: J })) : X++ } else if (K & H) { if (X > 0) X--; else if (q > 0) { for (Z = 0; !$[$.length - 1]._isolate;)$.pop(); var ie = $[$.length - 1]._isolInitIndex; null != ie && (p.set(ie, J), p.set(J, ie)), $.pop(), q-- } Y = $[$.length - 1], d[J] = Y._level, Y._override && u(J, Y._override) } else K & F ? (0 === X && (Z > 0 ? Z-- : !Y._isolate && $.length > 1 && ($.pop(), Y = $[$.length - 1])), d[J] = Y._level) : K & C && (d[J] = m.level); else d[J] = Y._level, Y._override && K !== D && u(J, Y._override) } for (var re = [], ne = null, ae = m.start; ae <= m.end; ae++) { var oe = i[ae]; if (!(oe & s)) { var se = d[ae], le = oe & n, ce = oe === H; ne && se === ne._level ? (ne._end = ae, ne._endsWithIsolInit = le) : re.push(ne = { _start: ae, _end: ae, _level: se, _startsWithPDI: ce, _endsWithIsolInit: le }) } } for (var he = [], ue = 0; ue < re.length; ue++) { var de = re[ue]; if (!de._startsWithPDI || de._startsWithPDI && !p.has(de._start)) { for (var pe = [ne = de], fe = void 0; ne && ne._endsWithIsolInit && null != (fe = p.get(ne._end));)for (var me = ue + 1; me < re.length; me++)if (re[me]._start === fe) { pe.push(ne = re[me]); break } for (var ge = [], ye = 0; ye < pe.length; ye++)for (var ve = pe[ye], _e = ve._start; _e <= ve._end; _e++)ge.push(_e); for (var be = d[ge[0]], xe = m.level, we = ge[0] - 1; we >= 0; we--)if (!(i[we] & s)) { xe = d[we]; break } var Se = ge[ge.length - 1], Me = d[Se], Te = m.level; if (!(i[Se] & n)) for (var Ae = Se + 1; Ae <= m.end; Ae++)if (!(i[Ae] & s)) { Te = d[Ae]; break } he.push({ _seqIndices: ge, _sosType: Math.max(xe, be) % 2 ? w : x, _eosType: Math.max(Te, Me) % 2 ? w : x }) } } for (var Ee = 0; Ee < he.length; Ee++) { var Ce = he[Ee], Le = Ce._seqIndices, Re = Ce._sosType, De = Ce._eosType; if (c.get(P)) for (var Pe = 0; Pe < Le.length; Pe++) { var Oe = Le[Pe]; if (i[Oe] & P) { for (var Ie = Re, ke = Pe - 1; ke >= 0; ke--)if (!(i[Le[ke]] & s)) { Ie = i[Le[ke]]; break } u(Oe, Ie & (n | H) ? R : Ie) } } if (c.get(S)) for (var Be = 0; Be < Le.length; Be++) { var Ne = Le[Be]; if (i[Ne] & S) for (var Fe = Be - 1; Fe >= -1; Fe--) { var Ue = -1 === Fe ? Re : i[Le[Fe]]; if (Ue & a) { Ue === O && u(Ne, A); break } } } if (c.get(O)) for (var ze = 0; ze < Le.length; ze++) { var Ge = Le[ze]; i[Ge] & O && u(Ge, w) } if (c.get(M) || c.get(E)) for (var He = 1; He < Le.length - 1; He++) { var Ve = Le[He]; if (i[Ve] & (M | E)) { for (var je = 0, We = 0, $e = He - 1; $e >= 0 && (je = i[Le[$e]]) & s; $e--); for (var Ye = He + 1; Ye < Le.length && (We = i[Le[Ye]]) & s; Ye++); je === We && (i[Ve] === M ? je === S : je & (S | A)) && u(Ve, je) } } if (c.get(S)) for (var Xe = 0; Xe < Le.length; Xe++) { var Ze = Le[Xe]; if (i[Ze] & S) { for (var qe = Xe - 1; qe >= 0 && i[Le[qe]] & (T | s); qe--)u(Le[qe], S); for (var Je = Xe + 1; Je < Le.length && i[Le[Je]] & (T | s); Je++)u(Le[Je], S) } } if (c.get(T) || c.get(M) || c.get(E)) for (var Ke = 0; Ke < Le.length; Ke++) { var Qe = Le[Ke]; if (i[Qe] & (T | M | E)) { u(Qe, R); for (var et = Ke - 1; et >= 0 && i[Le[et]] & s; et--)u(Le[et], R); for (var tt = Ke + 1; tt < Le.length && i[Le[tt]] & s; tt++)u(Le[tt], R) } } if (c.get(S)) for (var it = 0, rt = Re; it < Le.length; it++) { var nt = Le[it], at = i[nt]; at & S ? rt === x && u(nt, x) : at & a && (rt = at) } if (c.get(o)) { for (var ot = w | S | A, st = ot | x, lt = [], ct = [], ht = 0; ht < Le.length; ht++)if (i[Le[ht]] & o) { var ut = e[Le[ht]], dt = void 0; if (null !== v(ut)) { if (!(ct.length < 63)) break; ct.push({ char: ut, seqIndex: ht }) } else if (null !== (dt = _(ut))) for (var pt = ct.length - 1; pt >= 0; pt--) { var ft = ct[pt].char; if (ft === dt || ft === _(b(ut)) || v(b(ft)) === ut) { lt.push([ct[pt].seqIndex, ht]), ct.length = pt; break } } } lt.sort((function (e, t) { return e[0] - t[0] })); for (var mt = 0; mt < lt.length; mt++) { for (var gt = lt[mt], yt = gt[0], vt = gt[1], _t = !1, bt = 0, xt = yt + 1; xt < vt; xt++) { var wt = Le[xt]; if (i[wt] & st) { _t = !0; var St = i[wt] & ot ? w : x; if (St === Vt(wt)) { bt = St; break } } } if (_t && !bt) { bt = Re; for (var Mt = yt - 1; Mt >= 0; Mt--) { var Tt = Le[Mt]; if (i[Tt] & st) { var At = i[Tt] & ot ? w : x; bt = At !== Vt(Tt) ? At : Vt(Tt); break } } } if (bt) { if (i[Le[yt]] = i[Le[vt]] = bt, bt !== Vt(Le[yt])) for (var Et = yt + 1; Et < Le.length; Et++)if (!(i[Le[Et]] & s)) { h(e[Le[Et]]) & P && (i[Le[Et]] = bt); break } if (bt !== Vt(Le[vt])) for (var Ct = vt + 1; Ct < Le.length; Ct++)if (!(i[Le[Ct]] & s)) { h(e[Le[Ct]]) & P && (i[Le[Ct]] = bt); break } } } for (var Lt = 0; Lt < Le.length; Lt++)if (i[Le[Lt]] & o) { for (var Rt = Lt, Dt = Lt, Pt = Re, Ot = Lt - 1; Ot >= 0; Ot--) { if (!(i[Le[Ot]] & s)) { Pt = i[Le[Ot]] & ot ? w : x; break } Rt = Ot } for (var It = De, kt = Lt + 1; kt < Le.length; kt++) { if (!(i[Le[kt]] & (o | s))) { It = i[Le[kt]] & ot ? w : x; break } Dt = kt } for (var Bt = Rt; Bt <= Dt; Bt++)i[Le[Bt]] = Pt === It ? Pt : Vt(Le[Bt]); Lt = Dt } } } for (var Nt = m.start; Nt <= m.end; Nt++) { var Ft = d[Nt], Ut = i[Nt]; if (1 & Ft ? Ut & (x | S | A) && d[Nt]++ : Ut & w ? d[Nt]++ : Ut & (A | S) && (d[Nt] += 2), Ut & s && (d[Nt] = 0 === Nt ? m.level : d[Nt - 1]), Nt === m.end || h(e[Nt]) & (L | C)) for (var zt = Nt; zt >= 0 && h(e[zt]) & l; zt--)d[zt] = m.level } } return { levels: d, paragraphs: f }; function Gt(t, r) { for (var a = t; a < e.length; a++) { var o = i[a]; if (o & (w | O)) return 1; if (o & (C | x) || r && o === H) return 0; if (o & n) { var s = Ht(a); a = -1 === s ? e.length : s } } return 0 } function Ht(t) { for (var r = 1, a = t + 1; a < e.length; a++) { var o = i[a]; if (o & C) break; if (o & H) { if (0 == --r) return a } else o & n && r++ } return -1 } function Vt(e) { return 1 & d[e] ? w : x } }, e.getMirroredCharacter = j, e.getMirroredCharactersMap = function (e, t, i, r) { var n = e.length; i = Math.max(0, null == i ? 0 : +i), r = Math.min(n - 1, null == r ? n - 1 : +r); for (var a = new Map, o = i; o <= r; o++)if (1 & t[o]) { var s = j(e[o]); null !== s && a.set(o, s) } return a }, e.getReorderSegments = W, e.getReorderedIndices = $, e.getReorderedString = function (e, t, i, r) { var n = $(e, t, i, r), a = [].concat(e); return n.forEach((function (i, r) { a[r] = (1 & t.levels[i] ? j(e[i]) : null) || e[i] })), a.join("") }, e.openingToClosingBracket = v, Object.defineProperty(e, "__esModule", { value: !0 }), e }({}) } const voidMainRegExp = /\bvoid\s+main\s*\(\s*\)\s*{/g; function expandShaderIncludes(e) { return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, (function (e, t) { let i = ShaderChunk[t]; return i ? expandShaderIncludes(i) : e })) } const _lut = []; for (let e = 0; e < 256; e++)_lut[e] = (e < 16 ? "0" : "") + e.toString(16); function generateUUID() { const e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return (_lut[255 & e] + _lut[e >> 8 & 255] + _lut[e >> 16 & 255] + _lut[e >> 24 & 255] + "-" + _lut[255 & t] + _lut[t >> 8 & 255] + "-" + _lut[t >> 16 & 15 | 64] + _lut[t >> 24 & 255] + "-" + _lut[63 & i | 128] + _lut[i >> 8 & 255] + "-" + _lut[i >> 16 & 255] + _lut[i >> 24 & 255] + _lut[255 & r] + _lut[r >> 8 & 255] + _lut[r >> 16 & 255] + _lut[r >> 24 & 255]).toUpperCase() } const assign$1 = Object.assign || function () { let e = arguments[0]; for (let t = 1, i = arguments.length; t < i; t++) { let i = arguments[t]; if (i) for (let t in i) i.hasOwnProperty(t) && (e[t] = i[t]) } return e }, epoch = Date.now(), CONSTRUCTOR_CACHE = new WeakMap, SHADER_UPGRADE_CACHE = new Map; let materialInstanceId = 1e10; function createDerivedMaterial(e, t) { const i = getKeyForOptions(t); let r = CONSTRUCTOR_CACHE.get(e); if (r || CONSTRUCTOR_CACHE.set(e, r = Object.create(null)), r[i]) return new r[i]; const n = `_onBeforeCompile${i}`, a = function (r) { e.onBeforeCompile.call(this, r); const a = i + "|||" + r.vertexShader + "|||" + r.fragmentShader; let o = SHADER_UPGRADE_CACHE[a]; if (!o) { const e = upgradeShaders(r, t, i); o = SHADER_UPGRADE_CACHE[a] = e } r.vertexShader = o.vertexShader, r.fragmentShader = o.fragmentShader, assign$1(r.uniforms, this.uniforms), t.timeUniform && (r.uniforms[t.timeUniform] = { get value() { return Date.now() - epoch } }), this[n] && this[n](r) }, o = function () { return s(t.chained ? e : e.clone()) }, s = function (r) { const n = Object.create(r, l); return Object.defineProperty(n, "baseMaterial", { value: e }), Object.defineProperty(n, "id", { value: materialInstanceId++ }), n.uuid = generateUUID(), n.uniforms = assign$1({}, r.uniforms, t.uniforms), n.defines = assign$1({}, r.defines, t.defines), n.defines[`TROIKA_DERIVED_MATERIAL_${i}`] = "", n.extensions = assign$1({}, r.extensions, t.extensions), n._listeners = void 0, n }, l = { constructor: { value: o }, isDerivedMaterial: { value: !0 }, customProgramCacheKey: { writable: !0, configurable: !0, value: function () { return i } }, onBeforeCompile: { get: () => a, set(e) { this[n] = e } }, copy: { writable: !0, configurable: !0, value: function (t) { return e.copy.call(this, t), e.isShaderMaterial || e.isDerivedMaterial || (assign$1(this.extensions, t.extensions), assign$1(this.defines, t.defines), assign$1(this.uniforms, UniformsUtils.clone(t.uniforms))), this } }, clone: { writable: !0, configurable: !0, value: function () { const t = new e.constructor; return s(t).copy(this) } }, getDepthMaterial: { writable: !0, configurable: !0, value: function () { let i = this._depthMaterial; return i || (i = this._depthMaterial = createDerivedMaterial(e.isDerivedMaterial ? e.getDepthMaterial() : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), t), i.defines.IS_DEPTH_MATERIAL = "", i.uniforms = this.uniforms), i } }, getDistanceMaterial: { writable: !0, configurable: !0, value: function () { let i = this._distanceMaterial; return i || (i = this._distanceMaterial = createDerivedMaterial(e.isDerivedMaterial ? e.getDistanceMaterial() : new MeshDistanceMaterial, t), i.defines.IS_DISTANCE_MATERIAL = "", i.uniforms = this.uniforms), i } }, dispose: { writable: !0, configurable: !0, value() { const { _depthMaterial: t, _distanceMaterial: i } = this; t && t.dispose(), i && i.dispose(), e.dispose.call(this) } } }; return r[i] = o, new o } function upgradeShaders({ vertexShader: e, fragmentShader: t }, i, r) { let { vertexDefs: n, vertexMainIntro: a, vertexMainOutro: o, vertexTransform: s, fragmentDefs: l, fragmentMainIntro: c, fragmentMainOutro: h, fragmentColorTransform: u, customRewriter: d, timeUniform: p } = i; if (n = n || "", a = a || "", o = o || "", l = l || "", c = c || "", h = h || "", (s || d) && (e = expandShaderIncludes(e)), (u || d) && (t = expandShaderIncludes(t = t.replace(/^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, "\n//!BEGIN_POST_CHUNK $1\n$&\n//!END_POST_CHUNK\n"))), d) { let i = d({ vertexShader: e, fragmentShader: t }); e = i.vertexShader, t = i.fragmentShader } if (u) { let e = []; t = t.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, (t => (e.push(t), ""))), h = `${u}\n${e.join("\n")}\n${h}` } if (p) { const e = `\nuniform float ${p};\n`; n = e + n, l = e + l } return s && (n = `${n}\nvoid troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${s}\n}\n`, a = `\ntroika_position_${r} = vec3(position);\ntroika_normal_${r} = vec3(normal);\ntroika_uv_${r} = vec2(uv);\ntroikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});\n${a}\n`, e = (e = `vec3 troika_position_${r};\nvec3 troika_normal_${r};\nvec2 troika_uv_${r};\n${e}\n`).replace(/\b(position|normal|uv)\b/g, ((e, t, i, n) => /\battribute\s+vec[23]\s+$/.test(n.substr(0, i)) ? t : `troika_${t}_${r}`))), { vertexShader: e = injectIntoShaderCode(e, r, n, a, o), fragmentShader: t = injectIntoShaderCode(t, r, l, c, h) } } function injectIntoShaderCode(e, t, i, r, n) { return (r || n || i) && (e = e.replace(voidMainRegExp, `\n${i}\nvoid troikaOrigMain${t}() {`), e += `\nvoid main() {\n  ${r}\n  troikaOrigMain${t}();\n  ${n}\n}`), e } function optionsJsonReplacer(e, t) { return "uniforms" === e ? void 0 : "function" == typeof t ? t.toString() : t } let _idCtr = 0; const optionsHashesToIds = new Map; function getKeyForOptions(e) { const t = JSON.stringify(e, optionsJsonReplacer); let i = optionsHashesToIds.get(t); return null == i && optionsHashesToIds.set(t, i = ++_idCtr), i } function createSDFGenerator(e, t) { const { sdfExponent: i, sdfMargin: r } = t; function n(e, t, i, r, n, a, o) { const s = 1 - o; return { x: s * s * e + 2 * s * o * i + o * o * n, y: s * s * t + 2 * s * o * r + o * o * a } } function a(e, t, i, r, n, a, o, s, l) { const c = 1 - l; return { x: c * c * c * e + 3 * c * c * l * i + 3 * c * l * l * n + l * l * l * o, y: c * c * c * t + 3 * c * c * l * r + 3 * c * l * l * a + l * l * l * s } } return function (t, o) { const s = new Uint8Array(o * o), l = t.xMax - t.xMin, c = t.yMax - t.yMin, h = Math.max(l, c), u = Math.max(l, c) / o * (r * o + .5), d = t.xMin - u, p = t.yMin - u, f = t.xMax + u, m = t.yMax + u, g = f - d, y = m - p, v = Math.max(g, y); if (t.pathCommandCount) { const r = e(t); let l, c, u, f; t.forEachPathCommand(((e, t, i, o, s, h, d) => { switch (e) { case "M": u = l = t, f = c = i; break; case "L": t === u && i === f || r.addLineSegment(u, f, u = t, f = i); break; case "Q": { let e = { x: u, y: f }; for (let a = 1; a < 16; a++) { let l = n(u, f, t, i, o, s, a / 15); r.addLineSegment(e.x, e.y, l.x, l.y), e = l } u = o, f = s; break } case "C": { let e = { x: u, y: f }; for (let n = 1; n < 16; n++) { let l = a(u, f, t, i, o, s, h, d, n / 15); r.addLineSegment(e.x, e.y, l.x, l.y), e = l } u = h, f = d; break } case "Z": u === l && f === c || r.addLineSegment(u, f, l, c) } })); for (let e = 0; e < o; e++)for (let t = 0; t < o; t++) { const n = r.findNearestSignedDistance(d + g * (e + .5) / o, p + y * (t + .5) / o, h); let a = Math.pow(1 - Math.abs(n) / v, i) / 2; n < 0 && (a = 1 - a), a = Math.max(0, Math.min(255, Math.round(255 * a))), s[t * o + e] = a } } return { textureData: s, renderingBounds: [d, p, f, m] } } } function createFontProcessor(e, t, i, r) { const { defaultFontURL: n } = r, a = Object.create(null), o = Object.create(null), s = 1 / 0, l = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/; function c(t, i) { t || (t = n); let r = o[t]; r ? r.pending ? r.pending.push(i) : i(r) : (o[t] = { pending: [i] }, function (t, i) { !function r() { const a = e => { console.error(`Failure loading font ${t}${t === n ? "" : "; trying fallback"}`, e), t !== n && (t = n, r()) }; try { const r = new XMLHttpRequest; r.open("get", t, !0), r.responseType = "arraybuffer", r.onload = function () { if (r.status >= 400) a(new Error(r.statusText)); else if (r.status > 0) try { const t = e(r.response); i(t) } catch (e) { a(e) } }, r.onerror = a, r.send() } catch (e) { a(e) } }() }(t, (e => { let i = o[t].pending; o[t] = e, i.forEach((t => t(e))) }))) } function h({ text: e = "", font: r = n, sdfGlyphSize: o = 64, fontSize: h = 1, letterSpacing: f = 0, lineHeight: m = "normal", maxWidth: g = s, direction: y, textAlign: v = "left", textIndent: _ = 0, whiteSpace: b = "normal", overflowWrap: x = "normal", anchorX: w = 0, anchorY: S = 0, includeCaretPositions: M = !1, chunkedBoundsSize: T = 8192, colorRanges: A = null }, E, C = !1) { const L = d(), R = { total: 0, fontLoad: 0, layout: 0, sdf: {}, sdfTotal: 0 }; e.indexOf("\r") > -1 && (console.warn("FontProcessor.process: got text with \\r chars; normalizing to \\n"), e = e.replace(/\r\n/g, "\n").replace(/\r/g, "\n")), h = +h, f = +f, g = +g, m = m || "normal", _ = +_, function (e, t, i) { e || (e = n); let r = `${e}@${t}`, o = a[r]; o ? i(o) : c(e, (e => { o = a[r] || (a[r] = { fontObj: e, glyphs: {}, glyphCount: 0 }), i(o) })) }(r, o, (r => { const n = r.fontObj, a = isFinite(g); let c = null, D = null, P = null, O = null, I = null, k = null, B = null, N = 0, F = 0, U = "nowrap" !== b; const { ascender: z, descender: G, unitsPerEm: H } = n; R.fontLoad = d() - L; const V = d(), j = h / H; "normal" === m && (m = (z - G) / H); const W = ((m *= h) - (z - G) * j) / 2, $ = -(z * j + W), Y = Math.min(m, (z - G) * j), X = (z + G) / 2 * j - Y / 2; let Z = _, q = new p; const J = [q]; n.forEachGlyph(e, h, f, ((t, i, r) => { const n = e.charAt(r), o = t.advanceWidth * j, s = q.count; let c; if ("isEmpty" in t || (t.isWhitespace = !!n && /\s/.test(n), t.isEmpty = t.xMin === t.xMax || t.yMin === t.yMax || l.test(n)), t.isWhitespace || t.isEmpty || F++, U && a && !t.isWhitespace && i + o + Z > g && s) { if (q.glyphAt(s - 1).glyphObj.isWhitespace) c = new p, Z = -i; else for (let e = s; e--;) { if (0 === e && "break-word" === x) { c = new p, Z = -i; break } if (q.glyphAt(e).glyphObj.isWhitespace) { c = q.splitAt(e + 1); const t = c.glyphAt(0).x; Z -= t; for (let e = c.count; e--;)c.glyphAt(e).x -= t; break } } c && (q.isSoftWrapped = !0, q = c, J.push(q), N = g) } let u = q.glyphAt(q.count); u.glyphObj = t, u.x = i + Z, u.width = o, u.charIndex = r, "\n" === n && (q = new p, J.push(q), Z = -(i + o + f * h) + _) })), J.forEach((e => { for (let t = e.count; t--;) { let { glyphObj: i, x: r, width: n } = e.glyphAt(t); if (!i.isWhitespace) return e.width = r + n, void (e.width > N && (N = e.width)) } })); let K = 0, Q = 0; if (w && ("number" == typeof w ? K = -w : "string" == typeof w && (K = -N * ("left" === w ? 0 : "center" === w ? .5 : "right" === w ? 1 : u(w)))), S) if ("number" == typeof S) Q = -S; else if ("string" == typeof S) { let e = J.length * m; Q = "top" === S ? 0 : "top-baseline" === S ? -$ : "middle" === S ? e / 2 : "bottom" === S ? e : "bottom-baseline" === S ? e - W + G * j : u(S) * e } if (!C) { const a = i.getEmbeddingLevels(e, y); D = new Float32Array(4 * F), P = new Float32Array(F), k = [s, s, -1 / 0, -1 / 0], B = []; let l = $; M && (I = new Float32Array(3 * e.length)), A && (O = new Uint8Array(3 * F)); let h, u, p = 0, f = -1, g = -1; J.forEach(((y, _) => { let { count: b, width: x } = y; if (b > 0) { let m = 0; for (let e = b; e-- && y.glyphAt(e).glyphObj.isWhitespace;)m++; let _ = 0, w = 0; if ("center" === v) _ = (N - x) / 2; else if ("right" === v) _ = N - x; else if ("justify" === v && y.isSoftWrapped) { let e = 0; for (let t = b - m; t--;)y.glyphAt(t).glyphObj.isWhitespace && e++; w = (N - x) / e } if (w || _) { let e = 0; for (let t = 0; t < b; t++) { let i = y.glyphAt(t); const r = i.glyphObj; i.x += _ + e, 0 !== w && r.isWhitespace && t < b - m && (e += w, i.width += w) } } const S = i.getReorderSegments(e, a, y.glyphAt(0).charIndex, y.glyphAt(y.count - 1).charIndex); for (let e = 0; e < S.length; e++) { const [t, i] = S[e]; let r = 1 / 0, n = -1 / 0; for (let e = 0; e < b; e++)if (y.glyphAt(e).charIndex >= t) { let t = e, a = e; for (; a < b; a++) { let e = y.glyphAt(a); if (e.charIndex > i) break; a < b - m && (r = Math.min(r, e.x), n = Math.max(n, e.x + e.width)) } for (let e = t; e < a; e++) { const t = y.glyphAt(e); t.x = n - (t.x + t.width - r) } break } } let E; const C = e => E = e; for (let m = 0; m < b; m++) { let v = y.glyphAt(m); E = v.glyphObj; const _ = 1 & a.levels[v.charIndex]; if (_) { const t = i.getMirroredCharacter(e[v.charIndex]); t && n.forEachGlyph(t, 0, 0, C) } if (M) { const { charIndex: e } = v, t = v.x + K, i = v.x + v.width + K; for (I[3 * e] = _ ? i : t, I[3 * e + 1] = _ ? t : i, I[3 * e + 2] = l + X + Q; e - f > 1;)I[3 * (f + 1)] = I[3 * f], I[3 * (f + 1) + 1] = I[3 * f + 1], I[3 * (f + 1) + 2] = I[3 * f + 2], f++; f = e } if (A) { const { charIndex: e } = v; for (; e > g;)g++, A.hasOwnProperty(g) && (u = A[g]) } if (!E.isWhitespace && !E.isEmpty) { const i = p++; let n = r.glyphs[E.index]; if (!n) { const i = d(), a = t(E, o); R.sdf[e.charAt(v.charIndex)] = d() - i, a.atlasIndex = r.glyphCount++, c || (c = []), c.push(a), n = r.glyphs[E.index] = { atlasIndex: a.atlasIndex, glyphObj: E, renderingBounds: a.renderingBounds } } const a = n.renderingBounds, f = 4 * i, m = v.x + K, g = l + Q; D[f] = m + a[0] * j, D[f + 1] = g + a[1] * j, D[f + 2] = m + a[2] * j, D[f + 3] = g + a[3] * j; const y = m + E.xMin * j, _ = g + E.yMin * j, b = m + E.xMax * j, x = g + E.yMax * j; y < k[0] && (k[0] = y), _ < k[1] && (k[1] = _), b > k[2] && (k[2] = b), x > k[3] && (k[3] = x), i % T == 0 && (h = { start: i, end: i, rect: [s, s, -1 / 0, -1 / 0] }, B.push(h)), h.end++; const w = h.rect; if (y < w[0] && (w[0] = y), _ < w[1] && (w[1] = _), b > w[2] && (w[2] = b), x > w[3] && (w[3] = x), P[i] = n.atlasIndex, A) { const e = 3 * i; O[e] = u >> 16 & 255, O[e + 1] = u >> 8 & 255, O[e + 2] = 255 & u } } } } l -= m })) } for (let e in R.sdf) R.sdfTotal += R.sdf[e]; R.layout = d() - V - R.sdfTotal, R.total = d() - L, E({ glyphBounds: D, glyphAtlasIndices: P, caretPositions: I, caretHeight: Y, glyphColors: O, chunkedBounds: B, ascender: z * j, descender: G * j, lineHeight: m, topBaseline: $, blockBounds: [K, Q - J.length * m, K + N, Q], visibleBounds: k, newGlyphSDFs: c, timings: R }) })) } function u(e) { let t = e.match(/^([\d.]+)%$/), i = t ? parseFloat(t[1]) : NaN; return isNaN(i) ? 0 : i / 100 } function d() { return (self.performance || Date).now() } function p() { this.data = [] } const f = ["glyphObj", "x", "width", "charIndex"]; return p.prototype = { width: 0, isSoftWrapped: !1, get count() { return Math.ceil(this.data.length / f.length) }, glyphAt(e) { let t = p.flyweight; return t.data = this.data, t.index = e, t }, splitAt(e) { let t = new p; return t.data = this.data.splice(e * f.length), t } }, p.flyweight = f.reduce(((e, t, i, r) => (Object.defineProperty(e, t, { get() { return this.data[this.index * f.length + i] }, set(e) { this.data[this.index * f.length + i] = e } }), e)), { data: null, index: 0 }), { process: h, measure: function (e, t) { h(e, (e => { const [i, r, n, a] = e.blockBounds; t({ width: n - i, height: a - r }) }), { metricsOnly: !0 }) }, loadFont: c } } function createGlyphSegmentsIndex() { let e = !1; const t = []; function i() { e && (t.sort((function (e, t) { return e.maxX - t.maxX })), e = !1) } function r(e, t, i, r, n, a) { const o = n - i, s = a - r, l = o * o + s * s, c = l ? Math.max(0, Math.min(1, ((e - i) * o + (t - r) * s) / l)) : 0, h = e - (i + c * o), u = t - (r + c * s); return h * h + u * u } return { addLineSegment: function (i, r, n, a) { const o = { x0: i, y0: r, x1: n, y1: a, minX: Math.min(i, n), minY: Math.min(r, a), maxX: Math.max(i, n), maxY: Math.max(r, a) }; t.push(o), e = !0 }, findNearestSignedDistance: function (e, n) { i(); let a = 1 / 0, o = 1 / 0; for (let i = t.length; i--;) { const s = t[i]; if (s.maxX + o <= e) break; if (e + o > s.minX && n - o < s.maxY && n + o > s.minY) { const t = r(e, n, s.x0, s.y0, s.x1, s.y1); t < a && (a = t, o = Math.sqrt(a)) } } return function (e, r) { i(); let n = !1; for (let i = t.length; i--;) { const a = t[i]; if (a.maxX <= e) break; if (a.minY < r && a.maxY > r) { a.y0 > r != a.y1 > r && e < (a.x1 - a.x0) * (r - a.y0) / (a.y1 - a.y0) + a.x0 && (n = !n) } } return n }(e, n) && (o = -o), o } } }
/*!
  Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
  Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
  */function typrFactory() {
      return "undefined" == typeof window && (self.window = self), function (e) { var t = { parse: function (e) { var i = t._bin, r = new Uint8Array(e); if ("ttcf" == i.readASCII(r, 0, 4)) { var n = 4; i.readUshort(r, n), n += 2, i.readUshort(r, n), n += 2; var a = i.readUint(r, n); n += 4; for (var o = [], s = 0; s < a; s++) { var l = i.readUint(r, n); n += 4, o.push(t._readFont(r, l)) } return o } return [t._readFont(r, 0)] }, _readFont: function (e, i) { var r = t._bin, n = i; r.readFixed(e, i), i += 4; var a = r.readUshort(e, i); i += 2, r.readUshort(e, i), i += 2, r.readUshort(e, i), i += 2, r.readUshort(e, i), i += 2; for (var o = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], s = { _data: e, _offset: n }, l = {}, c = 0; c < a; c++) { var h = r.readASCII(e, i, 4); i += 4, r.readUint(e, i), i += 4; var u = r.readUint(e, i); i += 4; var d = r.readUint(e, i); i += 4, l[h] = { offset: u, length: d } } for (c = 0; c < o.length; c++) { var p = o[c]; l[p] && (s[p.trim()] = t[p.trim()].parse(e, l[p].offset, l[p].length, s)) } return s }, _tabOffset: function (e, i, r) { for (var n = t._bin, a = n.readUshort(e, r + 4), o = r + 12, s = 0; s < a; s++) { var l = n.readASCII(e, o, 4); o += 4, n.readUint(e, o), o += 4; var c = n.readUint(e, o); if (o += 4, n.readUint(e, o), o += 4, l == i) return c } return 0 } }; t._bin = { readFixed: function (e, t) { return (e[t] << 8 | e[t + 1]) + (e[t + 2] << 8 | e[t + 3]) / 65540 }, readF2dot14: function (e, i) { return t._bin.readShort(e, i) / 16384 }, readInt: function (e, i) { var r = t._bin.t.uint8; return r[0] = e[i + 3], r[1] = e[i + 2], r[2] = e[i + 1], r[3] = e[i], t._bin.t.int32[0] }, readInt8: function (e, i) { return t._bin.t.uint8[0] = e[i], t._bin.t.int8[0] }, readShort: function (e, i) { var r = t._bin.t.uint8; return r[1] = e[i], r[0] = e[i + 1], t._bin.t.int16[0] }, readUshort: function (e, t) { return e[t] << 8 | e[t + 1] }, readUshorts: function (e, i, r) { for (var n = [], a = 0; a < r; a++)n.push(t._bin.readUshort(e, i + 2 * a)); return n }, readUint: function (e, i) { var r = t._bin.t.uint8; return r[3] = e[i], r[2] = e[i + 1], r[1] = e[i + 2], r[0] = e[i + 3], t._bin.t.uint32[0] }, readUint64: function (e, i) { return 4294967296 * t._bin.readUint(e, i) + t._bin.readUint(e, i + 4) }, readASCII: function (e, t, i) { for (var r = "", n = 0; n < i; n++)r += String.fromCharCode(e[t + n]); return r }, readUnicode: function (e, t, i) { for (var r = "", n = 0; n < i; n++) { var a = e[t++] << 8 | e[t++]; r += String.fromCharCode(a) } return r }, _tdec: "undefined" != typeof window && window.TextDecoder ? new window.TextDecoder : null, readUTF8: function (e, i, r) { var n = t._bin._tdec; return n && 0 == i && r == e.length ? n.decode(e) : t._bin.readASCII(e, i, r) }, readBytes: function (e, t, i) { for (var r = [], n = 0; n < i; n++)r.push(e[t + n]); return r }, readASCIIArray: function (e, t, i) { for (var r = [], n = 0; n < i; n++)r.push(String.fromCharCode(e[t + n])); return r } }, t._bin.t = { buff: new ArrayBuffer(8) }, t._bin.t.int8 = new Int8Array(t._bin.t.buff), t._bin.t.uint8 = new Uint8Array(t._bin.t.buff), t._bin.t.int16 = new Int16Array(t._bin.t.buff), t._bin.t.uint16 = new Uint16Array(t._bin.t.buff), t._bin.t.int32 = new Int32Array(t._bin.t.buff), t._bin.t.uint32 = new Uint32Array(t._bin.t.buff), t._lctf = {}, t._lctf.parse = function (e, i, r, n, a) { var o = t._bin, s = {}, l = i; o.readFixed(e, i), i += 4; var c = o.readUshort(e, i); i += 2; var h = o.readUshort(e, i); i += 2; var u = o.readUshort(e, i); return i += 2, s.scriptList = t._lctf.readScriptList(e, l + c), s.featureList = t._lctf.readFeatureList(e, l + h), s.lookupList = t._lctf.readLookupList(e, l + u, a), s }, t._lctf.readLookupList = function (e, i, r) { var n = t._bin, a = i, o = [], s = n.readUshort(e, i); i += 2; for (var l = 0; l < s; l++) { var c = n.readUshort(e, i); i += 2; var h = t._lctf.readLookupTable(e, a + c, r); o.push(h) } return o }, t._lctf.readLookupTable = function (e, i, r) { var n = t._bin, a = i, o = { tabs: [] }; o.ltype = n.readUshort(e, i), i += 2, o.flag = n.readUshort(e, i), i += 2; var s = n.readUshort(e, i); i += 2; for (var l = o.ltype, c = 0; c < s; c++) { var h = n.readUshort(e, i); i += 2; var u = r(e, l, a + h, o); o.tabs.push(u) } return o }, t._lctf.numOfOnes = function (e) { for (var t = 0, i = 0; i < 32; i++)0 != (e >>> i & 1) && t++; return t }, t._lctf.readClassDef = function (e, i) { var r = t._bin, n = [], a = r.readUshort(e, i); if (i += 2, 1 == a) { var o = r.readUshort(e, i); i += 2; var s = r.readUshort(e, i); i += 2; for (var l = 0; l < s; l++)n.push(o + l), n.push(o + l), n.push(r.readUshort(e, i)), i += 2 } if (2 == a) { var c = r.readUshort(e, i); for (i += 2, l = 0; l < c; l++)n.push(r.readUshort(e, i)), i += 2, n.push(r.readUshort(e, i)), i += 2, n.push(r.readUshort(e, i)), i += 2 } return n }, t._lctf.getInterval = function (e, t) { for (var i = 0; i < e.length; i += 3) { var r = e[i], n = e[i + 1]; if (e[i + 2], r <= t && t <= n) return i } return -1 }, t._lctf.readCoverage = function (e, i) { var r = t._bin, n = {}; n.fmt = r.readUshort(e, i), i += 2; var a = r.readUshort(e, i); return i += 2, 1 == n.fmt && (n.tab = r.readUshorts(e, i, a)), 2 == n.fmt && (n.tab = r.readUshorts(e, i, 3 * a)), n }, t._lctf.coverageIndex = function (e, i) { var r = e.tab; if (1 == e.fmt) return r.indexOf(i); if (2 == e.fmt) { var n = t._lctf.getInterval(r, i); if (-1 != n) return r[n + 2] + (i - r[n]) } return -1 }, t._lctf.readFeatureList = function (e, i) { var r = t._bin, n = i, a = [], o = r.readUshort(e, i); i += 2; for (var s = 0; s < o; s++) { var l = r.readASCII(e, i, 4); i += 4; var c = r.readUshort(e, i); i += 2; var h = t._lctf.readFeatureTable(e, n + c); h.tag = l.trim(), a.push(h) } return a }, t._lctf.readFeatureTable = function (e, i) { var r = t._bin, n = i, a = {}, o = r.readUshort(e, i); i += 2, o > 0 && (a.featureParams = n + o); var s = r.readUshort(e, i); i += 2, a.tab = []; for (var l = 0; l < s; l++)a.tab.push(r.readUshort(e, i + 2 * l)); return a }, t._lctf.readScriptList = function (e, i) { var r = t._bin, n = i, a = {}, o = r.readUshort(e, i); i += 2; for (var s = 0; s < o; s++) { var l = r.readASCII(e, i, 4); i += 4; var c = r.readUshort(e, i); i += 2, a[l.trim()] = t._lctf.readScriptTable(e, n + c) } return a }, t._lctf.readScriptTable = function (e, i) { var r = t._bin, n = i, a = {}, o = r.readUshort(e, i); i += 2, a.default = t._lctf.readLangSysTable(e, n + o); var s = r.readUshort(e, i); i += 2; for (var l = 0; l < s; l++) { var c = r.readASCII(e, i, 4); i += 4; var h = r.readUshort(e, i); i += 2, a[c.trim()] = t._lctf.readLangSysTable(e, n + h) } return a }, t._lctf.readLangSysTable = function (e, i) { var r = t._bin, n = {}; r.readUshort(e, i), i += 2, n.reqFeature = r.readUshort(e, i), i += 2; var a = r.readUshort(e, i); return i += 2, n.features = r.readUshorts(e, i, a), n }, t.CFF = {}, t.CFF.parse = function (e, i, r) { var n = t._bin; (e = new Uint8Array(e.buffer, i, r))[i = 0], e[++i], e[++i], e[++i], i++; var a = []; i = t.CFF.readIndex(e, i, a); for (var o = [], s = 0; s < a.length - 1; s++)o.push(n.readASCII(e, i + a[s], a[s + 1] - a[s])); i += a[a.length - 1]; var l = []; i = t.CFF.readIndex(e, i, l); var c = []; for (s = 0; s < l.length - 1; s++)c.push(t.CFF.readDict(e, i + l[s], i + l[s + 1])); i += l[l.length - 1]; var h = c[0], u = []; i = t.CFF.readIndex(e, i, u); var d = []; for (s = 0; s < u.length - 1; s++)d.push(n.readASCII(e, i + u[s], u[s + 1] - u[s])); if (i += u[u.length - 1], t.CFF.readSubrs(e, i, h), h.CharStrings) { i = h.CharStrings, u = [], i = t.CFF.readIndex(e, i, u); var p = []; for (s = 0; s < u.length - 1; s++)p.push(n.readBytes(e, i + u[s], u[s + 1] - u[s])); h.CharStrings = p } if (h.ROS) { i = h.FDArray; var f = []; for (i = t.CFF.readIndex(e, i, f), h.FDArray = [], s = 0; s < f.length - 1; s++) { var m = t.CFF.readDict(e, i + f[s], i + f[s + 1]); t.CFF._readFDict(e, m, d), h.FDArray.push(m) } i += f[f.length - 1], i = h.FDSelect, h.FDSelect = []; var g = e[i]; if (i++, 3 != g) throw g; var y = n.readUshort(e, i); for (i += 2, s = 0; s < y + 1; s++)h.FDSelect.push(n.readUshort(e, i), e[i + 2]), i += 3 } return h.Encoding && (h.Encoding = t.CFF.readEncoding(e, h.Encoding, h.CharStrings.length)), h.charset && (h.charset = t.CFF.readCharset(e, h.charset, h.CharStrings.length)), t.CFF._readFDict(e, h, d), h }, t.CFF._readFDict = function (e, i, r) { var n; for (var a in i.Private && (n = i.Private[1], i.Private = t.CFF.readDict(e, n, n + i.Private[0]), i.Private.Subrs && t.CFF.readSubrs(e, n + i.Private.Subrs, i.Private)), i) -1 != ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(a) && (i[a] = r[i[a] - 426 + 35]) }, t.CFF.readSubrs = function (e, i, r) { var n = t._bin, a = []; i = t.CFF.readIndex(e, i, a); var o, s = a.length; o = s < 1240 ? 107 : s < 33900 ? 1131 : 32768, r.Bias = o, r.Subrs = []; for (var l = 0; l < a.length - 1; l++)r.Subrs.push(n.readBytes(e, i + a[l], a[l + 1] - a[l])) }, t.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], t.CFF.glyphByUnicode = function (e, t) { for (var i = 0; i < e.charset.length; i++)if (e.charset[i] == t) return i; return -1 }, t.CFF.glyphBySE = function (e, i) { return i < 0 || i > 255 ? -1 : t.CFF.glyphByUnicode(e, t.CFF.tableSE[i]) }, t.CFF.readEncoding = function (e, i, r) { t._bin; var n = [".notdef"], a = e[i]; if (i++, 0 != a) throw "error: unknown encoding format: " + a; var o = e[i]; i++; for (var s = 0; s < o; s++)n.push(e[i + s]); return n }, t.CFF.readCharset = function (e, i, r) { var n = t._bin, a = [".notdef"], o = e[i]; if (i++, 0 == o) for (var s = 0; s < r; s++) { var l = n.readUshort(e, i); i += 2, a.push(l) } else { if (1 != o && 2 != o) throw "error: format: " + o; for (; a.length < r;) { l = n.readUshort(e, i), i += 2; var c = 0; for (1 == o ? (c = e[i], i++) : (c = n.readUshort(e, i), i += 2), s = 0; s <= c; s++)a.push(l), l++ } } return a }, t.CFF.readIndex = function (e, i, r) { var n = t._bin, a = n.readUshort(e, i) + 1, o = e[i += 2]; if (i++, 1 == o) for (var s = 0; s < a; s++)r.push(e[i + s]); else if (2 == o) for (s = 0; s < a; s++)r.push(n.readUshort(e, i + 2 * s)); else if (3 == o) for (s = 0; s < a; s++)r.push(16777215 & n.readUint(e, i + 3 * s - 1)); else if (1 != a) throw "unsupported offset size: " + o + ", count: " + a; return (i += a * o) - 1 }, t.CFF.getCharString = function (e, i, r) { var n = t._bin, a = e[i], o = e[i + 1]; e[i + 2], e[i + 3], e[i + 4]; var s = 1, l = null, c = null; a <= 20 && (l = a, s = 1), 12 == a && (l = 100 * a + o, s = 2), 21 <= a && a <= 27 && (l = a, s = 1), 28 == a && (c = n.readShort(e, i + 1), s = 3), 29 <= a && a <= 31 && (l = a, s = 1), 32 <= a && a <= 246 && (c = a - 139, s = 1), 247 <= a && a <= 250 && (c = 256 * (a - 247) + o + 108, s = 2), 251 <= a && a <= 254 && (c = 256 * -(a - 251) - o - 108, s = 2), 255 == a && (c = n.readInt(e, i + 1) / 65535, s = 5), r.val = null != c ? c : "o" + l, r.size = s }, t.CFF.readCharString = function (e, i, r) { for (var n = i + r, a = t._bin, o = []; i < n;) { var s = e[i], l = e[i + 1]; e[i + 2], e[i + 3], e[i + 4]; var c = 1, h = null, u = null; s <= 20 && (h = s, c = 1), 12 == s && (h = 100 * s + l, c = 2), 19 != s && 20 != s || (h = s, c = 2), 21 <= s && s <= 27 && (h = s, c = 1), 28 == s && (u = a.readShort(e, i + 1), c = 3), 29 <= s && s <= 31 && (h = s, c = 1), 32 <= s && s <= 246 && (u = s - 139, c = 1), 247 <= s && s <= 250 && (u = 256 * (s - 247) + l + 108, c = 2), 251 <= s && s <= 254 && (u = 256 * -(s - 251) - l - 108, c = 2), 255 == s && (u = a.readInt(e, i + 1) / 65535, c = 5), o.push(null != u ? u : "o" + h), i += c } return o }, t.CFF.readDict = function (e, i, r) { for (var n = t._bin, a = {}, o = []; i < r;) { var s = e[i], l = e[i + 1]; e[i + 2], e[i + 3], e[i + 4]; var c = 1, h = null, u = null; if (28 == s && (u = n.readShort(e, i + 1), c = 3), 29 == s && (u = n.readInt(e, i + 1), c = 5), 32 <= s && s <= 246 && (u = s - 139, c = 1), 247 <= s && s <= 250 && (u = 256 * (s - 247) + l + 108, c = 2), 251 <= s && s <= 254 && (u = 256 * -(s - 251) - l - 108, c = 2), 255 == s) throw u = n.readInt(e, i + 1) / 65535, c = 5, "unknown number"; if (30 == s) { var d = []; for (c = 1; ;) { var p = e[i + c]; c++; var f = p >> 4, m = 15 & p; if (15 != f && d.push(f), 15 != m && d.push(m), 15 == m) break } for (var g = "", y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], v = 0; v < d.length; v++)g += y[d[v]]; u = parseFloat(g) } s <= 21 && (h = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][s], c = 1, 12 == s && (h = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][l], c = 2)), null != h ? (a[h] = 1 == o.length ? o[0] : o, o = []) : o.push(u), i += c } return a }, t.cmap = {}, t.cmap.parse = function (e, i, r) { e = new Uint8Array(e.buffer, i, r), i = 0; var n = t._bin, a = {}; n.readUshort(e, i), i += 2; var o = n.readUshort(e, i); i += 2; var s = []; a.tables = []; for (var l = 0; l < o; l++) { var c = n.readUshort(e, i); i += 2; var h = n.readUshort(e, i); i += 2; var u = n.readUint(e, i); i += 4; var d = "p" + c + "e" + h, p = s.indexOf(u); if (-1 == p) { var f; p = a.tables.length, s.push(u); var m = n.readUshort(e, u); 0 == m ? f = t.cmap.parse0(e, u) : 4 == m ? f = t.cmap.parse4(e, u) : 6 == m ? f = t.cmap.parse6(e, u) : 12 == m ? f = t.cmap.parse12(e, u) : console.debug("unknown format: " + m, c, h, u), a.tables.push(f) } if (null != a[d]) throw "multiple tables for one platform+encoding"; a[d] = p } return a }, t.cmap.parse0 = function (e, i) { var r = t._bin, n = {}; n.format = r.readUshort(e, i), i += 2; var a = r.readUshort(e, i); i += 2, r.readUshort(e, i), i += 2, n.map = []; for (var o = 0; o < a - 6; o++)n.map.push(e[i + o]); return n }, t.cmap.parse4 = function (e, i) { var r = t._bin, n = i, a = {}; a.format = r.readUshort(e, i), i += 2; var o = r.readUshort(e, i); i += 2, r.readUshort(e, i), i += 2; var s = r.readUshort(e, i); i += 2; var l = s / 2; a.searchRange = r.readUshort(e, i), i += 2, a.entrySelector = r.readUshort(e, i), i += 2, a.rangeShift = r.readUshort(e, i), i += 2, a.endCount = r.readUshorts(e, i, l), i += 2 * l, i += 2, a.startCount = r.readUshorts(e, i, l), i += 2 * l, a.idDelta = []; for (var c = 0; c < l; c++)a.idDelta.push(r.readShort(e, i)), i += 2; for (a.idRangeOffset = r.readUshorts(e, i, l), i += 2 * l, a.glyphIdArray = []; i < n + o;)a.glyphIdArray.push(r.readUshort(e, i)), i += 2; return a }, t.cmap.parse6 = function (e, i) { var r = t._bin, n = {}; n.format = r.readUshort(e, i), i += 2, r.readUshort(e, i), i += 2, r.readUshort(e, i), i += 2, n.firstCode = r.readUshort(e, i), i += 2; var a = r.readUshort(e, i); i += 2, n.glyphIdArray = []; for (var o = 0; o < a; o++)n.glyphIdArray.push(r.readUshort(e, i)), i += 2; return n }, t.cmap.parse12 = function (e, i) { var r = t._bin, n = {}; n.format = r.readUshort(e, i), i += 2, i += 2, r.readUint(e, i), i += 4, r.readUint(e, i), i += 4; var a = r.readUint(e, i); i += 4, n.groups = []; for (var o = 0; o < a; o++) { var s = i + 12 * o, l = r.readUint(e, s + 0), c = r.readUint(e, s + 4), h = r.readUint(e, s + 8); n.groups.push([l, c, h]) } return n }, t.glyf = {}, t.glyf.parse = function (e, t, i, r) { for (var n = [], a = 0; a < r.maxp.numGlyphs; a++)n.push(null); return n }, t.glyf._parseGlyf = function (e, i) { var r = t._bin, n = e._data, a = t._tabOffset(n, "glyf", e._offset) + e.loca[i]; if (e.loca[i] == e.loca[i + 1]) return null; var o = {}; if (o.noc = r.readShort(n, a), a += 2, o.xMin = r.readShort(n, a), a += 2, o.yMin = r.readShort(n, a), a += 2, o.xMax = r.readShort(n, a), a += 2, o.yMax = r.readShort(n, a), a += 2, o.xMin >= o.xMax || o.yMin >= o.yMax) return null; if (o.noc > 0) { o.endPts = []; for (var s = 0; s < o.noc; s++)o.endPts.push(r.readUshort(n, a)), a += 2; var l = r.readUshort(n, a); if (a += 2, n.length - a < l) return null; o.instructions = r.readBytes(n, a, l), a += l; var c = o.endPts[o.noc - 1] + 1; for (o.flags = [], s = 0; s < c; s++) { var h = n[a]; if (a++, o.flags.push(h), 0 != (8 & h)) { var u = n[a]; a++; for (var d = 0; d < u; d++)o.flags.push(h), s++ } } for (o.xs = [], s = 0; s < c; s++) { var p = 0 != (2 & o.flags[s]), f = 0 != (16 & o.flags[s]); p ? (o.xs.push(f ? n[a] : -n[a]), a++) : f ? o.xs.push(0) : (o.xs.push(r.readShort(n, a)), a += 2) } for (o.ys = [], s = 0; s < c; s++)p = 0 != (4 & o.flags[s]), f = 0 != (32 & o.flags[s]), p ? (o.ys.push(f ? n[a] : -n[a]), a++) : f ? o.ys.push(0) : (o.ys.push(r.readShort(n, a)), a += 2); var m = 0, g = 0; for (s = 0; s < c; s++)m += o.xs[s], g += o.ys[s], o.xs[s] = m, o.ys[s] = g } else { var y; o.parts = []; do { y = r.readUshort(n, a), a += 2; var v = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 }; if (o.parts.push(v), v.glyphIndex = r.readUshort(n, a), a += 2, 1 & y) { var _ = r.readShort(n, a); a += 2; var b = r.readShort(n, a); a += 2 } else _ = r.readInt8(n, a), a++, b = r.readInt8(n, a), a++; 2 & y ? (v.m.tx = _, v.m.ty = b) : (v.p1 = _, v.p2 = b), 8 & y ? (v.m.a = v.m.d = r.readF2dot14(n, a), a += 2) : 64 & y ? (v.m.a = r.readF2dot14(n, a), a += 2, v.m.d = r.readF2dot14(n, a), a += 2) : 128 & y && (v.m.a = r.readF2dot14(n, a), a += 2, v.m.b = r.readF2dot14(n, a), a += 2, v.m.c = r.readF2dot14(n, a), a += 2, v.m.d = r.readF2dot14(n, a), a += 2) } while (32 & y); if (256 & y) { var x = r.readUshort(n, a); for (a += 2, o.instr = [], s = 0; s < x; s++)o.instr.push(n[a]), a++ } } return o }, t.GPOS = {}, t.GPOS.parse = function (e, i, r, n) { return t._lctf.parse(e, i, r, n, t.GPOS.subt) }, t.GPOS.subt = function (e, i, r, n) { var a = t._bin, o = r, s = {}; if (s.fmt = a.readUshort(e, r), r += 2, 1 == i || 2 == i || 3 == i || 7 == i || 8 == i && s.fmt <= 2) { var l = a.readUshort(e, r); r += 2, s.coverage = t._lctf.readCoverage(e, l + o) } if (1 == i && 1 == s.fmt) { var c = a.readUshort(e, r); r += 2; var h = t._lctf.numOfOnes(c); 0 != c && (s.pos = t.GPOS.readValueRecord(e, r, c)) } else if (2 == i && s.fmt >= 1 && s.fmt <= 2) { c = a.readUshort(e, r), r += 2; var u = a.readUshort(e, r); r += 2, h = t._lctf.numOfOnes(c); var d = t._lctf.numOfOnes(u); if (1 == s.fmt) { s.pairsets = []; var p = a.readUshort(e, r); r += 2; for (var f = 0; f < p; f++) { var m = o + a.readUshort(e, r); r += 2; var g = a.readUshort(e, m); m += 2; for (var y = [], v = 0; v < g; v++) { var _ = a.readUshort(e, m); m += 2, 0 != c && (T = t.GPOS.readValueRecord(e, m, c), m += 2 * h), 0 != u && (A = t.GPOS.readValueRecord(e, m, u), m += 2 * d), y.push({ gid2: _, val1: T, val2: A }) } s.pairsets.push(y) } } if (2 == s.fmt) { var b = a.readUshort(e, r); r += 2; var x = a.readUshort(e, r); r += 2; var w = a.readUshort(e, r); r += 2; var S = a.readUshort(e, r); for (r += 2, s.classDef1 = t._lctf.readClassDef(e, o + b), s.classDef2 = t._lctf.readClassDef(e, o + x), s.matrix = [], f = 0; f < w; f++) { var M = []; for (v = 0; v < S; v++) { var T = null, A = null; 0 != c && (T = t.GPOS.readValueRecord(e, r, c), r += 2 * h), 0 != u && (A = t.GPOS.readValueRecord(e, r, u), r += 2 * d), M.push({ val1: T, val2: A }) } s.matrix.push(M) } } } else { if (9 == i && 1 == s.fmt) { var E = a.readUshort(e, r); r += 2; var C = a.readUint(e, r); if (r += 4, 9 == n.ltype) n.ltype = E; else if (n.ltype != E) throw "invalid extension substitution"; return t.GPOS.subt(e, n.ltype, o + C) } console.debug("unsupported GPOS table LookupType", i, "format", s.fmt) } return s }, t.GPOS.readValueRecord = function (e, i, r) { var n = t._bin, a = []; return a.push(1 & r ? n.readShort(e, i) : 0), i += 1 & r ? 2 : 0, a.push(2 & r ? n.readShort(e, i) : 0), i += 2 & r ? 2 : 0, a.push(4 & r ? n.readShort(e, i) : 0), i += 4 & r ? 2 : 0, a.push(8 & r ? n.readShort(e, i) : 0), i += 8 & r ? 2 : 0, a }, t.GSUB = {}, t.GSUB.parse = function (e, i, r, n) { return t._lctf.parse(e, i, r, n, t.GSUB.subt) }, t.GSUB.subt = function (e, i, r, n) { var a = t._bin, o = r, s = {}; if (s.fmt = a.readUshort(e, r), r += 2, 1 != i && 4 != i && 5 != i && 6 != i) return null; if (1 == i || 4 == i || 5 == i && s.fmt <= 2 || 6 == i && s.fmt <= 2) { var l = a.readUshort(e, r); r += 2, s.coverage = t._lctf.readCoverage(e, o + l) } if (1 == i && s.fmt >= 1 && s.fmt <= 2) { if (1 == s.fmt) s.delta = a.readShort(e, r), r += 2; else if (2 == s.fmt) { var c = a.readUshort(e, r); r += 2, s.newg = a.readUshorts(e, r, c), r += 2 * s.newg.length } } else if (4 == i) { s.vals = [], c = a.readUshort(e, r), r += 2; for (var h = 0; h < c; h++) { var u = a.readUshort(e, r); r += 2, s.vals.push(t.GSUB.readLigatureSet(e, o + u)) } } else if (5 == i && 2 == s.fmt) { if (2 == s.fmt) { var d = a.readUshort(e, r); r += 2, s.cDef = t._lctf.readClassDef(e, o + d), s.scset = []; var p = a.readUshort(e, r); for (r += 2, h = 0; h < p; h++) { var f = a.readUshort(e, r); r += 2, s.scset.push(0 == f ? null : t.GSUB.readSubClassSet(e, o + f)) } } } else if (6 == i && 3 == s.fmt) { if (3 == s.fmt) { for (h = 0; h < 3; h++) { c = a.readUshort(e, r), r += 2; for (var m = [], g = 0; g < c; g++)m.push(t._lctf.readCoverage(e, o + a.readUshort(e, r + 2 * g))); r += 2 * c, 0 == h && (s.backCvg = m), 1 == h && (s.inptCvg = m), 2 == h && (s.ahedCvg = m) } c = a.readUshort(e, r), r += 2, s.lookupRec = t.GSUB.readSubstLookupRecords(e, r, c) } } else { if (7 == i && 1 == s.fmt) { var y = a.readUshort(e, r); r += 2; var v = a.readUint(e, r); if (r += 4, 9 == n.ltype) n.ltype = y; else if (n.ltype != y) throw "invalid extension substitution"; return t.GSUB.subt(e, n.ltype, o + v) } console.debug("unsupported GSUB table LookupType", i, "format", s.fmt) } return s }, t.GSUB.readSubClassSet = function (e, i) { var r = t._bin.readUshort, n = i, a = [], o = r(e, i); i += 2; for (var s = 0; s < o; s++) { var l = r(e, i); i += 2, a.push(t.GSUB.readSubClassRule(e, n + l)) } return a }, t.GSUB.readSubClassRule = function (e, i) { var r = t._bin.readUshort, n = {}, a = r(e, i), o = r(e, i += 2); i += 2, n.input = []; for (var s = 0; s < a - 1; s++)n.input.push(r(e, i)), i += 2; return n.substLookupRecords = t.GSUB.readSubstLookupRecords(e, i, o), n }, t.GSUB.readSubstLookupRecords = function (e, i, r) { for (var n = t._bin.readUshort, a = [], o = 0; o < r; o++)a.push(n(e, i), n(e, i + 2)), i += 4; return a }, t.GSUB.readChainSubClassSet = function (e, i) { var r = t._bin, n = i, a = [], o = r.readUshort(e, i); i += 2; for (var s = 0; s < o; s++) { var l = r.readUshort(e, i); i += 2, a.push(t.GSUB.readChainSubClassRule(e, n + l)) } return a }, t.GSUB.readChainSubClassRule = function (e, i) { for (var r = t._bin, n = {}, a = ["backtrack", "input", "lookahead"], o = 0; o < a.length; o++) { var s = r.readUshort(e, i); i += 2, 1 == o && s--, n[a[o]] = r.readUshorts(e, i, s), i += 2 * n[a[o]].length } return s = r.readUshort(e, i), i += 2, n.subst = r.readUshorts(e, i, 2 * s), i += 2 * n.subst.length, n }, t.GSUB.readLigatureSet = function (e, i) { var r = t._bin, n = i, a = [], o = r.readUshort(e, i); i += 2; for (var s = 0; s < o; s++) { var l = r.readUshort(e, i); i += 2, a.push(t.GSUB.readLigature(e, n + l)) } return a }, t.GSUB.readLigature = function (e, i) { var r = t._bin, n = { chain: [] }; n.nglyph = r.readUshort(e, i), i += 2; var a = r.readUshort(e, i); i += 2; for (var o = 0; o < a - 1; o++)n.chain.push(r.readUshort(e, i)), i += 2; return n }, t.head = {}, t.head.parse = function (e, i, r) { var n = t._bin, a = {}; return n.readFixed(e, i), i += 4, a.fontRevision = n.readFixed(e, i), i += 4, n.readUint(e, i), i += 4, n.readUint(e, i), i += 4, a.flags = n.readUshort(e, i), i += 2, a.unitsPerEm = n.readUshort(e, i), i += 2, a.created = n.readUint64(e, i), i += 8, a.modified = n.readUint64(e, i), i += 8, a.xMin = n.readShort(e, i), i += 2, a.yMin = n.readShort(e, i), i += 2, a.xMax = n.readShort(e, i), i += 2, a.yMax = n.readShort(e, i), i += 2, a.macStyle = n.readUshort(e, i), i += 2, a.lowestRecPPEM = n.readUshort(e, i), i += 2, a.fontDirectionHint = n.readShort(e, i), i += 2, a.indexToLocFormat = n.readShort(e, i), i += 2, a.glyphDataFormat = n.readShort(e, i), i += 2, a }, t.hhea = {}, t.hhea.parse = function (e, i, r) { var n = t._bin, a = {}; return n.readFixed(e, i), i += 4, a.ascender = n.readShort(e, i), i += 2, a.descender = n.readShort(e, i), i += 2, a.lineGap = n.readShort(e, i), i += 2, a.advanceWidthMax = n.readUshort(e, i), i += 2, a.minLeftSideBearing = n.readShort(e, i), i += 2, a.minRightSideBearing = n.readShort(e, i), i += 2, a.xMaxExtent = n.readShort(e, i), i += 2, a.caretSlopeRise = n.readShort(e, i), i += 2, a.caretSlopeRun = n.readShort(e, i), i += 2, a.caretOffset = n.readShort(e, i), i += 2, i += 8, a.metricDataFormat = n.readShort(e, i), i += 2, a.numberOfHMetrics = n.readUshort(e, i), i += 2, a }, t.hmtx = {}, t.hmtx.parse = function (e, i, r, n) { for (var a = t._bin, o = { aWidth: [], lsBearing: [] }, s = 0, l = 0, c = 0; c < n.maxp.numGlyphs; c++)c < n.hhea.numberOfHMetrics && (s = a.readUshort(e, i), i += 2, l = a.readShort(e, i), i += 2), o.aWidth.push(s), o.lsBearing.push(l); return o }, t.kern = {}, t.kern.parse = function (e, i, r, n) { var a = t._bin, o = a.readUshort(e, i); if (i += 2, 1 == o) return t.kern.parseV1(e, i - 2, r, n); var s = a.readUshort(e, i); i += 2; for (var l = { glyph1: [], rval: [] }, c = 0; c < s; c++) { i += 2, r = a.readUshort(e, i), i += 2; var h = a.readUshort(e, i); i += 2; var u = h >>> 8; if (0 != (u &= 15)) throw "unknown kern table format: " + u; i = t.kern.readFormat0(e, i, l) } return l }, t.kern.parseV1 = function (e, i, r, n) { var a = t._bin; a.readFixed(e, i), i += 4; var o = a.readUint(e, i); i += 4; for (var s = { glyph1: [], rval: [] }, l = 0; l < o; l++) { a.readUint(e, i), i += 4; var c = a.readUshort(e, i); i += 2, a.readUshort(e, i), i += 2; var h = c >>> 8; if (0 != (h &= 15)) throw "unknown kern table format: " + h; i = t.kern.readFormat0(e, i, s) } return s }, t.kern.readFormat0 = function (e, i, r) { var n = t._bin, a = -1, o = n.readUshort(e, i); i += 2, n.readUshort(e, i), i += 2, n.readUshort(e, i), i += 2, n.readUshort(e, i), i += 2; for (var s = 0; s < o; s++) { var l = n.readUshort(e, i); i += 2; var c = n.readUshort(e, i); i += 2; var h = n.readShort(e, i); i += 2, l != a && (r.glyph1.push(l), r.rval.push({ glyph2: [], vals: [] })); var u = r.rval[r.rval.length - 1]; u.glyph2.push(c), u.vals.push(h), a = l } return i }, t.loca = {}, t.loca.parse = function (e, i, r, n) { var a = t._bin, o = [], s = n.head.indexToLocFormat, l = n.maxp.numGlyphs + 1; if (0 == s) for (var c = 0; c < l; c++)o.push(a.readUshort(e, i + (c << 1)) << 1); if (1 == s) for (c = 0; c < l; c++)o.push(a.readUint(e, i + (c << 2))); return o }, t.maxp = {}, t.maxp.parse = function (e, i, r) { var n = t._bin, a = {}, o = n.readUint(e, i); return i += 4, a.numGlyphs = n.readUshort(e, i), i += 2, 65536 == o && (a.maxPoints = n.readUshort(e, i), i += 2, a.maxContours = n.readUshort(e, i), i += 2, a.maxCompositePoints = n.readUshort(e, i), i += 2, a.maxCompositeContours = n.readUshort(e, i), i += 2, a.maxZones = n.readUshort(e, i), i += 2, a.maxTwilightPoints = n.readUshort(e, i), i += 2, a.maxStorage = n.readUshort(e, i), i += 2, a.maxFunctionDefs = n.readUshort(e, i), i += 2, a.maxInstructionDefs = n.readUshort(e, i), i += 2, a.maxStackElements = n.readUshort(e, i), i += 2, a.maxSizeOfInstructions = n.readUshort(e, i), i += 2, a.maxComponentElements = n.readUshort(e, i), i += 2, a.maxComponentDepth = n.readUshort(e, i), i += 2), a }, t.name = {}, t.name.parse = function (e, i, r) { var n = t._bin, a = {}; n.readUshort(e, i), i += 2; var o = n.readUshort(e, i); i += 2, n.readUshort(e, i); for (var s, l = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], c = i += 2, h = 0; h < o; h++) { var u = n.readUshort(e, i); i += 2; var d = n.readUshort(e, i); i += 2; var p = n.readUshort(e, i); i += 2; var f = n.readUshort(e, i); i += 2; var m = n.readUshort(e, i); i += 2; var g = n.readUshort(e, i); i += 2; var y, v = l[f], _ = c + 12 * o + g; if (0 == u) y = n.readUnicode(e, _, m / 2); else if (3 == u && 0 == d) y = n.readUnicode(e, _, m / 2); else if (0 == d) y = n.readASCII(e, _, m); else if (1 == d) y = n.readUnicode(e, _, m / 2); else if (3 == d) y = n.readUnicode(e, _, m / 2); else { if (1 != u) throw "unknown encoding " + d + ", platformID: " + u; y = n.readASCII(e, _, m), console.debug("reading unknown MAC encoding " + d + " as ASCII") } var b = "p" + u + "," + p.toString(16); null == a[b] && (a[b] = {}), a[b][void 0 !== v ? v : f] = y, a[b]._lang = p } for (var x in a) if (null != a[x].postScriptName && 1033 == a[x]._lang) return a[x]; for (var x in a) if (null != a[x].postScriptName && 0 == a[x]._lang) return a[x]; for (var x in a) if (null != a[x].postScriptName && 3084 == a[x]._lang) return a[x]; for (var x in a) if (null != a[x].postScriptName) return a[x]; for (var x in a) { s = x; break } return console.debug("returning name table with languageID " + a[s]._lang), a[s] }, t["OS/2"] = {}, t["OS/2"].parse = function (e, i, r) { var n = t._bin.readUshort(e, i); i += 2; var a = {}; if (0 == n) t["OS/2"].version0(e, i, a); else if (1 == n) t["OS/2"].version1(e, i, a); else if (2 == n || 3 == n || 4 == n) t["OS/2"].version2(e, i, a); else { if (5 != n) throw "unknown OS/2 table version: " + n; t["OS/2"].version5(e, i, a) } return a }, t["OS/2"].version0 = function (e, i, r) { var n = t._bin; return r.xAvgCharWidth = n.readShort(e, i), i += 2, r.usWeightClass = n.readUshort(e, i), i += 2, r.usWidthClass = n.readUshort(e, i), i += 2, r.fsType = n.readUshort(e, i), i += 2, r.ySubscriptXSize = n.readShort(e, i), i += 2, r.ySubscriptYSize = n.readShort(e, i), i += 2, r.ySubscriptXOffset = n.readShort(e, i), i += 2, r.ySubscriptYOffset = n.readShort(e, i), i += 2, r.ySuperscriptXSize = n.readShort(e, i), i += 2, r.ySuperscriptYSize = n.readShort(e, i), i += 2, r.ySuperscriptXOffset = n.readShort(e, i), i += 2, r.ySuperscriptYOffset = n.readShort(e, i), i += 2, r.yStrikeoutSize = n.readShort(e, i), i += 2, r.yStrikeoutPosition = n.readShort(e, i), i += 2, r.sFamilyClass = n.readShort(e, i), i += 2, r.panose = n.readBytes(e, i, 10), i += 10, r.ulUnicodeRange1 = n.readUint(e, i), i += 4, r.ulUnicodeRange2 = n.readUint(e, i), i += 4, r.ulUnicodeRange3 = n.readUint(e, i), i += 4, r.ulUnicodeRange4 = n.readUint(e, i), i += 4, r.achVendID = [n.readInt8(e, i), n.readInt8(e, i + 1), n.readInt8(e, i + 2), n.readInt8(e, i + 3)], i += 4, r.fsSelection = n.readUshort(e, i), i += 2, r.usFirstCharIndex = n.readUshort(e, i), i += 2, r.usLastCharIndex = n.readUshort(e, i), i += 2, r.sTypoAscender = n.readShort(e, i), i += 2, r.sTypoDescender = n.readShort(e, i), i += 2, r.sTypoLineGap = n.readShort(e, i), i += 2, r.usWinAscent = n.readUshort(e, i), i += 2, r.usWinDescent = n.readUshort(e, i), i + 2 }, t["OS/2"].version1 = function (e, i, r) { var n = t._bin; return i = t["OS/2"].version0(e, i, r), r.ulCodePageRange1 = n.readUint(e, i), i += 4, r.ulCodePageRange2 = n.readUint(e, i), i + 4 }, t["OS/2"].version2 = function (e, i, r) { var n = t._bin; return i = t["OS/2"].version1(e, i, r), r.sxHeight = n.readShort(e, i), i += 2, r.sCapHeight = n.readShort(e, i), i += 2, r.usDefault = n.readUshort(e, i), i += 2, r.usBreak = n.readUshort(e, i), i += 2, r.usMaxContext = n.readUshort(e, i), i + 2 }, t["OS/2"].version5 = function (e, i, r) { var n = t._bin; return i = t["OS/2"].version2(e, i, r), r.usLowerOpticalPointSize = n.readUshort(e, i), i += 2, r.usUpperOpticalPointSize = n.readUshort(e, i), i + 2 }, t.post = {}, t.post.parse = function (e, i, r) { var n = t._bin, a = {}; return a.version = n.readFixed(e, i), i += 4, a.italicAngle = n.readFixed(e, i), i += 4, a.underlinePosition = n.readShort(e, i), i += 2, a.underlineThickness = n.readShort(e, i), i += 2, a }, null == t && (t = {}), null == t.U && (t.U = {}), t.U.codeToGlyph = function (e, t) { var i = e.cmap, r = -1; if (null != i.p0e4 ? r = i.p0e4 : null != i.p3e1 ? r = i.p3e1 : null != i.p1e0 ? r = i.p1e0 : null != i.p0e3 && (r = i.p0e3), -1 == r) throw "no familiar platform and encoding!"; var n = i.tables[r]; if (0 == n.format) return t >= n.map.length ? 0 : n.map[t]; if (4 == n.format) { for (var a = -1, o = 0; o < n.endCount.length; o++)if (t <= n.endCount[o]) { a = o; break } return -1 == a || n.startCount[a] > t ? 0 : 65535 & (0 != n.idRangeOffset[a] ? n.glyphIdArray[t - n.startCount[a] + (n.idRangeOffset[a] >> 1) - (n.idRangeOffset.length - a)] : t + n.idDelta[a]) } if (12 == n.format) { if (t > n.groups[n.groups.length - 1][1]) return 0; for (o = 0; o < n.groups.length; o++) { var s = n.groups[o]; if (s[0] <= t && t <= s[1]) return s[2] + (t - s[0]) } return 0 } throw "unknown cmap table format " + n.format }, t.U.glyphToPath = function (e, i) { var r = { cmds: [], crds: [] }; if (e.SVG && e.SVG.entries[i]) { var n = e.SVG.entries[i]; return null == n ? r : ("string" == typeof n && (n = t.SVG.toPath(n), e.SVG.entries[i] = n), n) } if (e.CFF) { var a = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: e.CFF.Private ? e.CFF.Private.defaultWidthX : 0, open: !1 }, o = e.CFF, s = e.CFF.Private; if (o.ROS) { for (var l = 0; o.FDSelect[l + 2] <= i;)l += 2; s = o.FDArray[o.FDSelect[l + 1]].Private } t.U._drawCFF(e.CFF.CharStrings[i], a, o, s, r) } else e.glyf && t.U._drawGlyf(i, e, r); return r }, t.U._drawGlyf = function (e, i, r) { var n = i.glyf[e]; null == n && (n = i.glyf[e] = t.glyf._parseGlyf(i, e)), null != n && (n.noc > -1 ? t.U._simpleGlyph(n, r) : t.U._compoGlyph(n, i, r)) }, t.U._simpleGlyph = function (e, i) { for (var r = 0; r < e.noc; r++) { for (var n = 0 == r ? 0 : e.endPts[r - 1] + 1, a = e.endPts[r], o = n; o <= a; o++) { var s = o == n ? a : o - 1, l = o == a ? n : o + 1, c = 1 & e.flags[o], h = 1 & e.flags[s], u = 1 & e.flags[l], d = e.xs[o], p = e.ys[o]; if (o == n) if (c) { if (!h) { t.U.P.moveTo(i, d, p); continue } t.U.P.moveTo(i, e.xs[s], e.ys[s]) } else h ? t.U.P.moveTo(i, e.xs[s], e.ys[s]) : t.U.P.moveTo(i, (e.xs[s] + d) / 2, (e.ys[s] + p) / 2); c ? h && t.U.P.lineTo(i, d, p) : u ? t.U.P.qcurveTo(i, d, p, e.xs[l], e.ys[l]) : t.U.P.qcurveTo(i, d, p, (d + e.xs[l]) / 2, (p + e.ys[l]) / 2) } t.U.P.closePath(i) } }, t.U._compoGlyph = function (e, i, r) { for (var n = 0; n < e.parts.length; n++) { var a = { cmds: [], crds: [] }, o = e.parts[n]; t.U._drawGlyf(o.glyphIndex, i, a); for (var s = o.m, l = 0; l < a.crds.length; l += 2) { var c = a.crds[l], h = a.crds[l + 1]; r.crds.push(c * s.a + h * s.b + s.tx), r.crds.push(c * s.c + h * s.d + s.ty) } for (l = 0; l < a.cmds.length; l++)r.cmds.push(a.cmds[l]) } }, t.U._getGlyphClass = function (e, i) { var r = t._lctf.getInterval(i, e); return -1 == r ? 0 : i[r + 2] }, t.U.getPairAdjustment = function (e, i, r) { var n = 0; if (e.GPOS) for (var a = e.GPOS, o = a.lookupList, s = a.featureList, l = [], c = 0; c < s.length; c++) { var h = s[c]; if ("kern" == h.tag) for (var u = 0; u < h.tab.length; u++)if (!l[h.tab[u]]) { l[h.tab[u]] = !0; for (var d = o[h.tab[u]], p = 0; p < d.tabs.length; p++)if (null != d.tabs[p]) { var f, m = d.tabs[p]; if (!m.coverage || -1 != (f = t._lctf.coverageIndex(m.coverage, i))) if (1 == d.ltype); else if (2 == d.ltype) { var g; if (1 == m.fmt) { var y = m.pairsets[f]; for (c = 0; c < y.length; c++)y[c].gid2 == r && (g = y[c]) } else if (2 == m.fmt) { var v = t.U._getGlyphClass(i, m.classDef1), _ = t.U._getGlyphClass(r, m.classDef2); g = m.matrix[v][_] } g && g.val1 && g.val1[2] && (n += g.val1[2]), g && g.val2 && g.val2[0] && (n += g.val2[0]) } } } } if (e.kern) { var b = e.kern.glyph1.indexOf(i); if (-1 != b) { var x = e.kern.rval[b].glyph2.indexOf(r); -1 != x && (n += e.kern.rval[b].vals[x]) } } return n }, t.U._applySubs = function (e, i, r, n) { for (var a = e.length - i - 1, o = 0; o < r.tabs.length; o++)if (null != r.tabs[o]) { var s, l = r.tabs[o]; if (!l.coverage || -1 != (s = t._lctf.coverageIndex(l.coverage, e[i]))) if (1 == r.ltype) e[i], 1 == l.fmt ? e[i] = e[i] + l.delta : e[i] = l.newg[s]; else if (4 == r.ltype) for (var c = l.vals[s], h = 0; h < c.length; h++) { var u = c[h], d = u.chain.length; if (!(d > a)) { for (var p = !0, f = 0, m = 0; m < d; m++) { for (; -1 == e[i + f + (1 + m)];)f++; u.chain[m] != e[i + f + (1 + m)] && (p = !1) } if (p) { for (e[i] = u.nglyph, m = 0; m < d + f; m++)e[i + m + 1] = -1; break } } } else if (5 == r.ltype && 2 == l.fmt) for (var g = t._lctf.getInterval(l.cDef, e[i]), y = l.cDef[g + 2], v = l.scset[y], _ = 0; _ < v.length; _++) { var b = v[_], x = b.input; if (!(x.length > a)) { for (p = !0, m = 0; m < x.length; m++) { var w = t._lctf.getInterval(l.cDef, e[i + 1 + m]); if (-1 == g && l.cDef[w + 2] != x[m]) { p = !1; break } } if (p) { var S = b.substLookupRecords; for (h = 0; h < S.length; h += 2)S[h], S[h + 1] } } } else if (6 == r.ltype && 3 == l.fmt) { if (!t.U._glsCovered(e, l.backCvg, i - l.backCvg.length)) continue; if (!t.U._glsCovered(e, l.inptCvg, i)) continue; if (!t.U._glsCovered(e, l.ahedCvg, i + l.inptCvg.length)) continue; var M = l.lookupRec; for (_ = 0; _ < M.length; _ += 2) { g = M[_]; var T = n[M[_ + 1]]; t.U._applySubs(e, i + g, T, n) } } } }, t.U._glsCovered = function (e, i, r) { for (var n = 0; n < i.length; n++)if (-1 == t._lctf.coverageIndex(i[n], e[r + n])) return !1; return !0 }, t.U.glyphsToPath = function (e, i, r) { for (var n = { cmds: [], crds: [] }, a = 0, o = 0; o < i.length; o++) { var s = i[o]; if (-1 != s) { for (var l = o < i.length - 1 && -1 != i[o + 1] ? i[o + 1] : 0, c = t.U.glyphToPath(e, s), h = 0; h < c.crds.length; h += 2)n.crds.push(c.crds[h] + a), n.crds.push(c.crds[h + 1]); for (r && n.cmds.push(r), h = 0; h < c.cmds.length; h++)n.cmds.push(c.cmds[h]); r && n.cmds.push("X"), a += e.hmtx.aWidth[s], o < i.length - 1 && (a += t.U.getPairAdjustment(e, s, l)) } } return n }, t.U.P = {}, t.U.P.moveTo = function (e, t, i) { e.cmds.push("M"), e.crds.push(t, i) }, t.U.P.lineTo = function (e, t, i) { e.cmds.push("L"), e.crds.push(t, i) }, t.U.P.curveTo = function (e, t, i, r, n, a, o) { e.cmds.push("C"), e.crds.push(t, i, r, n, a, o) }, t.U.P.qcurveTo = function (e, t, i, r, n) { e.cmds.push("Q"), e.crds.push(t, i, r, n) }, t.U.P.closePath = function (e) { e.cmds.push("Z") }, t.U._drawCFF = function (e, i, r, n, a) { for (var o = i.stack, s = i.nStems, l = i.haveWidth, c = i.width, h = i.open, u = 0, d = i.x, p = i.y, f = 0, m = 0, g = 0, y = 0, v = 0, _ = 0, b = 0, x = 0, w = 0, S = 0, M = { val: 0, size: 0 }; u < e.length;) { t.CFF.getCharString(e, u, M); var T = M.val; if (u += M.size, "o1" == T || "o18" == T) o.length % 2 != 0 && !l && (c = o.shift() + n.nominalWidthX), s += o.length >> 1, o.length = 0, l = !0; else if ("o3" == T || "o23" == T) o.length % 2 != 0 && !l && (c = o.shift() + n.nominalWidthX), s += o.length >> 1, o.length = 0, l = !0; else if ("o4" == T) o.length > 1 && !l && (c = o.shift() + n.nominalWidthX, l = !0), h && t.U.P.closePath(a), p += o.pop(), t.U.P.moveTo(a, d, p), h = !0; else if ("o5" == T) for (; o.length > 0;)d += o.shift(), p += o.shift(), t.U.P.lineTo(a, d, p); else if ("o6" == T || "o7" == T) for (var A = o.length, E = "o6" == T, C = 0; C < A; C++) { var L = o.shift(); E ? d += L : p += L, E = !E, t.U.P.lineTo(a, d, p) } else if ("o8" == T || "o24" == T) { A = o.length; for (var R = 0; R + 6 <= A;)f = d + o.shift(), m = p + o.shift(), g = f + o.shift(), y = m + o.shift(), d = g + o.shift(), p = y + o.shift(), t.U.P.curveTo(a, f, m, g, y, d, p), R += 6; "o24" == T && (d += o.shift(), p += o.shift(), t.U.P.lineTo(a, d, p)) } else { if ("o11" == T) break; if ("o1234" == T || "o1235" == T || "o1236" == T || "o1237" == T) "o1234" == T && (m = p, g = (f = d + o.shift()) + o.shift(), S = y = m + o.shift(), _ = y, x = p, d = (b = (v = (w = g + o.shift()) + o.shift()) + o.shift()) + o.shift(), t.U.P.curveTo(a, f, m, g, y, w, S), t.U.P.curveTo(a, v, _, b, x, d, p)), "o1235" == T && (f = d + o.shift(), m = p + o.shift(), g = f + o.shift(), y = m + o.shift(), w = g + o.shift(), S = y + o.shift(), v = w + o.shift(), _ = S + o.shift(), b = v + o.shift(), x = _ + o.shift(), d = b + o.shift(), p = x + o.shift(), o.shift(), t.U.P.curveTo(a, f, m, g, y, w, S), t.U.P.curveTo(a, v, _, b, x, d, p)), "o1236" == T && (f = d + o.shift(), m = p + o.shift(), g = f + o.shift(), S = y = m + o.shift(), _ = y, b = (v = (w = g + o.shift()) + o.shift()) + o.shift(), x = _ + o.shift(), d = b + o.shift(), t.U.P.curveTo(a, f, m, g, y, w, S), t.U.P.curveTo(a, v, _, b, x, d, p)), "o1237" == T && (f = d + o.shift(), m = p + o.shift(), g = f + o.shift(), y = m + o.shift(), w = g + o.shift(), S = y + o.shift(), v = w + o.shift(), _ = S + o.shift(), b = v + o.shift(), x = _ + o.shift(), Math.abs(b - d) > Math.abs(x - p) ? d = b + o.shift() : p = x + o.shift(), t.U.P.curveTo(a, f, m, g, y, w, S), t.U.P.curveTo(a, v, _, b, x, d, p)); else if ("o14" == T) { if (o.length > 0 && !l && (c = o.shift() + r.nominalWidthX, l = !0), 4 == o.length) { var D = o.shift(), P = o.shift(), O = o.shift(), I = o.shift(), k = t.CFF.glyphBySE(r, O), B = t.CFF.glyphBySE(r, I); t.U._drawCFF(r.CharStrings[k], i, r, n, a), i.x = D, i.y = P, t.U._drawCFF(r.CharStrings[B], i, r, n, a) } h && (t.U.P.closePath(a), h = !1) } else if ("o19" == T || "o20" == T) o.length % 2 != 0 && !l && (c = o.shift() + n.nominalWidthX), s += o.length >> 1, o.length = 0, l = !0, u += s + 7 >> 3; else if ("o21" == T) o.length > 2 && !l && (c = o.shift() + n.nominalWidthX, l = !0), p += o.pop(), d += o.pop(), h && t.U.P.closePath(a), t.U.P.moveTo(a, d, p), h = !0; else if ("o22" == T) o.length > 1 && !l && (c = o.shift() + n.nominalWidthX, l = !0), d += o.pop(), h && t.U.P.closePath(a), t.U.P.moveTo(a, d, p), h = !0; else if ("o25" == T) { for (; o.length > 6;)d += o.shift(), p += o.shift(), t.U.P.lineTo(a, d, p); f = d + o.shift(), m = p + o.shift(), g = f + o.shift(), y = m + o.shift(), d = g + o.shift(), p = y + o.shift(), t.U.P.curveTo(a, f, m, g, y, d, p) } else if ("o26" == T) for (o.length % 2 && (d += o.shift()); o.length > 0;)f = d, m = p + o.shift(), d = g = f + o.shift(), p = (y = m + o.shift()) + o.shift(), t.U.P.curveTo(a, f, m, g, y, d, p); else if ("o27" == T) for (o.length % 2 && (p += o.shift()); o.length > 0;)m = p, g = (f = d + o.shift()) + o.shift(), y = m + o.shift(), d = g + o.shift(), p = y, t.U.P.curveTo(a, f, m, g, y, d, p); else if ("o10" == T || "o29" == T) { var N = "o10" == T ? n : r; if (0 == o.length) console.debug("error: empty stack"); else { var F = o.pop(), U = N.Subrs[F + N.Bias]; i.x = d, i.y = p, i.nStems = s, i.haveWidth = l, i.width = c, i.open = h, t.U._drawCFF(U, i, r, n, a), d = i.x, p = i.y, s = i.nStems, l = i.haveWidth, c = i.width, h = i.open } } else if ("o30" == T || "o31" == T) { var z = o.length, G = (R = 0, "o31" == T); for (R += z - (A = -3 & z); R < A;)G ? (m = p, g = (f = d + o.shift()) + o.shift(), p = (y = m + o.shift()) + o.shift(), A - R == 5 ? (d = g + o.shift(), R++) : d = g, G = !1) : (f = d, m = p + o.shift(), g = f + o.shift(), y = m + o.shift(), d = g + o.shift(), A - R == 5 ? (p = y + o.shift(), R++) : p = y, G = !0), t.U.P.curveTo(a, f, m, g, y, d, p), R += 4 } else { if ("o" == (T + "").charAt(0)) throw console.debug("Unknown operation: " + T, e), T; o.push(T) } } } i.x = d, i.y = p, i.nStems = s, i.haveWidth = l, i.width = c, i.open = h }; var i = t, r = { Typr: i }; return e.Typr = i, e.default = r, Object.defineProperty(e, "__esModule", { value: !0 }), e }({}).Typr
/*!
  Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
  (https://github.com/101arrowz/fflate) for use in Troika text rendering. 
  Original licenses apply: 
  - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
  - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
  */} function woff2otfFactory() { return function (e) { var t = Uint8Array, i = Uint16Array, r = Uint32Array, n = new t([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), a = new t([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), o = new t([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), s = function (e, t) { for (var n = new i(31), a = 0; a < 31; ++a)n[a] = t += 1 << e[a - 1]; var o = new r(n[30]); for (a = 1; a < 30; ++a)for (var s = n[a]; s < n[a + 1]; ++s)o[s] = s - n[a] << 5 | a; return [n, o] }, l = s(n, 2), c = l[0], h = l[1]; c[28] = 258, h[258] = 28; for (var u = s(a, 0)[0], d = new i(32768), p = 0; p < 32768; ++p) { var f = (43690 & p) >>> 1 | (21845 & p) << 1; f = (61680 & (f = (52428 & f) >>> 2 | (13107 & f) << 2)) >>> 4 | (3855 & f) << 4, d[p] = ((65280 & f) >>> 8 | (255 & f) << 8) >>> 1 } var m = function (e, t, r) { for (var n = e.length, a = 0, o = new i(t); a < n; ++a)++o[e[a] - 1]; var s, l = new i(t); for (a = 0; a < t; ++a)l[a] = l[a - 1] + o[a - 1] << 1; if (r) { s = new i(1 << t); var c = 15 - t; for (a = 0; a < n; ++a)if (e[a]) for (var h = a << 4 | e[a], u = t - e[a], p = l[e[a] - 1]++ << u, f = p | (1 << u) - 1; p <= f; ++p)s[d[p] >>> c] = h } else for (s = new i(n), a = 0; a < n; ++a)s[a] = d[l[e[a] - 1]++] >>> 15 - e[a]; return s }, g = new t(288); for (p = 0; p < 144; ++p)g[p] = 8; for (p = 144; p < 256; ++p)g[p] = 9; for (p = 256; p < 280; ++p)g[p] = 7; for (p = 280; p < 288; ++p)g[p] = 8; var y = new t(32); for (p = 0; p < 32; ++p)y[p] = 5; var v = m(g, 9, 1), _ = m(y, 5, 1), b = function (e) { for (var t = e[0], i = 1; i < e.length; ++i)e[i] > t && (t = e[i]); return t }, x = function (e, t, i) { var r = t / 8 >> 0; return (e[r] | e[r + 1] << 8) >>> (7 & t) & i }, w = function (e, t) { var i = t / 8 >> 0; return (e[i] | e[i + 1] << 8 | e[i + 2] << 16) >>> (7 & t) }, S = function (e, s, l) { var h = e.length, d = !s || l, p = !l || l.i; l || (l = {}), s || (s = new t(3 * h)); var f, g = function (e) { var i = s.length; if (e > i) { var r = new t(Math.max(2 * i, e)); r.set(s), s = r } }, y = l.f || 0, S = l.p || 0, M = l.b || 0, T = l.l, A = l.d, E = l.m, C = l.n, L = 8 * h; do { if (!T) { l.f = y = x(e, S, 1); var R = x(e, S + 1, 3); if (S += 3, !R) { var D = e[(H = ((f = S) / 8 >> 0) + (7 & f && 1) + 4) - 4] | e[H - 3] << 8, P = H + D; if (P > h) { if (p) throw "unexpected EOF"; break } d && g(M + D), s.set(e.subarray(H, P), M), l.b = M += D, l.p = S = 8 * P; continue } if (1 == R) T = v, A = _, E = 9, C = 5; else { if (2 != R) throw "invalid block type"; var O = x(e, S, 31) + 257, I = x(e, S + 10, 15) + 4, k = O + x(e, S + 5, 31) + 1; S += 14; for (var B = new t(k), N = new t(19), F = 0; F < I; ++F)N[o[F]] = x(e, S + 3 * F, 7); S += 3 * I; var U = b(N), z = (1 << U) - 1; if (!p && S + k * (U + 7) > L) break; var G = m(N, U, 1); for (F = 0; F < k;) { var H, V = G[x(e, S, z)]; if (S += 15 & V, (H = V >>> 4) < 16) B[F++] = H; else { var j = 0, W = 0; for (16 == H ? (W = 3 + x(e, S, 3), S += 2, j = B[F - 1]) : 17 == H ? (W = 3 + x(e, S, 7), S += 3) : 18 == H && (W = 11 + x(e, S, 127), S += 7); W--;)B[F++] = j } } var $ = B.subarray(0, O), Y = B.subarray(O); E = b($), C = b(Y), T = m($, E, 1), A = m(Y, C, 1) } if (S > L) throw "unexpected EOF" } d && g(M + 131072); for (var X = (1 << E) - 1, Z = (1 << C) - 1, q = E + C + 18; p || S + q < L;) { var J = (j = T[w(e, S) & X]) >>> 4; if ((S += 15 & j) > L) throw "unexpected EOF"; if (!j) throw "invalid length/literal"; if (J < 256) s[M++] = J; else { if (256 == J) { T = null; break } var K = J - 254; if (J > 264) { var Q = n[F = J - 257]; K = x(e, S, (1 << Q) - 1) + c[F], S += Q } var ee = A[w(e, S) & Z], te = ee >>> 4; if (!ee) throw "invalid distance"; if (S += 15 & ee, Y = u[te], te > 3 && (Q = a[te], Y += w(e, S) & (1 << Q) - 1, S += Q), S > L) throw "unexpected EOF"; d && g(M + 131072); for (var ie = M + K; M < ie; M += 4)s[M] = s[M - Y], s[M + 1] = s[M + 1 - Y], s[M + 2] = s[M + 2 - Y], s[M + 3] = s[M + 3 - Y]; M = ie } } l.l = T, l.p = S, l.b = M, T && (y = 1, l.m = E, l.d = A, l.n = C) } while (!y); return M == s.length ? s : function (e, n, a) { (null == n || n < 0) && (n = 0), (null == a || a > e.length) && (a = e.length); var o = new (e instanceof i ? i : e instanceof r ? r : t)(a - n); return o.set(e.subarray(n, a)), o }(s, 0, M) }; return e.convert_streams = function (e) { var t = new DataView(e), i = 0; function r() { var e = t.getUint16(i); return i += 2, e } function n() { var e = t.getUint32(i); return i += 4, e } function a(e) { y.setUint16(v, e), v += 2 } function o(e) { y.setUint32(v, e), v += 4 } for (var s = { signature: n(), flavor: n(), length: n(), numTables: r(), reserved: r(), totalSfntSize: n(), majorVersion: r(), minorVersion: r(), metaOffset: n(), metaLength: n(), metaOrigLength: n(), privOffset: n(), privLength: n() }, l = 0; Math.pow(2, l) <= s.numTables;)l++; l--; for (var c = 16 * Math.pow(2, l), h = 16 * s.numTables - c, u = 12, d = [], p = 0; p < s.numTables; p++)d.push({ tag: n(), offset: n(), compLength: n(), origLength: n(), origChecksum: n() }), u += 16; var f, m = new Uint8Array(12 + 16 * d.length + d.reduce((function (e, t) { return e + t.origLength + 4 }), 0)), g = m.buffer, y = new DataView(g), v = 0; return o(s.flavor), a(s.numTables), a(c), a(l), a(h), d.forEach((function (e) { o(e.tag), o(e.origChecksum), o(u), o(e.origLength), e.outOffset = u, (u += e.origLength) % 4 != 0 && (u += 4 - u % 4) })), d.forEach((function (t) { var i, r = e.slice(t.offset, t.offset + t.compLength); if (t.compLength != t.origLength) { var n = new Uint8Array(t.origLength); i = new Uint8Array(r, 2), S(i, n) } else n = new Uint8Array(r); m.set(n, t.outOffset); var a = 0; (u = t.outOffset + t.origLength) % 4 != 0 && (a = 4 - u % 4), m.set(new Uint8Array(a).buffer, t.outOffset + t.origLength), f = u + a })), g.slice(0, f) }, e }({}).convert_streams } function parserFactory(e, t) { const i = { M: 2, L: 2, Q: 4, C: 6, Z: 0 }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }; let n; function a(e) { if (!n) { const e = { R: 2, L: 1, D: 4, C: 16, U: 32, T: 8 }; n = new Map; for (let t in r) { let i = 0; r[t].split(",").forEach((r => { let [a, o] = r.split("+"); a = parseInt(a, 36), o = o ? parseInt(o, 36) : 0, n.set(i += a, e[t]); for (let r = o; r--;)n.set(++i, e[t]) })) } } return n.get(e) || 32 } const o = [null, "isol", "init", "fina", "medi"]; function s(e) { const t = new Uint8Array(e.length); let i = 32, r = 1, n = -1; for (let o = 0; o < e.length; o++) { const s = e.codePointAt(o); let l = 0 | a(s), c = 1; 8 & l || (21 & i ? 22 & l ? (c = 3, 1 !== r && 3 !== r || t[n]++) : 33 & l && (2 !== r && 4 !== r || t[n]--) : 34 & i && (2 !== r && 4 !== r || t[n]--), r = t[o] = c, i = l, n = o, s > 65535 && o++) } return t } function l(t) { const r = Object.create(null), n = { unitsPerEm: t.head.unitsPerEm, ascender: t.hhea.ascender, descender: t.hhea.descender, forEachGlyph(a, l, c, h) { let u = 0; const d = 1 / n.unitsPerEm * l, p = function (t, i) { const r = []; for (let n = 0; n < i.length; n++) { const a = i.codePointAt(n); a > 65535 && n++, r.push(e.U.codeToGlyph(t, a)) } const n = t.GSUB; if (n) { const { lookupList: t, featureList: a } = n; let l; const c = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, h = []; a.forEach((n => { if (c.test(n.tag)) for (let a = 0; a < n.tab.length; a++) { if (h[n.tab[a]]) continue; h[n.tab[a]] = !0; const c = t[n.tab[a]], u = /^(isol|init|fina|medi)$/.test(n.tag); u && !l && (l = s(i)); for (let i = 0; i < r.length; i++)l && u && o[l[i]] !== n.tag || e.U._applySubs(r, i, c, t) } })) } return r }(t, a); let f = 0, m = -1; return p.forEach(((n, o) => { if (-1 !== n) { let a = r[n]; if (!a) { const { cmds: o, crds: s } = e.U.glyphToPath(t, n); let l, c, h, u; if (s.length) { l = c = 1 / 0, h = u = -1 / 0; for (let e = 0, t = s.length; e < t; e += 2) { let t = s[e], i = s[e + 1]; t < l && (l = t), i < c && (c = i), t > h && (h = t), i > u && (u = i) } } else l = h = c = u = 0; a = r[n] = { index: n, advanceWidth: t.hmtx.aWidth[n], xMin: l, yMin: c, xMax: h, yMax: u, pathCommandCount: o.length, forEachPathCommand(e) { let t = 0; const r = []; for (let n = 0, a = o.length; n < a; n++) { const a = i[o[n]]; r.length = 1 + a, r[0] = o[n]; for (let e = 1; e <= a; e++)r[e] = s[t++]; e.apply(null, r) } } } } -1 !== m && (u += e.U.getPairAdjustment(t, m, n) * d), h.call(null, a, u, f), a.advanceWidth && (u += a.advanceWidth * d), c && (u += c * l), m = n } f += a.codePointAt(f) > 65535 ? 2 : 1 })), u } }; return n } return function (i) { const r = new Uint8Array(i, 0, 4), n = e._bin.readASCII(r, 0, 4); if ("wOFF" === n) i = t(i); else if ("wOF2" === n) throw new Error("woff2 fonts not supported"); return l(e.parse(i)[0]) } } const workerModule = defineWorkerModule({ name: "Typr Font Parser", dependencies: [typrFactory, woff2otfFactory, parserFactory], init: (e, t, i) => i(e(), t()) }), CONFIG = { defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff", sdfGlyphSize: 64, sdfMargin: 1 / 16, sdfExponent: 9, textureWidth: 2048 }, tempColor = new Color$1, atlases = Object.create(null); function getTextRenderInfo(e, t) { if ((e = assign({}, e)).font = toAbsoluteURL(e.font || CONFIG.defaultFontURL), e.text = "" + e.text, e.sdfGlyphSize = e.sdfGlyphSize || CONFIG.sdfGlyphSize, null != e.colorRanges) { let t = {}; for (let i in e.colorRanges) if (e.colorRanges.hasOwnProperty(i)) { let r = e.colorRanges[i]; "number" != typeof r && (r = tempColor.set(r).getHex()), t[i] = r } e.colorRanges = t } Object.freeze(e); const { textureWidth: i, sdfExponent: r } = CONFIG, { sdfGlyphSize: n } = e; let a = `${e.font}@${n}`, o = atlases[a]; o || (o = atlases[a] = { sdfTexture: new DataTexture(new Uint8Array(n * i * 4), i, n, RGBAFormat, void 0, void 0, void 0, void 0, LinearFilter, LinearFilter) }, o.sdfTexture.font = e.font), processInWorker(e).then((i => { i.newGlyphSDFs && (i.newGlyphSDFs.forEach((({ textureData: e, atlasIndex: t }) => { const i = o.sdfTexture.image; for (; i.data.length < (t + 1) * n * n;) { const e = new Uint8Array(2 * i.data.length); e.set(i.data), i.data = e, i.height *= 2 } const r = Math.floor(t / 4), a = i.width / n, s = Math.floor(r / a) * i.width * n * 4 + r % a * n * 4 + t % 4; for (let t = 0; t < n; t++) { const r = t * n, a = s + t * i.width * 4; for (let t = 0; t < n; t++)i.data[a + 4 * t] = e[r + t] } })), o.sdfTexture.needsUpdate = !0), t(Object.freeze({ parameters: e, sdfTexture: o.sdfTexture, sdfGlyphSize: n, sdfExponent: r, glyphBounds: i.glyphBounds, glyphAtlasIndices: i.glyphAtlasIndices, glyphColors: i.glyphColors, caretPositions: i.caretPositions, caretHeight: i.caretHeight, chunkedBounds: i.chunkedBounds, ascender: i.ascender, descender: i.descender, lineHeight: i.lineHeight, topBaseline: i.topBaseline, blockBounds: i.blockBounds, visibleBounds: i.visibleBounds, timings: i.timings, get totalBounds() { return console.log("totalBounds deprecated, use blockBounds instead"), i.blockBounds }, get totalBlockSize() { console.log("totalBlockSize deprecated, use blockBounds instead"); const [e, t, r, n] = i.blockBounds; return [r - e, n - t] } })) })) } function assign(e, t) { for (let i in t) t.hasOwnProperty(i) && (e[i] = t[i]); return e } let linkEl; function toAbsoluteURL(e) { return linkEl || (linkEl = "undefined" == typeof document ? {} : document.createElement("a")), linkEl.href = e, linkEl.href } const fontProcessorWorkerModule = defineWorkerModule({ name: "FontProcessor", dependencies: [CONFIG, workerModule, createGlyphSegmentsIndex, createSDFGenerator, createFontProcessor, bidiFactory], init(e, t, i, r, n, a) { const { sdfExponent: o, sdfMargin: s, defaultFontURL: l } = e; return n(t, r(i, { sdfExponent: o, sdfMargin: s }), a(), { defaultFontURL: l }) } }), processInWorker = defineWorkerModule({ name: "TextBuilder", dependencies: [fontProcessorWorkerModule, ThenableWorkerModule], init: (e, t) => function (i) { const r = new t; return e.process(i, r.resolve), r }, getTransferables(e) { const t = [e.glyphBounds.buffer, e.glyphAtlasIndices.buffer]; return e.caretPositions && t.push(e.caretPositions.buffer), e.newGlyphSDFs && e.newGlyphSDFs.forEach((e => { t.push(e.textureData.buffer) })), t } }), GlyphsGeometry = (() => { const e = {}; const t = "aTroikaGlyphIndex"; class i extends InstancedBufferGeometry { constructor() { super(), this.detail = 1, this.curveRadius = 0, this.groups = [{ start: 0, count: 1 / 0, materialIndex: 0 }, { start: 0, count: 1 / 0, materialIndex: 1 }], this.boundingSphere = new Sphere, this.boundingBox = new Box3 } computeBoundingSphere() { } computeBoundingBox() { } set detail(t) { if (t !== this._detail) { this._detail = t, ("number" != typeof t || t < 1) && (t = 1); let i = function (t) { let i = e[t]; return i || (i = e[t] = new PlaneGeometry(1, 1, t, t).translate(.5, .5, 0)), i }(t);["position", "normal", "uv"].forEach((e => { this.attributes[e] = i.attributes[e].clone() })), this.setIndex(i.getIndex().clone()) } } get detail() { return this._detail } set curveRadius(e) { e !== this._curveRadius && (this._curveRadius = e, this._updateBounds()) } get curveRadius() { return this._curveRadius } updateGlyphs(e, i, a, o, s) { r(this, "aTroikaGlyphBounds", e, 4), r(this, t, i, 1), r(this, "aTroikaGlyphColor", s, 3), this._blockBounds = a, this._chunkedBounds = o, n(this, i.length), this._updateBounds() } _updateBounds() { const e = this._blockBounds; if (e) { const { curveRadius: t, boundingBox: i } = this; if (t) { const { PI: r, floor: n, min: a, max: o, sin: s, cos: l } = Math, c = r / 2, h = 2 * r, u = Math.abs(t), d = e[0] / u, p = e[2] / u, f = n((d + c) / h) !== n((p + c) / h) ? -u : a(s(d) * u, s(p) * u), m = n((d - c) / h) !== n((p - c) / h) ? u : o(s(d) * u, s(p) * u), g = n((d + r) / h) !== n((p + r) / h) ? 2 * u : o(u - l(d) * u, u - l(p) * u); i.min.set(f, e[1], t < 0 ? -g : 0), i.max.set(m, e[3], t < 0 ? 0 : g) } else i.min.set(e[0], e[1], 0), i.max.set(e[2], e[3], 0); i.getBoundingSphere(this.boundingSphere) } } applyClipRect(e) { let i = this.getAttribute(t).count, r = this._chunkedBounds; if (r) for (let t = r.length; t--;) { i = r[t].end; let n = r[t].rect; if (n[1] < e.w && n[3] > e.y && n[0] < e.z && n[2] > e.x) break } n(this, i) } } function r(e, t, i, r) { const n = e.getAttribute(t); i ? n && n.array.length === i.length ? (n.array.set(i), n.needsUpdate = !0) : (e.setAttribute(t, new InstancedBufferAttribute(i, r)), delete e._maxInstanceCount, e.dispose()) : n && e.deleteAttribute(t) } function n(e, t) { e[e.hasOwnProperty("instanceCount") ? "instanceCount" : "maxInstancedCount"] = t } return i.prototype.setAttribute || (i.prototype.setAttribute = function (e, t) { return this.attributes[e] = t, this }), i })(), VERTEX_DEFS = "\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n", VERTEX_TRANSFORM = "\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n", FRAGMENT_DEFS = "\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaDistanceOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaOutlineOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of encoding in SDFGenerator.js\n  \n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  \n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  \n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n", FRAGMENT_TRANSFORM = "\nfloat aaDist = troikaGetAADist();\nfloat distance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(distance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  distance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n"; function createTextDerivedMaterial(e) { const t = createDerivedMaterial(e, { chained: !0, extensions: { derivatives: !0 }, uniforms: { uTroikaSDFTexture: { value: null }, uTroikaSDFTextureSize: { value: new Vector2 }, uTroikaSDFGlyphSize: { value: 0 }, uTroikaSDFExponent: { value: 0 }, uTroikaTotalBounds: { value: new Vector4(0, 0, 0, 0) }, uTroikaClipRect: { value: new Vector4(0, 0, 0, 0) }, uTroikaDistanceOffset: { value: 0 }, uTroikaOutlineOpacity: { value: 0 }, uTroikaFillOpacity: { value: 1 }, uTroikaPositionOffset: { value: new Vector2 }, uTroikaCurveRadius: { value: 0 }, uTroikaBlurRadius: { value: 0 }, uTroikaStrokeWidth: { value: 0 }, uTroikaStrokeColor: { value: new Color$1 }, uTroikaStrokeOpacity: { value: 1 }, uTroikaOrient: { value: new Matrix3 }, uTroikaUseGlyphColors: { value: !0 }, uTroikaSDFDebug: { value: !1 } }, vertexDefs: VERTEX_DEFS, vertexTransform: VERTEX_TRANSFORM, fragmentDefs: FRAGMENT_DEFS, fragmentColorTransform: FRAGMENT_TRANSFORM, customRewriter({ vertexShader: e, fragmentShader: t }) { let i = /\buniform\s+vec3\s+diffuse\b/; return i.test(t) && (t = t.replace(i, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), i.test(e) || (e = e.replace(voidMainRegExp, "uniform vec3 diffuse;\n$&\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\n"))), { vertexShader: e, fragmentShader: t } } }); return t.transparent = !0, Object.defineProperties(t, { isTroikaTextMaterial: { value: !0 }, shadowSide: { get() { return this.side }, set() { } } }), t } const Text = (() => { const e = new MeshBasicMaterial({ color: 16777215, side: DoubleSide, transparent: !0 }), t = 8421504, i = new Matrix4, r = new Vector3, n = new Vector3, a = [], o = new Vector3, s = "+x+y"; function l(e) { return Array.isArray(e) ? e[0] : e } let c = () => { const t = new Mesh(new PlaneGeometry(1, 1), e); return c = () => t, t }, h = () => { const t = new Mesh(new PlaneGeometry(1, 1, 32, 1), e); return h = () => t, t }; const u = { type: "syncstart" }, d = { type: "synccomplete" }, p = ["font", "fontSize", "letterSpacing", "lineHeight", "maxWidth", "overflowWrap", "text", "direction", "textAlign", "textIndent", "whiteSpace", "anchorX", "anchorY", "colorRanges", "sdfGlyphSize"], f = p.concat("material", "color", "depthOffset", "clipRect", "curveRadius", "orientation", "glyphGeometryDetail"); class m extends Mesh { constructor() { super(new GlyphsGeometry, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.fontSize = .1, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = t, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = s, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.debugSDF = !1 } sync(e) { this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(u), getTextRenderInfo({ text: this.text, font: this.font, fontSize: this.fontSize || .1, letterSpacing: this.letterSpacing || 0, lineHeight: this.lineHeight || "normal", maxWidth: this.maxWidth, direction: this.direction || "auto", textAlign: this.textAlign, textIndent: this.textIndent, whiteSpace: this.whiteSpace, overflowWrap: this.overflowWrap, anchorX: this.anchorX, anchorY: this.anchorY, colorRanges: this.colorRanges, includeCaretPositions: !0, sdfGlyphSize: this.sdfGlyphSize }, (t => { this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(t.glyphBounds, t.glyphAtlasIndices, t.blockBounds, t.chunkedBounds, t.glyphColors); const i = this._queuedSyncs; i && (this._queuedSyncs = null, this._needsSync = !0, this.sync((() => { i.forEach((e => e && e())) }))), this.dispatchEvent(d), e && e() })))) } onBeforeRender(e, t, i, r, n, a) { this.sync(), n.isTroikaTextMaterial && this._prepareForRender(n) } dispose() { this.geometry.dispose() } get textRenderInfo() { return this._textRenderInfo || null } get material() { let t = this._derivedMaterial; const i = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = e.clone()); if (t && t.baseMaterial === i || (t = this._derivedMaterial = createTextDerivedMaterial(i), i.addEventListener("dispose", (function e() { i.removeEventListener("dispose", e), t.dispose() }))), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) { let e = t._outlineMtl; return e || (e = t._outlineMtl = Object.create(t, { id: { value: t.id + .1 } }), e.isTextOutlineMaterial = !0, e.depthWrite = !1, e.map = null, t.addEventListener("dispose", (function i() { t.removeEventListener("dispose", i), e.dispose() }))), [e, t] } return t } set material(e) { e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e } get glyphGeometryDetail() { return this.geometry.detail } set glyphGeometryDetail(e) { this.geometry.detail = e } get curveRadius() { return this.geometry.curveRadius } set curveRadius(e) { this.geometry.curveRadius = e } get customDepthMaterial() { return l(this.material).getDepthMaterial() } get customDistanceMaterial() { return l(this.material).getDistanceMaterial() } _prepareForRender(e) { const a = e.isTextOutlineMaterial, l = e.uniforms, c = this.textRenderInfo; if (c) { const { sdfTexture: e, blockBounds: i } = c; l.uTroikaSDFTexture.value = e, l.uTroikaSDFTextureSize.value.set(e.image.width, e.image.height), l.uTroikaSDFGlyphSize.value = c.sdfGlyphSize, l.uTroikaSDFExponent.value = c.sdfExponent, l.uTroikaTotalBounds.value.fromArray(i), l.uTroikaUseGlyphColors.value = !a && !!c.glyphColors; let r, n, o, s = 0, h = 0, u = 0, d = 0, p = 0; if (a) { let { outlineWidth: e, outlineOffsetX: t, outlineOffsetY: i, outlineBlur: n, outlineOpacity: a } = this; s = this._parsePercent(e) || 0, h = Math.max(0, this._parsePercent(n) || 0), r = a, d = this._parsePercent(t) || 0, p = this._parsePercent(i) || 0 } else u = Math.max(0, this._parsePercent(this.strokeWidth) || 0), u && (o = this.strokeColor, l.uTroikaStrokeColor.value.set(null == o ? t : o), n = this.strokeOpacity, null == n && (n = 1)), r = this.fillOpacity; l.uTroikaDistanceOffset.value = s, l.uTroikaPositionOffset.value.set(d, p), l.uTroikaBlurRadius.value = h, l.uTroikaStrokeWidth.value = u, l.uTroikaStrokeOpacity.value = n, l.uTroikaFillOpacity.value = null == r ? 1 : r, l.uTroikaCurveRadius.value = this.curveRadius || 0; let f = this.clipRect; if (f && Array.isArray(f) && 4 === f.length) l.uTroikaClipRect.value.fromArray(f); else { const e = 100 * (this.fontSize || .1); l.uTroikaClipRect.value.set(i[0] - e, i[1] - e, i[2] + e, i[3] + e) } this.geometry.applyClipRect(l.uTroikaClipRect.value) } l.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0; const h = a ? this.outlineColor || 0 : this.color; if (null == h) delete e.color; else { const t = e.hasOwnProperty("color") ? e.color : e.color = new Color$1; h === t._input && "object" != typeof h || t.set(t._input = h) } let u = this.orientation || s; if (u !== e._orientation) { let t = l.uTroikaOrient.value; u = u.replace(/[^-+xyz]/g, ""); let a = u !== s && u.match(/^([-+])([xyz])([-+])([xyz])$/); if (a) { let [, e, s, l, c] = a; r.set(0, 0, 0)[s] = "-" === e ? 1 : -1, n.set(0, 0, 0)[c] = "-" === l ? -1 : 1, i.lookAt(o, r.cross(n), n), t.setFromMatrix4(i) } else t.identity(); e._orientation = u } } _parsePercent(e) { if ("string" == typeof e) { let t = e.match(/^(-?[\d.]+)%$/), i = t ? parseFloat(t[1]) : NaN; e = (isNaN(i) ? 0 : i / 100) * this.fontSize } return e } localPositionToTextCoords(e, t = new Vector2) { t.copy(e); const i = this.curveRadius; return i && (t.x = Math.atan2(e.x, Math.abs(i) - Math.abs(e.z)) * Math.abs(i)), t } worldPositionToTextCoords(e, t = new Vector2) { return r.copy(e), this.localPositionToTextCoords(this.worldToLocal(r), t) } raycast(e, t) { const { textRenderInfo: i, curveRadius: r } = this; if (i) { const n = i.blockBounds, o = r ? h() : c(), s = o.geometry, { position: l, uv: u } = s.attributes; for (let e = 0; e < u.count; e++) { let t = n[0] + u.getX(e) * (n[2] - n[0]); const i = n[1] + u.getY(e) * (n[3] - n[1]); let a = 0; r && (a = r - Math.cos(t / r) * r, t = Math.sin(t / r) * r), l.setXYZ(e, t, i, a) } s.boundingSphere = this.geometry.boundingSphere, s.boundingBox = this.geometry.boundingBox, o.matrixWorld = this.matrixWorld, o.material.side = this.material.side, a.length = 0, o.raycast(e, a); for (let e = 0; e < a.length; e++)a[e].object = this, t.push(a[e]) } } copy(e) { const t = this.geometry; return super.copy(e), this.geometry = t, f.forEach((t => { this[t] = e[t] })), this } clone() { return (new this.constructor).copy(this) } } p.forEach((e => { const t = "_private_" + e; Object.defineProperty(m.prototype, e, { get() { return this[t] }, set(e) { e !== this[t] && (this[t] = e, this._needsSync = !0) } }) })); let g = !1; return Object.defineProperty(m.prototype, "anchor", { get() { return this._deprecated_anchor }, set(e) { this._deprecated_anchor = e, g || (console.warn("TextMesh: `anchor` has been deprecated; use `anchorX` and `anchorY` instead."), g = !0), Array.isArray(e) ? (this.anchorX = 100 * (+e[0] || 0) + "%", this.anchorY = 100 * (+e[1] || 0) + "%") : this.anchorX = this.anchorY = 0 } }), m })(); class AreaGeometry extends BufferGeometry { constructor(e = [], t = 1, i = 1, r = !1, n) { super(), this.type = "AreaGeometry", this.faceType = n, this.parameters = { points: e, height: t, steps: i, openEnded: r }; const a = this; i = Math.floor(i); const o = e.length; let s = [0], l = 0; this.min = { x: 1 / 0, y: 1 / 0 }, this.max = { x: -1 / 0, y: -1 / 0 }; for (let t = 1; t < e.length; t++) { e[t].x > this.max.x && (this.max.x = e[t].x), e[t].x < this.min.x && (this.min.x = e[t].x), e[t].y > this.max.y && (this.max.y = e[t].y), e[t].y < this.min.y && (this.min.y = e[t].y); let i = Math.sqrt((e[t].x - e[t - 1].x) * (e[t].x - e[t - 1].x) + (e[t].y - e[t - 1].y) * (e[t].y - e[t - 1].y)); l += i, s.push(l) } if (this.max.x === this.min.x || this.max.y === this.min.y) return; this.center = { x: (this.max.x - this.min.x) / 2 + this.min.x, y: (this.max.y - this.min.y) / 2 + this.min.y }, this.sideWallSegments = l / t; const c = [], h = [], u = [], d = []; let p = 0; const f = []; let m = 0; !function () { const r = new Vector3, n = new Vector3; let g = 0; for (let a = 0; a <= i; a++) { const c = [], m = a / i; for (let i = 0; i < o; i++)n.x = e[i].x, n.y = m * t, n.z = -e[i].y, h.push(n.x, n.y, n.z), r.set(n.x, 0, n.z).normalize(), u.push(r.x, r.y, r.z), d.push(s[i] / l, 1 - m), c.push(p++); f.push(c) } for (let e = 0; e < o; e++)for (let t = 0; t < i; t++) { const i = f[t][e], r = f[t + 1][e], n = f[t + 1][e + 1], a = f[t][e + 1]; c.push(i, r, a), c.push(r, n, a), g += 6 } a.addGroup(m, g, 0), m += g }(); const g = []; let y = new Shape; y.setFromPoints(e); const v = y.extractPoints(12); let _ = v.shape; const b = v.holes; if (!ShapeUtils.isClockWise(_)) { _ = _.reverse(); for (let e = 0, t = b.length; e < t; e++) { const t = b[e]; ShapeUtils.isClockWise(t) && (b[e] = t.reverse()) } } const x = ShapeUtils.triangulateShape(_, b); for (let e = 0, t = b.length; e < t; e++) { const t = b[e]; _ = _.concat(t) } const w = _.length, S = x.length; for (let e = 0; e < w; e++) { const i = _[e]; M(i.x, i.y, t) } for (let e = 0; e < w; e++) { const t = _[e]; M(t.x, t.y, 0) } function M(e, t, i) { g.push(e), g.push(t), g.push(i) } function T(e, t, i) { A(e), A(t), A(i) } function A(e) { h.push(g[3 * e + 0]), h.push(g[3 * e + 2]), h.push(-g[3 * e + 1]), u.push(0, g[3 * e + 2] > 0 ? 1 : -1, 0); let t = new Vector2; var i; t.x = (g[3 * e + 0] - a.min.x) / (a.max.x - a.min.x), t.y = (g[3 * e + 1] - a.min.y) / (a.max.y - a.min.y), i = t, d.push(i.x), d.push(i.y), c.push(p), p++ } !function (e) { if (0 === e) return; const t = p; let i = !1; if (1 === e || 2 === e) { i = !0; for (let e = 0; e < S; e++) { const t = x[e]; T(t[0], t[1], t[2]) } a.addGroup(3 * t, p - t, 1) } if (-1 === e || 2 === e) { const e = 2 * t + p; for (let e = 0; e < S; e++) { const t = x[e]; T(t[2] + w, t[1] + w, t[0] + w) } a.addGroup(e, p - e + 2 * t, i ? 2 : 1) } }(this.faceType), this.setIndex(c), this.setAttribute("position", new Float32BufferAttribute(h, 3)), this.setAttribute("normal", new Float32BufferAttribute(u, 3)), this.setAttribute("uv", new Float32BufferAttribute(d, 2)) } } class AnimatedSprite extends Sprite { constructor(e, t = {}) { if (!e || !e.map) return void console.warn("AnimatedSprite 必须在构造时提供材质和基本帖图。"); super(e); let i = t.dimension instanceof Array ? t.dimension : [1, 1], r = "number" == typeof t.duration ? t.duration : 1; this.loop = !!t.loop, this.destroyOnFinish = !!t.destroyOnFinish, e.map.wrapS = RepeatWrapping, e.map.wrapT = RepeatWrapping, e.map.repeat.set(1 / i[0], 1 / i[1]), e.map.offset.set(0, 1 - 1 / i[1]); let n = e.opacity, a = !1, o = i[0] * i[1], s = r / o, l = 0, c = 1; this.fadeInFrame = "number" == typeof t.fadeInFrame ? Math.floor(t.fadeInFrame) : -1, this.fadeOutFrame = "number" == typeof t.fadeOutFrame ? Math.floor(t.fadeOutFrame) : -1, this.needsRemove = !1, this.play = () => { this.material.map.offset.set(0, 1 - 1 / i[1]), this.material.opacity = n, a = !0 }, this.stop = () => { a = !1 }, this.update = e => { if (a && (l += e = e || 1 / 60, l >= s)) { if (c++, l = 0, c > o && (c = 1, !this.loop)) return a = !1, void (this.destroyOnFinish && (this.needsRemove = !0)); this.material.opacity = n, this.fadeInFrame > 0 && c < this.fadeInFrame && (this.material.transparent = !0, this.material.opacity = n * (c / this.fadeInFrame + 1)), this.fadeOutFrame > 0 && c > this.fadeOutFrame && (this.material.transparent = !0, this.material.opacity = n * (o - c) / (o - this.fadeOutFrame + 1)); let e = (c - 1) % i[0] / i[0], t = Math.floor((o - c) / i[0]) / i[1]; this.material.map.offset.set(e, t) } }, this.dispose = () => { this.material.map.dispose(), this.material.dispose(), this.parent && this.parent.remove(this) } } get isPlaying() { return _isPlaying } get dimension() { return _dimension } set dimension(e) { e instanceof Array && e.length >= 2 && (_dimension = e, _frameCount = _dimension[0] * _dimension[1], _frameDuration = _duration / _frameCount, this.material.map.repeat.set(1 / _dimension[0], 1 / _dimension[1]), this.material.map.offset.set(0, 1 - 1 / _dimension[1])) } get duration() { return _duration } set duration(e) { "number" == typeof e && (_duration = e, _frameDuration = _duration / _frameCount) } } class coreUtil { static createText(e, t) { var i; if (null != t) { var r = t.canvas, n = new CanvasTexture(r), a = new SpriteMaterial({ map: n, color: 16777215, fog: DRAWABLE_FOG, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, sizeAttenuation: t.sizeAttenuation }); return (i = new Sprite(a)).onBeforeRender = function () { this.userData.inView = !0 }, i.scale.set(t.width, t.height, 1), i.center = new Vector2(t.offsetV, t.offsetH), i.visible = t.enableText, e ? e.add(i) : _context.objectStore.add(i), i } } static createText_Billboard(e, t) { var i; if (null != t) { var r = t.canvas, n = new CanvasTexture(r), a = new SpriteMaterial({ map: n, color: 16777215, fog: DRAWABLE_FOG, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, sizeAttenuation: t.sizeAttenuation }); if ((i = new Sprite(a)).onBeforeRender = function () { this.userData.inView = !0 }, i.scale.set(t.sizeAttenuation ? .045 * t.canvas.width : 405e-6 * t.canvas.width, t.sizeAttenuation ? .045 * t.canvas.height : 405e-6 * t.canvas.height, 1), "left" === t.labelAlignment) { let r = e.children[1].material.map.image.width, a = r / e.children[1].scale.x, o = n.image.width; r = r / a * (o / i.scale.x); let s = r / 1.8 / o * -1; i.center.set(s, t.offsetH) } else i.center.set(t.offsetV, t.offsetH); return i.visible = t.enableText, e ? e.add(i) : _context.objectStore.add(i), i } } } class ModelsPartial { setModelMaterial(e, t) { if (!e.texture) return void (t && t({ result: 0, message: `失败，纹理文件参数 ${e.texture} 错误。` })); const i = _context.defaultObjectTree.getItemByName(e.id); if (!i) return void (t && t({ result: 0, message: `失败，模型 ${e.id} 不存在。` })); const r = i.findNode(e.nodeId); if (!r) return void (t && t({ result: 0, message: `失败，模型节点 ${e.nodeId} 不存在。` })); const n = _context.textureStore.find(e.texture); if (n) { const e = new Texture$1(n.textureSource); if (e.name = n.name, e.encoding = 3001, e.flipY = !1, e.format = 1022, e.version = 10, Array.isArray(r.material)) for (const t of r.material) t.map = e, t.needsUpdate = !0; else r.material.map = e, r.material.needsUpdate = !0; t && t({ result: 1, message: "成功。" }) } else _context.cacheStore.load({ path: e.texture, type: "texture", onLoad: i => { if (i) { if (Array.isArray(r.material)) for (const e of r.material) e.map = i; else r.material.map = i; t && t({ result: 1, message: "成功。" }) } else t && t({ result: 0, message: `失败，纹理文件 ${e.texture} 获取失败。` }) } }) } highlightModel(e, t = !0) { const i = _context.defaultObjectTree.getItemByName(e); return !!i && (_context.effectStore.highlightObject(i.getGroup(), t), !0) } cancleHighlightModel(e) { const t = _context.defaultObjectTree.getItemByName(e); return !!t && (_context.effectStore.cancleHighlightObject(t.getGroup()), !0) } setModelTransform2(e, t) { let i = _context.scene.models.getObjectByName(e.id); if (!i) return void (t && t({ result: 0, message: `失败，模型 ${e.id} 不存在。` })); let r = _context.animationStore.findNodeAnimation(i, ModelTransformAnimationController.type); r && _context.animationStore.remove(r), r = new ModelTransformAnimationController(i, e), _context.animationStore.add(r), t && t({ result: 1, message: "成功。" }) } setModelStyle(e, { scale: t, isVisible: i, xRay: r, alpha: n, maskType: a, maskAlpha: o, maskColor: s, maskPicture: l, maskPictureScale: c, maskFlowSpeed: h, maskFlowDirection: u }) { let d = _context.defaultObjectTree.getItemByName(e); if (!d) return; let p, f = d.getGroup(); if (f) { if ("none" === a && f.traverse((e => { if (!e.isMesh) return; if (null == e.userData.material) return; let t = _context.animationStore.findMaterialAnimation(e.material, UVAnimationController.type); t && _context.animationStore.remove(t), e.material.dispose(), e.material = e.userData.material, e.userData.material = void 0 })), "color" === a && (f.traverse((e => { e.isMesh && (void 0 === e.userData.material && (e.userData.material = e.material), e.material = new MeshLambertMaterial({ color: s })) })), p = o), "picture" === a) { let e = `texture/path/${l.toLowerCase()}.jpg`; f.traverse((t => { if (!t.isMesh) return; if (void 0 !== t.userData.defaultStyle) return; if (null != t.userData.material) { let e = _context.animationStore.findMaterialAnimation(t.material, UVAnimationController.type); e && _context.animationStore.remove(e), t.material.map && t.material.map.dispose(), t.material.dispose() } null == t.userData.material && (t.userData.material = t.material); let i = _context.loaders.textureLoader.load(util$1.url(_context.instance.resourceBasePath, e)); if (t.material = new MeshLambertMaterial({ map: i, alphaMap: i }), i.wrapS = RepeatWrapping, i.wrapT = RepeatWrapping, void 0 !== c && (i.repeat.x = c, i.repeat.y = c), null != h) { t.material.map.wrapS = RepeatWrapping, t.material.map.wrapT = RepeatWrapping; let e = MathUtils.degToRad(u), i = h * Math.cos(e), r = h * Math.sin(e); i = Math.round(100 * i) / 100, r = Math.round(100 * r) / 100; let n = 0 !== i, a = 0 !== r, o = _context.animationStore.findMaterialAnimation(t.material, UVAnimationController.type); if (o) o.enableU = n, o.enableV = a, o.uSpeed = i, o.vSpeed = r; else { let e = new UVAnimationController(t.material, n, a, i, r); _context.animationStore.add(e) } } })), p = o } void 0 !== t && f.scale.setScalar(t), void 0 !== r && f.traverse((e => { if (e.isMesh) if (e.material instanceof Array) for (const t of e.material) t.depthTest = "off" === r; else e.material.depthTest = "off" === r })), void 0 === n && void 0 === p || (void 0 === n && (n = 1), void 0 === p && (p = 1), p *= n, f.traverse((e => { if (e.isMesh && !e.isWater) if (e.material instanceof Array) for (const t of e.material) t.opacity = p, t.transparent = p < 1; else e.material.opacity = p, e.material.transparent = p < 1 }))), null != i && (f.visible = !!i) } } setModelArticulation(e, t) { if (!e) return void (t && t({ result: 0, message: "参数错误" })); let i = _context.instance.defaultObjectTree.getItemByName(e.id); i ? (e.data && e.data.forEach((r => { let n = i.articulations.find((e => e._name == r.articulation)); if (n) { let t; switch (r.type) { case "float": t = Number(r.value); break; case "enum": t = r.value; break; case "bool": t = Boolean(r.value) }n.set(t, e.duration) } else t && t({ result: 0, message: `找不到名称为${r.articulation}的模型关节！` }) })), t && t({ result: 1, message: "成功" })) : t && t({ result: 0, message: `找不到名称为${e.id}的模型！` }) } selectModel(e, t) { e && _context.selectControl.startSelect({ type: e.type, modelType: e.modelType, selectType: "select", events: t }) } endSelectModel(e) { e && _context.selectControl.endSelect(e) } pickModel(e, t) { e && _context.selectControl.startSelect({ type: e.type, modelType: e.modelType, selectType: "pick", events: t }) } endPickModel(e) { e && _context.selectControl.endSelect(e) } clickModel(e, t, i) { if (!e) return; let r = "model" === e.modelType ? "ModelItem" : "BuildingItem", n = _context.scene.models.children.find((t => t.name === e.id)); if (n) { if ((_context.defaultObjectTree.findItemByObject3D(n) || {}).getType() === r) { if (!0 === n.visible) { e.selected ? _context.effectStore.highlightObject(n, !1) : _context.effectStore.cancleHighlightObject(n); let r = { type: e.modelType, id: n.name, selected: e.selected }; i && i(r), t && t({ result: 1, message: "成功。" }) } } else t && t({ result: 0, message: "模型id和模型类型不匹配！" }) } else t && t({ result: 0, message: `模型${id}不存在！` }) } clickModelType(e, t) { if (!e) return; let i = "model" === e.modelType ? "ModelItem" : "BuildingItem", r = []; _context.scene.models.children.forEach((t => { (_context.defaultObjectTree.findItemByObject3D(t) || {}).getType() === i && !0 === t.visible && (r.push(t), e.selected ? _context.effectStore.highlightObject(t, !0) : _context.effectStore.highlightObject()) })); let n = { type: e.modelType, selected: e.selected, data: r.map((e => ({ id: e.name }))) }; t && t(n) } clearModelSelected(e) { _context.effectStore.highlightObject() } highlightBuilding(e, t) { if (!e) return void (t && t({ result: 0, message: "参数错误" })); let i = _context.instance.defaultObjectTree.getItemByName(e.id); i ? ("none" === e.type ? _context.effectStore.highlightObject() : _context.effectStore.highlightObject(i.getGroup(), !1), t && t({ result: 1, message: "成功" })) : t && t({ result: 0, message: `建筑${e.id}不存在` }) } highlightFloor(e, t) { if (!e) return void (t && t({ result: 0, message: "参数错误" })); let i, r = _context.instance.defaultObjectTree.getItemByName(e.id); r ? "BuildingItem" === (_context.instance.defaultObjectTree.findItemByObject3D(r.getGroup()) || {}).getType() ? (r.children.forEach((t => { t.level === Number(e.floor) && (i = t) })), i ? ("none" === e.type ? _context.effectStore.highlightObject() : this.highlightNode(r.name, i.name, !1), t && t({ result: 1, message: "成功" })) : t && t({ result: 0, message: `楼层号${e.floor}不存在` })) : t && t({ result: 0, message: "指定的对象非建筑" }) : t && t({ result: 0, message: `建筑${e.id}不存在` }) } highlightRoom(e, t) { e ? t && t({ result: 0, message: "底层实现中..." }) : t && t({ result: 0, message: "参数错误" }) } getBuildings(e, t) { let i = { result: 1, message: "成功", buildings: [] }; _context.scene.models.children.forEach((e => { if ("BuildingItem" === (_context.defaultObjectTree.findItemByObject3D(e) || {}).getType()) { let t = _context.instance.defaultObjectTree.getItemByName(e.name), r = { id: e.name, floors: [] }; t.children.forEach((e => { e.level && r.floors.push({ num: e.level, rooms: [] }) })), i.buildings.push(r) } })), t && t(i) } highlightNode(e, t, i) { if (!_context.scene) return void logger.debug("_context.scene 为空"); if (!e) return _context.effectStore.highlightObject(void 0), !1; if (!_context.instance.defaultObjectTree.getItemByName(e)) return; let r = _context.instance.defaultObjectTree.getItemByName(e).getGroup(); if (null == t) return r ? (_context.effectStore.highlightObject(r, i), !0) : (_context.effectStore.highlightObject(void 0), !1); if (r && r instanceof Object3D) { let e; if (r.traverse((function (i) { i.name === t && (e = i) })), e) return _context.effectStore.highlightObject(e, i), !0 } } setModelRotationState(e) { e && _context.scene.models.traverse((t => { if (t.name === e.id) { let i = _context.animationStore.findNodeAnimation(t, NodeRotationAnimationController.type); i && ("stop" == e.state ? (i.reset(), _context.animationStore.remove(i)) : "pause" == e.state ? i.pause() : "continue" == e.state && i.resume()) } })) } blinkingModel(e) { if (e) for (let t = 0; t < _context.scene.models.children.length; t++) { const i = _context.scene.models.children[t]; if (i.name === e.id) { let t = _context.animationStore.findNodeAnimation(i, NodeBlinkingAnimationController.type); t && (t.reset(), _context.animationStore.remove(t)), t = new NodeBlinkingAnimationController(i, e.duration, e.color, e.type), _context.animationStore.add(t); break } } } setModelBlinkState(e) { e && _context.scene.models.traverse((t => { if (t.name === e.id) { let i = _context.animationStore.findNodeAnimation(t, NodeBlinkingAnimationController.type); i && ("stop" == e.state ? (i.reset(), _context.animationStore.remove(i)) : "pause" == e.state ? i.pause() : "continue" == e.state && i.resume()) } })) } movingModel(e) { e && _context.scene.models.traverse((t => { if (t.name === e.id) { let i = _context.animationStore.findNodeAnimation(t, NodeMovingAnimationController.type); i && (i.reset(), _context.animationStore.remove(i)), !e.points || e.points[0].speed && 0 != e.points[0].speed ? e.points.splice(0, 0, { x: t.position.x, y: t.position.y, z: t.position.z }) : (t.position.x = e.points[0].x, t.position.y = e.points[0].y, t.position.z = e.points[0].z), i = new NodeMovingAnimationController(t, e.loopMode, e.reverse, e.direction, e.points, e.offset), _context.animationStore.add(i) } })) } setModelMoveState(e) { e && _context.scene.models.traverse((t => { if (t.name === e.id) { let i = _context.animationStore.findNodeAnimation(t, NodeMovingAnimationController.type); i && ("stop" == e.state ? (i.reset(), _context.animationStore.remove(i)) : "pause" == e.state ? i.pause() : "continue" == e.state && i.resume()) } })) } pathingModel(e) { e && (e.points.forEach((t => { t.speed = e.speed })), _context.scene.models.traverse((t => { if (t.name === e.id) { let i = _context.animationStore.findNodeAnimation(t, NodeMovingAnimationController.type); i && (i.reset(), _context.animationStore.remove(i)), i = new NodeMovingAnimationController(t, e.loopMode, e.reverse, e.direction, e.points, e.offset, e.pathId, e.passChange), _context.animationStore.add(i) } }))) } updatePathingModel(e, t, i) { _context.animationStore.findAnimationByPathId(e, NodeMovingAnimationController.type).forEach((r => { r.reset(); let n = r.points[0].speed; t.forEach((e => { e.speed = n })); let a = new NodeMovingAnimationController(r.animationObject, r.loopMode, r.reverse, r.direction, t, r.offset, e, i); _context.animationStore.add(a), _context.animationStore.remove(r) })) } deletePathingModel(e) { _context.animationStore.findAnimationByPathId(e, NodeMovingAnimationController.type).forEach((e => { e.reset(), _context.animationStore.remove(e) })) } setModelPathingState(e) { e && _context.scene.models.traverse((t => { if (t.name === e.id) { let i = _context.animationStore.findNodeAnimation(t, NodeMovingAnimationController.type); i && ("stop" == e.state ? (i.reset(), _context.animationStore.remove(i), e.passChange && e.passChange({ id: i.pathId, pass: 0, ratio: 0 })) : "pause" == e.state ? i.pause() : "continue" == e.state && i.resume()) } })) } getModelArticulation(e, t) { if (!e) return void (t && t({ result: 0, message: "参数错误" })); let i = _context.instance.defaultObjectTree.getItemByName(e.id); if (!i) return void (t && t({ result: 0, message: `找不到名称为${e.id}的模型！` })); let r = []; i.articulations.forEach((e => { let t = {}; switch (t.articulation = e.name, t.currentValue = e.value, e.type) { case "numeric": t.type = "float", t.minValue = Math.min(...e._values), t.maxValue = Math.max(...e._values); break; case "boolean": t.type = "bool"; break; case "enum": t.type = "enum", t.value = [...e._values]; break; case "text": t.type = "string" }r.push(t) })), t && t({ result: 1, message: "成功", id: e.id, data: r }) } getModelAnimation(e, t) { if (!e) return void (t && t({ result: 0, message: "参数错误" })); let i = _context.instance.defaultObjectTree.getItemByName(e.id); if (!i) return void (t && t({ result: 0, message: `找不到名称为${e.id}的模型！` })); let r = []; i.articulationAnimations.forEach((e => { let t = {}; t.name = e.animationName, t.speed = e.animationSpeed, t.rerverserType = e.animationType; let n = _context.animationStore.findAnimation(i.name + e.animationName, ArticulationAnimationGroupController.type); n ? n.getIsPaused() ? t.state = "pause" : t.state = "playing" : t.state = "stop", r.push(t) })), r.length <= 0 ? t && t({ result: 0, message: "失败，模型没有动画。" }) : t && t({ result: 1, message: "成功", id: e.id, data: r }) } playModelAnimation(e, t) { if (!e) return void (t && t({ result: 0, message: "参数错误" })); let i = _context.instance.defaultObjectTree.getItemByName(e.id); if (!i) return void (t && t({ result: 0, message: `找不到名称为${e.id}的模型！` })); let r = i.articulationAnimations.find((t => t.animationName === e.name)); if (r) { switch (e.state.toLocaleLowerCase()) { case "begin": i.playArticulationAnimation(r.animationName); break; case "pause": i.pauseArticulationAnimation(r.animationName); break; case "restart": i.resumeArticulationAnimation(r.animationName); break; case "stop": i.resetArticulationAnimation(r.animationName) }t && t({ result: 1, message: "成功" }) } else t && t({ result: 0, message: `找不到名称为${e.id}的模型动画！` }) } setModelAnimation(e, t) { if (!e) return void (t && t({ result: 0, message: "参数错误" })); let i = _context.instance.defaultObjectTree.getItemByName(e.id); if (!i) return void (t && t({ result: 0, message: `找不到名称为${e.id}的模型！` })); let r = i.articulationAnimations.find((t => t.animationName === e.name)); r ? Number(e.speed) <= 0 || !["none", "round", "repeat"].includes(e.rerverserType.toLowerCase()) ? t && t({ result: 0, message: "参数异常!" }) : (r.animationSpeed = Number(e.speed), r.animationType = e.rerverserType, t && t({ result: 1, message: "成功" })) : t && t({ result: 0, message: `找不到名称为${e.id}的模型动画！` }) } addModelForApi(e, t) { let i, r = !1; if (_context.instance.defaultObjectTree.children.forEach((t => { t.name === e.id && (r = !0), t.name === e.modelType && (i = t) })), r) return void (t && t({ result: 0, message: `模型${e.id}已经存在！` })); if (!i) return void (t && t({ result: 0, message: `模型${e.modelType}不存在！` })); if (i.formApi) return void (t && t({ result: 0, message: `模型${e.modelType}非可添加类型！` })); e.opacity = "number" == typeof e.alpha && e.alpha >= 0 && e.alpha <= 1 ? e.alpha : 1; let n = _context.scene.models.children.find((t => t.name == e.modelType)); n || t && t({ result: 1, message: `添加失败,未找到modelType为${e.modelType}的模型` }); let a = n.clone(); a.name = e.id, a.position.setScalar(0), a.visible = !0, a.activeVisible = !0, a.rotation.set(MathUtils.degToRad(e.rotation.x), MathUtils.degToRad(e.rotation.y), MathUtils.degToRad(e.rotation.z)), a.scale.set(e.scale.x, e.scale.y, e.scale.z), a.traverse((t => { if ("Mesh" == t.type) if (t.geometry = t.geometry.clone(), t.material instanceof Array) { t.material = t.material.map((e => e.clone())); for (let i of t.material) i.opacity = e.opacity, i.transparent = e.opacity < 1 } else t.material = t.material.clone(), t.material.opacity = e.opacity, t.material.transparent = e.opacity < 1 })); const o = new Group; if (o.name = e.id, o.position.set(e.position.x, e.position.y, e.position.z), o.visible = "" == (e.visible ?? "") || e.visible, o.activeVisible = o.visible, o.add(a), e.titleText) { let t = new Group; t.name = e.id + "title"; const i = e.titileAutoScale ? .045 * e.canvas.width : 414e-6 * e.canvas.width, r = e.titileAutoScale ? .045 * e.canvas.height : 414e-6 * e.canvas.height; let n = coreUtil.createText(t, { canvas: e.canvas, sizeAttenuation: !!e.titileAutoScale, width: i, height: r, offsetV: .5, offsetH: 0, enableText: !0 }); n.name = e.id; const s = new Box3; a.traverse((function (t) { t.name = e.id, t.geometry && (null === t.geometry.boundingBox && t.geometry.computeBoundingBox(), s.expandByPoint(t.geometry.boundingBox.min), s.expandByPoint(t.geometry.boundingBox.max)) })), n.position.y = s.max.y * e.scale.y, o.add(t) } _context.scene.models.add(o); let s = util$1.cloneDeep(i.getSettings()); if (s.name = e.id, s.loadModel = o, "ModelItem" == i.type) { const e = new ModelItem(s); _context.instance.defaultObjectTree.addItem(e), util$1.setArticulation(s, e) } if ("IconAsset" == i.type && new IconItem(s, null), "GroupItem" == i.type) { let e = new GroupItem(s); s.children.forEach((t => { switch (t.type) { case "IconAsset": new IconItem(t, e); break; case "ModelAsset": let i = { name: t.name, gltf: { scene: s.loadModel }, transform: t.transform, points: t.points, matrix: t.matrix }, r = e.children.find((e => e.name === i.name)); r ? r.addInstanceIsMatrix(i.matrix) : e.childrenAdd(new InstancedObject(i, e)) } })) } "BuildingItem" == i.type && _context.instance.defaultObjectTree.addBuilding(s), _context.instance.defaultObjectTree.children.find((t => t.name === e.id)).formApi = !0, t && t({ result: 1, message: "成功。" }) } removeModelForApi(e, t) { let i = _context.instance.defaultObjectTree.children.find((t => t.name === e.id)); if (!i) return void (t && t({ result: 0, message: `模型${e.id}不存在！` })); if (!i.formApi) return void (t && t({ result: 0, message: "非接口添加不能删除！" })); _context.instance.defaultObjectTree.removeItem(e.id); let r = _context.scene.models.children.find((t => t.name == e.modelType)); r && util$1.disposeThreeObject(r), t && t({ result: 1, message: "成功。" }) } } var ModelsPartial$1 = new ModelsPartial; function modelLandmarkUtil(e, t, i) { function r(e) { return new Promise((function (t) { _context.loaders.textureLoader.load(e, (function (e) { t(e) })) })) } function n(e) { e.traverse((function (e) { !0 === e.isMesh && !0 === e.isSprite && (e.geometry.dispose(), Array.isArray(e.material) ? e.material.forEach((function (e) { e.dispose(), e.map && e.map.dispose() })) : (e.material.dispose(), e.material.map && e.material.map.dispose())); const t = _context.animationStore.findAnimation(e.uuid, DistanceController); t && _context.animationStore.remove(t) })) } function a(e, t) { e.traverse((function (e) { if (!0 === e.isMesh || !0 === e.isSprite) { if (!Array.isArray(e.material)) return void 0 === e.userData.transparent && (e.userData.transparent = e.material.transparent), void (t < 1 ? (e.material.transparent = !0, e.material.opacity = t) : (e.material.transparent = e.userData.transparent, e.material.opacity = t)); if (void 0 === e.userData.transparent) { e.userData.transparent = {}; for (const t of e.material) e.userData.transparent[t.uuid] = t.transparent } if (t < 1) for (const i of e.material) i.transparent = !0, i.opacity = t; else for (const i of e.material) i.transparent = e.userData.transparent[i.uuid], i.opacity = t } })) } function o() { const { modelType: i } = t, r = _context.defaultObjectTree.getItemByName(i).getGroup().clone(); r.name = e, r.position.setScalar(0), r.userData.modelType = i; const { rotation: n } = t, a = MathUtils.degToRad(n.x), o = MathUtils.degToRad(n.y), s = MathUtils.degToRad(n.z); r.rotation.set(a, o, s); const { modelMaxDistance: l } = t; return r.enableAutoHidebyDistance = !0, r.minDistance = 0, r.maxDistance = l * _context.worldScale, _context.animationStore.addDistance(r.uuid, DistanceController, _context.camera, r), r } async function s() { const { iconAssetName: i } = t, r = _context.sceneSettings.objectTree.children.find((e => "IconAsset" === e.type && e.name === i)), n = JSON.parse(JSON.stringify(r)); n.transform.position.x = 0, n.transform.position.y = 0, n.transform.position.z = 0; const { labelText: a, labelColor: o, labelBackground: s } = t; n.textParam.enableText = !!a, n.textParam.text = a, n.textParam.color = o, n.textParam.background = s; const l = new Group, c = await function (e, t) { return new Promise((function (i) { new IconItem(e, t, (function (e, t) { i(t) })) })) }(n, l), h = l.children[0]; h.name = e, h.userData.iconItem = c; for (const t of h.children) t.onBeforeRender = function () { this.userData.inView = !0 }, t.name = e; const { modelMaxDistance: u, iconMaxDistance: d } = t; return h.enableAutoHidebyDistance = !0, h.minDistance = u * _context.worldScale, h.maxDistance = d * _context.worldScale, _context.animationStore.addDistance(h.uuid, DistanceController, _context.camera, h), h } async function l() { const i = new Group; i.name = e; const { iconBackground: n } = t; if (n) { const a = "texture/iconBackground/" + n + ".png", o = util$1.url(_context.instance.resourceBasePath, a), s = await r(o), { iconBackgroundColor: l, sizeAttenuation: c, polygonOffset: h, polygonOffsetFactor: u, polygonOffsetUnits: d } = t, p = new SpriteMaterial({ alphaTest: .1, transparent: !0, fog: DRAWABLE_FOG, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, map: s, color: new Color$1(l), sizeAttenuation: c, polygonOffset: h, polygonOffsetFactor: u, polygonOffsetUnits: d }); if ("rgba" === l.substring(0, 4)) { let e = l.slice(4); e = e.split(","), e = parseFloat(e[3].replace(/[^0-9.]/gi, "")), p.opacity = e } const f = new Sprite(p); f.name = e, f.onBeforeRender = function () { this.userData.inView = !0 }; const { iconWidth: m, iconHeight: g } = t, y = c ? m / 30 : m / 3e3, v = c ? g / 30 : g / 3e3; f.scale.set(y, v, 1); const { iconXOffset: _, iconYOffset: b, factor: x = -.1 } = t, w = _ / 30 * x + .5, S = b / 30 * x + .5; f.center = new Vector2(w, S), f.userData.iconBackground = n, i.add(f) } else i.add(new Group); const { iconPath: a } = t, o = await r(a), { sizeAttenuation: s, polygonOffset: l, polygonOffsetFactor: c, polygonOffsetUnits: h } = t, u = new SpriteMaterial({ alphaTest: .1, depthWrite: !1, transparent: !0, color: new Color$1("#ffffff"), fog: DRAWABLE_FOG, depthTest: _context.drawableDepthTest, map: o, sizeAttenuation: s, polygonOffset: l, polygonOffsetFactor: c, polygonOffsetUnits: h }), d = new Sprite(u); d.name = e, d.onBeforeRender = function () { this.userData.inView = !0 }; const { iconWidth: p, iconHeight: f } = t, m = s ? p / 50 : p / 5e3, g = s ? f / 50 : f / 5e3; d.scale.set(m, g, 1); const { iconXOffset: y, iconYOffset: v } = t; d.center.set(y, v), d.userData.iconPath = a, i.add(d); const { enableLabel: _ } = t; if (_) { const { labelCanvas: r, labelAlignment: n, labelXOffset: a, labelYOffset: o } = t, l = { enableText: _, canvas: r, sizeAttenuation: s, labelAlignment: n, offsetV: a, offsetH: o }; coreUtil.createText_Billboard(i, l).name = e } else i.add(new Group); const { modelMaxDistance: b, iconMaxDistance: x } = t; return i.enableAutoHidebyDistance = !0, i.minDistance = b * _context.worldScale, i.maxDistance = x * _context.worldScale, _context.animationStore.addDistance(i.uuid, DistanceController, _context.camera, i), i } async function c(i) { const { useIconAsset: a } = t; !0 === a ? void 0 !== i.userData.iconItem ? i = function (i) { const { iconAssetName: r } = t, n = _context.sceneSettings.objectTree.children.find((e => "IconAsset" === e.type && e.name === r)), a = JSON.parse(JSON.stringify(n)); a.transform.position.x = 0, a.transform.position.y = 0, a.transform.position.z = 0; const { labelText: o, labelColor: s, labelBackground: l } = t; a.textParam.enableText = !!o, a.textParam.text = o, a.textParam.color = s, a.textParam.background = l, i.userData.iconItem.update(a, void 0, !1), i.name = e; for (const t of i.children) t.onBeforeRender = function () { this.userData.inView = !0 }, t.name = e; const { modelMaxDistance: c, iconMaxDistance: h } = t; return i.minDistance = c * _context.worldScale, i.maxDistance = h * _context.worldScale, i }(i) : (n(i), (i = await s()).enableAutoHidebyDistance = !0, i.minDistance = 0, _context.animationStore.addDistance(i.uuid, DistanceController, _context.camera, i)) : void 0 === i.userData.iconItem ? i = await async function (i) { let a = i.children[0], o = i.children[1], s = i.children[2]; const { iconBackground: l } = t; if (l) { if (!0 !== a.isSprite) { const t = new SpriteMaterial({ alphaTest: .1, transparent: !0, fog: DRAWABLE_FOG }); a = new Sprite(t), a.name = e } if (a.userData.iconBackground !== l) { const e = "texture/iconBackground/" + l + ".png", t = util$1.url(_context.instance.resourceBasePath, e), i = await r(t); a.material.map.dispose(), a.material.map = i } a.material.depthWrite = _context.drawableDepthTest, a.material.depthTest = _context.drawableDepthTest; const { iconBackgroundColor: i, sizeAttenuation: n, polygonOffset: o, polygonOffsetFactor: s, polygonOffsetUnits: c } = t; if (a.material.color = new Color$1(i), a.material.sizeAttenuation = n, a.material.polygonOffset = o, a.material.polygonOffsetFactor = s, a.material.polygonOffsetUnits = c, "rgba" === i.substring(0, 4)) { let e = i.slice(4); e = e.split(","), e = parseFloat(e[3].replace(/[^0-9.]/gi, "")), a.material.opacity = e } const { iconWidth: h, iconHeight: u } = t, d = n ? h / 30 : h / 3e3, p = n ? u / 30 : u / 3e3; a.scale.set(d, p, 1); const { iconXOffset: f, iconYOffset: m, factor: g = -.1 } = t, y = f / 30 * g + .5, v = m / 30 * g + .5; a.center = new Vector2(y, v) } else n(a), a = new Group; const { iconPath: c } = t; if (o.userData.iconPath !== c) { const e = await r(c); o.material.map.dispose(), o.material.map = e } o.material.depthTest = _context.drawableDepthTest; const { sizeAttenuation: h, polygonOffset: u, polygonOffsetFactor: d, polygonOffsetUnits: p } = t; o.material.sizeAttenuation = h, o.material.polygonOffset = u, o.material.polygonOffsetFactor = d, o.material.polygonOffsetUnits = p; const { iconWidth: f, iconHeight: m } = t, g = h ? f / 50 : f / 5e3, y = h ? m / 50 : m / 5e3; o.scale.set(g, y, 1); const { iconXOffset: v, iconYOffset: _ } = t; o.center.set(v, _); const { enableLabel: b } = t; if (n(s), b) { const { labelCanvas: i, labelAlignment: r, labelXOffset: n, labelYOffset: a } = t, l = { enableText: b, canvas: i, sizeAttenuation: h, labelAlignment: r, offsetV: n, offsetH: a }, c = new Group; c.children[1] = o, s = coreUtil.createText_Billboard(c, l), s.name = e } else s = new Group; i.clear(), i.add(a), i.add(o), i.add(s); const { modelMaxDistance: x, iconMaxDistance: w } = t; return i.minDistance = x * _context.worldScale, i.maxDistance = w * _context.worldScale, i }(i) : (n(i), (i = await l()).enableAutoHidebyDistance = !0, i.minDistance = 0, _context.animationStore.addDistance(i.uuid, DistanceController, _context.camera, i)); const { iconMaxDistance: o } = t; return i.maxDistance = o * _context.worldScale, i } return { create: async function () { const r = function () { _context.objectStore.remove(e); const i = new Group; i.name = e; const { renderOrder: r, scale: n } = t; i.renderOrder = DRAWABLE_RENDER_ORDER_BASE + r, i.scale.setScalar(n); const { isShow: a } = t; i.visible = !!a, i.activeVisible = !!a; const { enableAutoHidebyDistance: o, minDistance: s, maxDistance: l } = t; i.enableAutoHidebyDistance = !!o, i.minDistance = s * _context.worldScale, i.maxDistance = l * _context.worldScale, _context.animationStore.addDistance(i.uuid, DistanceController, _context.camera, i); let { position: c } = t; return i.position.set(c.x, c.y, c.z), _context.datumShiftModel && "ecef" === _context.datumShiftModel.type && (i.rotation.order = "YXZ", i.rotation.y = (c.lon + 90) / 180 * Math.PI, i.rotation.x = (90 - c.lat) / 180 * Math.PI), i }(), n = o(), c = await async function () { let e = null; const { useIconAsset: i } = t; e = !0 === i ? await s() : await l(); const { modelMaxDistance: r, iconMaxDistance: n } = t; return e.enableAutoHidebyDistance = !0, e.minDistance = r * _context.worldScale, e.maxDistance = n * _context.worldScale, _context.animationStore.addDistance(e.uuid, DistanceController, _context.camera, e), e }(); r.add(n), r.add(c); const { alpha: h } = t; a(r, h), _context.objectStore.add(e, r), i && i(1) }, update: async function () { const r = _context.objectStore.find(e); if (void 0 === r) return void (i && i(0)); !function (e) { const { renderOrder: i, scale: r } = t; e.renderOrder = DRAWABLE_RENDER_ORDER_BASE + i, e.scale.setScalar(r); const { isShow: n } = t; e.visible = !!n, e.activeVisible = !!n; const { enableAutoHidebyDistance: a, minDistance: o, maxDistance: s } = t; e.enableAutoHidebyDistance = !!a, e.minDistance = o * _context.worldScale, e.maxDistance = s * _context.worldScale; let { position: l } = t; e.position.set(l.x, l.y, l.z) }(r); const s = function (e) { const { modelType: i } = t; if (e.userData.modelType !== i) n(e), e = o(); else { const { rotation: i } = t, r = MathUtils.degToRad(i.x), n = MathUtils.degToRad(i.y), a = MathUtils.degToRad(i.z); e.rotation.set(r, n, a); const { modelMaxDistance: o } = t; e.maxDistance = o * _context.worldScale } return e }(r.children[0]), l = await c(r.children[1]); r.clear(), r.add(s), r.add(l); const { alpha: h } = t; a(r, h), i && i(1) } } } class ModelLandmark { addModelLandmark(e, t, i) { modelLandmarkUtil(...arguments).create() } updateModelLandmark(e, t, i) { modelLandmarkUtil(...arguments).update() } setModelLandmarkHighlight(e, t) { const i = _context.objectStore.find(e); if (void 0 === i) return void (callback && callback(0)); const r = i.children[1]; if (!1 === t) { if (_context.effectStore.cancleHighlightObject(i.children[0]), void 0 !== r.children[3]) { let e = r.children[3]; e.material.map.dispose(), e.material.dispose(), e.geometry.dispose(), r.remove(e) } } else if (_context.effectStore.highlightObject(i.children[0], !0), void 0 === r.children[3]) { const t = "texture/ui/highlight-landmark.png", i = r.children[1], n = _context.loaders.textureLoader.load(util$1.url(_context.instance.resourceBasePath, t)), a = new SpriteMaterial({ map: n, color: 16777215, fog: !1, sizeAttenuation: i.material.sizeAttenuation, polygonOffset: !0, polygonOffsetFactor: 1, polygonOffsetUnits: -3e4, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest }), o = new Sprite(a); o.name = e + "_selector", o.position.set(i.position.x, i.position.y, i.position.z), o.scale.set(.02304 / r.scale.x, .02304 / r.scale.y, 1), o.center = new Vector2(.5, .5), r.add(o) } } } var ModelLandmark$1 = new ModelLandmark; function modelTrailUtil(e, t, i) { function r(e) { return new Promise((function (t) { _context.loaders.textureLoader.load(e, (function (e) { t(e) })) })) } function n(e) { e.traverse((function (e) { !0 === e.isMesh && !0 === e.isSprite && (e.geometry.dispose(), Array.isArray(e.material) ? e.material.forEach((function (e) { e.dispose(), e.map && e.map.dispose() })) : (e.material.dispose(), e.material.map && e.material.map.dispose())); const t = _context.animationStore.findAnimation(e.uuid, DistanceController); t && _context.animationStore.remove(t) })) } function a() { const { modelType: i } = t, r = _context.defaultObjectTree.getItemByName(i).getGroup().clone(); r.position.setScalar(0), r.userData.modelType = i, r.traverse((function (t) { t.onBeforeRender = function () { this.userData.inView = !0 }, t.name = e })); const { rotation: n } = t, a = MathUtils.degToRad(n.x), o = MathUtils.degToRad(n.y), s = MathUtils.degToRad(n.z); r.rotation.set(a, o, s); const { modelMaxDistance: l } = t; return r.enableAutoHidebyDistance = !0, r.minDistance = 0, r.maxDistance = l * _context.worldScale, _context.animationStore.addDistance(r.uuid, DistanceController, _context.camera, r), r } async function o() { const { iconAssetName: i } = t, r = _context.sceneSettings.objectTree.children.find((e => "IconAsset" === e.type && e.name === i)), n = JSON.parse(JSON.stringify(r)); n.transform.position.x = 0, n.transform.position.y = 0, n.transform.position.z = 0; const { labelText: a, labelColor: o, labelBackground: s } = t; n.textParam.enableText = !!a, n.textParam.text = a, n.textParam.color = o, n.textParam.background = s; const l = new Group, c = await function (e, t) { return new Promise((function (i) { new IconItem(e, t, (function (e, t) { i(t) })) })) }(n, l), h = l.children[0]; h.name = e, h.userData.iconItem = c; for (const t of h.children) t.onBeforeRender = function () { this.userData.inView = !0 }, t.name = e; const { modelMaxDistance: u, iconMaxDistance: d } = t; return h.enableAutoHidebyDistance = !0, h.minDistance = u * _context.worldScale, h.maxDistance = d * _context.worldScale, _context.animationStore.addDistance(h.uuid, DistanceController, _context.camera, h), h } async function s() { const i = new Group; i.name = e; const { iconBackground: n } = t; if (n) { const a = "texture/iconBackground/" + n + ".png", o = util$1.url(_context.instance.resourceBasePath, a), s = await r(o), { iconBackgroundColor: l, sizeAttenuation: c, polygonOffset: h, polygonOffsetFactor: u, polygonOffsetUnits: d } = t, p = new SpriteMaterial({ alphaTest: .1, transparent: !0, fog: DRAWABLE_FOG, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, map: s, color: new Color$1(l), sizeAttenuation: c, polygonOffset: h, polygonOffsetFactor: u, polygonOffsetUnits: d }); if ("rgba" === l.substring(0, 4)) { let e = l.slice(4); e = e.split(","), e = parseFloat(e[3].replace(/[^0-9.]/gi, "")), p.opacity = e } const f = new Sprite(p); f.name = e, f.onBeforeRender = function () { this.userData.inView = !0 }; const { iconWidth: m, iconHeight: g } = t, y = c ? m / 30 : m / 3e3, v = c ? g / 30 : g / 3e3; f.scale.set(y, v, 1); const { iconXOffset: _, iconYOffset: b, factor: x = -.1 } = t, w = _ / 30 * x + .5, S = b / 30 * x + .5; f.center = new Vector2(w, S), f.userData.iconBackground = n, i.add(f) } else i.add(new Group); const { iconPath: a } = t, o = await r(a), { sizeAttenuation: s, polygonOffset: l, polygonOffsetFactor: c, polygonOffsetUnits: h } = t, u = new SpriteMaterial({ alphaTest: .1, depthWrite: !1, transparent: !0, color: new Color$1("#ffffff"), fog: DRAWABLE_FOG, depthTest: _context.drawableDepthTest, map: o, sizeAttenuation: s, polygonOffset: l, polygonOffsetFactor: c, polygonOffsetUnits: h }), d = new Sprite(u); d.name = e, d.onBeforeRender = function () { this.userData.inView = !0 }; const { iconWidth: p, iconHeight: f } = t, m = s ? p / 50 : p / 5e3, g = s ? f / 50 : f / 5e3; d.scale.set(m, g, 1); const { iconXOffset: y, iconYOffset: v } = t; d.center.set(y, v), d.userData.iconPath = a, i.add(d); const { enableLabel: _ } = t; if (_) { const { labelCanvas: r, labelAlignment: n, labelXOffset: a, labelYOffset: o } = t, l = { enableText: _, canvas: r, sizeAttenuation: s, labelAlignment: n, offsetV: a, offsetH: o }; coreUtil.createText_Billboard(i, l).name = e } else i.add(new Group); const { modelMaxDistance: b, iconMaxDistance: x } = t; return i.enableAutoHidebyDistance = !0, i.minDistance = b * _context.worldScale, i.maxDistance = x * _context.worldScale, _context.animationStore.addDistance(i.uuid, DistanceController, _context.camera, i), i } async function l(i) { const { useIconAsset: a } = t; if (!0 === a) { if (void 0 !== i.userData.iconItem) return i = function (i) { const { iconAssetName: r } = t, n = _context.sceneSettings.objectTree.children.find((e => "IconAsset" === e.type && e.name === r)), a = JSON.parse(JSON.stringify(n)); a.transform.position.x = 0, a.transform.position.y = 0, a.transform.position.z = 0; const { labelText: o, labelColor: s, labelBackground: l } = t; a.textParam.enableText = !!o, a.textParam.text = o, a.textParam.color = s, a.textParam.background = l, i.userData.iconItem.update(a, void 0, !1), i.name = e; for (const t of i.children) t.onBeforeRender = function () { this.userData.inView = !0 }, t.name = e; const { modelMaxDistance: c, iconMaxDistance: h } = t; return i.minDistance = c * _context.worldScale, i.maxDistance = h * _context.worldScale, i }(i); n(i); return await o() } if (void 0 === i.userData.iconItem) return i = await async function (i) { let a = i.children[0], o = i.children[1], s = i.children[2]; const { iconBackground: l } = t; if (l) { if (!0 !== a.isSprite) { const t = new SpriteMaterial({ alphaTest: .1, transparent: !0, fog: DRAWABLE_FOG }); a = new Sprite(t), a.name = e } if (a.userData.iconBackground !== l) { const e = "texture/iconBackground/" + l + ".png", t = util$1.url(_context.instance.resourceBasePath, e), i = await r(t); a.material.map.dispose(), a.material.map = i } a.material.depthWrite = _context.drawableDepthTest, a.material.depthTest = _context.drawableDepthTest; const { iconBackgroundColor: i, sizeAttenuation: n, polygonOffset: o, polygonOffsetFactor: s, polygonOffsetUnits: c } = t; if (a.material.color = new Color$1(i), a.material.sizeAttenuation = n, a.material.polygonOffset = o, a.material.polygonOffsetFactor = s, a.material.polygonOffsetUnits = c, "rgba" === i.substring(0, 4)) { let e = i.slice(4); e = e.split(","), e = parseFloat(e[3].replace(/[^0-9.]/gi, "")), a.material.opacity = e } const { iconWidth: h, iconHeight: u } = t, d = n ? h / 30 : h / 3e3, p = n ? u / 30 : u / 3e3; a.scale.set(d, p, 1); const { iconXOffset: f, iconYOffset: m, factor: g = -.1 } = t, y = f / 30 * g + .5, v = m / 30 * g + .5; a.center = new Vector2(y, v) } else n(a), a = new Group; const { iconPath: c } = t; if (o.userData.iconPath !== c) { const e = await r(c); o.material.map.dispose(), o.material.map = e } o.material.depthTest = _context.drawableDepthTest; const { sizeAttenuation: h, polygonOffset: u, polygonOffsetFactor: d, polygonOffsetUnits: p } = t; o.material.sizeAttenuation = h, o.material.polygonOffset = u, o.material.polygonOffsetFactor = d, o.material.polygonOffsetUnits = p; const { iconWidth: f, iconHeight: m } = t, g = h ? f / 50 : f / 5e3, y = h ? m / 50 : m / 5e3; o.scale.set(g, y, 1); const { iconXOffset: v, iconYOffset: _ } = t; o.center.set(v, _); const { enableLabel: b } = t; if (n(s), b) { const { labelCanvas: i, labelAlignment: r, labelXOffset: n, labelYOffset: a } = t, l = { enableText: b, canvas: i, sizeAttenuation: h, labelAlignment: r, offsetV: n, offsetH: a }, c = new Group; c.children[1] = o, s = coreUtil.createText_Billboard(c, l), s.name = e } else s = new Group; i.clear(), i.add(a), i.add(o), i.add(s); const { modelMaxDistance: x, iconMaxDistance: w } = t; return i.minDistance = x * _context.worldScale, i.maxDistance = w * _context.worldScale, i }(i); n(i); return await s() } return { create: async function () { const n = function () { _context.objectStore.remove(e); const i = new Group; i.name = e; const { renderOrder: r, scale: n } = t; i.renderOrder = DRAWABLE_RENDER_ORDER_BASE + r, i.scale.setScalar(n); const { isShow: a } = t; i.visible = !!a, i.activeVisible = !!a; const { enableAutoHidebyDistance: o, minDistance: s, maxDistance: l } = t; i.enableAutoHidebyDistance = !!o, i.minDistance = s * _context.worldScale, i.maxDistance = l * _context.worldScale, _context.animationStore.addDistance(i.uuid, DistanceController, _context.camera, i); let { position: c } = t; return i.position.set(c.x, c.y, c.z), i }(), l = a(), c = await async function () { const { useIconAsset: e } = t; if (!0 === e) return await o(); return await s() }(); await async function (i) { const n = i.position; i.userData.startPos = n.clone(), i.userData.targetPos = n.clone(), _context.baseCarrierController.add(e, i); const a = util$1.url(_context.instance.resourceBasePath, "texture/trail/trail.png"), o = await r(a); o.wrapS = ClampToEdgeWrapping, o.wrapT = ClampToEdgeWrapping, o.repeat.set(1, 1); const { trailColor: s = "#ff0000", trackWidth: l } = t, c = new Vector2(window.innerWidth, window.innerHeight), h = new THREE_MeshLine.MeshLineMaterial({ fog: DRAWABLE_FOG, map: o, useMap: !0, color: new Color$1(s), opacity: 1, resolution: c, sizeAttenuation: 0, lineWidth: l * _context.worldScale, depthWrite: _context.drawableDepthTest, depthTest: !0, alphaTest: 0, transparent: !0, side: DoubleSide, repeat: new Vector2(1, 1), dashArray: 0, dashOffset: 1, dashRatio: 0 }), u = new THREE_MeshLine$1.MeshLine; u.setPoints([n.x, n.y, n.z]); const d = new Mesh(u, h); d.onBeforeRender = function () { this.userData.inView = !0 }; const { iconMaxDistance: p } = t; d.enableAutoHidebyDistance = !0, d.minDistance = 0, d.maxDistance = p * _context.worldScale, _context.animationStore.addDistance(e + "Line", DistanceController, _context.camera, d); const { duration: f, trackDuration: m } = t; i.userData.mesh = d, i.userData.currentTime = 0, i.userData.duration = f, i.userData.trailDuration = m; let g = _context.animationStore.findLayerAnimation(e, TrailAnimationController.type); g && _context.animationStore.remove(g); const y = new TrailController(i); g = new TrailAnimationController(_context.baseCarrierController, y, e), _context.animationStore.add(g), _context.objectStore.add(e + "Line", d) }(n), n.add(l), n.add(c), _context.objectStore.add(e, n), i && i(1) }, update: async function () { const r = _context.objectStore.find(e); if (void 0 === r) return void (i && i(0)); !function (e) { const { renderOrder: i, scale: r } = t; e.renderOrder = DRAWABLE_RENDER_ORDER_BASE + i, e.scale.setScalar(r); const { isShow: n } = t; e.visible = !!n, e.activeVisible = !!n; const { enableAutoHidebyDistance: a, minDistance: o, maxDistance: s } = t; e.enableAutoHidebyDistance = !!a, e.minDistance = o * _context.worldScale, e.maxDistance = s * _context.worldScale }(r); const o = function (e) { const { modelType: i } = t; if (e.userData.modelType !== i) n(e), e = a(); else { const { rotation: i } = t, r = MathUtils.degToRad(i.x), n = MathUtils.degToRad(i.y), a = MathUtils.degToRad(i.z); e.rotation.set(r, n, a); const { modelMaxDistance: o } = t; e.maxDistance = o * _context.worldScale } return e }(r.children[0]), s = await l(r.children[1]); !async function (e) { e.userData.currentTime = 0, e.userData.startPos = e.position.clone(); let { position: i } = t; e.userData.targetPos = i; const { duration: r, trackDuration: n } = t; e.userData.duration = r, e.userData.trailDuration = n; const { trailColor: a = "#ff0000", trackWidth: o } = t; e.userData.mesh.material.lineWidth = o, e.userData.mesh.material.color = new Color$1(a); const { iconMaxDistance: s } = t; e.userData.mesh.maxDistance = s * _context.worldScale, e.userData.moveComplete = !1 }(r), r.clear(), r.add(o), r.add(s), i && i(1) } } } class ModelTrail { addModelTrail(e, t, i) { modelTrailUtil(...arguments).create() } updateModelTrail(e, t, i) { modelTrailUtil(...arguments).update() } setModelTrailHighlight(e, t) { const i = _context.objectStore.find(e); if (void 0 === i) return void (callback && callback(0)); const r = i.children[1]; if (!1 === t) { if (_context.effectStore.cancleHighlightObject(i.children[0]), void 0 !== r.children[3]) { let e = r.children[3]; e.material.map.dispose(), e.material.dispose(), e.geometry.dispose(), r.remove(e) } } else if (_context.effectStore.highlightObject(i.children[0], !0), void 0 === r.children[3]) { const t = "texture/ui/highlight-landmark.png", i = r.children[1], n = _context.loaders.textureLoader.load(util$1.url(_context.instance.resourceBasePath, t)), a = new SpriteMaterial({ map: n, color: 16777215, fog: !1, sizeAttenuation: i.material.sizeAttenuation, polygonOffset: !0, polygonOffsetFactor: 1, polygonOffsetUnits: -3e4, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest }), o = new Sprite(a); o.name = e + "_selector", o.position.set(i.position.x, i.position.y, i.position.z), o.scale.set(.02304 / r.scale.x, .02304 / r.scale.y, 1), o.center = new Vector2(.5, .5), r.add(o) } } } var ModelTrail$1 = new ModelTrail; function markerLandmarkUtil(e, t, i) { function r(e) { return new Promise((function (t) { _context.loaders.textureLoader.load(e, (function (e) { t(e) })) })) } function n(e) { e.userData.marker && e.userData.marker.destroy(), util$1.disposeThreeObject(e) } function a(e, t) { e.traverse((function (e) { if (!0 === e.isMesh || !0 === e.isSprite) { if (!Array.isArray(e.material)) return void 0 === e.userData.transparent && (e.userData.transparent = e.material.transparent), void (t < 1 ? (e.material.transparent = !0, e.material.opacity = t) : (e.material.transparent = e.userData.transparent, e.material.opacity = t)); if (void 0 === e.userData.transparent) { e.userData.transparent = {}; for (const t of e.material) e.userData.transparent[t.uuid] = t.transparent } if (t < 1) for (const i of e.material) i.transparent = !0, i.opacity = t; else for (const i of e.material) i.transparent = e.userData.transparent[i.uuid], i.opacity = t } })) } function o() { const { asset: i, labelCanvas: r, enableLabel: n } = t; return i.color = i.color || "#ffffff", i.position = i.position || [0, 0, 0], i.size = "number" == typeof i.size && i.size >= 0 ? i.size : 100, i.opacity = "number" == typeof i.opacity && i.opacity >= 0 && i.opacity <= 1 ? i.opacity : 1, new Promise(((a, o) => { (new Group).name = i.name; let s = new MarkerItem; s.load(i, ((o, l) => { const { scale: c } = t; l.children[0].scale.setScalar(c); let h = new Group; if (h.name = i.name + "title", l.add(h), r && n) { let e = coreUtil.createText(h, { canvas: r, sizeAttenuation: !1, width: 414e-6 * r.width, height: 414e-6 * r.height, offsetV: .5, offsetH: .5, enableText: !0 }); e.name = i.name, e.position.y = i.titleHeight * c } l.visible = !0, l.activeVisible = !0, l.position.setScalar(0), l.userData.modelType = i.name; const { rotation: u } = t, d = MathUtils.degToRad(u.x), p = MathUtils.degToRad(u.y), f = MathUtils.degToRad(u.z); l.rotation.set(d, p, f); const { modelMaxDistance: m } = t; l.enableAutoHidebyDistance = !0, l.minDistance = 0, l.maxDistance = m * _context.worldScale, _context.animationStore.addDistance(l.uuid, DistanceController, _context.camera, l); const g = []; l.traverse((function (t) { t.name = e, !0 === t.isMesh && (t.geometry.computeBoundingBox(), g.push(t.geometry.boundingBox.clone())) })); const y = g.reduce((function (e, t) { return e.min.x > t.min.x && (e.min.x = t.min.x), e.min.y > t.min.y && (e.min.y = t.min.y), e.min.z > t.min.z && (e.min.z = t.min.z), e.max.x < t.max.x && (e.max.x = t.max.x), e.max.y < t.max.y && (e.max.y = t.max.y), e.max.z < t.max.z && (e.max.z = t.max.z), e })); l.userData.boundingBox = y, l.userData.marker = s, a(l) })) })) } async function s() { const { iconAssetName: i } = t, r = _context.sceneSettings.objectTree.children.find((e => "IconAsset" === e.type && e.name === i)), n = JSON.parse(JSON.stringify(r)); n.transform.position.x = 0, n.transform.position.y = 0, n.transform.position.z = 0; const { labelText: a, labelColor: o, labelBackground: s } = t; n.textParam.enableText = !!a, n.textParam.text = a, n.textParam.color = o, n.textParam.background = s; const l = new Group, c = await function (e, t) { return new Promise((function (i) { new IconItem(e, t, (function (e, t) { i(t) })) })) }(n, l), h = l.children[0]; h.name = e, h.userData.iconItem = c; for (const t of h.children) t.onBeforeRender = function () { this.userData.inView = !0 }, t.name = e; const { modelMaxDistance: u, iconMaxDistance: d } = t; return h.enableAutoHidebyDistance = !0, h.minDistance = u * _context.worldScale, h.maxDistance = d * _context.worldScale, _context.animationStore.addDistance(h.uuid, DistanceController, _context.camera, h), h } async function l() { const i = new Group; i.name = e; const { iconBackground: n } = t; if (n) { const a = "texture/iconBackground/" + n + ".png", o = util$1.url(_context.instance.resourceBasePath, a), s = await r(o), { iconBackgroundColor: l, sizeAttenuation: c, polygonOffset: h, polygonOffsetFactor: u, polygonOffsetUnits: d } = t, p = new SpriteMaterial({ alphaTest: .1, transparent: !0, fog: DRAWABLE_FOG, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, map: s, color: new Color$1(l), sizeAttenuation: c, polygonOffset: h, polygonOffsetFactor: u, polygonOffsetUnits: d }); if ("rgba" === l.substring(0, 4)) { let e = l.slice(4); e = e.split(","), e = parseFloat(e[3].replace(/[^0-9.]/gi, "")), p.opacity = e } const f = new Sprite(p); f.name = e, f.onBeforeRender = function () { this.userData.inView = !0 }; const { iconWidth: m, iconHeight: g } = t, y = c ? m / 30 : m / 3e3, v = c ? g / 30 : g / 3e3; f.scale.set(y, v, 1); const { iconXOffset: _, iconYOffset: b, factor: x = -.1 } = t, w = _ / 30 * x + .5, S = b / 30 * x + .5; f.center = new Vector2(w, S), f.userData.iconBackground = n, i.add(f) } else i.add(new Group); const { iconPath: a } = t, o = await r(a), { sizeAttenuation: s, polygonOffset: l, polygonOffsetFactor: c, polygonOffsetUnits: h } = t, u = new SpriteMaterial({ alphaTest: .1, depthWrite: !1, transparent: !0, color: new Color$1("#ffffff"), fog: DRAWABLE_FOG, depthTest: _context.drawableDepthTest, map: o, sizeAttenuation: s, polygonOffset: l, polygonOffsetFactor: c, polygonOffsetUnits: h }), d = new Sprite(u); d.name = e, d.onBeforeRender = function () { this.userData.inView = !0 }; const { iconWidth: p, iconHeight: f } = t, m = s ? p / 50 : p / 5e3, g = s ? f / 50 : f / 5e3; d.scale.set(m, g, 1); const { iconXOffset: y, iconYOffset: v } = t; d.center.set(y, v), d.userData.iconPath = a, i.add(d); const { enableLabel: _ } = t; if (_) { const { labelCanvas: r, labelAlignment: n, labelXOffset: a, labelYOffset: o } = t, l = { enableText: _, canvas: r, sizeAttenuation: s, labelAlignment: n, offsetV: a, offsetH: o }; coreUtil.createText_Billboard(i, l).name = e } else i.add(new Group); const { modelMaxDistance: b, iconMaxDistance: x } = t; return i.enableAutoHidebyDistance = !0, i.minDistance = b * _context.worldScale, i.maxDistance = x * _context.worldScale, _context.animationStore.addDistance(i.uuid, DistanceController, _context.camera, i), i } async function c(i) { const { useIconAsset: a } = t; return !0 === a ? void 0 !== i.userData.iconItem ? i = function (i) { const { iconAssetName: r } = t, n = _context.sceneSettings.objectTree.children.find((e => "IconAsset" === e.type && e.name === r)), a = JSON.parse(JSON.stringify(n)); a.transform.position.x = 0, a.transform.position.y = 0, a.transform.position.z = 0; const { labelText: o, labelColor: s, labelBackground: l } = t; a.textParam.enableText = !!o, a.textParam.text = o, a.textParam.color = s, a.textParam.background = l, i.userData.iconItem.update(a, void 0, !1), i.name = e; for (const t of i.children) t.onBeforeRender = function () { this.userData.inView = !0 }, t.name = e; const { modelMaxDistance: c, iconMaxDistance: h } = t; return i.minDistance = c * _context.worldScale, i.maxDistance = h * _context.worldScale, i }(i) : (n(i), (i = await s()).enableAutoHidebyDistance = !0, i.minDistance = 0, _context.animationStore.addDistance(i.uuid, DistanceController, _context.camera, i)) : void 0 === i.userData.iconItem ? i = await async function (i) { let a = i.children[0], o = i.children[1], s = i.children[2]; const { iconBackground: l } = t; if (l) { if (!0 !== a.isSprite) { const t = new SpriteMaterial({ alphaTest: .1, transparent: !0, fog: DRAWABLE_FOG }); a = new Sprite(t), a.name = e } if (a.userData.iconBackground !== l) { const e = "texture/iconBackground/" + l + ".png", t = util$1.url(_context.instance.resourceBasePath, e), i = await r(t); a.material.map.dispose(), a.material.map = i } a.material.depthWrite = _context.drawableDepthTest, a.material.depthTest = _context.drawableDepthTest; const { iconBackgroundColor: i, sizeAttenuation: n, polygonOffset: o, polygonOffsetFactor: s, polygonOffsetUnits: c } = t; if (a.material.color = new Color$1(i), a.material.sizeAttenuation = n, a.material.polygonOffset = o, a.material.polygonOffsetFactor = s, a.material.polygonOffsetUnits = c, "rgba" === i.substring(0, 4)) { let e = i.slice(4); e = e.split(","), e = parseFloat(e[3].replace(/[^0-9.]/gi, "")), a.material.opacity = e } const { iconWidth: h, iconHeight: u } = t, d = n ? h / 30 : h / 3e3, p = n ? u / 30 : u / 3e3; a.scale.set(d, p, 1); const { iconXOffset: f, iconYOffset: m, factor: g = -.1 } = t, y = f / 30 * g + .5, v = m / 30 * g + .5; a.center = new Vector2(y, v) } else n(a), a = new Group; const { iconPath: c } = t; if (o.userData.iconPath !== c) { const e = await r(c); o.material.map.dispose(), o.material.map = e } o.material.depthTest = _context.drawableDepthTest; const { sizeAttenuation: h, polygonOffset: u, polygonOffsetFactor: d, polygonOffsetUnits: p } = t; o.material.sizeAttenuation = h, o.material.polygonOffset = u, o.material.polygonOffsetFactor = d, o.material.polygonOffsetUnits = p; const { iconWidth: f, iconHeight: m } = t, g = h ? f / 50 : f / 5e3, y = h ? m / 50 : m / 5e3; o.scale.set(g, y, 1); const { iconXOffset: v, iconYOffset: _ } = t; o.center.set(v, _); const { enableLabel: b } = t; if (n(s), b) { const { labelCanvas: i, labelAlignment: r, labelXOffset: n, labelYOffset: a } = t, l = { enableText: b, canvas: i, sizeAttenuation: h, labelAlignment: r, offsetV: n, offsetH: a }, c = new Group; c.children[1] = o, s = coreUtil.createText_Billboard(c, l), s.name = e } else s = new Group; i.clear(), i.add(a), i.add(o), i.add(s); const { modelMaxDistance: x, iconMaxDistance: w } = t; return i.minDistance = x * _context.worldScale, i.maxDistance = w * _context.worldScale, i }(i) : (n(i), (i = await l()).enableAutoHidebyDistance = !0, i.minDistance = 0, _context.animationStore.addDistance(i.uuid, DistanceController, _context.camera, i)), i } return { create: async function () { const r = function () { _context.objectStore.remove(e); const i = new Group; i.name = e; const { renderOrder: r } = t; i.renderOrder = DRAWABLE_RENDER_ORDER_BASE + r; const { isShow: n } = t; i.visible = !!n, i.activeVisible = !!n; const { enableAutoHidebyDistance: a, minDistance: o, maxDistance: s } = t; i.enableAutoHidebyDistance = !!a, i.minDistance = o * _context.worldScale, i.maxDistance = s * _context.worldScale, _context.animationStore.addDistance(i.uuid, DistanceController, _context.camera, i); let { position: l } = t; return i.position.set(l.x, l.y, l.z), i }(), n = await o(), c = await async function () { let e = null; const { useIconAsset: i } = t; return e = !0 === i ? await s() : await l(), e }(); r.add(n), r.add(c); const h = n.userData.boundingBox; c.position.y = (h.max.y - h.min.y) * n.scale.y; const { alpha: u } = t; a(r, u), _context.objectStore.add(e, r), i && i(1) }, update: async function () { const r = _context.objectStore.find(e); if (void 0 === r) return void (i && i(0)); !function (e) { const { renderOrder: i } = t; e.renderOrder = DRAWABLE_RENDER_ORDER_BASE + i; const { isShow: r } = t; e.visible = !!r, e.activeVisible = !!r; const { enableAutoHidebyDistance: n, minDistance: a, maxDistance: o } = t; e.enableAutoHidebyDistance = !!n, e.minDistance = a * _context.worldScale, e.maxDistance = o * _context.worldScale; let { position: s } = t; e.position.set(s.x, s.y, s.z) }(r); const s = await async function (e) { n(e), e = await o(); const { rotation: i } = t, r = MathUtils.degToRad(i.x), a = MathUtils.degToRad(i.y), s = MathUtils.degToRad(i.z); e.rotation.set(r, a, s); const { modelMaxDistance: l } = t; return e.maxDistance = l * _context.worldScale, e }(r.children[0]), l = await c(r.children[1]); r.clear(), r.add(s), r.add(l); const h = s.userData.boundingBox; l.position.y = (h.max.y - h.min.y) * s.scale.y; const { alpha: u } = t; a(r, u), i && i(1) } } } class MarkerLandmark { addMarkerLandmark(e, t, i) { markerLandmarkUtil(...arguments).create() } updateMarkerLandmark(e, t, i) { markerLandmarkUtil(...arguments).update() } } var MarkerLandmark$1 = new MarkerLandmark; function trailUtil(e, t, i, r) { function n(e) { return new Promise((function (t) { _context.loaders.textureLoader.load(e, (function (e) { t(e) })) })) } function a(e) { e.traverse((function (e) { !0 === e.isMesh && !0 === e.isSprite && (e.geometry.dispose(), Array.isArray(e.material) ? e.material.forEach((function (e) { e.dispose(), e.map && e.map.dispose() })) : (e.material.dispose(), e.material.map && e.material.map.dispose())); const t = _context.animationStore.findAnimation(e.uuid, DistanceController); t && _context.animationStore.remove(t) })) } async function o() { const { iconAssetName: r } = t, n = _context.sceneSettings.objectTree.children.find((e => "IconAsset" === e.type && e.name === r)), a = JSON.parse(JSON.stringify(n)); a.transform.position.x = 0, a.transform.position.y = 0, a.transform.position.z = 0; const { enableText: o, labelText: s } = i; a.textParam.enableText = o, a.textParam.text = s; const l = new Group, c = await function (e, t) { return new Promise((function (i) { new IconItem(e, t, (function (e, t) { i(t) })) })) }(a, l), h = l.children[0]; h.userData.iconItem = c; for (const t of h.children) t.onBeforeRender = function () { this.userData.inView = !0 }, t.name = e; return h } async function s() { const r = new Group, { background: a } = t; if (a) { const i = "texture/iconBackground/" + a + ".png", o = util$1.url(_context.instance.resourceBasePath, i), s = await n(o), { backgroundColor: l, sizeAttenuation: c } = t, h = new SpriteMaterial({ alphaTest: .1, transparent: !0, fog: DRAWABLE_FOG, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, map: s, color: new Color$1(l), sizeAttenuation: c }); if ("rgba" === l.substring(0, 4)) { let e = l.slice(4); e = e.split(","), e = parseFloat(e[3].replace(/[^0-9.]/gi, "")), h.opacity = e } const u = new Sprite(h); u.name = e, u.onBeforeRender = function () { this.userData.inView = !0 }; const { width: d, height: p } = t, f = c ? d / 30 : d / 3e3, m = c ? p / 30 : p / 3e3; u.scale.set(f, m, 1); const { offsetV: g, offsetH: y, factor: v = -.1 } = t, _ = g / 30 * v + .5, b = y / 30 * v + .5; u.center = new Vector2(_, b), u.userData.background = a, r.add(u) } else r.add(new Group); const { path: o } = t, s = await n(o), { sizeAttenuation: l } = t, c = new SpriteMaterial({ alphaTest: .1, depthWrite: !1, transparent: !0, color: new Color$1("#ffffff"), fog: DRAWABLE_FOG, depthTest: _context.drawableDepthTest, map: s, sizeAttenuation: l }), h = new Sprite(c); h.name = e, h.onBeforeRender = function () { this.userData.inView = !0 }; const { width: u, height: d } = t, p = l ? u / 50 : u / 5e3, f = l ? d / 50 : d / 5e3; h.scale.set(p, f, 1); const { offsetV: m, offsetH: g } = t; h.center.set(m, g), h.userData.path = o, r.add(h); const { enableText: y } = i; if (y) { const { canvas: t, labelAlignment: n, offsetV: a, offsetH: o } = i, s = { enableText: y, canvas: t, sizeAttenuation: l, labelAlignment: n, offsetV: a, offsetH: o }; coreUtil.createText_Billboard(r, s).name = e } else r.add(new Group); return r } async function l(r) { const { useIconAsset: l } = t; if (!0 === l) { if (void 0 !== r.userData.iconItem) return r = function (r) { const { iconAssetName: n } = t, a = _context.sceneSettings.objectTree.children.find((e => "IconAsset" === e.type && e.name === n)), o = JSON.parse(JSON.stringify(a)); o.transform.position.x = 0, o.transform.position.y = 0, o.transform.position.z = 0; const { labelText: s } = i; o.textParam.enableText = !!s, o.textParam.text = s, r.userData.iconItem.update(o, void 0, !1), r.name = e; for (const t of r.children) t.onBeforeRender = function () { this.userData.inView = !0 }, t.name = e; return r }(r); a(r); return await o() } if (void 0 === r.userData.iconItem) return r = await async function (r) { let o = r.children[0], s = r.children[1], l = r.children[2]; const { background: c } = t; if (c) { if (!0 !== o.isSprite) { const t = new SpriteMaterial({ alphaTest: .1, transparent: !0, fog: DRAWABLE_FOG }); o = new Sprite(t), o.name = e } if (o.userData.background !== c) { const e = "texture/iconBackground/" + c + ".png", t = util$1.url(_context.instance.resourceBasePath, e), i = await n(t); o.material.map.dispose(), o.material.map = i, o.userData.background = c } o.material.depthWrite = _context.drawableDepthTest, o.material.depthTest = _context.drawableDepthTest; const { backgroundColor: i, sizeAttenuation: r } = t; if (o.material.color = new Color$1(i), o.material.sizeAttenuation = r, "rgba" === i.substring(0, 4)) { let e = i.slice(4); e = e.split(","), e = parseFloat(e[3].replace(/[^0-9.]/gi, "")), o.material.opacity = e } const { width: a, height: s } = t, l = r ? a / 30 : a / 3e3, h = r ? s / 30 : s / 3e3; o.scale.set(l, h, 1); const { offsetV: u, offsetH: d, factor: p = -.1 } = t, f = u / 30 * p + .5, m = d / 30 * p + .5; o.center = new Vector2(f, m) } else a(o), o = new Group; const { path: h } = t; if (s.userData.path !== h) { const e = await n(h); s.material.map.dispose(), s.material.map = e } s.material.depthTest = _context.drawableDepthTest; const { sizeAttenuation: u } = t; s.material.sizeAttenuation = u; const { width: d, height: p } = t, f = u ? d / 50 : d / 5e3, m = u ? p / 50 : p / 5e3; s.scale.set(f, m, 1); const { offsetV: g, offsetH: y } = t; s.center.set(g, y); const { enableText: v } = i; if (a(l), v) { const { canvas: t, labelAlignment: r, offsetV: n, offsetH: a } = i, o = { enableText: v, canvas: t, sizeAttenuation: u, labelAlignment: r, offsetV: n, offsetH: a }, c = new Group; c.children[1] = s, l = coreUtil.createText_Billboard(c, o), l.name = e } else l = new Group; return r.clear(), r.add(o), r.add(s), r.add(l), r }(r); a(r); return await s() } return { create: async function () { const i = function () { _context.objectStore.remove(e); const i = new Group; i.name = e; const { renderOrder: r } = t; i.renderOrder = DRAWABLE_RENDER_ORDER_BASE + r; const { isShow: n } = t; i.visible = !!n, i.activeVisible = !!n; const { enableAutoHidebyDistance: a, minDistance: o, maxDistance: s } = t; i.enableAutoHidebyDistance = !!a, i.minDistance = o * _context.worldScale, i.maxDistance = s * _context.worldScale, _context.animationStore.addDistance(i.uuid, DistanceController, _context.camera, i); let { pos: l } = t; return i.position.set(l.x, l.y, l.z), i }(), a = await async function () { const { useIconAsset: e } = t; if (!0 === e) return await o(); return await s() }(); i.add(...a.children), i.userData.billboard = a, i.position.copy(a.position), i.rotation.copy(a.rotation), i.scale.copy(a.scale), await async function (i) { const r = i.position; i.userData.startPos = r.clone(), i.userData.targetPos = r.clone(), _context.baseCarrierController.add(e, i); const a = util$1.url(_context.instance.resourceBasePath, "texture/trail/trail.png"), o = await n(a); o.wrapS = ClampToEdgeWrapping, o.wrapT = ClampToEdgeWrapping, o.repeat.set(1, 1); const { color: s = "#ff0000", lineWidth: l } = t, c = new Vector2(window.innerWidth, window.innerHeight), h = new THREE_MeshLine.MeshLineMaterial({ opacity: 1, dashArray: 0, dashOffset: 1, dashRatio: 0, sizeAttenuation: 0, alphaTest: 0, useMap: !0, transparent: !0, repeat: new Vector2(1, 1), side: DoubleSide, depthWrite: _context.drawableDepthTest, depthTest: !0, fog: DRAWABLE_FOG, resolution: c, map: o, color: new Color$1(s), lineWidth: l * _context.worldScale }), u = new THREE_MeshLine$1.MeshLine; u.setPoints([r.x, r.y, r.z]); const d = new Mesh(u, h); d.onBeforeRender = function () { this.userData.inView = !0 }; const { enableAutoHidebyDistance: p, minDistance: f, maxDistance: m } = t; d.enableAutoHidebyDistance = !!p, d.minDistance = f * _context.worldScale, d.maxDistance = m * _context.worldScale, _context.animationStore.addDistance(e + "Line", DistanceController, _context.camera, d); const { duration: g } = t; i.userData.mesh = d, i.userData.currentTime = 0, i.userData.duration = 0, i.userData.trailDuration = g; let y = _context.animationStore.findLayerAnimation(e, TrailAnimationController.type); y && _context.animationStore.remove(y); const v = new TrailController(i); y = new TrailAnimationController(_context.baseCarrierController, v, e), _context.animationStore.add(y), _context.objectStore.add(e + "Line", d) }(i), _context.objectStore.add(e, i), r && r(1) }, update: async function () { const i = _context.objectStore.find(e); if (void 0 === i) return void (r && r(0)); !function (e) { const { renderOrder: i } = t; e.renderOrder = DRAWABLE_RENDER_ORDER_BASE + i; const { isShow: r } = t; e.visible = !!r, e.activeVisible = !!r; const { enableAutoHidebyDistance: n, minDistance: a, maxDistance: o } = t; e.enableAutoHidebyDistance = !!n, e.minDistance = a * _context.worldScale, e.maxDistance = o * _context.worldScale }(i); const n = i.children[3]; i.userData.billboard.add(...i.children); const a = await l(i.userData.billboard); i.add(...a.children), i.userData.billboard = a, i.rotation.copy(a.rotation), i.scale.copy(a.scale), void 0 !== n && i.add(n), async function (e) { e.userData.currentTime = 0, e.userData.startPos = e.position.clone(); let { pos: i } = t; e.userData.targetPos = i; const { travelingTime: r, duration: n } = t; e.userData.duration = r, e.userData.trailDuration = n; const { color: a = "#ff0000", lineWidth: o } = t; e.userData.mesh.material.lineWidth = o, e.userData.mesh.material.color = new Color$1(a); const { enableAutoHidebyDistance: s, minDistance: l, maxDistance: c } = t; e.userData.mesh.enableAutoHidebyDistance = !!s, e.userData.mesh.minDistance = l * _context.worldScale, e.userData.mesh.maxDistance = c * _context.worldScale, e.userData.moveComplete = !1 }(i), r && r(1) } } } class Trail { addTrail(e, t, i, r) { trailUtil(...arguments).create() } updateTrail(e, t, i) { trailUtil(...arguments).update() } } var Trail$1 = new Trail, partials = Object.freeze({ __proto__: null, ModelsPartial: ModelsPartial$1, ModelLandmark: ModelLandmark$1, ModelTrail: ModelTrail$1, MarkerLandmark: MarkerLandmark$1, Trail: Trail$1 }); class Core { constructor() { Cache.enabled = !0; for (const e in partials) { const t = partials[e]; Object.getOwnPropertyNames(t.__proto__).filter((e => "constructor" !== e)).forEach((e => { this[e] = t[e].bind(t) })) } let e, t; logger.debug("avw.scene.Core constructed."); let i, r, n, a = !1, o = !1, s = !0, l = !1, c = !1, h = !1, u = {}, d = !0, p = !0, f = !1, m = null, g = {}, y = {}, v = 1, _ = -1, b = new Vector3(0, 0, 0), x = new Vector2(0, 0), w = new Raycaster, S = 0, M = new Raycaster, T = "", A = 0, E = !1, C = null, L = null, R = new Vector3, D = !1, P = {}, O = null, I = null, k = null, B = null, N = { position: { x: 0, y: 0, z: 0 }, rotation: { _x: 0, _y: 0, _z: 0, _order: "XYZ" }, scale: { x: 1, y: 1, z: 1 } }, F = [], U = null, z = [], G = null, H = null, V = !0; _context.sceneName = "", _context.currentMeshs = [], _context.objectStore = e, _context.eventHandlerStore = t, _context.exporters = g, _context.loaders = y, _context.instance = this, _context.background = {}, _context.sceneSettings = null, _context.ssr = [], _context.envMapIntensity = [], _context.copyModel = null, _context.backgroundBlur = null, _context.backgroundBlur2 = null, _context.background.colorCSSValue = { type: "single", dataUrl: "", color1: "#3070a0", color2: "", gradientValue: "" }, _context.background.textureURL = { textureName: "MSE01Background-blue", customName: "", customDataUrl: "", imgType: "default" }, _context.worldScale = 1, _context.drawableDepthTest = !1; let j = {}, W = null; this.container = void 0, this.resourceBasePath = "./", this.defaultNodeSelection, this.defaultModelSelection, this.selectionControls, this.defaultEffectStore, this.defaultView, this.sysObjectStore, this.allState, this.notState; var $ = []; this.nextRender = function (e, t = 1) { $.push({ frameCount: t, callback: e }) }, this.onNextRender = function () { $.forEach((e => { e.frameCount -= 1, e.frameCount < 0 && e.callback() })) }, this.destroyNextRender = function () { $ = $.filter((e => e.frameCount >= 0)) }, this.setPaused = function (e) { a = e }, this.setMark = e => { !0 === e && this.container && !_context.markDom && (_context.markDom = document.createElement("div"), _context.markDom.style = "position: absolute;top:0;left:0;right:0;bottom: 0;background: #000000;z-index: 1", this.container.append(_context.markDom)), !1 === e && this.container && _context.markDom && (this.container.removeChild(_context.markDom), _context.markDom = null) }; var Y = () => { if (a) return _context.targetCameraControls.update(_context.deltaA), void _context.orbitControls.update(_context.deltaA); if (u.rS && u.rS("frame").start(), u.rS && u.rS("rAF").tick(), u.rS && u.rS("FPS").frame(), u.rS && u.rS("setup").start(), c && i.update(_context.deltaA), _context.rafCallbacks instanceof Array) for (let e of _context.rafCallbacks) e(_context.deltaA), _context.sceneBufferCacheExpired = !0; if (_context.materialPreview && _context.materialPreview.hasRenderer && _context.materialPreview.renderer && _context.materialPreview.scene && _context.materialPreview.camera && _context.materialPreview.orbitControls && (_context.materialPreview.orbitControls.update(), _context.materialPreview.renderer.render(_context.materialPreview.scene, _context.materialPreview.camera)), _context.scene.traverse((e => e.userData.inView = !1)), !V) for (let e of _context.animationMixers) e.update(_context.deltaA), _context.sceneBufferCacheExpired = !0; if (_context.pgl.terrain && _context.pgl.terrain.draw(), _context.animationStore.update(_context.deltaA) && (_context.sceneBufferCacheExpired = !0), _context.modelStore.updateAnimation(_context.deltaA) && (_context.sceneBufferCacheExpired = !0), E) _context.alpha && _context.renderer.getContext().clearColor(0, 0, 0, 0), u.rS && u.rS("setup").end(), this.passiveMode && !_context.sceneBufferCacheExpired || _context.renderer.render(_context.scene, _context.cameraOrtho); else { if (_context.instancedObjectStore) { let e = _context.instancedObjectStore.findInstancedObject("tree"); if (e && e.points instanceof Array) { let t = .01 + .02 * Math.random(); e.setPoints(t) } } t.update(), _context.targetCameraControls.update(_context.deltaA), _context.orbitControls.update(_context.deltaA), _context.sceneBufferCacheExpired = _context.sceneBufferCacheExpired || o, u.rS && u.rS("setup").end(), this.passiveMode && _context.sceneBufferCacheExpired && 1 !== this.passiveModeRenderRate && !o && (++_context.passiveModeRenderRateFrameCount < 1 / this.passiveModeRenderRate ? _context.sceneBufferCacheExpired = !1 : _context.passiveModeRenderRateFrameCount = 0), o = !1; let e = this.passiveMode && !_context.sceneBufferCacheExpired; e ? ++_context.passiveModeSkipFrameCount > 60 && (e = !1, _context.passiveModeSkipFrameCount = 0) : _context.passiveModeSkipFrameCount = 0, _context.composer.render(_context.deltaA, e) } this._tilesRenderers && this._tilesNeedRerender && this._tilesRenderers.forEach((e => { e.update() })), u.rS && u.rS("focus").start(), _context.effectStore.visualEffect.enableDOF && "auto" === _context.effectStore.visualEffect.dofFocus && (S += _context.deltaA, S >= 1 && (S = 0, this.passiveMode && !_context.sceneBufferCacheExpired || this.focus())), u.rS && u.rS("focus").end(), u.rS && u.rS("frame").end(), u.rS && u.rS("rStats").start(), u.rS && u.rS().update(), u.rS && u.rS("rStats").end(), _context.statistics.update(), _context.rendererInfo = _context.statistics.getRendererInfo(_context.renderer), _context.renderer.info.reset(), _context.deltaA = 0, _context.sceneBufferCacheExpired && (_context.sceneBufferCacheExpired = !1) }, X = () => { if (s) return; const e = _context.clock.getDelta(); if (_context.deltaA += e, _context.deltaA < _context.frameTimeLimit) return _context.frameTimeGap < _context.frameTimeLimit ? void (this.frameId = requestAnimationFrame(X.bind(this))) : (Y(), _context.instance.onNextRender(), _context.instance.destroyNextRender(), this.frameId = requestAnimationFrame(X.bind(this)), void (_context.frameTimeGap -= _context.frameTimeLimit - e)); _context.deltaA < 1 && (_context.frameTimeGap += _context.deltaA - _context.frameTimeLimit), Y(), _context.instance.onNextRender(), _context.instance.destroyNextRender(), this.frameId = requestAnimationFrame(X.bind(this)) }; let Z = () => { w.setFromCamera(x, _context.camera); let e = w.intersectObjects(_context.scene.models.children, !0); if (logger.debug(`Picked ${e.length} objects at ${x.x}, ${x.y}.`), e.length > 0) { var t = e[0]; t.distance >= 0 ? (b.set(t.point.x, t.point.y, t.point.z), _ = t.distance) : (b.set(0, 0, 0), _ = -1) } else b.set(0, 0, 0), _ = -1; return x.set(0, 0), _ }; this._pausePickInFocusObject = () => { }, this._resumePickInFocusObject = () => { }, this.pickObjectInFocus = () => { Z() }; let q = (e, t) => { let i = document.createElement("a"); i.style.display = "none", document.body.appendChild(i), i.href = URL.createObjectURL(e), i.download = t, i.click(), document.body.removeChild(i) }, J = e => `${this.resourceBasePath}///${e}`.replace("/////", "/").replace("////", "/").replace("///", "/"); this._exportScene = e => { switch ((e = e || "gltf").toLowerCase()) { case "gltf": default: let e = { trs: !0, onlyVisible: !1, truncateDrawRange: !1, binary: !0, forcePowerOfTwoTextures: !0, includeCustomExtensions: !0, maxTextureSize: 1 / 0 }; logger.debug(_context.scene), g.gltfExporter.parse(_context.scene, (e => { var t; e instanceof ArrayBuffer ? (t = "scene.glb", q(new Blob([e], { type: "application/octet-stream" }), t)) : ((e, t) => { q(new Blob([e], { type: "text/plain" }), t) })(JSON.stringify(e, null, 2), "scene.gltf") }), e) } }; let K = function (t, i, r, n) { e.remove(t); var a = new Group; a.name = t, a.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0); for (var o = [], s = 0; s < i.point.length; s += 2)o.push(new Vector2(i.point[s], i.point[s + 1])); o.push(new Vector2(i.point[0], i.point[1])), i.fillRepeat = i.fillRepeat || [1, 1]; let l = 0; switch (i.fillType) { case "top": l = 1; break; case "bottom": l = -1; break; case "both": l = 2; break; case "none": l = 0 }const c = new AreaGeometry(o, i.depth * _context.worldScale, 1, !1, l); (e => { if (i.fillArea && "none" !== i.fillArea) { let t = `texture/area/fill/${i.fillArea.toLowerCase()}.jpg`; _context.loaders.textureLoader.load(util$1.url(this.resourceBasePath, t), (t => { t.wrapS = RepeatWrapping, t.wrapT = RepeatWrapping; let r = o[0].x, n = o[0].x; for (let e of o) e.x > r ? r = e.x : e.x < n && (n = e.x); let a = new Vector2(r, 0).distanceTo(new Vector2(n, 0)); t.repeat.set(a / t.image.height * 2, 1); let s = new MeshPhongMaterial({ map: t, alphaMap: t, transparent: !0, fog: DRAWABLE_FOG, color: new Color$1(i.color), opacity: i.fillAlpha, side: DoubleSide, emissive: new Color$1(i.color), emissiveIntensity: "number" != typeof i.brightness ? .5 : i.brightness, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest }); s.name = "AreaFillMaterial", i.depth, _context.worldScale, util$1.interpolate(i.point, 2, 50, !0); let l = 0, c = 0; "Gradient01" === i.fillArea || "Gradient02" === i.fillArea ? l = -1 / 6 : "Grid01" === i.fillArea ? l = 1 / 6 : "Grid02" === i.fillArea || "Segment01" === i.fillArea ? l = -1 / 6 : "Segment02" === i.fillArea && (c = -1 / 6); let h = new UVAnimationController(s, !0, !0, -l, c); _context.animationStore.add(h), e(s) })) } else { let t = new MeshBasicMaterial({ fog: DRAWABLE_FOG, side: DoubleSide, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest }); t.name = "AreaFillMaterial", t.visible = !1, e(t) } })((r => { let o = `texture/area/${i.areaType.toLowerCase()}.jpg`; _context.loaders.textureLoader.load(util$1.url(this.resourceBasePath, o), (o => { o.flipY = !1, o.wrapS = RepeatWrapping, o.wrapT = RepeatWrapping, o.repeat.set(Math.ceil(c.sideWallSegments) || 1, 1), "arrow01" === i.areaType.toLowerCase() ? o.repeat.set(Math.ceil(c.sideWallSegments) || 1, 1) : "segment01" === i.areaType.toLowerCase() && (o.wrapS = MirroredRepeatWrapping, o.repeat.set(Math.ceil(c.sideWallSegments) || 1, 1)); let s = new MeshPhongMaterial({ map: o, fog: DRAWABLE_FOG, alphaMap: o, transparent: !0, color: new Color$1(i.fillColor), opacity: i.alpha, side: DoubleSide, emissive: new Color$1(i.fillColor), emissiveIntensity: "number" != typeof i.brightness ? .5 : i.brightness, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest }); s.name = "AreaSideMaterial", i.depth, _context.worldScale, util$1.interpolate(i.point, 2, 50, !0); let l = 0, h = 0; "Arrow01" === i.areaType ? l = 1 / 6 : "Gradient01" === i.areaType || ("Gradient02" === i.areaType ? h = 1 / 6 : "Gradient03" === i.areaType || "Grid01" === i.areaType || ("Grid02" === i.areaType ? h = -1 / 6 : "Grid03" === i.areaType ? h = 1 / 6 : "Grid04" === i.areaType ? h = -1 / 6 : "Grid05" === i.areaType ? h = 1 / 6 : "Segment01" === i.areaType ? l = 1 / 6 : "Segment02" === i.areaType ? h = 1 / 6 : "Segment03" === i.areaType && (l = 1 / 6))); let u = new UVAnimationController(s, !0, !0, -l, h); _context.animationStore.add(u); let d = null; switch (i.fillType) { case "top": case "bottom": d = new Mesh(c, [s, r]); break; case "both": d = new Mesh(c, [s, r, r]); break; case "none": d = new Mesh(c, [s]) }d.onBeforeRender = function () { this.userData.inView = !0 }, d.name = t, a.add(d), a.visible = i.isShow, a.activeVisible = i.isShow, e.add(t, a), null != i.enableAutoHidebyDistance && (a.enableAutoHidebyDistance = i.enableAutoHidebyDistance, a.minDistance = i.minDistance * _context.worldScale, a.maxDistance = i.maxDistance * _context.worldScale, _context.animationStore.addDistance(t, DistanceController, _context.camera, a)), i.offset && a.position.set(i.lonOffset, i.altOffset + i.alt, i.latOffset), c.computeBoundingSphere(); let p = c.boundingSphere.center; a.position.x += p.x, a.position.y += p.y, a.position.z += p.z, d.position.x -= p.x, d.position.y -= p.y, d.position.z -= p.z, a.userData.center = a.position.clone(), n && n(a) })) })) }, Q = function (e) { return new Promise((t => { const i = new Image; i.setAttribute("crossOrigin", "anonymous"), i.src = e, i.onload = function () { t(i) }, i.onerror = function () { t() } })) }, ee = function ({ target: e } = {}) { if (!_context.compass || !_context.compass.canvas) return; let t = _context.compass.canvas, i = t.getContext("2d"), r = 180 / Math.PI * e.getAzimuthalAngle(); r = (r + 360) % 360; const n = _context.compass.size, a = _context.renderer.domElement.scrollHeight, o = _context.renderer.domElement.scrollWidth, s = n < a ? n : a < o ? a : o; let l = _context.compass.dialPlate, c = _context.compass.pointer; t.width = s, t.height = s, i.translate(t.width / 2, t.height / 2), i.rotate(Math.PI / 180 * r), i.translate(-t.width / 2, -t.height / 2); let h = t.width / 2 - s / 2, u = t.height / 2 - s / 2; i.drawImage(l, h, u, s, s), i.translate(t.width / 2, t.height / 2), i.rotate(Math.PI / 180 * -r), i.translate(-t.width / 2, -t.height / 2), i.restore(), i.drawImage(c, 0, 0, s, s) }; this.onPointerMove = function (e) { _context.orbitControls.onPointerMove(e) }, this.cameraFollowing = function ({ type: t, name: i, distance: r, pitch: n, heading: a }) { let o, s = _context.animationStore.findAnimation(CameraFollowingController.type, CameraFollowingController.type); if (void 0 === s && (s = new CameraFollowingController(CameraFollowingController.type), _context.animationStore.add(s)), "model" === t) { o = this.defaultObjectTree.getItemByName(i).getGroup() } else { if ("drawable" !== t) return; o = e.find(i) } s.set(o, r, n, a) }, this.cameraFollowingStState = function (e, t) { let i = _context.animationStore.findAnimation(CameraFollowingController.type, CameraFollowingController.type); void 0 !== i ? ("pause" === e ? i.pause() : "continue" === e ? i.continue() : "stop" === e ? _context.animationStore.remove(i) : t && t({ result: 0, message: "失败。" }), t && t({ result: 0, message: "成功。" })) : t && t({ result: 0, message: "失败。" }) }, this.addEventListener = function (e, t, i) { "transformControls" == e && _context.transformControls.addEventListener(t, i), "modelSelection" == e && (this.defaultModelSelection[t] = i) }, this.removeEventListener = function (e, t, i) { "transformControls" == e && _context.transformControls.removeEventListener(t, i) }, this.transformObject = function (t, i, r) { const n = e.find(t); n ? (_context.transformControls.setMode("translate"), _context.transformControls.attach(n), void 0 !== i && _context.transformControls.setTranslationSnap(i), r && r({ result: 1, message: "成功。" })) : r && r({ result: 0, message: "失败，没有对应绘制物实体。" }) }, this.untransformObject = function () { _context.transformControls.detach() }, this.domElement = function () { return _context.renderer.domElement }, this.setCompass = async function ({ isShow: e = !0, hor: t = "right", ver: i = "top", offset: r = [0, 0], size: n = 1 } = {}) { let a = document.getElementById("compass"); if (!e && !a) return; if (!e && a) return _context.orbitControls.removeEventListener("change", ee), this.container.removeChild(a), void (_context.compass.canvas = void 0); if (!a) { a = document.createElement("canvas"), a.setAttribute("id", "compass"), a.style.position = "absolute", a.style.pointerEvents = "none", this.container.appendChild(a); let e = new Image; e.src = util$1.url(this.resourceBasePath, "./texture/compass/DialPlate.png"), e.onload = () => { _context.compass = { dialPlate: e }, e = new Image, e.src = util$1.url(this.resourceBasePath, "./texture/compass/Pointer.png"), e.onload = () => { _context.compass.pointer = e, _context.compass.size = n, _context.compass.canvas = a, ee({ target: _context.orbitControls }), _context.orbitControls.addEventListener("change", ee) } } } let o = r[0], s = r[1]; a.style.transform = "unset", a.style.left = "unset", a.style.right = "unset", a.style.top = "unset", a.style.bottom = "unset", "left" === t ? a.style.left = `${o}px` : "right" === t && (a.style.right = -o + "px"), "top" === i ? a.style.top = `${s}px` : "bottom" === i && (a.style.bottom = -s + "px"), "center" === t && "center" === i ? (a.style.left = `calc(50% + ${o}px)`, a.style.top = `calc(50% + ${s}px)`, a.style.transform = "translate(-50%, -50%)") : "center" === t ? (a.style.left = `calc(50% + ${o}px)`, a.style.transform = "translate(-50%, 0)") : "center" === i && (a.style.top = `calc(50% + ${s}px)`, a.style.transform = "translate(0, -50%)"), _context.compass && (_context.compass.size = n, ee({ target: _context.orbitControls })) }, this.setWatermark = async function (e = [], t) { let i = []; Array.isArray(e) || (e = [e]); const n = e; e = []; for (const t of n) { let r = await Q(t.src); r ? (t.img = r, e.push(t)) : i.push(t.src) } if (i.length > 0) return void (t && t(0, `${i.join("、")} 图片加载失败。`)); let a = r.width, o = r.height, s = document.createElement("canvas"); s.setAttribute("width", a), s.setAttribute("height", o); let l = s.getContext("2d"); for (const t of e) { let e = t.img.width * t.scale, i = t.img.height * t.scale, r = 0; "right" === t.hor ? r = a - e : "center" === t.hor && (r = a / 2 - e / 2); let n = 0; "bottom" === t.ver ? n = o - i : "center" === t.ver && (n = o / 2 - i / 2), r += t.offset[0], n += t.offset[1], l.globalAlpha = t.alpha, l.drawImage(t.img, r, n, e, i) } try { let e = s.toDataURL("image/png"); _context.effectStore.visualEffect.watermark = e } catch (e) { return void (t && t(0, `生成水印失败：${e} 。`)) } t && t(1, {}) }, this.endSelectDrawable = function () { _context.selectControl.endSelectDrawable(...arguments) }, this.selectDrawable = function () { _context.selectControl.startSelectDrawable(...arguments) }, this.getModelBox = function (e) { let t = this.defaultObjectTree.getItemByName(e).getGroup(), i = new Box3; return i.setFromObject(t), i }, this.restrictCamera = function (e, t) { null === W && (W = {}, W.default = { minDistance: _context.orbitControls.minDistance, maxDistance: _context.orbitControls.maxDistance, minPolarAngle: _context.orbitControls.minPolarAngle, maxPolarAngle: _context.orbitControls.maxPolarAngle, minAzimuthAngle: _context.orbitControls.minAzimuthAngle, maxAzimuthAngle: _context.orbitControls.maxAzimuthAngle, targetLimit: { limitHeight: _context.orbitControls.targetLimit.limitHeight, center: _context.orbitControls.targetLimit.center, radius: _context.orbitControls.targetLimit.radius }, isUse: !0 }, W.custom = { minDistance: _context.orbitControls.minDistance, maxDistance: _context.orbitControls.maxDistance, minPolarAngle: _context.orbitControls.minPolarAngle, maxPolarAngle: _context.orbitControls.maxPolarAngle, minAzimuthAngle: _context.orbitControls.minAzimuthAngle, maxAzimuthAngle: _context.orbitControls.maxAzimuthAngle, targetLimit: { limitHeight: _context.orbitControls.targetLimit.limitHeight, center: _context.orbitControls.targetLimit.center, radius: _context.orbitControls.targetLimit.radius }, isUse: !1 }); const { limitDistance: i } = e; W.custom.minDistance = i[0] / _context.worldScale, W.custom.maxDistance = i[1] / _context.worldScale; const { limitPitch: r } = e; let n = MathUtils.degToRad(90 - r[1]); W.custom.minPolarAngle = n; let a = MathUtils.degToRad(90 - r[0]); W.custom.maxPolarAngle = a; const { limitYaw: o } = e; 180 == o[0] && (o[0] += 1e-4), o[0] = (o[0] + 180) % 360 - 180, o[0] = MathUtils.degToRad(o[0]), NaN == o[0] && (o[0] = -1 / 0), W.custom.minAzimuthAngle = o[0], 180 == o[1] && (o[1] += 1e-4), o[1] = (o[1] + 180) % 360 - 180, o[1] = MathUtils.degToRad(o[1]), NaN == o[1] && (o[1] = 1 / 0), W.custom.maxAzimuthAngle = o[1]; const { limitHeight: s, center: l, radius: c } = e, h = W.custom.targetLimit; h.limitHeight = [s[0] / _context.worldScale, s[1] / _context.worldScale], h.center = l, h.radius = c / _context.worldScale, W.custom.isUse && _context.instance.setCameraRestrictionState(!0), t && t({ result: 1, message: "成功。" }) }, this.setCameraRestrictionState = function (e, t) { if (null === W && (W = {}, W.default = { minDistance: _context.orbitControls.minDistance, maxDistance: _context.orbitControls.maxDistance, minPolarAngle: _context.orbitControls.minPolarAngle, maxPolarAngle: _context.orbitControls.maxPolarAngle, minAzimuthAngle: _context.orbitControls.minAzimuthAngle, maxAzimuthAngle: _context.orbitControls.maxAzimuthAngle, targetLimit: { limitHeight: _context.orbitControls.targetLimit.limitHeight, center: _context.orbitControls.targetLimit.center, radius: _context.orbitControls.targetLimit.radius }, isUse: !0 }, W.custom = { minDistance: _context.orbitControls.minDistance, maxDistance: _context.orbitControls.maxDistance, minPolarAngle: _context.orbitControls.minPolarAngle, maxPolarAngle: _context.orbitControls.maxPolarAngle, minAzimuthAngle: _context.orbitControls.minAzimuthAngle, maxAzimuthAngle: _context.orbitControls.maxAzimuthAngle, targetLimit: { limitHeight: _context.orbitControls.targetLimit.limitHeight, center: _context.orbitControls.targetLimit.center, radius: _context.orbitControls.targetLimit.radius }, isUse: !1 }), e) { const e = W.custom; _context.orbitControls.minDistance = e.minDistance, _context.orbitControls.maxDistance = e.maxDistance, _context.orbitControls.minPolarAngle = e.minPolarAngle, _context.orbitControls.maxPolarAngle = e.maxPolarAngle, _context.orbitControls.minAzimuthAngle = e.minAzimuthAngle, _context.orbitControls.maxAzimuthAngle = e.maxAzimuthAngle, _context.orbitControls.targetLimit = e.targetLimit, W.custom.isUse = !0, W.default.isUse = !1 } else { const e = W.default; _context.orbitControls.minDistance = e.minDistance, _context.orbitControls.maxDistance = e.maxDistance, _context.orbitControls.minPolarAngle = e.minPolarAngle, _context.orbitControls.maxPolarAngle = e.maxPolarAngle, _context.orbitControls.minAzimuthAngle = e.minAzimuthAngle, _context.orbitControls.maxAzimuthAngle = e.maxAzimuthAngle, _context.orbitControls.targetLimit = e.targetLimit, W.custom.isUse = !1, W.default.isUse = !0 } t && t({ result: 1, message: "成功。" }) }, this.setSceneName = function (e) { _context.sceneName = e }, this.getSceneName = function () { return _context.sceneName }, this.addBillboardAsset = function (t, i, r) { e.remove(t); var n = new Group; let a = _context.sceneSettings.objectTree.children.find((e => "IconAsset" === e.type && e.name === i.iconAssetName)); a = JSON.parse(JSON.stringify(a)), a.name = t, a.transform.position.x = i.pos.x, a.transform.position.y = i.pos.y, a.transform.position.z = i.pos.z, a.textParam.text = i.labelText, a.textParam.enableText = "" != a.textParam.text, a.textParam.color = i.labelColor, a.isVisible = void 0 === i.isShow ? a.isVisible : i.isShow, new IconItem(a, n, (() => { for (const e of n.children[0].children) e.onBeforeRender = function () { this.userData.inView = !0 }; n.children[0].renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0), e.add(t, n.children[0]), r && r(e) })) }, this.updateBillboardAsset = function (t, i, r) { let n = _context.sceneSettings.objectTree.children.find((e => "IconAsset" === e.type && e.name === i.iconAssetName)); n = JSON.parse(JSON.stringify(n)), n.name = t, n.transform.position.x = i.pos.x, n.transform.position.y = i.pos.y, n.transform.position.z = i.pos.z, n.textParam.text = i.labelText, n.textParam.enableText = "" != i.labelText, n.textParam.color = i.labelColor, n.isVisible = void 0 === i.isShow ? n.isVisible : i.isShow; let a = this.getIconAsset(t); if (a) a.update(n), r && r(1); else { e.remove(t); var o = new Group; o.renderOrder = 2, new IconItem(n, o, (() => { o.children[0].renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0), e.add(t, o.children[0]), r && r(1) })) } }, this.isContentAssets = function (e, t = "IconAsset") { if (null == e || "" == e) return !1; let i = e.indexOf("custom-") > -1, r = _context.sceneSettings.objectTree.children; return i ? r.findIndex((i => i.type === t && i.isEditor && i.name === e.replace("custom-", ""))) > -1 : r.findIndex((i => i.type == t && !i.isEditor && i.name === e)) > -1 }, this.interruptCameraFly = function (e = !0) { if (_context.orbitControls.removeEventListener("start", this.interruptCameraFly), _context.orbitControls.autoRotate) return _context.orbitControls.autoRotate = !1, _context.autoRotateChange && (_context.autoRotateChange(!1), _context.autoRotateChange = void 0), _context.orbitControls.autoRotateSpeed = 0, void _context.orbitControls.update(); if (_context.targetCameraControls.isZoomTo) if (-1 !== Z()) { const e = { target: b, distance: _ }; let t = this.getCamera(); e.target = e.target || { x: t.targetX, y: t.targetY, z: t.targetZ }, e.azimuthAngle = e.azimuthAngle || 0 === e.azimuthAngle ? e.azimuthAngle : t.azimuthAngle, e.inclinationAngle = "number" == typeof e.inclinationAngle ? e.inclinationAngle : t.inclinationAngle, e.distance = "number" == typeof e.distance && e.distance > 0 ? e.distance : t.viewDistance; let i = this.getDatumShiftModel(); e.distance = i?.editor?.YScale ? e.distance * i.editor.YScale : e.distance, _context.targetCameraControls.zoomTo(new Vector3(e.target.x, e.target.y, e.target.z), e.azimuthAngle, e.inclinationAngle, e.distance, 0, !0) } else { let e = this.getCamera(), t = new Vector3(e.targetX, e.targetY, e.targetZ), i = e.azimuthAngle, r = e.inclinationAngle, n = e.viewDistance; _context.targetCameraControls.zoomTo(t, i, r, n, 0, !0, void 0, !0) } }.bind(this), this.drawableIsSelected = function (t, i) { let r = e.find(i); return !!r && ("landmark" === t && void 0 !== r.children[3]) }, this.getAngleByPositions = function (e, t) { let i = new Vector3(e.x, e.y, e.z); return 180 * new Vector3(t.x, t.y, t.z).angleTo(i) / Math.PI }, this.getDistanceByPositions = function (e, t) { let i = new Vector3(e.x, e.y, e.z); return new Vector3(t.x, t.y, t.z).distanceTo(i) * _context.worldScale }, this.positionLerp = function (e, t, i) { let r = new Vector3(e.x, e.y, e.z), n = new Vector3(t.x, t.y, t.z); return r.lerp(n, i) }, this.addPath = function (t, i, r) { e.remove(t); let n = new Group; n.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0), n.name = t; let a = []; i.points.forEach((e => { a.push(e.x), a.push(e.y), a.push(e.z) })); let o = util$1.interpolate(a, 3); const s = util$1.interpolate(a, 3, 50, !0); let l = `texture/path/${i.pathType.toLowerCase()}.jpg`; _context.loaders.textureLoader.load(util$1.url(this.resourceBasePath, l), (a => { a.wrapS = RepeatWrapping, a.wrapT = RepeatWrapping; var l = new THREE_MeshLine.MeshLineMaterial({ fog: DRAWABLE_FOG, map: a, maskMap: a, useMaskMap: !0, color: new Color$1(i.color), opacity: i.alpha, resolution: new Vector2(window.innerWidth, window.innerHeight), sizeAttenuation: 0, lineWidth: i.width * _context.worldScale, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, alphaTest: .05, transparent: !0, side: DoubleSide, repeat: new Vector2(s / (4 * i.width), 1), colorPass: new Color$1(i.colorPass), passRange: i.passRange || 0, pass: i.pass, faceUp: !0 }), c = new THREE_MeshLine.MeshLine; c.material = l, c.setGeometry(o); var h = new Mesh(c.geometry, l); h.onBeforeRender = function () { this.userData.inView = !0 }, h.name = t, n.add(h), e.add(t, n); let u = 0; "Arrow01" === i.pathType || "Arrow02" === i.pathType || "Arrow03" === i.pathType || "Arrow04" === i.pathType ? u = 1.3 * i.width / s : "Arrow05" === i.pathType ? u = 1.5 * i.width / s : "Arrow06" === i.pathType ? u = 5 * i.width / s : "Segment01" === i.pathType ? u = 15 * i.width / s : "Segment02" === i.pathType || "Segment03" === i.pathType ? u = 30 * i.width / s : "Segment04" === i.pathType ? u = 15 * i.width / s : ("Segment05" === i.pathType || "Segment06" === i.pathType) && (u = 0); let d = new UVMeshLineAnimationController(l, !0, !1, -u, 0); _context.animationStore.add(d), n.visible = i.isShow; let p = 0; const f = i.points.length; for (let e = 0; e < f - 1; e++) { const t = i.points[e], r = i.points[e + 1], n = new Vector3(t.x, t.y, t.z), a = new Vector3(r.x, r.y, r.z); p += n.distanceTo(a) } let m = new Vector3; if (0 !== p) { const e = p / 2; p = 0; for (let t = 0; t < f - 1; t++) { const r = i.points[t], n = i.points[t + 1], a = new Vector3(r.x, r.y, r.z), o = new Vector3(n.x, n.y, n.z); if (p += a.distanceTo(o), p > e) { const t = p - e; m = a.lerp(o, 1 - t / a.distanceTo(o)); break } } } else m.x = i.points[0].x, m.y = i.points[0].y, m.z = i.points[0].z; n.position.x += m.x, n.position.y += m.y, n.position.z += m.z, h.position.x -= m.x, h.position.y -= m.y, h.position.z -= m.z, n.userData.center = n.position.clone(), r && r(n) })) }, this.updatePathData = function (t, i) { let r = e.find(t); if (!r) return; let n = []; i.points.forEach((e => { n.push(e.x), n.push(e.y), n.push(e.z) })), r.children[0].geometry.setGeometry(n) }, this.updatePathPass = function (t, { colorPass: i, pass: r }) { let n = e.find(t); if (!n) return; let a = n.children[0].material; a.pass = r, a.colorPass = new Color$1(i) }, this.cameraFlyTo = function (e, t, i, r, n, a, o) { this.interruptCameraFly(), _context.orbitControls.addEventListener("start", this.interruptCameraFly); let s = this.getDatumShiftModel(); r = s?.editor?.YScale ? r * s.editor.YScale : r, _context.targetCameraControls.zoomTo(new Vector3(e.x, e.y, e.z), t, i, r, n, a, (e => { _context.orbitControls.removeEventListener("start", this.interruptCameraFly), o && o(e) })) }, this.getCameraAutoRotate = () => _context.orbitControls.autoRotate, this.getDatumShiftModel = function () { return _context.datumShiftModel }, this.setDatumShiftModel = function (e) { _context.datumShiftModel = e, L.setDatumShiftModel(e) }, this.setReferencePoints = function (e) { e instanceof Array && !(e.length < 2) || logger.warn("未提供有效的参考点信息。") }, this.convertLLAToXYZ = function (e) { return L.convertTransform(e) }, this.convertXYZToLLA = function (e) { return L.XYZToLLA(e) }, this.getModelTransform = e => { var t = {}; return _context.scene.models.children.map((i => { i.name === e && (t.position = JSON.parse(JSON.stringify(i.position)), t.rotation = JSON.parse(JSON.stringify(i.rotation)), t.rotation.x = t.rotation._x, t.rotation.y = t.rotation._y, t.rotation.z = t.rotation._z, t.scale = JSON.parse(JSON.stringify(i.scale)), t.rotation.x = t.rotation._x = MathUtils.radToDeg(t.rotation._x), t.rotation.y = t.rotation._y = MathUtils.radToDeg(t.rotation._y), t.rotation.z = t.rotation._z = MathUtils.radToDeg(t.rotation._z)) })), t }, this.setModelTransform = (e, t) => { if (t) for (let i = 0; i < _context.scene.models.children.length; i++)_context.scene.models.children[i].name === e && this.setTransform(_context.scene.models.children[i], t) }, this.getModelTransformByUUID = e => { var t = {}; let i = _context.scene.models.getObjectByProperty("uuid", e); if (i && i.uuid === e) { let e = i.position, r = i.rotation, n = i.scale; if (i instanceof InstancedHelper) { let { key: t } = i.userData, a = i.instanced.getTransform(t); e = a.position, r = a.rotation, n = a.scale } t.position = JSON.parse(JSON.stringify(e)), t.rotation = JSON.parse(JSON.stringify(r)), t.rotation.x = t.rotation._x, t.rotation.y = t.rotation._y, t.rotation.z = t.rotation._z, t.scale = JSON.parse(JSON.stringify(n)), t.rotation.x = t.rotation._x = MathUtils.radToDeg(t.rotation._x), t.rotation.y = t.rotation._y = MathUtils.radToDeg(t.rotation._y), t.rotation.z = t.rotation._z = MathUtils.radToDeg(t.rotation._z) } return t }, this.setModelTransformByUUID = (e, t, i = !1) => { if (!t) return; if (i) { var r = { type: "mouseDown", uuid: e }, n = { type: "mouseUp", mode: null, uuid: e }; _context.transformControls.dispatchEvent(r) } let a = this.defaultObjectTree.getItemByUUID(e); a && (a.transformNode = t, a.transform = t, "IconAsset" === a.type && a.isInstancedItem && a.setTransform(a.transform)), _context.scene.models.traverse((i => { i.uuid === e && this.setTransform(i, t) })), i && (n.mode = _context.transformControls.mode, _context.transformControls.dispatchEvent(n)), this.nextRender((() => { this.cutLevelByUUID(e, !1) })) }, this.setTransformHistory = e => { e > 0 ? _context.transformStore.advance() : e < 0 && _context.transformStore.backOff() }, this.clearTransformHistory = () => { _context.transformStore.clear() }, this.setTransformStoreMode = e => { _context.transformStore.setMode(e) }, this.onTransformEvent = (e, t) => { _context.transformStore.addEventListener(e, t) }, this.offTransformEvent = (e, t) => { _context.transformStore.removeEventListener(e, t) }, this.setModelOpacity = (e, t) => { let i = _context.scene.models.getObjectByName(e); if (!i) return; let r = e => { for (let t of e) t.material && (t.userData.defaultOpacity || (t.userData.defaultOpacity = {}, t.userData.defaultOpacity.transparent = t.material.transparent, t.userData.defaultOpacity.opacity = t.material.opacity)), r(t.children) }; r(i.children); let n = e => { for (let i of e) i.material && (i.material.transparent = !(t >= 1) || i.userData.defaultOpacity.transparent, i.material.opacity = i.userData.defaultOpacity.opacity * t), n(i.children) }; n(i.children) }, this.getModelNodeTransform = (e, t) => { let i = {}; for (let r = 0; r < this.defaultObjectTree.children.length; r++)switch (this.defaultObjectTree.children[r].type) { case "ModelItem": this.defaultObjectTree.children[r].name === e && (i = this.getModelTransformRecursion(this.defaultObjectTree.children[r].getGroup(), t)); case "BuildingItem": this.defaultObjectTree.children[r].name === e ? i = this.getModelTransformRecursion(this.defaultObjectTree.children[r].getGroup(), t) : this.defaultObjectTree.children[r].children.forEach((r => { switch (r.type) { case "ModelItem": r.name === e && (i = this.getModelTransformRecursion(r.getGroup(), t)); case "BuildingFloorItem": r.name === e ? i = this.getModelTransformRecursion(r.getGroup(), t) : r.children.forEach((r => { r.name === e && (i = this.getModelTransformRecursion(r.getGroup(), t)) })) } })) }return i }, this.setModelNodeTransform = (e, t, i) => { if (i) for (let r = 0; r < this.defaultObjectTree.children.length; r++)switch (this.defaultObjectTree.children[r].type) { case "ModelItem": this.defaultObjectTree.children[r].name === e && this.setModelTransformRecursion(this.defaultObjectTree.children[r].getGroup(), t, i); case "BuildingItem": this.defaultObjectTree.children[r].name === e ? this.setModelTransformRecursion(this.defaultObjectTree.children[r].getGroup(), t, i) : this.defaultObjectTree.children[r].children.forEach((r => { switch (r.type) { case "ModelItem": r.name === e && this.setModelTransformRecursion(r.getGroup(), t, i); case "BuildingFloorItem": r.name === e ? this.setModelTransformRecursion(r.getGroup(), t, i) : r.children.forEach((r => { r.name === e && this.setModelTransformRecursion(r.getGroup(), t, i) })) } })) } }, this.getModelTransformRecursion = (e, t) => { if (!(null != e.children && e.children.length > 0)) return !1; for (let r = 0; r < e.children.length; r++) { if (e.children[r].name === t) { var i = {}; return i.position = JSON.parse(JSON.stringify(e.children[r].position)), i.rotation = JSON.parse(JSON.stringify(e.children[r].rotation)), i.rotation.x = i.rotation._x, i.rotation.y = i.rotation._y, i.rotation.z = i.rotation._z, i.scale = JSON.parse(JSON.stringify(e.children[r].scale)), i.rotation.x = i.rotation._x = MathUtils.radToDeg(i.rotation._x), i.rotation.y = i.rotation._y = MathUtils.radToDeg(i.rotation._y), i.rotation.z = i.rotation._z = MathUtils.radToDeg(i.rotation._z), i } { let i = this.getModelTransformRecursion(e.children[r], t); if (i) return i } } }, this.setModelTransformRecursion = (e, t, i) => { if (null != e.children && e.children.length > 0) for (let r = 0; r < e.children.length; r++) { if (e.children[r].name === t) return i.position && (e.children[r].position.x = "number" == typeof i.position.x ? i.position.x : e.children[r].position.x, e.children[r].position.y = "number" == typeof i.position.y ? i.position.y : e.children[r].position.y, e.children[r].position.z = "number" == typeof i.position.z ? i.position.z : e.children[r].position.z), i.rotation && (e.children[r].rotation.order = i.rotation._order || e.children[r].rotation.order, e.children[r].rotation.x = "number" == typeof i.rotation.x ? MathUtils.degToRad(i.rotation.x) : e.children[r].rotation.x, e.children[r].rotation.y = "number" == typeof i.rotation.y ? MathUtils.degToRad(i.rotation.y) : e.children[r].rotation.y, e.children[r].rotation.z = "number" == typeof i.rotation.z ? MathUtils.degToRad(i.rotation.z) : e.children[r].rotation.z), void (i.scale && (e.children[r].scale.x = "number" == typeof i.scale.x ? i.scale.x : e.children[r].scale.x, e.children[r].scale.y = "number" == typeof i.scale.y ? i.scale.y : e.children[r].scale.y, e.children[r].scale.z = "number" == typeof i.scale.z ? i.scale.z : e.children[r].scale.z)); this.setModelTransformRecursion(e.children[r], t, i) } }, this.setTransform = (e, t) => { let i = { x: "number" == typeof t.position.x ? t.position.x : e.position.x, y: "number" == typeof t.position.y ? t.position.y : e.position.y, z: "number" == typeof t.position.z ? t.position.z : e.position.z }, r = { order: t.rotation._order || e.rotation.order, x: "number" == typeof t.rotation.x ? MathUtils.degToRad(t.rotation.x) : e.rotation.x, y: "number" == typeof t.rotation.y ? MathUtils.degToRad(t.rotation.y) : e.rotation.y, z: "number" == typeof t.rotation.z ? MathUtils.degToRad(t.rotation.z) : e.rotation.z }, n = { x: "number" == typeof t.scale.x ? t.scale.x : e.scale.x, y: "number" == typeof t.scale.y ? t.scale.y : e.scale.y, z: "number" == typeof t.scale.z ? t.scale.z : e.scale.z }; e instanceof InstancedHelper ? e.update(i, r, n) : (t.position && (e.position.x = i.x, e.position.y = i.y, e.position.z = i.z, _context.eventHandlerStore.cameraMove()), t.rotation && (e.rotation.order = r.order, e.rotation.x = r.x, e.rotation.y = r.y, e.rotation.z = r.z), t.scale && (e.scale.x = n.x, e.scale.y = n.y, e.scale.z = n.z)) }, this.getSceneTransform = () => { var e = {}; return e.position = _context.scene.models.position, e.rotation = JSON.parse(JSON.stringify(_context.scene.models.rotation)), e.scale = _context.scene.models.scale, e.rotation.x = e.rotation._x = MathUtils.radToDeg(e.rotation._x), e.rotation.y = e.rotation._y = MathUtils.radToDeg(e.rotation._y), e.rotation.z = e.rotation._z = MathUtils.radToDeg(e.rotation._z), e }, this.setSceneTransform = e => { e && (e.position && (_context.scene.models.position.x = "number" == typeof e.position.x ? e.position.x : _context.scene.models.position.x, _context.scene.models.position.y = "number" == typeof e.position.y ? e.position.y : _context.scene.models.position.y, _context.scene.models.position.z = "number" == typeof e.position.z ? e.position.z : _context.scene.models.position.z), e.rotation && (_context.scene.models.rotation.order = e.rotation._order || _context.scene.models.rotation.order, _context.scene.models.rotation.x = "number" == typeof e.rotation._x ? MathUtils.degToRad(e.rotation._x) : _context.scene.models.rotation.x, _context.scene.models.rotation.y = "number" == typeof e.rotation._y ? MathUtils.degToRad(e.rotation._y) : _context.scene.models.rotation.y, _context.scene.models.rotation.z = "number" == typeof e.rotation._z ? MathUtils.degToRad(e.rotation._z) : _context.scene.models.rotation.z), e.scale && (_context.scene.models.scale.x = "number" == typeof e.scale.x ? e.scale.x : _context.scene.models.scale.x, _context.scene.models.scale.y = "number" == typeof e.scale.y ? e.scale.y : _context.scene.models.scale.y, _context.scene.models.scale.z = "number" == typeof e.scale.z ? e.scale.z : _context.scene.models.scale.z)) }, this.setAvwToken = function (e, t, i) { switch (e.toLowerCase()) { case "header": let e = {}; "authorization:bearer" === t.toLowerCase() ? e.Authorization = "Bearer " + i : e[t] = i; for (let t in _context.loaders) "function" == typeof _context.loaders[t].setRequestHeader && _context.loaders[t].setRequestHeader(e) } }, this.addState = function (e) { return _context.stateStore.add(e + "") }, this.getStates = function () { return _context.stateStore.getStates() }, this.setDefaultState = function (e) { return _context.stateStore.setDefaultState(e) }, this.removeState = function (e) { _context.stateStore.remove(e) }, this.updateState = function (e, t) { return _context.stateStore.update(e, t) }, this.copyState = function (e, t) { return _context.stateStore.copyState(e, t) }, this.getCurrentState = () => { if (_context.stateStore) return _context.stateStore.getCurrentState() }, this.synchronizaArticulation = () => { _context.stateStore && _context.stateStore.synchronizaArticulation() }, this.synchronizaAnimation = () => { _context.stateStore && _context.stateStore.synchronizaAnimation() }, this.recoverView = e => { let t = null; _context.sceneSettings || this.saveSceneSettings(this.getSettings()); let i = _context.sceneSettings.states.find((t => t.name == e)); t = i ? i.settings.view : _context.sceneSettings.view, this.defaultView.applySettings(t) }, this.setCurrentState = (e, t, i) => { if (_context.stateStore) { if (e) return this.notState || (this.notState = JSON.parse(JSON.stringify(this.getSettings()))), this.notDistance ? (this.notState.view.camera.distanceMin = this.notDistance.minDistance, this.notState.view.camera.distanceMax = this.notDistance.maxDistance) : (this.notDistance || (this.notDistance = {}), this.notDistance.minDistance = this.notState.view.camera.distanceMin, this.notDistance.maxDistance = this.notState.view.camera.distanceMax), window.firstLoadEnd ? G && (this.notState.view.camera.targetX = G.targetX, this.notState.view.camera.targetY = G.targetY, this.notState.view.camera.targetZ = G.targetZ, this.notState.view.camera.distance = G.viewDistance, this.notState.view.camera.azimuth = G.azimuthAngle, this.notState.view.camera.inclination = G.inclinationAngle, this.notState.view.camera.fov = G.fov, this.notState.view.camera.maxDistance = G.distanceMax, this.notState.view.camera.minDistance = G.distanceMin, this.notState.view.camera.near = G.near, this.notState.view.camera.far = G.far, this.notState.view.camera.inclinationAngleMin = G.inclinationAngleMin, this.notState.view.camera.inclinationAngleMax = G.inclinationAngleMax) : (window.firstLoadEnd = !0, _context.sceneSettings && (this.notState.view.camera = _context.sceneSettings.view.camera), G && (G.targetX = this.notState.view.camera.targetX, G.targetY = this.notState.view.camera.targetY, G.targetZ = this.notState.view.camera.targetZ, G.viewDistance = this.notState.view.camera.distance, G.azimuthAngle = this.notState.view.camera.azimuth, G.inclinationAngle = this.notState.view.camera.inclination, G.fov = this.notState.view.camera.fov, G.distanceMax = this.notState.view.camera.maxDistance, G.distanceMin = this.notState.view.camera.minDistance, G.near = this.notState.view.camera.near, G.far = this.notState.view.camera.far, G.inclinationAngleMin = this.notState.view.camera.inclinationAngleMin, G.inclinationAngleMax = this.notState.view.camera.inclinationAngleMax)), _context.stateStore.selectState(e, t, i); this.notState ? (this.notState.view.camera.duration = 1.5, this.applySceneSettings(this.notState, t), _context.stateStore.setNotState(), this.notState = null) : (this.notState = JSON.parse(JSON.stringify(this.getSettings())), this.notState.view.camera.duration = 1.5, this.applySceneSettings(this.notState, t), _context.stateStore.setNotState(), this.notState = null) } }, this.saveCurrentStateSettings = () => { _context.stateStore && _context.stateStore.saveCurrentStateSettings() }, this.saveCameraParam = (e, t) => { _context.stateStore && _context.stateStore.saveCameraParam(e, t) }, this.getCameraDuration = () => this.defaultView._camera.duration ? this.defaultView._camera.duration : 1.5, this.addCone = function (t, i = {}, r) { if (e.find(t)) return void console.warn(`已存在名称为${t}的绘制物。`); i.radius = i.radius || 1, i.height = i.height || 1, i.radialSegments = i.radialSegments || 8, i.heightSegments = i.heightSegments || 1, i.openEnded = !!i.openEnded, i.thetaStart = i.thetaStart || 0, i.thetaLength = i.thetaLength || 2 * Math.PI, i.materialType = i.materialType || "basic", i.color = i.color || 35071; let n, a = new ConeGeometry(i.radius, i.height, i.radialSegments, i.heightSegments, i.openEnded, i.thetaStart, i.thetaLength); switch (i.originOffset && (i.originOffset.position && a.translate(i.originOffset.position.x || 0, i.originOffset.position.y || 0, i.originOffset.position.z || 0), i.originOffset.rotation && (a.rotateY(MathUtils.degToRad(i.originOffset.rotation.y || 0)), a.rotateX(MathUtils.degToRad(i.originOffset.rotation.x || 0)), a.rotateZ(MathUtils.degToRad(i.originOffset.rotation.z || 0)))), i.materialType.toLowerCase()) { case "standard": case "lambert": n = new MeshLambertMaterial({}); break; case "phong": n = new MeshPhongMaterial({}); break; case "basic": default: n = new MeshBasicMaterial({}) }i.map && (n.map = _context.loaders.textureLoader.load(util$1.url(this.resourceBasePath, i.map)), n.map.wrapS = "number" == typeof i.repeatX && 1 != i.repeatX ? RepeatWrapping : ClampToEdgeWrapping, n.map.wrapT = "number" == typeof i.repeatY && 1 != i.repeatY ? RepeatWrapping : ClampToEdgeWrapping, n.map.repeat.set(i.repeatX || 1, i.repeatY || 1)), i.alphaMap && (n.alphaMap = _context.loaders.textureLoader.load(util$1.url(this.resourceBasePath, i.alphaMap)), n.alphaMap.wrapS = "number" == typeof i.repeatX && 1 != i.repeatX ? RepeatWrapping : ClampToEdgeWrapping, n.alphaMap.wrapT = "number" == typeof i.repeatY && 1 != i.repeatY ? RepeatWrapping : ClampToEdgeWrapping, n.alphaMap.repeat.set(i.repeatX || 1, i.repeatY || 1)), n.alphaTest = .05, n.color = new Color$1(i.color), n.transparent = !(!i.alphaMap && "number" != typeof i.opacity), n.opacity = "number" == typeof i.opacity ? i.opacity : 1, n.side = "number" == typeof i.side && i.side >= 0 && i.side <= 2 ? i.side : 0; let o = new Mesh(a, n); if (o.name = t, i.transform && (i.transform.position && o.position.set(i.transform.position.x || 0, i.transform.position.y || 0, i.transform.position.z || 0), i.transform.rotation && o.rotation.set(MathUtils.degToRad(i.transform.rotation.x || 0), MathUtils.degToRad(i.transform.rotation.y || 0), MathUtils.degToRad(i.transform.rotation.z || 0)), i.transform.scale && o.scale.set(i.transform.scale.x || 1, i.transform.scale.y || 1, i.transform.scale.z || 1)), e.add(t, o), i.follow && this.defaultObjectTree.getItemByName(i.follow.modelName)) { let e = this.defaultObjectTree.getItemByName(i.follow.modelName).getGroup(); if (e instanceof Object3D) { if (i.follow.modelName) { let t = e.getObjectByName(i.follow.nodeName); t && (e = t) } _context.animationStore.add(new FollowAnimationController(o, e, { followType: i.follow.type, enableRotation: !0, enableScale: !0, limit: i.limit, distance0: i.height })) } } }, this.addRAFCallback = e => { if ("function" == typeof e) { _context.rafCallbacks instanceof Array || (_context.rafCallbacks = []); for (let t = 0; t < _context.rafCallbacks.length; t++)if (_context.rafCallbacks[t] === e) return; _context.rafCallbacks.push(e) } }, this.removeRAFCallback = e => { if (_context.rafCallbacks instanceof Array) for (let t = 0; t < _context.rafCallbacks.length; t++)if (_context.rafCallbacks[t] === e) return void _context.rafCallbacks.splice(t, 1) }, this.clearRAFCallbacks = () => { _context.rafCallbacks instanceof Array && (_context.rafCallbacks = void 0) }, this.addBillboard = function (t, i, r, n) { e.remove(t); var a = new Group; if (a.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0), a.position.set(i.pos.x, i.pos.y, i.pos.z), i.background) { let e = _context.loaders.textureLoader.load(util$1.url(_context.instance.resourceBasePath, "texture/iconBackground/" + i.background + ".png")); var o = new SpriteMaterial({ map: e, color: new Color$1(i.backgroundColor), fog: DRAWABLE_FOG, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, alphaTest: .1, transparent: !0, sizeAttenuation: i.sizeAttenuation, polygonOffset: i.polygonOffset, polygonOffsetFactor: i.polygonOffsetFactor, polygonOffsetUnits: i.polygonOffsetUnits }), s = new Sprite(o); s.onBeforeRender = function () { this.userData.inView = !0 }, s.name = t, s.scale.set(i.sizeAttenuation ? Number(i.width) / 30 : Number(i.width) / 3e3, i.sizeAttenuation ? Number(i.height) / 30 : Number(i.height) / 3e3, 1); let r = -.1; if (s.center = new Vector2(i.offsetV / 30 * r + .5, i.offsetH / 30 * r + .5), i.backgroundColor && "rgba" === i.backgroundColor.substring(0, 4)) { let e = i.backgroundColor.slice(4); e = e.split(","), e = parseFloat(e[3].replace(/[^0-9.]/gi, "")), s.material.opacity = e } a.add(s) } else a.add(new Group); const l = o => { var s = new SpriteMaterial({ map: o, color: new Color$1(i.foregroundColor || "#ffffff"), fog: DRAWABLE_FOG, depthWrite: !1, depthTest: _context.drawableDepthTest, alphaTest: .1, transparent: !0, sizeAttenuation: i.sizeAttenuation, polygonOffset: i.polygonOffset, polygonOffsetFactor: i.polygonOffsetFactor, polygonOffsetUnits: i.polygonOffsetUnits }), l = new Sprite(s); l.onBeforeRender = function () { this.userData.inView = !0 }, l.name = t, l.scale.set(i.sizeAttenuation ? Number(i.width) / 50 : Number(i.width) / 5e3, i.sizeAttenuation ? Number(i.height) / 50 : Number(i.height) / 5e3, 1), a.add(l), l.center.set(i.offsetV, i.offsetH); null != r && r.enableText ? te(a, r).name = t : a.add(new Group), null != i.enableAutoHidebyDistance && (a.activeVisible = !0, a.enableAutoHidebyDistance = i.enableAutoHidebyDistance, a.minDistance = i.pointMinDistance * _context.worldScale, a.maxDistance = i.pointMaxDistance * _context.worldScale, _context.animationStore.addDistance(t, DistanceController, _context.camera, a)), e.add(t, a), i.isShow ? (a.visible = !0, a.activeVisible = !0) : (a.visible = !1, a.activeVisible = !1), n && n(a) }; return void 0 !== j[i.path] ? (j[i.path].objectNames.push(t), l(j[i.path].map)) : y.textureLoader.load(i.path, (e => { j[i.path] = {}, j[i.path].map = e, j[i.path].objectNames = [t], l(e) })), a }; let te = (t, i) => { var r; if (null != i) { var n = i.canvas, a = new CanvasTexture(n), o = new SpriteMaterial({ map: a, color: 16777215, fog: DRAWABLE_FOG, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, sizeAttenuation: i.sizeAttenuation }); if ((r = new Sprite(o)).onBeforeRender = function () { this.userData.inView = !0 }, r.scale.set(i.sizeAttenuation ? .045 * i.canvas.width : 405e-6 * i.canvas.width, i.sizeAttenuation ? .045 * i.canvas.height : 405e-6 * i.canvas.height, 1), "left" === i.labelAlignment) { let e = t.children[1].material.map.image.width, n = e / t.children[1].scale.x, o = a.image.width; e = e / n * (o / r.scale.x); let s = e / 1.8 / o * -1; r.center.set(s, i.offsetH) } else r.center.set(i.offsetV, i.offsetH); return r.visible = i.enableText, t ? t.add(r) : e.add(r), r } }; this.updateBillboard = function (t, i, r, n) { let a = e.find(t); if (null != a) { if (a.position.set(i.pos.x, i.pos.y, i.pos.z), i.background) { let e = a.children[0]; e.material.color = new Color$1(i.backgroundColor), e.material.map = _context.loaders.textureLoader.load(util$1.url(_context.instance.resourceBasePath, "texture/iconBackground/" + i.background + ".png")), e.material.sizeAttenuation = i.sizeAttenuation, e.scale.set(i.sizeAttenuation ? Number(i.width) / 30 : Number(i.width) / 3e3, i.sizeAttenuation ? Number(i.height) / 30 : Number(i.height) / 3e3, 1), e.material.depthWrite = !1, e.material.depthTest = !1; let t = -.1; e.center = new Vector2(i.offsetV / 30 * t + .5, i.offsetH / 30 * t + .5) } else a.children[0].traverse((e => { e.geometry && e.geometry.dispose(), e.material && (e.material.dispose(), e.material.map && e.material.map.dispose()) })), a.children[0] = new Group; let e = a.children[1]; e.material.sizeAttenuation = i.sizeAttenuation, e.scale.set(i.sizeAttenuation ? Number(i.width) / 50 : Number(i.width) / 5e3, i.sizeAttenuation ? Number(i.height) / 50 : Number(i.height) / 5e3, 1), e.center.set(i.offsetV, i.offsetH), _context.loaders.textureLoader.load(i.path, (o => { if (e.material.map = o, e.material.depthWrite = _context.drawableDepthTest, e.material.depthTest = _context.drawableDepthTest, null != a.children[1] && a.children[1]) if (null != r && r) if (r.enableText) { let i = new CanvasTexture(r.canvas), n = a.children[2]; n.isGroup && (a.remove(n), n = te(a, r), n.name = t); let o = n.material; if (o.map = i, o.sizeAttenuation = r.sizeAttenuation, n.scale.set(r.sizeAttenuation ? .045 * r.canvas.width : 405e-6 * r.canvas.width, r.sizeAttenuation ? .045 * r.canvas.height : 405e-6 * r.canvas.height, 1), "left" === r.labelAlignment) { let t = e.material.map.image.width, a = t / e.scale.x, o = i.image.width; t = t / a * (o / n.scale.x); let s = t / 1.75 / o * -1; n.center.set(s, r.offsetH) } else n.center.set(r.offsetV, r.offsetH); n.visible = r.enableText } else a.children[2] = new Group; else a.children[2] = new Group; else if (r.enableText) { coreUtil.createText(a, r).name = t } null != i.enableAutoHidebyDistance && (a.activeVisible = !0, a.enableAutoHidebyDistance = i.enableAutoHidebyDistance, a.minDistance = i.pointMinDistance * _context.worldScale, a.maxDistance = i.pointMaxDistance * _context.worldScale, _context.animationStore.addDistance(t, DistanceController, _context.camera, a)), a.visible = i.isShow, a.activeVisible = i.isShow, n && n(1) })) } }, this.selectBillboard = function (t, i) { var r = e.find(t); if (r && i && null == r.children[3]) { var n = r.children[1], a = y.textureLoader.load(util$1.url(this.resourceBasePath, i.path)), o = new SpriteMaterial({ map: a, color: 16777215, fog: !1, sizeAttenuation: n.material.sizeAttenuation, polygonOffset: !0, polygonOffsetFactor: 1, polygonOffsetUnits: -3e4, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest }), s = new Sprite(o); s.name = t + "_selector", s.position.set(n.position.x, n.position.y, n.position.z), s.scale.set(.02304 / r.scale.x, .02304 / r.scale.y, 1), s.center = new Vector2(.5, .5), r.add(s) } }, this.deselectBillboard = function (t) { var i = e.find(t); if (!i) return; if (null == i.children[3]) return; let r = i.children[3]; r.material.map.dispose(), r.material.dispose(), r.geometry.dispose(), i.remove(r) }, this.deselectAllBillboard = function () { e.forEach((e => { for (let t of e.children) if (-1 != t.name.indexOf("_selector")) { t.material.dispose(), t.geometry.dispose(), e.remove(t); break } })) }, this.addBillboard3D = function (t, i, r) { if (!t) return !1; if (!t.name) return !1; let n = t.name; e.remove(n); let a = new Group; a.name = n, e.add(n, a), a.position.set(t.position.x, t.position.y, t.position.z), a.scale.set(t.scale, t.scale, t.scale); let o = MathUtils.degToRad(t.rotation.x), s = MathUtils.degToRad(t.rotation.y), l = MathUtils.degToRad(t.rotation.z); if (a.rotation.set(o, s, l), t.enableAutoHidebyDistance && (a.enableAutoHidebyDistance = t.enableAutoHidebyDistance, a.minDistance = t.minVisibleDistance * _context.worldScale, a.maxDistance = t.maxVisibleDistance * _context.worldScale, _context.animationStore.addDistance(n, DistanceController, _context.camera, a)), t.visible = t.isShow, i) { let e = new PlaneGeometry(i.width, i.height, 1, 1), r = new MeshStandardMaterial, o = y.textureLoader.load(i.path); r.map = o, r.transparent = !0, r.side = DoubleSide, r.depthTest = t.depthTest, r.color.r *= i.brightness, r.color.g *= i.brightness, r.color.b *= i.brightness; let s = new Mesh(e, r); mesh.onBeforeRender = function () { this.userData.inView = !0 }, s.position.set(i.offset.x, i.offset.y, i.offset.z), s.scale.set(i.scale, i.scale, i.scale), s.visible = i.isShow, s.name = `${n}-icon`, a.add(s) } if (r) { let e = new Text; e.text = r.content, e.font = r.font, e.fontSize = r.size, e.anchorX = r.alignment, e.anchorY = "middle"; let i = new Color$1(r.color); i.r *= r.brightness, i.g *= r.brightness, i.b *= r.brightness, e.color = "#" + i.getHexString(), e.material.depthTest = t.depthTest, e.position.x = r.offset.x, e.position.y = r.offset.y, e.position.z = r.offset.z + .1, e.visible = r.isShow, e.name = `${n}-text`, a.add(e), e.sync() } }, this.updateBillboard3D = function (t, i, r) { if (!t) return; let n = e.find(t.name); if (!t) return; n.position.set(t.position.x, t.position.y, t.position.z), n.scale.set(t.scale, t.scale, t.scale); let a = MathUtils.degToRad(t.rotation.x), o = MathUtils.degToRad(t.rotation.y), s = MathUtils.degToRad(t.rotation.z); n.rotation.set(a, o, s), t.enableAutoHidebyDistance && (n.enableAutoHidebyDistance = t.enableAutoHidebyDistance, n.minDistance = t.minVisibleDistance * _context.worldScale, n.maxDistance = t.maxVisibleDistance * _context.worldScale, _context.animationStore.addDistance(name, DistanceController, _context.camera, n)), t.visible = t.isShow; let l = n.children[0]; if (i && l) { l.geometry = new PlaneGeometry(i.width, i.height, 1, 1); let e = l.material, r = y.textureLoader.load(i.path); e.map = r, e.transparent = !0, e.side = DoubleSide, e.depthTest = t.depthTest, e.color.r *= i.brightness, e.color.g *= i.brightness, e.color.b *= i.brightness, l.position.set(i.offset.x, i.offset.y, i.offset.z), l.scale.set(i.scale, i.scale, i.scale), l.visible = i.isShow } let c = n.children[1]; if (r && c) { c.text = r.content, c.font = r.font, c.fontSize = r.size, c.anchorX = r.alignment, c.anchorY = "middle"; let e = new Color$1(r.color); e.r *= r.brightness, e.g *= r.brightness, e.b *= r.brightness, c.color = "#" + e.getHexString(), c.material.depthTest = t.depthTest, c.position.x = r.offset.x, c.position.y = r.offset.y, c.position.z = r.offset.z + .1, c.visible = r.isShow, c.sync() } }, this.addBar = function (t, i, r) { e.remove(t); var n, a = new Group; a.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0), n = "bar" == i.type || null == i.type ? new BoxGeometry(1, 1, 1) : new CylinderGeometry(.5, .5, 1, 32); let o = new MeshPhongMaterial({ fog: DRAWABLE_FOG, opacity: i.alpha, transparent: !0, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest }); if (o.color = new Color$1(i.color), o.emissive = new Color$1(i.color), o.emissiveIntensity = i.brightness, "linear" === i.columnPaint) { o.vertexColors = !0; let e = util$1.colorToRGBAObject(i.colorMax), t = util$1.colorToRGBAObject(i.colorMin), r = new Color$1((e.r - t.r) / 2 + t.r, (e.g - t.g) / 2 + t.g, (e.b - t.b) / 2 + t.b); o.color = new Color$1("0xffffff"), o.emissive = r, o.emissiveIntensity = 1.5 * i.brightness; let a = []; for (let e = 0; e < n.attributes.position.count; e++)a.push(1, 1, 1); n.setAttribute("color", new Float32BufferAttribute(a, 3)), a = n.attributes.color; let s = new Color$1(i.colorMax), l = new Color$1(i.colorMin); for (let e = 0; e < n.attributes.position.count; e++)n.attributes.position.array[3 * e + 1] >= .5 ? (a.setXYZ(e, s.r, s.g, s.b), a.setXYZ(e + 1, s.r, s.g, s.b), a.setXYZ(e + 2, s.r, s.g, s.b)) : (a.setXYZ(e, l.r, l.g, l.b), a.setXYZ(e + 1, l.r, l.g, l.b), a.setXYZ(e + 2, l.r, l.g, l.b)); a.needsUpdate = !0 } var s = new Mesh(n, o); s.needsUpdate = !0, s.onBeforeRender = function () { this.userData.inView = !0 }, a.position.set(i.pos.x, i.pos.y + i.value * _context.worldScale * .5, i.pos.z), s.scale.set(i.width * _context.worldScale, i.value * _context.worldScale, i.width * _context.worldScale), _context.datumShiftModel && "ecef" === _context.datumShiftModel.type && (a.rotation.order = "YXZ", a.rotation.y = (i.pos.lon + 90) / 180 * Math.PI, a.rotation.x = (90 - i.pos.lat) / 180 * Math.PI), i.alpha > 0 && (s.castShadow = !0), a.add(s), s.name = t; var l = null; null != r && r.enableText && ((l = coreUtil.createText(a, r)).name = t, l.position.y = i.value * _context.worldScale * .5), null != i.enableAutoHidebyDistance && (a.activeVisible = !0, a.enableAutoHidebyDistance = i.enableAutoHidebyDistance, a.minDistance = i.minDistance * _context.worldScale, a.maxDistance = i.maxDistance * _context.worldScale, _context.animationStore.addDistance(t, DistanceController, _context.camera, a)), e.add(t, a), i.isShow ? (a.visible = !0, a.activeVisible = !0, !r.enableText && l && (l.visible = !1)) : (a.visible = !1, a.activeVisible = !1, l && (l.visible = !1)) }, this.addInstancedBar = function (t, i, r) { e.remove(t); var n = new Group; n.renderOrder = 2; var a = new Mesh("bar" == i.type || null == i.type ? new BoxGeometry(1, 1, 1) : new CylinderGeometry(.5, .5, 1, 32), new MeshPhongMaterial({ fog: DRAWABLE_FOG, color: new Color$1(i.color), opacity: i.alpha, emissive: new Color$1(i.color), emissiveIntensity: i.brightness, transparent: !0, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest })); n.position.set(i.pos.x, i.pos.y + i.value * _context.worldScale * .5, i.pos.z), a.scale.set(i.width * _context.worldScale, i.value * _context.worldScale, i.width * _context.worldScale), i.alpha > 0 && (a.castShadow = !0), n.add(a), a.name = t; var o = null; null != r && r.enableText && ((o = coreUtil.createText(n, r)).name = t), null != i.enableAutoHidebyDistance && (n.activeVisible = !0, n.enableAutoHidebyDistance = i.enableAutoHidebyDistance, n.minDistance = i.minDistance * _context.worldScale, n.maxDistance = i.maxDistance * _context.worldScale, _context.animationStore.addDistance(t, DistanceController, _context.camera, n)), e.add(t, n), i.isShow ? (n.visible = !0, n.activeVisible = !0, !r.enableText && o && (o.visible = !1)) : (n.visible = !1, n.activeVisible = !1, o && (o.visible = !1)) }, this.addBubble = function (t, i, r, n) { _context.loaders.textureLoader.load(util$1.url(this.resourceBasePath, "texture/bubble/bubble.png"), (a => { var o = new Group; o.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0); var s = new CircleGeometry(1, 32), l = new MeshBasicMaterial({ fog: DRAWABLE_FOG, color: i.color, opacity: Number(i.alpha), transparent: !0, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest }); l.alphaMap = a; var c = new Mesh(s, l); c.onBeforeRender = function () { this.userData.inView = !0 }, c.name = t, o.add(c), o.position.set(i.pos.x, i.pos.y, i.pos.z), c.rotateX(-.5 * Math.PI); let h = _context.animationStore.findNodeAnimation(t, NodeScaleAnimationController.type); h && _context.animationStore.remove(h), h = new NodeScaleAnimationController(c, 0, i.value * _context.worldScale, .8 * i.value * _context.worldScale, i.diffSpeed * _context.worldScale, !0), _context.animationStore.add(h); var u = null; null != r && r.enableText && ((u = coreUtil.createText(o, r)).name = t), null != i.enableAutoHidebyDistance && (o.activeVisible = !0, o.enableAutoHidebyDistance = i.enableAutoHidebyDistance, o.minDistance = i.minDistance * _context.worldScale, o.maxDistance = i.maxDistance * _context.worldScale, _context.animationStore.addDistance(t, DistanceController, _context.camera, o)), e.add(t, o), i.isShow ? (o.visible = !0, o.activeVisible = !0, !r.enableText && u && (u.visible = !1)) : (o.visible = !1, o.activeVisible = !1, u && (u.visible = !1)), n && n(o) })) }, this.addInstancedBubble = function (t, i, r, n) { if (!(i.points instanceof Array)) return void (n && n(0)); let a = "none" === i.fillArea.toLowerCase() ? "texture/bubble/bubble.png" : `texture/bubble/fill/${i.fillArea.toLowerCase()}.jpg`; _context.loaders.textureLoader.load(util$1.url(this.resourceBasePath, a), (r => { var a = new Group; a.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0); var o = new CircleGeometry(1, 32); o.rotateX(Math.PI / -2); let s = new InstancedMesh(o, new MeshBasicMaterial({ alphaMap: r, fog: DRAWABLE_FOG, opacity: 1, transparent: !0, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, side: DoubleSide }), INSTANCE_COUNT_MAX); s.count = i.points.length, s.name = t, s.onBeforeRender = function () { this.userData.inView = !0 }, s.instanceMatrix.setUsage(DynamicDrawUsage), s.visible = [], s.activeVisible = [], s.hideByDistance = [], s.minDistances = [], s.maxDistances = [], s.userData.names = i.points.map((e => e.name)); let l = new Object3D; for (let e = 0; e < i.points.length; e++) { "boolean" == typeof i.points[e].isShow ? s.visible[e] = i.points[e].isShow : s.visible[e] = !0, l.position.set(i.points[e].position.x, i.points[e].position.y, i.points[e].position.z), l.scale.set(1, 1, 1), _context.datumShiftModel && "ecef" === _context.datumShiftModel.type && (l.rotation.order = "YXZ", l.rotation.y = (i.points[e].position.lon + 90) / 180 * Math.PI, l.rotation.x = (90 - i.points[e].position.lat) / 180 * Math.PI), l.updateMatrix(), s.setMatrixAt(e, l.matrix.clone()), s.setColorAt(e, new Color$1(i.points[e].color)); let r = _context.animationStore.findInstancedAnimation(s, e, InstancedBubbleAnimationController.type); r && _context.animationStore.remove(r), null != i.points[e].enableAutoHidebyDistance && (s.activeVisible[e] = !0, s.hideByDistance[e] = i.points[e].enableAutoHidebyDistance, s.minDistances[e] = i.points[e].minDistance * _context.worldScale, s.maxDistances[e] = i.points[e].maxDistance * _context.worldScale), r = new InstancedBubbleAnimationController(s, e, 0, i.points[e].value * _context.worldScale, .8 * i.points[e].value * _context.worldScale, i.points[e].diffSpeed * _context.worldScale, !1, _context.camera), _context.animationStore.add(r); var c = null; null != i.points[e].textParam && i.points[e].textParam.enableText && ((c = coreUtil.createText(a, i.points[e].textParam)).position.set(i.points[e].position.x, i.points[e].position.y, i.points[e].position.z), c.name = `__bubble_${t}_${e}`, c.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0), a.add(c), null != i.points[e].enableAutoHidebyDistance && (c.activeVisible = !0, c.enableAutoHidebyDistance = i.points[e].enableAutoHidebyDistance, c.minDistance = i.points[e].minDistance * _context.worldScale, c.maxDistance = i.points[e].maxDistance * _context.worldScale, _context.animationStore.addDistance(`__bubble_dc_${t}_${e}`, DistanceController, _context.camera, c))), i.isShow ? !i.points[e].textParam.enableText && c && (c.visible = !1) : c && (c.visible = !1) } s.instanceColor.needsUpdate = !0, s.instanceMatrix.needsUpdate = !0, a.add(s), a.instancedBubble = s, e.add(t, a), i.isShow ? (a.visible = !0, a.activeVisible = !0) : (a.visible = !1, a.activeVisible = !1), n && n(1) })) }, this.updateInstancedBubble = function (t, i, r, n) { let a = _context.objectStore.find(t); if (!a) return; "number" == typeof i.renderOrder && (a.renderOrder = DRAWABLE_RENDER_ORDER_BASE + i.renderOrder); let o = a.instancedBubble; if (!o) return; if (!(i.points instanceof Array)) return; o.count = i.points.length, o.name = t, o.onBeforeRender = function () { this.userData.inView = !0 }, o.instanceMatrix.setUsage(DynamicDrawUsage), o.activeVisible = [], o.hideByDistance = [], o.minDistances = [], o.maxDistances = []; let s = new Object3D; for (let e = 0; e < i.points.length; e++) { s.position.set(i.points[e].position.x, i.points[e].position.y, i.points[e].position.z), s.scale.set(1, 1, 1), s.updateMatrix(), o.setMatrixAt(e, s.matrix.clone()), o.setColorAt(e, new Color$1(i.points[e].color)); let r = _context.animationStore.findInstancedAnimation(o, e, InstancedBubbleAnimationController.type); r && _context.animationStore.remove(r), null != i.points[e].enableAutoHidebyDistance && (o.activeVisible[e] = !0, o.hideByDistance[e] = i.points[e].enableAutoHidebyDistance, o.minDistances[e] = i.points[e].minDistance * _context.worldScale, o.maxDistances[e] = i.points[e].maxDistance * _context.worldScale), r = new InstancedBubbleAnimationController(o, e, 0, i.points[e].value * _context.worldScale, .8 * i.points[e].value * _context.worldScale, i.points[e].diffSpeed * _context.worldScale, !1, _context.camera), _context.animationStore.add(r); var l = null; null != i.points[e].textParam && i.points[e].textParam.enableText && ((l = coreUtil.createText(bubbleGroup, i.points[e].textParam)).position.set(i.points[e].position.x, i.points[e].position.y, i.points[e].position.z), l.name = `__bubble_${t}_${e}`, l.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0), bubbleGroup.add(l), null != i.points[e].enableAutoHidebyDistance && (l.activeVisible = !0, l.enableAutoHidebyDistance = i.points[e].enableAutoHidebyDistance, l.minDistance = i.points[e].minDistance * _context.worldScale, l.maxDistance = i.points[e].maxDistance * _context.worldScale, _context.animationStore.addDistance(`__bubble_dc_${t}_${e}`, DistanceController, _context.camera, l))) } o.instanceColor.needsUpdate = !0, o.instanceMatrix.needsUpdate = !0, bubbleGroup.add(o), e.add(t, bubbleGroup) }, this.removeInstancedBubble = function (t) { let i = _context.objectStore.find(t); if (!i) return; let r = i.instancedBubble; if (r) { for (let e = 0; e < r.count; e++) { let t = _context.animationStore.findInstancedAnimation(r, e, InstancedBubbleAnimationController.type); t && _context.animationStore.remove(t) } r.geometry.dispose(); for (let e in r.material) r.material[e] instanceof Texture$1 && r.material[e].dispose(); r.material.dispose(), r.dispose(), i.remove(r); for (let e of i.children) { for (let t in e.material) e.material[t] instanceof Texture$1 && e.material[t].dispose(); i.remove(e) } e.remove(t) } }, this.addODLine = function (t, i, r, n) { var a = new Group; let o, s, l, c; a.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0), a.name = t, o = new Vector3(i.startPos.x, i.startPos.y, i.startPos.z), c = new Vector3(i.endPos.x, i.endPos.y, i.endPos.z), s = new Vector3, l = new Vector3; var h = c.clone().add(o.clone().divideScalar(-1)); if (s.lerpVectors(o, c, .25), l.lerpVectors(o, c, .75), _context.datumShiftModel && "ecef" === _context.datumShiftModel.type) { const e = h.length() * parseFloat(i.curvatureCoefficient / 50); s.setLength(s.length() + e), l.setLength(l.length() + e) } else s.setY(s.y + h.length() * parseFloat(i.curvatureCoefficient / 100)), l.setY(l.y + h.length() * parseFloat(i.curvatureCoefficient / 100)); let u = new CubicBezierCurve3(o, s, l, c); var d = u.getPoints(32), p = u.getPointAt(.5); let f = []; d.forEach((e => { f.push(e.x), f.push(e.y), f.push(e.z) })); let m = "texture/odline/" + i.imageType.toLowerCase() + ".jpg"; _context.loaders.textureLoader.load(util$1.url(this.resourceBasePath, m), (o => { o.wrapS = RepeatWrapping, o.wrapT = RepeatWrapping; let s = util$1.interpolate(f, 3, 50, !0) / (i.lineWidth * _context.worldScale / o.image.height * o.image.width); "default" === i.imageType.toLowerCase() ? s /= 4 : "ray" === i.imageType.toLowerCase() && (s = 1); var l = new THREE_MeshLine.MeshLineMaterial({ fog: DRAWABLE_FOG, map: o, maskMap: o, useMaskMap: !0, color: new Color$1(i.color), opacity: 1, resolution: new Vector2(window.innerWidth, window.innerHeight), sizeAttenuation: 1, lineWidth: i.lineWidth * _context.worldScale, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, alphaTest: .05, transparent: !0, side: DoubleSide, repeat: new Vector2(s, 1) }), c = new THREE_MeshLine.MeshLine; c.setGeometry(d); var h = new Mesh(c.geometry, l); h.onBeforeRender = function () { this.userData.inView = !0 }; let u = new UVMeshLineAnimationController(l, !0, !1, -i.animationSpeed * _context.worldScale / 20, 0); _context.animationStore.add(u), h.material.uniforms.dashOffset.value = 1.5, h.labelPoint = p, h.raycast = c.raycast, h.name = t, a.add(h), a.position.set(h.position.x, h.position.y, h.position.z), a.userData.mesh = h; var m = null; null != r && r.enableText && ((m = coreUtil.createText(a, r)).position.set(p.x, p.y, p.z), m.name = t), null != i.enableAutoHidebyDistance && (a.activeVisible = !0, a.distance = new Vector3, a.distance.set(p.x, p.y, p.z), a.enableAutoHidebyDistance = i.enableAutoHidebyDistance, a.minDistance = i.minDistance * _context.worldScale, a.maxDistance = i.maxDistance * _context.worldScale, _context.animationStore.addDistance(t, DistanceController, _context.camera, a)), e.add(t, a), i.isShow ? (a.visible = !0, a.activeVisible = !0, !r.enableText && m && (m.visible = !1)) : (a.visible = !1, a.activeVisible = !1, m && (m.visible = !1)), n && n(1, p) })) }, this.addInstancedODLine = function (t, i, r, n) { if (!(i.points instanceof Array)) return; let a, o, s, l; a = new Vector3(0, 0, 0), l = new Vector3(1, 0, 1), o = new Vector3, s = new Vector3; var c = l.clone().add(a.clone().divideScalar(-1)); o.lerpVectors(a, l, .25), s.lerpVectors(a, l, .75), o.setY(o.y + c.length() * parseFloat(i.curvatureCoefficient / 100)), s.setY(s.y + c.length() * parseFloat(i.curvatureCoefficient / 100)); let h = new CubicBezierCurve3(a, o, s, l); var u = h.getPoints(32), d = h.getPointAt(.5); let p = []; u.forEach((e => { p.push(e.x), p.push(e.y), p.push(e.z) })); let f = [], m = {}; for (let e of i.points) "string" == typeof e.imageType && (f.includes(e.imageType) || f.push(e.imageType), m[e.imageType] || (m[e.imageType] = []), m[e.imageType].push(e)); var g = new Group; g.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0), g.name = t, new CircleGeometry(1, 32).rotateX(Math.PI / -2); for (let e of f) { let r = "texture/odline/" + e.toLowerCase() + ".jpg"; _context.loaders.textureLoader.load(util$1.url(this.resourceBasePath, r), (r => { r.wrapS = RepeatWrapping, r.wrapT = RepeatWrapping; util$1.interpolate(p, 3, 0, !0); i.lineWidth, _context.worldScale, r.image.height, r.image.width, "default" === e.toLowerCase() || e.toLowerCase(); var a = new MeshBasicMaterial({ color: new Color$1(16776960) }), o = new THREE_MeshLine.MeshLine; o.setGeometry(u); let s = new InstancedMesh(o, a, INSTANCE_COUNT_MAX); s.count = m[e].length, s.name = t, s.onBeforeRender = function () { this.userData.inView = !0 }, s.instanceMatrix.setUsage(DynamicDrawUsage); let l = new Object3D; for (let t = 0; t < m[e].length; t++) { let i = m[e][t]; l.scale.set(i.endPos.x - i.startPos.x, 0, i.endPos.z - i.startPos.z), l.scale.y = Math.sqrt(l.scale.x * l.scale.x + l.scale.z * l.scale.z), l.position.set(i.startPos.x, i.startPos.y, i.startPos.z), l.updateMatrix(), s.setMatrixAt(t, l.matrix.clone()), s.setColorAt(t, new Color$1(i.color)) } s.instanceColor.needsUpdate = !0, s.instanceMatrix.needsUpdate = !0, g.add(s), g.userData.mesh = s, n && n(1, d) })) } e.add(t, g) }, this.addHeatMapLayer = function (t, i) { var r = document.createElement("canvas"); 0 == i.opacity && (i.opacity = 1e-7); var n = heatmap.create({ container: r, gradient: i.gradient, opacity: i.opacity, radius: 10, blur: .75, width: i.width, height: i.height }), a = r.getElementsByTagName("canvas")[0]; let o = new PlaneGeometry(i.width, i.height), s = new Texture$1(a), l = new ShaderMaterial({ fog: DRAWABLE_FOG, uniforms: { map: { value: s }, bgMap: { value: u }, color: { value: new Color$1(1, 1, 1) }, brightness: { value: 1 } }, vertexShader: HeatmapShader.vertexShader, fragmentShader: HeatmapShader.fragmentShader, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, transparent: !0 }); if ("dot" === i.style) { var c = _context.loaders.textureLoader.load(util$1.url(this.resourceBasePath, "texture/heatmap/heatmap-dot.png")); c.wrapS = RepeatWrapping, c.wrapT = RepeatWrapping, l.uniforms.bgMap.value = c } else if ("line" === i.style) { var h = _context.loaders.textureLoader.load(util$1.url(this.resourceBasePath, "texture/heatmap/heatmap-line.png")); h.wrapS = RepeatWrapping, h.wrapT = RepeatWrapping, l.uniforms.bgMap.value = h } else { var u = _context.loaders.textureLoader.load(util$1.url(this.resourceBasePath, "texture/heatmap/heatmap-none.png")); u.wrapS = RepeatWrapping, u.wrapT = RepeatWrapping, l.uniforms.bgMap.value = u } l.uniforms.map.value.needsUpdate = !0; var d = new Mesh(o, l); d.onBeforeRender = function () { this.userData.inView = !0 }, d.name = t, d.rotation.x = -Math.PI / 2 + i.rotation.x, d.rotation.y = i.rotation.y, d.rotation.z = i.rotation.z, d.position.set(i.pos.x, i.pos.y, i.pos.z), null != i.enableAutoHidebyDistance && (d.activeVisible = !0, d.enableAutoHidebyDistance = i.enableAutoHidebyDistance, d.minDistance = i.minDistance * _context.worldScale, d.maxDistance = i.maxDistance * _context.worldScale, _context.animationStore.addDistance(t, DistanceController, _context.camera, d)); let p = new Group; p.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0), p.name = t, p.add(d), p.userData = { dom: a, heatmap: n, plane: d }, e.add(t, p), i.isShow ? (p.activeVisible = !0, p.visible = !0) : (p.activeVisible = !1, p.visible = !1) }, this.updateHeatMapData = function (t, i, r, n, a = 1) { var o = e.find(t); if (null != o.userData) { var s = o.userData.heatmap; null != s && s.setData({ min: i, max: r, data: n }); var l = o.userData.plane; l.scale.set(a * _context.worldScale, a * _context.worldScale, a * _context.worldScale); var c = o.userData.dom; if (null != l && null != c) { let e = new Texture$1(c); l.material.uniforms.map.value = e, l.material.uniforms.map.value.needsUpdate = !0 } } }, this.addArea = function (t, i, r, n) { if (i.areaType) return void K.call(this, t, i, r, n); var a = new Group; a.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof i.renderOrder ? i.renderOrder : 0), a.name = t; for (var o = [], s = 0; s < i.point.length; s += 2)o.push(new Vector2(i.point[s], i.point[s + 1])); o.push(new Vector2(i.point[0], i.point[1])); var l, c, h = new Shape(o), u = { depth: i.depth * _context.worldScale, bevelEnabled: !1, bevelSegments: 1, steps: 1, bevelSize: 1, bevelThickness: 10 }, d = new Mesh(new ExtrudeGeometry(h, u), new MeshBasicMaterial({ fog: DRAWABLE_FOG, transparent: !0, color: new Color$1(i.color), shininess: 0, opacity: i.alpha, depthWrite: !0, depthTest: _context.drawableDepthTest, depthFunc: AlwaysDepth })); d.onBeforeRender = function () { this.userData.inView = !0 }, d.name = t, a.add(d), d.geometry.computeBoundingSphere(), d.updateMatrixWorld(!0), null != d.geometry.boundingSphere && (l = d.geometry.boundingSphere.center), c = i.followPolygonColor ? new Color$1(i.color) : new Color$1(i.lineColor); var p = new LineMaterial({ fog: DRAWABLE_FOG, opacity: i.lineAlpha, color: c, linewidth: i.lineWidth * _context.worldScale, dashed: !1, depthWrite: _context.drawableDepthTest, depthTest: _context.drawableDepthTest, transparent: !0 }); i.lineFlag || (p.visible = !1); for (var f = new LineGeometry, m = [], g = 0; g < o.length; g++)m.push(o[g].x), m.push(o[g].y), m.push(0); f.setPositions(m); var y = new Line2(f, p); y.computeLineDistances(), y.scale.set(1, 1, 1), y.name = t, a.add(y); var v = null; null != r && r.enableText && ((v = coreUtil.createText(a, r)).name = t, v.position.set(l.x, l.y, l.z)), a.rotation.set(.5 * Math.PI, 0, 0), i.offset && a.position.set(i.lonOffset, i.altOffset, i.latOffset), null != i.enableAutoHidebyDistance && (a.activeVisible = !0, a.enableAutoHidebyDistance = i.enableAutoHidebyDistance, a.minDistance = i.minDistance * _context.worldScale, a.maxDistance = i.maxDistance * _context.worldScale, _context.animationStore.addDistance(t, DistanceController, _context.camera, a)); let _ = _context.animationStore.findNodeAnimation(t, AreaLineAnimationController.type); _ && _context.animationStore.remove(_); let b = new Vector2(window.innerWidth, window.innerHeight); _ = new AreaLineAnimationController(p, b), _context.animationStore.add(_), e.add(t, a), i.isShow ? (a.activeVisible = !0, a.visible = !0, !r.enableText && v && (v.visible = !1)) : (a.activeVisible = !1, a.visible = !1, v && (v.visible = !1)) }, this.removeLayer = function (t) { var i = t.substr(t.lastIndexOf("/") + 1, t.length - t.lastIndexOf("/")); "trail" != i && "modeltrail" !== i || (e.remove(t + "Line"), _context.animationStore.remove(_context.animationStore.findNodeAnimation(t + "Line", DistanceController.type)), _context.animationStore.remove(_context.animationStore.findNodeAnimation(t, TrailAnimationController.type)), C.remove(t)), "area" == i && _context.animationStore.remove(_context.animationStore.findNodeAnimation(t, AreaLineAnimationController.type)), "odline" == i && _context.animationStore.remove(_context.animationStore.findNodeAnimation(t, ODLineRollingAnimationController.type)), "bubble" == i && _context.animationStore.remove(_context.animationStore.findNodeAnimation(t, NodeScaleAnimationController.type)), "instancedbubble" == i && this.removeInstancedBubble(t), e.remove(t), _context.animationStore.remove(_context.animationStore.findNodeAnimation(t, DistanceController.type)); for (const e in j) { const i = j[e], r = i.objectNames.indexOf(t); if (-1 !== r) { if (i.objectNames.splice(r, 1), e.includes("/icons/universal/pin.png") || e.includes("/icons/universal/none.png")) continue; i.objectNames.length <= 0 && (i.map.dispose(), delete j[e]) } } }, this.showLayer = function (t) { e.find(t) && (e.find(t).visible = !0, e.find(t).activeVisible = !0) }, this.hideLayer = function (t) { e.find(t) && (e.find(t).visible = !1, e.find(t).activeVisible = !1) }, this.addFireworks = function (e) { e.type = "fireworks", this.defaultEffectStore.spaceEffect.addEffect(e) }, this.updateFireworks = function (e, t) { t.type = "fireworks", this.defaultEffectStore.spaceEffect.updateEffect(e, t) }, this.showFireworks = function (e) { this.defaultEffectStore.spaceEffect.showEffect(e) }, this.hideFireworks = function (e) { this.defaultEffectStore.spaceEffect.hideEffect(e) }, this.renameFireworks = function (e, t) { this.defaultEffectStore.spaceEffect.renameEffect(e, t) }, this.removeFireworks = function (e) { this.defaultEffectStore.spaceEffect.removeEffect(e) }, this.addFirefly = function (e) { e.type = "firefly", this.defaultEffectStore.spaceEffect.addEffect(e) }, this.addFireFly = function (e) { return this.addFirefly(e) }, this.updateFirefly = function (e, t) { t.type = "firefly", this.defaultEffectStore.spaceEffect.updateEffect(e, t) }, this.updateFireFly = function (e, t) { return this.updateFirefly(e, t) }, this.showFirefly = function (e) { this.defaultEffectStore.spaceEffect.showEffect(e) }, this.showFireFly = function (e) { return this.showFirefly(e) }, this.hideFirefly = function (e) { this.defaultEffectStore.spaceEffect.hideEffect(e) }, this.hideFireFly = function (e) { return this.hideFirefly(e) }, this.renameFirefly = function (e, t) { this.defaultEffectStore.spaceEffect.renameEffect(e, t) }, this.renameFireFly = function (e, t) { return this.renameFirefly(e, t) }, this.removeFirefly = function (e) { this.defaultEffectStore.spaceEffect.removeEffect(e) }, this.removeFireFly = function (e) { return this.removeFirefly(e) }, this.addRainline = function (e) { e.type = "rainline", this.defaultEffectStore.spaceEffect.addEffect(e) }, this.updateRainline = function (e, t) { t.type = "rainline", this.defaultEffectStore.spaceEffect.updateEffect(e, t) }, this.showRainline = function (e) { this.defaultEffectStore.spaceEffect.showEffect(e) }, this.hideRainline = function (e) { this.defaultEffectStore.spaceEffect.hideEffect(e) }, this.renameRainline = function (e, t) { this.defaultEffectStore.spaceEffect.renameEffect(e, t) }, this.removeRainline = function (e) { this.defaultEffectStore.spaceEffect.removeEffect(e) }, this.addRain = function (e) { e.type = "rain", this.defaultEffectStore.spaceEffect.addEffect(e) }, this.updateRain = function (e, t) { t.type = "rain", this.defaultEffectStore.spaceEffect.updateEffect(e, t) }, this.showRain = function (e) { this.defaultEffectStore.spaceEffect.showEffect(e) }, this.hideRain = function (e) { this.defaultEffectStore.spaceEffect.hideEffect(e) }, this.renameRain = function (e, t) { this.defaultEffectStore.spaceEffect.renameEffect(e, t) }, this.removeRain = function (e) { this.defaultEffectStore.spaceEffect.removeEffect(e) }, this.addSnow = function (e) { e.type = "snow", this.defaultEffectStore.spaceEffect.addEffect(e) }, this.updateSnow = function (e, t) { t.type = "snow", this.defaultEffectStore.spaceEffect.updateEffect(e, t) }, this.showSnow = function (e) { this.defaultEffectStore.spaceEffect.showEffect(e) }, this.hideSnow = function (e) { this.defaultEffectStore.spaceEffect.hideEffect(e) }, this.renameSnow = function (e, t) { this.defaultEffectStore.spaceEffect.renameEffect(e, t) }, this.removeSnow = function (e) { this.defaultEffectStore.spaceEffect.removeEffect(e) }, this.add3DMarker = function (e, t) { (new MarkerItem).load(e, ((i, r) => { _context.objectStore.add(e.name, r); let n = new Group; if (n.name = e.name + "title", r.add(n), e.canvas) { let t = coreUtil.createText(n, { canvas: e.canvas, sizeAttenuation: !1, width: 414e-6 * e.canvas.width, height: 414e-6 * e.canvas.height, offsetV: .5, offsetH: .5, enableText: !0 }); t.name = e.name, t.position.y = e.titleHeight * e.size } r.visible = e.isShow, r.activeVisible = e.isShow, _context.datumShiftModel && "ecef" === _context.datumShiftModel.type && (r.rotation.order = "YXZ", r.rotation.y = (e.pos.lon + 90) / 180 * Math.PI, r.rotation.x = (90 - e.pos.lat) / 180 * Math.PI), t && t(i, r) })) }, this.update3DMarker = function (t, i, r) { let n = e.find(t); if (n.children[0].path !== i.path) this.removeLayer(t), this.add3DMarker(i, r); else { n.remove(n.children[n.children.length - 1]); let e = new Group; if (e.name = i.name + "title", n.add(e), i.canvas) { let t = coreUtil.createText(e, { canvas: i.canvas, sizeAttenuation: !1, width: 414e-6 * i.canvas.width, height: 414e-6 * i.canvas.height, offsetV: .5, offsetH: .5, enableText: !0 }); t.name = i.name, t.position.y = i.titleHeight * i.size } n.position.set(i.position[0], i.position[1], i.position[2]), n.children[0].scale.set(i.size, i.size, i.size), n.traverse((e => { e.isMesh && (i.opacity < .99 ? e.material.transparent = !0 : e.material.transparent = e.userData.transparent, e.material.opacity = i.opacity) })), r && r(1, n) } }, this.addAnimatedSprite = (e = {}, t) => { e.url && _context.loaders.textureLoader.load(e.url, (i => { let r = new SpriteMaterial({ map: i, depthTest: !!e.depthTest }); r.rotation = MathUtils.degToRad(e.rotation || 0); let n = new AnimatedSprite(r, { dimension: e.dimension, duration: e.duration, fadeInFrame: e.fadeInFrame, fadeOutFrame: e.fadeOutFrame, loop: e.loop, destroyOnFinish: !!e.destroyOnFinish }); n.name = e.name || util$1.randomString(8), e.center = e.center || [.5, .5], e.position = e.position || { x: 0, y: 0, z: 0 }, e.scale = e.scale || { x: 1, y: 1, z: 1 }, n.center.set(e.center[0], e.center[1]), n.scale.setScalar(e.scale), _context.animationStore.add(n); const a = new Group; a.name = e.name, a.add(n), a.position.set(e.position.x, e.position.y, e.position.z); const o = new Group; if (o.name = e.name + "title", a.add(o), e.canvas) { let t = coreUtil.createText(o, { canvas: e.canvas, sizeAttenuation: !1, width: 414e-6 * e.canvas.width, height: 414e-6 * e.canvas.height, offsetV: .5, offsetH: .5, enableText: !0 }); t.name = e.name, t.position.y = e.titleHeight * e.scale, t.renderOrder = DRAWABLE_RENDER_ORDER_BASE + ("number" == typeof e.zLevel ? e.zLevel : 0) } a.visible = e.isShow, a.activeVisible = e.isShow, _context.objectStore.add(a.name, a), e.autoPlay && n.play(), "function" == typeof t && t() })) }, this.getStatistics = () => _context.renderer ? _context.rendererInfo : { fps: 0, geometries: 0, textures: 0, calls: 0, faces: 0, vertices: 0 }, this._onWebContextLost = () => { document.getElementById("panel").innerHTML = "<p>场景显示异常,请刷新重试！</p>", clearInterval(O), O = null }, this._findFpsValueElement = (e, t) => { let i = e.getElementsByClassName(t); if (!i.length) return e; let r = i[0].children.length; return r ? i[0].children[r - 1] : i[0] }, this.fpsPanelOn = () => { let e = document.createElement("div"); e.setAttribute("id", "panel"), e.className = "fps-panel", e.innerHTML = '<p style="margin-left: 50px;float: left;" class="fps"><label class="fps-label"><span class="fps-span">帧率</span><spap>：</span></label><span class="fps-value">0</span></p><p style="margin-left: 20px;float: left;" class="faces"><label class="fps-label"><span class="fps-span">三角面数</span><spap>：</span></label><span class="fps-value">0</span></p><p style="margin-left: 20px;float: left;" class="vertices"><label class="fps-label"><span class="fps-span">顶点数</span><spap>：</span></label><span class="fps-value">0</span></p><p style="margin-left: 20px;float: left;" class="calls"><label class="fps-label"><span class="fps-span">绘制调用</span><spap>：</span></label><span class="fps-value">0</span></p>', e.style = "position: absolute;\n                      min-width: 543px;\n                      max-width: 80%;\n                      padding: 0 10px;\n                      height: 32px;\n                      left: 50%;\n                      transform: translateX(-50%);\n                      bottom: 20px;\n                      border-radius:8px;\n                      background-color: rgba(0,0,0,0.5);\n                      line-height: 32px;\n                      font-size: 14px;\n                      color: #CCCCCC;", this.container.appendChild(e); let t = document.getElementsByClassName("fps-panel")[0], i = this._findFpsValueElement(t, "fps"), r = this._findFpsValueElement(t, "faces"), n = this._findFpsValueElement(t, "vertices"), a = this._findFpsValueElement(t, "calls"); O = setInterval((() => { let e = this.getStatistics(), t = util$1.formatWithRegex(e.fps); i.innerText = t, Number(t || 0) < 15 ? (i.classList.remove("is-normal"), i.classList.add("is-low")) : (i.classList.remove("is-low"), i.classList.add("is-normal")), r.innerText = util$1.formatWithRegex(e.faces), n.innerText = util$1.formatWithRegex(e.vertices), a.innerText = util$1.formatWithRegex(e.calls) }), 1e3), _context && _context.renderer && _context.renderer.getContext() && _context.renderer.getContext().canvas && _context.renderer.getContext().canvas.removeEventListener && _context.renderer.getContext().canvas.removeEventListener("webglcontextlost", this._onWebContextLost, !1), _context && _context.renderer && _context.renderer.getContext() && _context.renderer.getContext().canvas && _context.renderer.getContext().canvas.addEventListener && _context.renderer.getContext().canvas.addEventListener("webglcontextlost", this._onWebContextLost, !1) }, this.fpsPanelOff = () => { clearInterval(O), O = null, document.getElementById("panel") && document.getElementById("panel").remove(), _context && _context.renderer && _context.renderer.getContext() && _context.renderer.getContext().canvas && _context.renderer.getContext().canvas.removeEventListener && _context.renderer.getContext().canvas.removeEventListener("webglcontextlost", this._onWebContextLost, !1) }, this.leftButtonHandle = e => { _context.orbitControls.keyOperate = e }, this.autoRotate = (e, t = !0, i) => { let r = util$1.isNumber(e) && 0 !== e; r && t ? _context.orbitControls.addEventListener("start", this.interruptCameraFly) : _context.orbitControls.removeEventListener("start", this.interruptCameraFly), _context.autoRotateChange = i, _context.orbitControls.autoRotate = r, _context.orbitControls.autoRotateSpeed = e }, this.setAutoRotate = function (e, t, i, r) { e ? this.autoRotate(t, i, r) : this.autoRotate(0) }, this.addDirectionalLight = e => { logger.debug("TRACE: Core.addDirectionalLight() - Entering.", e), _context.lightStore.setDirectionalLight(e), logger.debug("TRACE: Core.addDirectionalLight() - Leaving.", e) }, this.setDirectionalLight = e => { logger.debug("TRACE: Core.setDirectionalLight() - Entering.", e); let t = JSON.parse(JSON.stringify(e)); _context.lightStore.setDirectionalLight(t), logger.debug("TRACE: Core.setDirectionalLight() - Leaving.", e) }, this.removeDirectionalLight = e => { logger.debug("TRACE: Core.removeDirectionalLight() - Entering.", e), _context.lightStore.removeDirectionalLight(e), logger.debug("TRACE: Core.removeDirectionalLight() - Leaving.", e) }, this.exportScene = (e, t, i) => { if (logger.debug("TRACE: Core.exportScene() - Entering."), !g.dhExporter) return void logger.error("未定义导出器，无法导出。"); let r; r = i && "number" == typeof i.maxTextureSize ? i.maxTextureSize : 1 / 0, g.dhExporter.exportBlob({ type: "glb", maxTextureSize: r, onFinish: e, onError: t }), logger.debug("TRACE: Core.exportScene() - Leaving.") }, this.showLightHelpers = () => { logger.debug("TRACE: Core.showLightHelpers() - Entering."), _context.lightStore.showLightHelpers(), logger.debug("TRACE: Core.showLightHelpers() - Leaving.") }, this.hideLightHelpers = () => { logger.debug("TRACE: Core.hideLightHelpers() - Entering."), _context.lightStore.hideLightHelpers(), logger.debug("TRACE: Core.hideLightHelpers() - Leaving.") }, this.convertWorldToScreen = e => { var t = new Vector3(e.x, e.y, e.z).project(_context.camera), i = this.container.clientWidth / 2, r = this.container.clientHeight / 2; return { x: Math.round(t.x * i + i), y: Math.round(-t.y * r + r) } }, this.convertScreenToWorld = ({ x: e, y: t, z: i = .5 }, r) => { const n = e / _context.renderer.domElement.clientWidth * 2 - 1, a = -t / _context.renderer.domElement.clientHeight * 2 + 1, o = new Vector3(n, a, i).unproject(_context.camera); void 0 !== r && r.copy(o); const s = _context.camera.position.clone(), l = o.clone().sub(s).normalize(), c = new Ray(o, l), h = new Plane(new Vector3(0, 1, 0), 0); let u = new Vector3; return c.intersectPlane(h, u), u }, this.convertNDCToWorld = (e, t) => { const i = e.x, r = e.y; if ("string" == typeof t) switch (t.toLowerCase()) { case "cameraortho": case "ortho": case "orthocamera": case "orthographic": case "orthographiccamera": t = _context.cameraOrtho; break; case "camera": case "perspective": case "perspectivecamera": default: t = _context.camera }t instanceof PerspectiveCamera || t instanceof OrthographicCamera || (t = _context.camera); return new Vector3(i, r, .5).unproject(t) }, this.pickScreenToWorld = e => { const t = e.x, i = e.y; let r = new Vector2(t / this.container.scrollWidth * 2 - 1, -i / this.container.scrollHeight * 2 + 1); w.setFromCamera(r, _context.camera); const n = [], a = _context.scene.getObjectByName("__models"); a && a.traverse((function (e) { n.push(e) })); const o = _context.scene.getObjectByName("__tilesGroup"); o && o.children[0] && n.push(o.children[0]); let s = w.intersectObjects(n); if (_context.scene.getObjectByName("__pgl") && _context.pgl.terrain) { let t = _context.pgl.terrain.pickTerrain({ x: e.x, y: e.y }); if (t && t.hit) { for (let e = 0; e < s.length; e++)if (s[e].distance > t.distance) { s.splice(e, 0, t); break } (0 === s.length || t.distance > s[s.length - 1].distance) && s.push(t) } } let l = []; for (let e = 0; e < s.length; e++) { if (!1 === s[e].object.visible || !1 === util$1.judegParentIsVisible(s[e].object)) continue; let t = util$1.findObjectToBuilding(s[e].object.uuid); if (t) { let i = _context.clippingStore.findCutBulidingByUUID(t.getGroup().uuid); if (i && i.clippingController.pointClipTest(s[e].point)) continue } l.push(s[e]) } if (l.length > 0) { var c = l[0]; if (c.distance >= 0) return c.point } return { x: 0, y: 0, z: 0, flag: !1 } }, this.pickNDCToWorld = (e, t) => { const i = e.x, r = e.y; let n = new Vector2(i, r); if ("string" == typeof t) switch (t.toLowerCase()) { case "cameraortho": case "ortho": case "orthocamera": case "orthographic": case "orthographiccamera": t = _context.cameraOrtho; break; case "camera": case "perspective": case "perspectivecamera": default: t = _context.camera }t instanceof PerspectiveCamera || t instanceof OrthographicCamera || (t = _context.camera), w.setFromCamera(n, t); let a = w.intersectObjects(_context.scene.models.children, !0); if (a.length > 0) { let e = -1; for (let t = 0; t < a.length; t++)if (a[t].object.visible) { e = t; break } if (-1 === e) return { x: 0, y: 0, z: 0 }; let t = a[0]; if (t.distance >= 0) return t.point } return { x: 0, y: 0, z: 0 } }, this.convertWorldToSceneLocal = e => { let t = new Vector4(e.x, e.y, e.z, 1), i = _context.scene.models.matrix.clone(); return i.invert(), t.applyMatrix4(i), { x: t.x, y: t.y, z: t.z } }, this.addModel = (e, t, i) => (logger.debug("TRACE: Core.addModel() - Entering.", e), this.resetSettings(), e = e || {}, logger.debug("TRACE: Core.addModel() - Leaving and return a Promise."), new Promise(((r, n) => { if (_context.loaders.gltfLoader || (t && t(0, "No loader initiated."), n(new Error("No loader initiated."))), e.name || (e.name = util$1.guid()), _context.modelStore.find(e.name)) return t && t(0, `Model with name ${e.name} already exists.`), void n(new Error(`Model with name ${e.name} already exists.`)); _context.cacheStore.load({ path: e.modelPath, type: "glb", onLoad: i => { i.name = e.name; const n = util$1.md5(e.modelPath); i.scene.sourceModelKey = n, i.scene.traverse((e => { if (util$1.capableForCastingShadow(e) && (A++, e.castShadow = !0, e.receiveShadow = !0), e.material instanceof MeshStandardMaterial) { e.material.alphaTest = .05, e.material.depthWrite = !0, e.material.depthTest = !0, e.material.vertexColors = !1, e.material.needsUpdate = !0; for (let t in e.material) e.material[t] instanceof Texture$1 && e.material[t].image && _context.textureStore.add(e.material[t].name || `${e.material.name}#${t}`, e.material[t], n); _context.materialStore.add(e.material.name, e.material, e) } })), t && t(1), r(), setTimeout((() => { this.focus() }), 500) }, onProgress: i, onError: e => { t ? t(0, e) : logger.debug(e), n(e) } }) }))), this.rankUpNode = (e, t) => { this.defaultObjectTree.rankUp(e, t) }, this.rankDownNode = (e, t) => { this.defaultObjectTree.rankDown(e, t) }, this.preloadScene = (e, t, i, r) => { if (!_context.sceneStore.findScene(e.serviceName)) return logger.debug("TRACE: Core.preloadScene() - Entering.", e), (e = e || {}).token && e.token.length > 64 && this.setAvwToken("header", "authorization:bearer", e.token), new Promise(((n, a) => { e.scenePath && "" != e.scenePath || a("场景预载失败：params.scenePath为空！"); let o = "glb"; if (e.scenePath.indexOf("http") > -1 || e.scenePath.indexOf("https") > -1) o = "avws"; else { let t = e.scenePath.lastIndexOf("."); o = e.scenePath.substr(t + 1) } _context.cacheStore.load({ path: e.scenePath, type: o, onLoad: () => { _context.sceneStore.addOrUpdateScene({ serviceName: e.serviceName, scenePath: e.scenePath, token: e.token }), t && t({ result: 1, message: "场景预载完毕。" }), r && r({ name: e.serviceName, default: !1 }), n() }, onProgress: e => { i && i({ type: "progress", total: e.total, loaded: e.loaded }) }, onError: i => { t ? t({ result: 0, message: `场景预载失败：${e.scenePath}` }) : logger.warn(`场景预载失败：${e.scenePath}`), a(`场景预载失败：${e.scenePath}`) } }) })); t && t({ result: 0, message: "服务已存在!" }) }, this.preloadResource = (e, t, i, r, { needExport: n = !1, newImport: a = !1 } = {}) => { logger.debug("TRACE: Core.preloadResource() - Entering.", e), logger.debug("TRACE: Core.preloadResource() - Leaving and return a Promise."), _context.preloads || (_context.preloads = []); for (let t = 0; t < _context.preloads.length; t++)if (_context.preloads[t].key === e) return void _context.preloads[t].callback.push(i); _context.preloads.push({ key: e, total: 0, loaded: 0, status: 0, callback: [i] }), _context.cacheStore.load({ path: e, type: t, needExport: n, newImport: a, onLoad: () => { for (let t = 0; t < _context.preloads.length; t++)if (_context.preloads[t].key === e) { _context.preloads[t].status = 1; break } let t = !0; for (let e = 0; e < _context.preloads.length; e++)0 === _context.preloads[e].status && (t = !1); if (t) { for (let t = 0; t < _context.preloads.length; t++)1 === _context.preloads[t].status ? _context.preloads[t].callback.forEach((t => { "function" == typeof t && t(1, `资源预载成功。${e}`) })) : -1 === _context.preloads[t].status && _context.preloads[t].callback.forEach((t => { "function" == typeof t && t(0, `资源预载失败。${e}`) })); _context.preloads.length = 0 } }, onProgress: t => { for (let i = 0; i < _context.preloads.length; i++)if (_context.preloads[i].key === e) { _context.preloads[i].total = t.total, _context.preloads[i].loaded = t.loaded; break } if (r) { let e = 0, t = 0; for (let i = 0; i < _context.preloads.length; i++)e += _context.preloads[i].total, t += _context.preloads[i].loaded; r({ type: "progress", total: e, loaded: t }) } }, onError: t => { for (let t = 0; t < _context.preloads.length; t++)if (_context.preloads[t].key === e) { _context.preloads[t].status = -1; break } let r = !0; for (let e = 0; e < _context.preloads.length; e++)0 === _context.preloads[e].status && (r = !1); if (r) { if ("function" == typeof i) { let e = 0, t = 0; for (let i = 0; i < _context.preloads.length; i++)1 === _context.preloads[i].status && e++, -1 === _context.preloads[i].status && t++; 0 === e ? i(0, "资源预载失败。") : i(1, 0 === t ? "资源预载成功。" : "部分资源预载失败。") } _context.preloads.length = 0 } } }) }, this.materialReplace = ({ path: e, material: t, onLoad: i, onProgress: r, newImport: n = !1 }, a, o) => { const s = util$1.md5(e); this.preloadResource(e, "avwa", (() => { let r = null, n = null, l = _context.cacheStore._cache.get(md5(e)); l.refCount <= 1 && (l.refCount = 2), l.resource.traverse((e => { e.material && !r && (r = e.material.clone()), e.userData && e.userData.dhAsset && !n && (n = e.userData.dhAsset) })); for (let e in r) r[e] instanceof Texture$1 && r[e].image && _context.customTextureStore.add(r[e].name || `${r.name}#${e}`, r[e], s); let c = JSON.parse(JSON.stringify(n.materials[r.name])); t.replace(r, e), c && (c.name = t.name, _context.materialStore.setMaterialParam({ [c.name]: c }, c.name, t, a, o)), i && i() }), (e => { r && r(e) }), { needExport: !0, newImport: n }) }, this.loadScene = (e, t, i) => (logger.debug("TRACE: Core.loadScene() - Entering.", e), e = e || {}, logger.debug("TRACE: Core.loadScene() - Leaving and return a Promise."), new Promise(((r, n) => { e.name || (e.name = util$1.guid()), this.defaultObjectTree.loadModel({ name: e.name, modelPath: e.scenePath, secretKey: e.secretKey }, ((i, n) => { if ("20220602-NEW-AVWS" === n.VERSION) { _context.sceneStore.addOrUpdateScene({ serviceName: e.serviceName, scenePath: e.scenePath, token: e.token, scene: _context.scene, defaultScene: e.default || !1 }), n && (_context.sceneSettings = util$1.cloneDeep(n), null != n.sceneName && (_context.sceneName = n.sceneName)), this.setColorSpace(_context.sceneSettings.colorSpace || "linear"); let i = _context.sceneSettings, a = null; a = _context.sceneSettings.states && _context.sceneSettings.states.length ? JSON.parse(JSON.stringify(_context.sceneSettings.states.find((e => e.defaultState)).settings.view)) : JSON.parse(JSON.stringify(i.view)), _context.stateStore && _context.stateStore.applySettings(_context.sceneSettings.states); let o = []; o.push(new Promise((e => { this.defaultView.applySettings(a, (t => { e(t) }), !0) }))), T = i && i.lights ? i.lights.skybox : "", i.background && (_context.background.mode = i.background.mode), _context.background.color = null, _context.background.texture = null, o.push(new Promise((e => { _context.lightStore.applySettings(i.lights, (() => { e() }), i.view.camera.duration) }))), i.background && (i.background.colorCSSValue && this.setBackgroundColor(i.background.colorCSSValue), i.background.textureURL && this.setBackgroundImage(i.background.textureURL), i.background.mode && this.setBackgroundMode(i.background.mode, i)), null != _context.sceneSettings.sceneModelTransform && null != _context.sceneSettings.sceneModelTransform.position ? (_context.scene.models.position.x = _context.sceneSettings.sceneModelTransform.position.x, _context.scene.models.position.y = _context.sceneSettings.sceneModelTransform.position.y, _context.scene.models.position.z = _context.sceneSettings.sceneModelTransform.position.z, _context.scene.models.rotation._order = _context.sceneSettings.sceneModelTransform.rotation._order, _context.scene.models.rotation._x = _context.sceneSettings.sceneModelTransform.rotation._x, _context.scene.models.rotation._y = _context.sceneSettings.sceneModelTransform.rotation._y, _context.scene.models.rotation._z = _context.sceneSettings.sceneModelTransform.rotation._z, _context.scene.models.scale.x = _context.sceneSettings.sceneModelTransform.scale.x, _context.scene.models.scale.y = _context.sceneSettings.sceneModelTransform.scale.y, _context.scene.models.scale.z = _context.sceneSettings.sceneModelTransform.scale.z) : (_context.scene.models.position.x = 0, _context.scene.models.position.y = 0, _context.scene.models.position.z = 0, _context.scene.models.rotation._order = "XYZ", _context.scene.models.rotation._x = 0, _context.scene.models.rotation._y = 0, _context.scene.models.rotation._z = 0, _context.scene.models.scale.x = 1, _context.scene.models.scale.y = 1, _context.scene.models.scale.z = 1), this.defaultEffectStore.applySettings(i.effects, (e => { r(e) })), _context.sceneSettings.datumShiftModel ? (this.setDatumShiftModel(_context.sceneSettings.datumShiftModel), "number" == typeof _context.sceneSettings.datumShiftModel.scaleY ? _context.worldScale = _context.sceneSettings.datumShiftModel.scaleX : _context.worldScale = 1) : _context.worldScale = 1, Promise.all(o).then((e => { _context.hasUpgradeSuggest && PerformanceSuggest.checkSuggestOn(), t && t(1) })), this.defaultObjectTree.children.forEach((e => { if ("BuildingItem" === e.type && (e.children.forEach((e => { e.level && e.hide() })), e.floor)) { this.cutLevel(e.getGroup().uuid, e.floor); for (let t = 0; t < z.length; t++)z[t].uuid === e.getGroup().uuid && (z.splice(t, 1), t--); z.push({ uuid: e.getGroup().uuid, level: e.floor }) } })) } else { _context.sceneStore.addOrUpdateScene({ serviceName: e.serviceName, scenePath: e.scenePath, token: e.token, scene: _context.scene, defaultScene: e.default || !1 }), n && (_context.sceneSettings = util$1.cloneDeep(n), null != n.sceneName && (_context.sceneName = n.sceneName)), this.setColorSpace(_context.sceneSettings.colorSpace || "linear"); let i = _context.sceneSettings, a = null; a = _context.sceneSettings.states && _context.sceneSettings.states.length ? JSON.parse(JSON.stringify(_context.sceneSettings.states.find((e => e.defaultState)).settings.view)) : JSON.parse(JSON.stringify(i.view)), _context.stateStore && _context.stateStore.applySettings(_context.sceneSettings.states); let o = []; o.push(new Promise((e => { this.defaultView.applySettings(a, (t => { e(t) }), !0) }))), T = i && i.lights ? i.lights.skybox : "", this.defaultObjectTree.applySettings(i.objectTree), i.background && (_context.background.mode = i.background.mode), _context.background.color = null, _context.background.texture = null, o.push(new Promise((e => { _context.lightStore.applySettings(i.lights, (() => { e() }), i.view.camera.duration) }))), i.background && (i.background.colorCSSValue && this.setBackgroundColor(i.background.colorCSSValue), i.background.textureURL && this.setBackgroundImage(i.background.textureURL), i.background.mode && this.setBackgroundMode(i.background.mode, i)), null != _context.sceneSettings.sceneModelTransform && null != _context.sceneSettings.sceneModelTransform.position ? (_context.scene.models.position.x = _context.sceneSettings.sceneModelTransform.position.x, _context.scene.models.position.y = _context.sceneSettings.sceneModelTransform.position.y, _context.scene.models.position.z = _context.sceneSettings.sceneModelTransform.position.z, _context.scene.models.rotation._order = _context.sceneSettings.sceneModelTransform.rotation._order, _context.scene.models.rotation._x = _context.sceneSettings.sceneModelTransform.rotation._x, _context.scene.models.rotation._y = _context.sceneSettings.sceneModelTransform.rotation._y, _context.scene.models.rotation._z = _context.sceneSettings.sceneModelTransform.rotation._z, _context.scene.models.scale.x = _context.sceneSettings.sceneModelTransform.scale.x, _context.scene.models.scale.y = _context.sceneSettings.sceneModelTransform.scale.y, _context.scene.models.scale.z = _context.sceneSettings.sceneModelTransform.scale.z) : (_context.scene.models.position.x = 0, _context.scene.models.position.y = 0, _context.scene.models.position.z = 0, _context.scene.models.rotation._order = "XYZ", _context.scene.models.rotation._x = 0, _context.scene.models.rotation._y = 0, _context.scene.models.rotation._z = 0, _context.scene.models.scale.x = 1, _context.scene.models.scale.y = 1, _context.scene.models.scale.z = 1), this.defaultEffectStore.applySettings(i.effects, (e => { r(e) })), _context.sceneSettings.datumShiftModel ? (this.setDatumShiftModel(_context.sceneSettings.datumShiftModel), "number" == typeof _context.sceneSettings.datumShiftModel.scaleY ? _context.worldScale = _context.sceneSettings.datumShiftModel.scaleX : _context.worldScale = 1) : _context.worldScale = 1, _context.sceneSettings.objectTree.children.forEach((e => { "TileSetItem" === e.type && o.push(new Promise((t => { new TileSetItem(e, (e => { t(e) })) }))) })), Promise.all(o).then((e => { _context.hasUpgradeSuggest && PerformanceSuggest.checkSuggestOn(), t && t(1) })), this.defaultObjectTree.children.forEach((e => { if ("BuildingItem" === e.type && (e.children.forEach((e => { e.level && e.hide() })), e.floor)) { this.cutLevel(e.getGroup().uuid, e.floor); for (let t = 0; t < z.length; t++)z[t].uuid === e.getGroup().uuid && (z.splice(t, 1), t--); z.push({ uuid: e.getGroup().uuid, level: e.floor }) } })) } }), (e => { i && i({ type: "progress", total: e.total, loaded: e.loaded }) })), r(), setTimeout((() => { this.focus() }), 500) }), (e => { t && t(0, "读取场景失败。"), logger.warn("读取场景失败。"), reject("读取场景失败。") }))), this.calibrateCoordinate = e => { e ? this.switchCameraMode(1) : this.switchCameraMode(0) }, this.setCalibrateCoordinateParams = e => { if (e.editor) if ("none" !== e.editor.mode) if ("basepoint" !== e.editor.mode) if ("map" !== e.editor.mode) _context.datumShiftModel = {}; else { if (!(e && e.center && e.bounds && e.bounds.sw && e.bounds.ne)) return; if ("number" != typeof e.center.lon || "number" != typeof e.center.lat) return; if ("number" != typeof e.bounds.sw.lon || "number" != typeof e.bounds.sw.lat) return; if ("number" != typeof e.bounds.ne.lon || "number" != typeof e.bounds.ne.lat) return; let t = { lon: e.center.lon, lat: e.center.lat, alt: e.center.alt || 0, x: 0, y: 0, z: 0 }, i = { lon: e.bounds.sw.lon, lat: e.bounds.sw.lat, x: 0, z: 0 }; e.bounds.ne.lon, e.bounds.ne.lat; let r = this.convertNDCToWorld({ x: 0, y: 0 }, _context.cameraOrtho), n = this.convertNDCToWorld({ x: -1, y: -1 }, _context.cameraOrtho), a = this.convertNDCToWorld({ x: 1, y: 1 }, _context.cameraOrtho); r.divideScalar(_context.scene.models.scale.x), n.divideScalar(_context.scene.models.scale.x), a.divideScalar(_context.scene.models.scale.x), t.x = r.x, t.y = r.y, t.z = r.z, i.x = n.x, i.z = n.z; let o = util$1.lonLatToWebMercator(t.lon, t.lat), s = util$1.lonLatToWebMercator(i.lon, i.lat), l = 2 * (o.y - s.y) / (n.z - a.z), c = 1 / l, h = { x: o.x - l * r.x, y: o.y + l * r.z }; h.y += .75 / c; let u = util$1.webMercatorToLonLat(h.x, h.y), d = u.lon, p = u.lat; this.setDatumShiftModel({ type: "mercator", lon: 0 - h.x, lat: h.y, alt: 0 - t.alt, scaleX: c, scaleY: c * e.editor.YScale, scaleZ: c, origin: [d, p], editor: { mode: "map", lon: e.center.lon, lat: e.center.lat, alt: e.center.alt || 0, rotation: this.getSceneRotationY(), scale: c, mapOperateMode: "default", mapCenter: [e.editor.mapCenter[0], e.editor.mapCenter[1]], mapZoom: e.editor.mapZoom, YScale: e.editor.YScale } }) } else this.setDatumShiftModel({ type: e.type, lon: e.lon, lat: e.lat, alt: e.alt, scaleX: e.scaleX, scaleY: e.scaleY, scaleZ: e.scaleZ, editor: { mode: "basepoint" } }); else _context.datumShiftModel = { editor: { mode: "none" } }; else logger.warn("setCalibrateCoordinateParams() 无效的参数。") }, this.setBackgroundMode = (e, t = {}) => { if (_context.scene) { if (_context.scene && _context.scene.background && _context.scene.background.isColor) switch (_context.background.color = _context.scene.background, _context.renderer.outputEncoding) { case sRGBEncoding: _context.background.color.convertLinearToSRGB && _context.background.color.convertLinearToSRGB(); break; case GammaEncoding: _context.background.color.convertLinearToGamma && _context.background.color.convertLinearToGamma() }switch (_context.scene && _context.scene.background && _context.scene.background instanceof Texture$1 && !(_context.scene.background instanceof CubeTexture) && (_context.background.texture = _context.scene.background), _context.scene && _context.scene.background && _context.scene.background instanceof CubeTexture && (_context.background.cubeTexture = _context.scene.background), "none" === e && (k = null), _context.background.mode = e, e.toLowerCase()) { case "none": if (_context.lightStore.disableLightProbe(), !_context.scene) return; _context.scene.background = null, _context.scene && !_context.scene.environment && t.lights && t.lights.skybox && this.setBackgroundSkybox(J(`texture/cubemap/sdr/${t.lights.skybox}/`), "jpg"); break; case "color": if (_context.lightStore.disableLightProbe(), _context.scene && _context.background.color && _context.background.color.isColor) { if (!_context.scene) return; switch (_context.scene.background = _context.background.color.clone(), _context.scene.background.needsUpdate = !0, _context.scene.background && _context.scene.background.getHexString ? _context.effectStore.visualEffect._fogColorFromSkybox = `#${_context.scene.background.getHexString()}` : _context.effectStore.visualEffect._fogColorFromSkybox = "#cccccc", _context.effectStore.visualEffect._setFog(), _context.renderer.outputEncoding) { case sRGBEncoding: _context.scene.background.convertSRGBToLinear && _context.scene.background.convertSRGBToLinear(); break; case GammaEncoding: _context.scene.background.convertGammaToLinear && _context.scene.background.convertGammaToLinear() }!_context.scene.environment && t.lights && t.lights.skybox && this.setBackgroundSkybox(J(`texture/cubemap/sdr/${t.lights.skybox}/`), "jpg") } break; case "image": if (_context.lightStore.disableLightProbe(), _context.scene && _context.background.texture && _context.background.texture instanceof Texture$1) { if (!_context.scene) return; _context.scene.background = _context.background.texture, _context.effectStore.visualEffect._fogColorFromSkybox = "#cccccc", _context.effectStore.visualEffect._setFog(), !_context.scene.environment && t.lights && t.lights.skybox && this.setBackgroundSkybox(J(`texture/cubemap/sdr/${t.lights.skybox}/`), "jpg") } break; case "skybox": _context.scene && _context.background.cubeTexture && _context.background.cubeTexture instanceof Texture$1 && this.setGlobalIllumination({ skybox: t && t.lights ? t.lights.skybox : this.getSettings().lights.skybox, ambientLight: t && t.lights ? t.lights.ambientLight : this.getSettings().lights.ambientLight, directionalLight: t && t.lights ? t.lights.directionalLights.GlobalDirectionalLight : this.getSettings().lights.directionalLights.GlobalDirectionalLight }, (() => { _context.scene && ("skybox" === _context.background.mode && (_context.scene.background = n.fromEquirectangular(_context.background.cubeTexture, _context.background.cubeTextureRotationY || 0, "number" == typeof _context.background.cubeTextureIntensity ? _context.background.cubeTextureIntensity : 1).texture, _context.scene.environment = _context.scene.background), this.crossfade()) })) }util$1.markObjectsNeedsUpdate() } }, this.setBackgroundColor = (e = BACKGROUND_COLOR_DEFAULT) => { if (e) { if ("string" == typeof e && (e = { type: "single", dataUrl: "", color1: e, color2: "", gradientValue: "" }), "color" === _context.background.mode) if ("single" === e.type) { switch (_context.scene.background && _context.scene.background.isColor && _context.scene.background.setStyle ? _context.scene.background.setStyle(e.color1) : _context.scene.background = new Color$1(e.color1), _context.scene.background && _context.scene.background.getHexString ? _context.effectStore.visualEffect._fogColorFromSkybox = `#${_context.scene.background.getHexString()}` : _context.effectStore.visualEffect._fogColorFromSkybox = "#cccccc", _context.effectStore.visualEffect._setFog(), _context.background.color = _context.scene.background.clone(), _context.renderer.outputEncoding) { case sRGBEncoding: _context.scene.background.convertSRGBToLinear && _context.scene.background.convertSRGBToLinear(); break; case GammaEncoding: _context.scene.background.convertGammaToLinear && _context.scene.background.convertGammaToLinear() }k = null, util$1.markObjectsNeedsUpdate() } else "gradient" === e.type && (new TextureLoader).load(util$1.base64ToBlob(e.dataUrl), (e => { e.encoding = _context.renderer.outputEncoding, _context.scene.background = e, k = null, _context.scene.background.isColor = !0, _context.background.color = _context.scene.background, util$1.markObjectsNeedsUpdate() })); _context.background.colorCSSValue = e } }, this.setBackgroundImage = e => { if (e) { if ("string" == typeof e && (e = { textureName: e, customName: "", customDataUrl: "", imgType: "default" }), "image" === _context.background.mode) { let t = null; "default" === e.imgType ? t = util$1.url(this.resourceBasePath, "texture/background/" + e.textureName + ".png") : "custom" === e.imgType && (t = e.customDataUrl, -1 != t.indexOf("[[origin]]") && (t = t.replace("[[origin]]", _context.origin))), this._imageBackgroundUrl != t && (this.crossfadeFreeze(), this.crossfade(1e3)), this._imageBackgroundUrl = t, (new TextureLoader).load(t, (e => { ("image" === _context.background.mode || D) && (!D && _context.scene && (e.encoding = _context.renderer.outputEncoding, _context.scene.background = e), k = null, _context.background.texture = e, util$1.markObjectsNeedsUpdate()) })), _context.effectStore.visualEffect._fogColorFromSkybox = "#cccccc", _context.effectStore.visualEffect._setFog() } _context.background.textureURL = e } }, this.setBackgroundSkybox = (e, t, i, r) => { if (_context.scene) { k = e; var a = this; if (_context) if (_context.cubeTextures) if (_context.cubeTextures[e]) { if (!D) { if (!_context.scene) return; "skybox" === _context.background.mode && (_context.scene.background = n.fromEquirectangular(_context.cubeTextures[e].envTexture, "number" == typeof _context.background.cubeTextureRotationY ? _context.background.cubeTextureRotationY : 0, "number" == typeof _context.background.cubeTextureIntensity ? _context.background.cubeTextureIntensity : 1).texture) } _context.background.cubeTexture = _context.cubeTextures[e].envTexture, _context.scene.environment = n.fromEquirectangular(_context.cubeTextures[e].envTexture, "number" == typeof _context.background.cubeTextureRotationY ? _context.background.cubeTextureRotationY : 0, "number" == typeof _context.background.environmentLuminosity ? _context.background.environmentLuminosity : 1).texture, _context.lightStore.enableLightProbe(), util$1.markObjectsNeedsUpdate(), util$1.isCSSColor(i) ? (_context.effectStore.visualEffect._fogColor = i, _context.effectStore.visualEffect._fogColorFromSkybox = i) : _context.effectStore.visualEffect._fogColorFromSkybox = util$1.lookupSkyboxFogColor(e, _context.scene.toneMapping), _context.effectStore.visualEffect._setFog(), this.setSkyboxRotationY(180 * (_context.background.cubeTextureRotationY || 0) / Math.PI), this.setSkyboxBlur(_context.background.cubeTextureBlur), a.crossfade(), r && r() } else _context.cacheStore.load({ path: util$1.genEquirectangularUrl(e, t), type: "texture", onLoad: t => { if (_context.scene) { if (t.name = e, t.wrapS = RepeatWrapping, "skybox" === _context.background.mode || D) { if (!D) { if (!_context.scene) return; "skybox" === _context.background.mode && (_context.scene.background = n.fromEquirectangular(t, "number" == typeof _context.background.cubeTextureRotationY ? _context.background.cubeTextureRotationY : 0, "number" == typeof _context.background.cubeTextureIntensity ? _context.background.cubeTextureIntensity : 1).texture) } _context.lightStore.enableLightProbe(), util$1.markObjectsNeedsUpdate(), util$1.isCSSColor(i) ? (_context.effectStore.visualEffect._fogColor = i, _context.effectStore.visualEffect._fogColorFromSkybox = i) : _context.effectStore.visualEffect._fogColorFromSkybox = util$1.lookupSkyboxFogColor(e, _context.scene.toneMapping), _context.effectStore.visualEffect._setFog(), a.crossfade() } _context.scene.environment = n.fromEquirectangular(t, "number" == typeof _context.background.cubeTextureRotationY ? _context.background.cubeTextureRotationY : 0, "number" == typeof _context.background.environmentLuminosity ? _context.background.environmentLuminosity : 1).texture, _context.background.cubeTexture = t, _context.cubeTextures[e] = { envTexture: null }, _context.cubeTextures[e].envTexture = t, this.setSkyboxRotationY(180 * (_context.background.cubeTextureRotationY || 0) / Math.PI), this.setSkyboxBlur(_context.background.cubeTextureBlur), r && r() } else logger.debug("_context.scene 为空") } }); else logger.debug("_context.cubeTextures 为空"); else logger.debug("_context 为空") } else logger.debug("_context.scene 为空") }, this.setSkybox = (e, t, i) => { this.setBackgroundSkybox(e, t, i) }, this.setSkyboxRotationY = e => { "number" == typeof e && _context.background.cubeTexture && (_context.background.cubeTextureRotationY = util$1.degreeToRadian(e), _context.scene.environment = n.fromEquirectangular(_context.background.cubeTexture, _context.background.cubeTextureRotationY, "number" == typeof _context.background.environmentLuminosity ? _context.background.environmentLuminosity : 1).texture, this.setSkyboxBlur(_context.background.cubeTextureBlur || 0)) }, this.getSkyBoxRotationY = () => 180 * (_context.background.cubeTextureRotationY || 0) / Math.PI, this.setSkyboxIntensity = e => { "number" == typeof e && _context.background.cubeTexture && (_context.background.cubeTextureIntensity = e, this.setSkyboxBlur(_context.background.cubeTextureBlur || 0)) }, this.getSkyBoxIntensity = () => "number" == typeof _context.background.cubeTextureIntensity ? _context.background.cubeTextureIntensity : 1, this.setEnvironmentLuminosity = e => { "number" == typeof e && _context.background.cubeTexture && (_context.background.environmentLuminosity = e, _context.scene.environment = n.fromEquirectangular(_context.background.cubeTexture, _context.background.cubeTextureRotationY || 0, "number" == typeof _context.background.environmentLuminosity ? _context.background.environmentLuminosity : 1).texture) }, this.getEnvironmentLuminosity = () => "number" == typeof _context.background.environmentLuminosity ? _context.background.environmentLuminosity : 1, this.setSkyboxBlur = e => { "number" != typeof e || e < 0 || e > 100 || !_context.background.cubeTexture || !_context.scene || _context.backgroundBlur2.textureBlur(_context.background.cubeTexture, e, (t => { _context.scene && (t.wrapS = RepeatWrapping, _context.scene && ("skybox" === _context.background.mode && (_context.scene.background = n.fromEquirectangular(t, _context.background.cubeTextureRotationY || 0, "number" == typeof _context.background.cubeTextureIntensity ? _context.background.cubeTextureIntensity : 1).texture), _context.background.cubeTextureBlur = e)) })) }, this.getSkyboxBlur = () => _context.background.cubeTextureBlur || 0, this.getSkyboxName = () => T, this.setEnvTime = e => { let t = new Date("0001/01/01 06:00:00"), i = new Date("0001/01/01 18:00:00"), r = 180 * (new Date(`0001/01/01 ${e.envTime}`) - t) / (i - t), n = "#ff0000", a = "skybox-day-10"; r > 180 && (r -= 180, n = "#0000ff", a = "skybox-night-24"), r < 0 && (r += 180, n = "#0000ff", a = "skybox-night-24"), (r <= 5 || r >= 175) && (n = "#00ff00", a = "skybox-dusk-6"); let o = this.getSettings().lights.directionalLights.GlobalDirectionalLight, s = Math.sqrt(Math.pow(o.position[0], 2) + Math.pow(o.position[1], 2)), l = MathUtils.degToRad(r); if (o.position[0] = s * Math.cos(l), o.position[1] = s * Math.sin(l), null != e.show) { let t = new MeshBasicMaterial({ color: n }), i = new Mesh(new BoxGeometry(e.show, e.show, e.show), t); i.position.set(o.position[0], o.position[1], o.position[2]), _context.scene.add(i) } this.setSkybox(J(`texture/cubemap/sdr/${a}/`), ".jpg"), _context.lightStore.setDirectionalLight(o, e.duration) }, this.setGlobalIllumination = ({ skybox: e = "", skyboxType: t = ".jpg", ambientLight: i = { color: "#ffffff", intensity: .75 }, directionalLight: r = { name: "GlobalDirectionalLight", color: "#ffffff", position: [100, 100, 100], castShadow: !0, shadow: { camera: { top: 100, bottom: -100, left: -100, right: 100, far: 200 }, mapSize: { height: 1024, width: 1024, x: 1024, y: 1024 } }, intensity: 1, duration: 0 } } = {}, a) => { if (logger.debug("TRACE: Core.setGlobalIllumination() - Entering."), k && k != J(`texture/cubemap/sdr/${e}/`) && this.crossfadeFreeze(), this.setAmbientLight(i.color, i.intensity), _context.lightStore.setDirectionalLight(r, r.duration), _context.stateStore.setGlobalIlluminationInCurrentState({ skybox: e, skyboxType: t, ambientLight: i, directionalLight: r }), "" === e) this.setBackgroundColor(BACKGROUND_COLOR_DEFAULT), a && a(1); else if ("skybox" === _context.background.mode) k != J(`texture/cubemap/sdr/${e}/`) ? (T = e.replace("/", "").replace("/", ""), this.setBackgroundSkybox(J(`texture/cubemap/sdr/${e}/`), t, void 0, a)) : (_context.background.cubeTexture && this.setSkyboxRotationY(180 * (_context.background.cubeTextureRotationY || 0) / Math.PI), a && a(1)); else { if (T = e.replace("/", "").replace("/", ""), _context.cubeTextures[J(`texture/cubemap/sdr/${e}/`)]) { let t = _context.cubeTextures[J(`texture/cubemap/sdr/${e}/`)].envTexture; if (a && a(1), !_context.scene) return void logger.debug("_context.scene 为空"); _context.scene.environment = n.fromEquirectangular(t).texture } else _context.cacheStore.load({ path: util$1.genEquirectangularUrl(J(`texture/cubemap/sdr/${e}/`), t), type: "texture", onLoad: t => { t.wrapS = RepeatWrapping, _context.background.cubeTexture = t, _context.cubeTextures[J(`texture/cubemap/sdr/${e}/`)] = { envTexture: null }, _context.cubeTextures[J(`texture/cubemap/sdr/${e}/`)].envTexture = t, _context.scene ? (_context.scene.environment = n.fromEquirectangular(t).texture, a && a(1)) : logger.debug("_context.scene 为空") } }); this.crossfade() } logger.debug("TRACE: Core.setGlobalIllumination() - Leaving.") }, this.getCamera = () => { var e = {}; return e.positionX = _context.camera.position.x, e.positionY = _context.camera.position.y, e.positionZ = _context.camera.position.z, e.inclinationAngle = _context.orbitControls.getPolarAngle() / (Math.PI / 2) * 90 - 90, e.azimuthAngle = _context.orbitControls.getAzimuthalAngle() / Math.PI * 180, e.viewDistance = Math.abs(_context.orbitControls.object.position.clone().sub(_context.orbitControls.target).length()) / _context.worldScale, e.targetX = _context.orbitControls.target.x, e.targetY = _context.orbitControls.target.y, e.targetZ = _context.orbitControls.target.z, e.fov = _context.camera.fov, e.far = _context.camera.far, e.near = _context.camera.near, e.inclinationAngleMin = _context.orbitControls.minPolarAngle / Math.PI * 180 - 90, e.inclinationAngleMax = _context.orbitControls.maxPolarAngle / Math.PI * 180 - 90, e.distanceMin = _context.orbitControls.minDistance / _context.worldScale, e.distanceMax = _context.orbitControls.maxDistance / _context.worldScale, e.viewLimitRadius = _context.orbitControls.viewLimitRadius, e.autoRotate = _context.stateStore._camera.autoRotate, e.autoRotateSpeed = _context.stateStore._camera.autoRotateSpeed, e.autoRotateDirection = _context.stateStore._camera.autoRotateDirection, e.duration = _context.stateStore._camera.duration, e }, this.setCamera = (e, t) => { if (t) if ("" === this.getCurrentState()) { let t = this.getCamera(); e.target = e.target || { x: t.targetX, y: t.targetY, z: t.targetZ }, e.azimuthAngle = e.azimuthAngle || 0 === e.azimuthAngle ? e.azimuthAngle : t.azimuthAngle, e.inclinationAngle = "number" == typeof e.inclinationAngle ? e.inclinationAngle : t.inclinationAngle, e.distance = "number" == typeof e.distance && e.distance > 0 ? e.distance : t.viewDistance, this.cameraFlyTo(new Vector3(e.target.x, e.target.y, e.target.z), e.azimuthAngle, e.inclinationAngle, e.distance * _context.worldScale, 0, !0, (() => { })), _context.camera.fov = e.fov || _context.camera.fov, ("number" != typeof e.near || e.near < 0) && (e.near = _context.camera.near), ("number" != typeof e.far || e.far < 0) && (e.far = _context.camera.far), e.near < e.far && (_context.camera.near = e.near, _context.camera.far = e.far, _context.camera.updateProjectionMatrix()), "number" == typeof e.inclinationAngleMin && (_context.orbitControls.minPolarAngle = (e.inclinationAngleMin + 90) / 180 * Math.PI), "number" == typeof e.inclinationAngleMax && (_context.orbitControls.maxPolarAngle = (e.inclinationAngleMax + 90) / 180 * Math.PI), "number" == typeof e.distanceMin && (_context.orbitControls.minDistance = e.distanceMin * _context.worldScale), "number" == typeof e.distanceMax && (_context.orbitControls.maxDistance = e.distanceMax * _context.worldScale), this.notDistance = { minDistance: e.distanceMin * _context.worldScale, maxDistance: e.distanceMax * _context.worldScale }, G = this.getCamera(), this.defaultEffectStore.visualEffect._updateCameraProjection(_context.camera), this.focus() } else this.notState.view.camera.viewDistanceMax = e.far, this.notState.view.camera.viewDistanceMin = e.near, this.notState.view.camera.distanceMax = e.distanceMax * _context.worldScale, this.notState.view.camera.distanceMin = e.distanceMin * _context.worldScale, this.notState.view.camera.fov = e.fov; else { let t = this.getCamera(); e.target = e.target || { x: t.targetX, y: t.targetY, z: t.targetZ }, e.azimuthAngle = e.azimuthAngle || 0 === e.azimuthAngle ? e.azimuthAngle : t.azimuthAngle, e.inclinationAngle = "number" == typeof e.inclinationAngle ? e.inclinationAngle : t.inclinationAngle, e.distance = "number" == typeof e.distance && e.distance > 0 ? e.distance : t.viewDistance, this.cameraFlyTo(new Vector3(e.target.x, e.target.y, e.target.z), e.azimuthAngle, e.inclinationAngle, e.distance * _context.worldScale, e.duration || 0, !0, (() => { })), _context.camera.fov = e.fov || _context.camera.fov, ("number" != typeof e.near || e.near < 0) && (e.near = _context.camera.near), ("number" != typeof e.far || e.far < 0) && (e.far = _context.camera.far), e.near < e.far && (_context.camera.near = e.near, _context.camera.far = e.far, _context.camera.updateProjectionMatrix()), "number" == typeof e.inclinationAngleMin && (_context.orbitControls.minPolarAngle = (e.inclinationAngleMin + 90) / 180 * Math.PI), "number" == typeof e.inclinationAngleMax && (_context.orbitControls.maxPolarAngle = (e.inclinationAngleMax + 90) / 180 * Math.PI), "number" == typeof e.distanceMin && (_context.orbitControls.minDistance = e.distanceMin * _context.worldScale), "number" == typeof e.distanceMax && (_context.orbitControls.maxDistance = e.distanceMax * _context.worldScale), this.defaultEffectStore.visualEffect._updateCameraProjection(_context.camera), this.focus() } }, this.setCameraToModel = (e, t = 0, i = {}, r = !1) => { let n = null; if (_context.scene.models.traverse((t => { t.name === e && (n = t) })), !n) return; let a = (new Box3).setFromObject(n), o = new Vector3; a.getSize(o), R.x = (a.max.x + a.min.x) / 2, R.y = (a.max.y + a.min.y) / 2, R.z = (a.max.z + a.min.z) / 2; let s = 3 * o.distanceTo(a.max.sub(a.min).divideScalar(2)); (isNaN(R.x) || isNaN(R.y) || isNaN(R.z)) && (logger.warn("无法获取有效的模型大小。"), R.copy(n.position)), (isNaN(s) || s === 1 / 0 || s === -1 / 0) && (s = 100), s <= this.getCamera().near && (s += this.getCamera().near), a = null, o = null, this.cameraFlyTo(R, util$1.numberOrDefault(i.azimuthAngle, 45), util$1.numberOrDefault(i.inclinationAngle, -45), util$1.numberOrDefault(i.distance, s) * _context.worldScale, util$1.numberOrDefault(t, 0), !0, (() => { this.focus() })), R = new Vector3 }, this.focusFloor = (e, t, i) => { if (!e) return void (t && t({ result: 0, message: "参数错误" })); let r, n = _context.instance.defaultObjectTree.getItemByName(e.buildingId); if (!n) return void (t && t({ result: 0, message: `建筑${e.buildingId}不存在` })); if ("BuildingItem" !== (_context.instance.defaultObjectTree.findItemByObject3D(n.getGroup()) || {}).getType()) return void (t && t({ result: 0, message: "指定的对象非建筑" })); if (n.children.forEach((t => { t.level === Number(e.floor) && (r = t) })), !r) return void (t && t({ result: 0, message: `楼层号${e.floor}不存在` })); let a = { floor: e.floor, idBuilding: e.buildingId }; i.onFocusFloorStart && i.onFocusFloorStart(a), this.setCameraToModel(r.name, 0, { distance: e.distance }), i.onFocusFloorEnd && i.onFocusFloorEnd(a), t && t({ result: 1, message: "成功。" }) }, this.setCameraToNode = (e, t, i = 0, r = {}, n = !1) => { let a = null; _context.scene.models.traverse((t => { t.name === e && (a = t) })); let o = util$1.findNodeInThree(a, t); if (!o) return; let s = (new Box3).setFromObject(o), l = new Vector3; s.getSize(l), R.x = (s.max.x + s.min.x) / 2, R.y = (s.max.y + s.min.y) / 2, R.z = (s.max.z + s.min.z) / 2; let c = 3 * l.distanceTo(s.max.sub(s.min).divideScalar(2)); (isNaN(R.x) || isNaN(R.y) || isNaN(R.z)) && (logger.warn("无法获取有效的模型大小。"), R.copy(a.position)), (isNaN(c) || c === 1 / 0 || c === -1 / 0) && (c = 100), c <= this.getCamera().near && (c += this.getCamera().near), s = null, l = null, this.cameraFlyTo(R, util$1.numberOrDefault(r.azimuthAngle, 45), util$1.numberOrDefault(r.inclinationAngle, -45), util$1.numberOrDefault(r.distance, c) * _context.worldScale, util$1.numberOrDefault(i, 0), !0, (() => { this.focus() })), R = new Vector3 }, this.setCameraToModelByUUID = (e, t = 0, i = {}, r = !1, n = !1) => { let a = null; _context.scene.models.traverse((t => { t.uuid === e && (a = t) })); let o = null; a ? o = (new Box3).setFromObject(a) : this._tilesRenderers && this._tilesRenderers.forEach((t => { if (t.group.uuid === e && t.tileSets[t.rootURL] && t.tileSets[t.rootURL].root && t.tileSets[t.rootURL].root.boundingVolume && t.tileSets[t.rootURL].root.boundingVolume.box) { let e = t.tileSets[t.rootURL].root.boundingVolume.box, i = new Vector3(e[0], e[2], -e[1]), r = new Vector3(t.offset.x, t.offset.y, t.offset.z), n = new Vector3(e[3], e[11], e[7]), a = new Vector3(t.absolutePosition.x, t.absolutePosition.y, t.absolutePosition.z), s = a.clone().add(n).add(i).add(r), l = a.clone().sub(n).add(i).add(r); o = new Box3(l, s) } })), o || (o = (new Box3).setFromObject(_context.scene.models)); let s = new Vector3; o.getSize(s), R.x = (o.max.x + o.min.x) / 2, R.y = (o.max.y + o.min.y) / 2, R.z = (o.max.z + o.min.z) / 2; let l = 3 * s.distanceTo(o.max.sub(o.min).divideScalar(2)); (isNaN(R.x) || isNaN(R.y) || isNaN(R.z)) && (logger.warn("无法获取有效的模型大小。"), R.copy(a.position)), (isNaN(l) || l === 1 / 0 || l === -1 / 0) && (l = 100), l <= this.getCamera().near && (l += this.getCamera().near), o = null, s = null, this.nextRender((() => { this.cameraFlyTo(R, util$1.numberOrDefault(i.azimuthAngle, 45), util$1.numberOrDefault(i.inclinationAngle, -45), util$1.numberOrDefault(i.distance, l) * _context.worldScale, util$1.numberOrDefault(t, 0), !0, (() => { this.focus() })), R = new Vector3 }), 1) }, this.getOrthoCamera = () => { var e = {}; return e.positionX = _context.cameraOrtho.position.x, e.positionY = _context.cameraOrtho.position.y, e.positionZ = _context.cameraOrtho.position.z, e.viewDistance = Math.abs(_context.orthoCameraControls.object.position.clone().sub(_context.orthoCameraControls.target).length()), e.targetX = _context.orthoCameraControls.target.x, e.targetY = _context.orthoCameraControls.target.y, e.targetZ = _context.orthoCameraControls.target.z, e.far = _context.cameraOrtho.far, e.near = _context.cameraOrtho.near, e }, this.setOrthoCamera = e => { let t = _context.cameraOrtho; if (!e.target) return; if ("number" != typeof e.target.x || "number" != typeof e.target.y || "number" != typeof e.target.z) return; if (isNaN(e.target.x) || isNaN(e.target.y) || isNaN(e.target.z)) return; if (NaN == e.target.x || NaN == e.target.y || NaN == e.target.z) return; e.target = e.target || { x: t.targetX, y: t.targetY, z: t.targetZ }; let i = ""; if ("number" != typeof e.height || isNaN(e.height) || (i = "z"), "number" != typeof e.width || isNaN(e.width) || (i = "y"), "" !== i) { if (!("number" == typeof e.distance && e.distance > 0)) if (_context.scene.models.children instanceof Array && _context.scene.models.children.length > 0) { let t = -1 / 0; _context.scene.models.traverse((e => { if (e.geometry) { e.geometry.computeBoundingBox(); const r = new Vector3(0, "y" === i ? e.geometry.boundingBox.max[i] : 0, "z" === i ? e.geometry.boundingBox.max[i] : 0); e.updateMatrixWorld(), r.applyMatrix4(e.matrixWorld), r[i] > t && (t = r[i]) } })), e.distance = t + 10 - e.target[i] } else e.distance = t.position[i] - e.target[i]; if ("y" === i) { let t = e.width, i = t / (_context.renderer.domElement.width / _context.renderer.domElement.height); _context.cameraOrtho.left = t / -2, _context.cameraOrtho.right = t / 2, _context.cameraOrtho.top = i / 2, _context.cameraOrtho.bottom = i / -2, _context.cameraOrtho.position.set(e.target.x, e.target.y + e.distance, e.target.z), _context.cameraOrtho.rotation.z = 0 } if ("z" === i) { let t = e.height, i = t / (_context.renderer.domElement.height / _context.renderer.domElement.width); _context.cameraOrtho.left = i / -2, _context.cameraOrtho.right = i / 2, _context.cameraOrtho.top = t / 2, _context.cameraOrtho.bottom = t / -2, _context.cameraOrtho.position.set(e.target.x, e.target.y, e.target.z + e.distance), _context.cameraOrtho.rotation.z = 0 } _context.cameraOrtho.zoom = 1, _context.cameraOrtho.updateProjectionMatrix(), _context.cameraOrtho.updateMatrixWorld(), _context.orthoCameraControls.target.set(e.target.x, e.target.y, e.target.z), _context.orthoCameraControls.update() } else console.warn("Invalid parameter in setOrthoCamera().") }, this.onGlobeCalibrate = (e, t) => { _context.globeCalibrateControls || (_context.globeCalibrateControls = new GlobeCalibrateControls), this.globeCalibrateControls = _context.globeCalibrateControls, _context.globeCalibrateControls.enable(e, t) }, this.offGlobeCalibrate = () => { _context.globeCalibrateControls && _context.globeCalibrateControls.disable() }, this.onGlobeMode = (e = "z", t) => { "string" == typeof e && ("y" !== (e = e.toLowerCase()) && "z" !== e || (document.getElementById("__refGlobeDiv") || (_context.refGlobeDiv = document.createElement("div"), _context.refGlobeDiv.id = "__refGlobeDiv", _context.refGlobeDiv.style.width = "100%", _context.refGlobeDiv.style.height = "100%", _context.refGlobeDiv.style.backgroundImage = `url(${util$1.url(this.resourceBasePath, "texture/ui/globe-front.jpg")})`, _context.refGlobeDiv.style.backgroundPosition = "center center", _context.refGlobeDiv.style.backgroundRepeat = "no-repeat", _context.refGlobeDiv.style.opacity = .5, _context.refGlobeDiv.style.position = "inherit", _context.refGlobeDiv.style.pointerEvents = "none", _context.refGlobeDiv.style.display = "none", _context.renderer.domElement.parentElement.insertBefore(_context.refGlobeDiv, _context.renderer.domElement)), "y" === e && (_context.refGlobeDiv.style.backgroundImage = `url(${util$1.url(this.resourceBasePath, "texture/ui/globe-top.jpg")})`), "z" === e && (_context.refGlobeDiv.style.backgroundImage = `url(${util$1.url(this.resourceBasePath, "texture/ui/globe-front.jpg")})`), _context.refGlobeDiv.style.display = "block", this.saveSceneCamera(), this.switchCameraMode(1, e, { fitX: !0 }), I = _context.background.mode, this.setBackgroundMode("none"), _context.orthoCameraControls.keyOperate = "translation", _context.orthoCameraControls.zoomAxis = e, _context.onCalibrate = () => { const e = _context.refGlobeDiv.offsetWidth / 360 * 6378139, i = (_context.cameraOrtho.right - _context.cameraOrtho.left) / _context.cameraOrtho.zoom / e, r = { type: "ecef", scaleX: i, scaleY: i, scaleZ: i, offset: { x: _context.orthoCameraControls.target.x, y: _context.orthoCameraControls.target.y, z: _context.orthoCameraControls.target.z }, rotation: { x: 0, y: 0, z: 0 }, editor: this.getDatumShiftModel() ? this.getDatumShiftModel().editor : {} }; this.setDatumShiftModel(r), "function" == typeof t && t(r) }, _context.orthoCameraControls.addEventListener("change", _context.onCalibrate), "y" === e && (_context.transformControls.attach(_context.scene.models), this.setTransformMode("rotate"), _context.transformControls.showX = !1, _context.transformControls.showY = !0, _context.transformControls.showZ = !1), N.rotation = JSON.parse(JSON.stringify(_context.scene.models.rotation)), B && _context.scene.models.rotation.set(0, MathUtils.degToRad(B), 0), D = !0)) }, this.offGlobeMode = () => { D && (_context.refGlobeDiv && (_context.refGlobeDiv.style.display = "none"), D = !1, this.switchCameraMode(0), I && this.setBackgroundMode(I), I = null, "editor" === _context.pointerMode ? _context.orthoCameraControls.keyOperate = "paint" : _context.orthoCameraControls.keyOperate = null, _context.orthoCameraControls.zoomAxis = "y", _context.orthoCameraControls.removeEventListener("change", _context.onCalibrate), _context.onCalibrate = null, this.disableTransform(), _context.transformControls.showX = !0, _context.transformControls.showY = !0, _context.transformControls.showZ = !0, _context.transformControls.showE = !1, B = this.getSceneRotationY(), this.notState && (this.notState.datumShiftModel = JSON.parse(JSON.stringify(this.getSettings().datumShiftModel))), _context.scene.models.rotation.order = N.rotation._order, _context.scene.models.rotation.x = N.rotation._x, _context.scene.models.rotation.y = N.rotation._y, _context.scene.models.rotation.z = N.rotation._z) }, this.findParentPosition = e => { let t = e.parent; t && (R.x = t.position.x + R.x, R.y = t.position.y + R.y, R.z = t.position.z + R.z, this.findParentPosition(t, R)) }, this.findNode = (e, t) => { let i = this.findModel(e); if (i) return i.findNode(t) }, this.destroy = () => { if (logger.debug("TRACE: Core.destroy() - Entering."), s) return; for (cancelAnimationFrame(this.frameId), this.disableTransform(), s = !0, PerformanceSuggest.dispose(), _context.scene.children.forEach((e => { util$1.disposeThreeObject(e) })); _context.scene.children.length;)_context.scene.remove(_context.scene.children[0]); _context.renderer.domElement && this.container.removeChild(_context.renderer.domElement), i && i.domElement && this.container.removeChild(i.domElement), O && this.fpsPanelOff(), _context.transformStore.destroy(), _context.transformStore = null, _context.cacheStore.destroy(), _context.cacheStore = null, _context.sceneStore.destroy(), _context.sceneStore = null, _context.scene.clear(), _context.scene = null, _context.camera = null, _context.targetCameraControls = null, _context.orbitControls = null, _context.animationStore = null, _context.effectStore = null, _context.lightStore = null, _context.materialStore = null, _context.modelStore = null, e = null, _context.textureStore = null, _context.customTextureStore = null, _context.datumShiftModel = null, l = !1, c = !1, g = {}, _context.loaders = {}, _context.paintControls.destroy(), this.notState = null, this.allState = null, _context.renderer.dispose(), _context.renderer.forceContextLoss(), _context.renderer.content = null; let t = _context.renderer.domElement.getContext("webgl"); t && t.getExtension("WEBGL_lose_context").loseContext(), _context.renderer = null, _context.markDom = null, ImageBitMapCache.clear(), Cache.clear(), logger.debug("TRACE: Core.destroy() - Leaving.") }, this.enableLut = () => this.defaultEffectStore.enableLut(), this.disableLut = () => this.defaultEffectStore.disableLut(), this.nextLut = () => this.defaultEffectStore.nextLut(), this.findMaterial = e => _context.materialStore.find(e), this.findMaterialInModel = (e, t) => { let i = this.defaultObjectTree.children; for (let r = 0; r < i.length; r++)if ("ModelItem" === i[r].type) { if (i[r].name === e) return i[r].getMaterials()[t] } else if ("BuildingItem" === i[r].type) for (let n = 0; n < i[r].children.length > 0; n++)if ("ModelItem" === i[r].children[n].type) { if (i[r].children[n].name === e) return i[r].children[n].getMaterials()[t] } else if ("BuildingFloorItem" === i[r].children[n].type) for (let a = 0; a < i[r].children[n].children.length; a++)if (i[r].children[n].children[a].name === e) return i[r].children[n].children[a].getMaterials()[t] }, this.findModel = (e, t) => { let i, r = this; return _context.scene.models.traverse((function (n) { n.name === e && (t ? r.findParent(n, t) && (i = n) : i = n) })), i }, this.findParent = (e, t) => { if (e.parent) { if (e.parent.name === t) return e.parent; var i = this.findParent(e.parent, t); return i || void 0 } }, this.findTexture = e => _context.textureStore.find(e), this.getModels = () => _context.modelStore.getModels(), this.setNodeRotation = ({ enabled: e = !0, node: t, rotatingAxis: i = "y", rotatingSpeed: r = .1 }) => { if (e) { let e = _context.animationStore.findNodeAnimation(t, NodeRotationAnimationController.type); e && (e.reset(), _context.animationStore.remove(e)), e = new NodeRotationAnimationController(t, "x" === i, "y" === i, "z" === i, "x" === i ? r : 0, "y" === i ? r : 0, "z" === i ? r : 0), _context.animationStore.add(e) } else { let e = _context.animationStore.findNodeAnimation(t, NodeRotationAnimationController.type); e && (e.reset(), _context.animationStore.remove(e)) } }, this.setNodeRotating = ({ enabled: e = !0, node: t, rotatingAxis: i = "y", rotatingSpeed: r = .1 }) => { let n = _context.animationStore.findNodeAnimation(t, NodeRotationAnimationController.type); if (n && (n.reset(), _context.animationStore.remove(n)), e) { let e = new NodeRotationAnimationController(t, "x" === i, "y" === i, "z" === i, "x" === i ? r : 0, "y" === i ? r : 0, "z" === i ? r : 0); _context.animationStore.add(e) } }, this.setNodeScaling = ({ enabled: e = !0, node: t, startScale: i = 1, stopScale: r = 2, fadeOutScale: n = 1.5, scalingSpeed: a = .1 }) => { let o = _context.animationStore.findNodeAnimation(t, NodeScaleAnimationController.type); if (o && (o.reset(), _context.animationStore.remove(o)), e) { let e = new NodeScaleAnimationController(t, i, r, n, a, !0); _context.animationStore.add(e) } }, this.setNodeBreathing = ({ enabled: e = !1, node: t, endBreathe: i = 1.5, breathingSpeed: r = .1 }) => { let n = _context.animationStore.findNodeAnimation(t, NodeBreatheAnimationController.type); if (n && (n.reset(), _context.animationStore.remove(n)), e) { let e = new NodeBreatheAnimationController(t, i, r, !0); _context.animationStore.add(e) } }, this.getMaterials = () => _context.materialStore.getAll(), this.setMaterialAnimation = ({ name: e = "", enableTranslation: t = !1, translationSpeedU: i = .1, translationSpeedV: r = .1, modelName: n }, a, o) => { logger.debug("TRACE: Core.setMaterialAnimation() - Entering.", { name: e, enableTranslation: t, translationSpeedU: i, translationSpeedV: r }); let s = this.defaultObjectTree.getItemByName(n); if (a && (s = this.defaultObjectTree.getItemByName(a).getItemByName(n), o && (s = this.defaultObjectTree.getItemByName(a).getInstanced("ModelAsset", o))), !s) return; let l = s.materialStore.find(e); if (!l) return logger.debug(`Material with specified name (${e}) not found.`), void logger.debug("TRACE: Core.setMaterialAnimation() - Leaving."); if (l._enableTranslation = t, l._translationSpeedU = i, l._translationSpeedV = r, 0 === i && 0 === r && (t = !1), t) { let e = _context.animationStore.findMaterialAnimation(l._material(), UVAnimationController.type); if (e) e.enableU = 0 !== i, e.enableV = 0 !== r, e.uSpeed = i, e.vSpeed = r; else { let e = new UVAnimationController(l._material(), 0 !== i, 0 !== r, i, r); _context.animationStore.add(e) } } else { let e = _context.animationStore.findMaterialAnimation(l._material(), UVAnimationController.type); e && (e.reset(), l.enableUV && (l.enableUV = !0), _context.animationStore.remove(e)) } if (l._copies instanceof Array) for (let e of l._copies) if (e._enableTranslation = t, e._translationSpeedU = i, e._translationSpeedV = r, 0 === i && 0 === r && (t = !1), t) { let t = _context.animationStore.findMaterialAnimation(e, UVAnimationController.type); if (t) t.enableU = 0 !== i, t.enableV = 0 !== r, t.uSpeed = i, t.vSpeed = r; else { let t = new UVAnimationController(e, 0 !== i, 0 !== r, i, r); _context.animationStore.add(t) } } else { let t = _context.animationStore.findMaterialAnimation(e, UVAnimationController.type); t && (t.reset(), _context.animationStore.remove(t)) } logger.debug("TRACE: Core.setMaterialAnimation() - Leaving.") }, this.init = a => { (a = a || {}).disableAvwExtensions, v = a.highDPI ? window.devicePixelRatio : 1, v = a.lowDPI ? .5 : v, v = a.dpi ? a.dpi : v, h = !!a._isManaged, _context.pointerMode = "classic", "string" == typeof a.pointerMode && "editor" === a.pointerMode.toLowerCase() && (_context.pointerMode = "editor"), "number" == typeof a.fpsLimit && a.fpsLimit > 0 && a.fpsLimit < 240 ? _context.fpsLimit = a.fpsLimit : _context.fpsLimit = 240, this.passiveMode = !!a.passiveMode, this.passiveModeRenderRate = "number" == typeof a.passiveModeRenderRate ? a.passiveModeRenderRate : 1, this.passiveModeRenderRate = Math.min(Math.max(this.passiveModeRenderRate, 0), 1), A = 0, a.container ? this.container = a.container : (this.container = document.body.appendChild(document.createElement("div")), l = !0), this.container.style.overflow = "hidden", a.fillWindow || l ? (l = !0, a.width = window.innerWidth, a.height = window.innerHeight, this.container.style.position = "absolute", this.container.style.top = "0px", this.container.style.right = "0px", this.container.style.bottom = "0px", this.container.style.left = "0px") : (a.width = a.width || this.container.scrollWidth, a.height = a.height || this.container.scrollHeight), _context.hasUpgradeSuggest = a.performanceSuggest, this.setResolution(a.width, a.height), r || this.setResolution(WIDTH_DEFAULT, HEIGHT_DEFAULT), _context.alpha = "boolean" == typeof a.isTransparent && a.isTransparent, _context.origin = a.origin ? a.origin : window.location.origin, i = new Stats$1, i.domElement.style.position = "absolute", i.domElement.style.top = "0px", i.domElement.style.display = "none", this.container.appendChild(i.domElement); let c = document.createElement("canvas"); _context.renderer = new WebGLRenderer({ canvas: c, alpha: _context.alpha, antialias: !1 }), _context.renderer.autoClear = !0, _context.renderer.outputEncoding = sRGBEncoding, _context.renderer.setPixelRatio(v), _context.renderer.setSize(r.width, r.height), this.container.appendChild(_context.renderer.domElement), window.addEventListener("resize", (() => { l && this.setResolution(window.innerWidth, window.innerHeight) })), _context.renderer.shadowMap.enabled = !0, _context.renderer.shadowMap.type = PCFSoftShadowMap, _context.renderer.toneMapping = NoToneMapping, _context.renderer.toneMappingExposure = 1; let y = 50, _ = 1, b = 1e6; a.camera && (y = a.camera.fieldOfView || y, _ = a.camera.near || _, b = a.camera.far || b); let w = 1 * r.width / r.height; if (_context.camera = new PerspectiveCamera(y, w, _, b), _context.activeCamera = _context.camera, _context.camera.position.set(0, 50, 100), _context.cameraOrtho = new OrthographicCamera(-200 * w, 200 * w, 200, -200, _, b), _context.cameraOrtho.position.y = 200, _context.cameraOrtho.lookAt(0, 0, 0), _context.orbitControls = new OrbitControls(_context.camera, _context.renderer.domElement), _context.orbitControls.enableDamping = !0, _context.orbitControls.dampingFactor = .2, _context.orbitControls.target.set(0, 0, 0), _context.orbitControls.addEventListener("change", (() => { o = !0 })), "editor" === _context.pointerMode && (_context.orbitControls.keyOperate = "paint"), _context.orbitControls.update(), _context.orbitControls.addEventListener("end", (() => { util$1.markObjectsNeedsUpdate() })), _context.orthoCameraControls = new OrbitControls(_context.cameraOrtho, _context.renderer.domElement), _context.orthoCameraControls.zoomCenter = "scene", _context.orthoCameraControls.zoomSpeed = .25, _context.orthoCameraControls.enableDamping = !1, _context.orthoCameraControls.enableRotate = !1, _context.orthoCameraControls.target.set(0, 0, 0), _context.orthoCameraControls.enabled = !1, _context.targetCameraControls = new TargetCameraControls(_context.orbitControls), this.defaultView = new View({}, _context.targetCameraControls, _context.camera), _context.transformControls = new TransformControls(_context.camera, _context.renderer.domElement), this.transformControls = _context.transformControls, _context.transformStore = new TransformStore(_context.transformControls), _context.transformControls.addEventListener("translate", (e => { this.cutLevelByUUID(e.object.uuid, !1) })), _context.transformControls.addEventListener("dragging-changed", (function (e) { _context.orbitControls.enabled = !e.value, _context.orthoCameraControls.enabled = !e.value })), _context.transformControls.addEventListener("mouseUp", (function (e) { let t = e.target.object, i = {}; if (t) { i.position = JSON.parse(JSON.stringify(t.position)), i.rotation = JSON.parse(JSON.stringify(t.rotation)), i.rotation.x = i.rotation._x, i.rotation.y = i.rotation._y, i.rotation.z = i.rotation._z, i.scale = JSON.parse(JSON.stringify(t.scale)), i.rotation.x = i.rotation._x = MathUtils.radToDeg(i.rotation._x), i.rotation.y = i.rotation._y = MathUtils.radToDeg(i.rotation._y), i.rotation.z = i.rotation._z = MathUtils.radToDeg(i.rotation._z); let e = _context.defaultObjectTree.getItemByUUID(t.uuid); e && (e.transformNode = i) } })), _context.scene = new Scene, _context.scene.name = "__avwCore", _context.scene.models = new Group, _context.scene.models.name = "__models", _context.scene.add(_context.scene.models), _context.scene.sysObjects = new Group, _context.scene.sysObjects.name = "__sysObjects", _context.scene.sysObjects.renderOrder = 1 / 0, _context.scene.add(_context.scene.sysObjects), _context.scene.noneModels = new Group, _context.scene.noneModels.name = "__noneModels", _context.scene.axesHelper = new AxesHelper(50), _context.scene.axesHelper.name = "__axesHelper", _context.scene.axesHelper.visible = !1, _context.scene.add(_context.scene.noneModels), _context.scene.sysObjects.add(_context.transformControls), !_context.alpha) { if (!_context.scene) return; switch (_context.scene.background = new Color$1(BACKGROUND_COLOR_DEFAULT), _context.renderer.outputEncoding) { case sRGBEncoding: _context.scene.background.convertSRGBToLinear && _context.scene.background.convertSRGBToLinear(); break; case GammaEncoding: _context.scene.background.convertGammaToLinear && _context.scene.background.convertGammaToLinear() } } _context.scene.setNodeRotation = this.setNodeRotation, _context.scene.setNodeRotating = this.setNodeRotating, _context.scene.setNodeScaling = this.setNodeScaling, _context.scene.setNodeBreathing = this.setNodeBreathing, _context.scene.add(_context.scene.axesHelper), _context.loaders.gltfLoader = new DHLoader, _context.loaders.gltfLoaderAVWS = new DHLoaderAVWS, window._textureMap = {}, window._needReplace = {}, _context.loaders.fbxLoader = new DHFBXLoader, _context.loaders.dracoLoader = new DRACOLoader, _context.loaders.dracoLoader.setDecoderPath(util$1.url(this.resourceBasePath, "lib/draco/gltf/")), _context.loaders.gltfLoader.setDRACOLoader(_context.loaders.dracoLoader), _context.loaders.bufferGeometryLoader = new BufferGeometryLoader, _context.loaders.textureLoader = new TextureLoader, _context.loaders.cubeTextureLoader = new CubeTextureLoader, _context.loaders.imageBitmapLoader = new ImageBitmapLoader, _context.cubeTextures = {}, _context.loaders.ddsLoader = new DDSLoader, _context.loaders.tgaLoader = new TGALoader, DefaultLoadingManager.addHandler(/\.tga$/i, _context.loaders.tgaLoader), DefaultLoadingManager.addHandler(/\.dds$/i, _context.loaders.ddsLoader), g.gltfExporter = new GLTFExporter$1, g.dhExporter = new DHExporter(_context.scene, this), _context.sceneStore = new SceneStore, _context.cacheStore = new CacheStore, _context.modelStore = new ModelStore(_context.scene), e = new ObjectStore(_context.scene), _context.objectStore = e, this.objectStore = e, _context.sysObjectStore = new SysObjectStore(_context.scene), _context.textureStore = new TextureStore("textureStore"), _context.customTextureStore = new TextureStore("customTextureStore"), this.customTextureStore = _context.customTextureStore, _context.materialStore = new MaterialStore(_context.textureStore, this), _context.lightStore = new LightStore(_context.scene, this), n = new PMREMGenerator(_context.renderer), _context.effectStore = new EffectStore, this.defaultEffectStore = _context.effectStore, _context.stateStore = new StateStore, this.defaultNodeSelection = new NodeSelection(_context.scene, this), this.defaultModelSelection = new ModelSelection, this.selectionControls = new SelectionControls, _context.animationStore = new AnimationStore, _context.animationMixers = [], _context.clippingStore = new ClippingStore, t = new EventHandlerStore(_context.renderer, _context.scene, _context.camera), _context.eventHandlerStore = t, this.defaultObjectTree = new ObjectTree(_context.scene), _context.defaultObjectTree = this.defaultObjectTree, _context.statistics = new Statistics, L = new CoordinateConvertHelper, C = new BaseCarrierController((e => { t.trailmove(e) })), _context.baseCarrierController = C, new Raycaster, _context.drawableDepthTest = "boolean" == typeof a.drawableDepthTest && a.drawableDepthTest, _context.paintControls = new PaintControls, _context.paintControls.init(), _context.selectControl = new SelectControls, _context.instancedObjectStore = new InstancedObjectStore, _context.backgroundBlur = new BackgroundBlur(_context.renderer), _context.backgroundBlur2 = new BackgroundBlur2(_context.renderer), a.camera && (a.camera.target || "number" == typeof a.camera.azimuthAngle || "number" == typeof a.camera.inclinationAngle || "number" == typeof a.camera.distance) && this.setCamera(a.camera), logger.debug("注册鼠标按下事件处理函数。"), _context.renderer.domElement.addEventListener("pointerdown", (function (e) { _context.pointerDisabled || 0 !== e.button && 2 !== e.button || (f = !0, m = { x: e.offsetX, y: e.offsetY }, d = !1, p = !1) }), !1), logger.debug("注册鼠标抬起事件处理函数。"), _context.renderer.domElement.addEventListener("pointerup", (i => { if (_context.pointerDisabled) return; if (0 !== i.button && 2 !== i.button) return; let r = !0; i.upFlag = !0, f && (i.upFlag = !1, f = !1, null !== m && (r = Math.abs(i.offsetX - m.x) < 3, !0 === r && (r = Math.abs(i.offsetY - m.y) < 3), m = null)), r ? (t.onClick(i, e, L), "manual" === _context.effectStore.visualEffect.dofFocus && (x.set(i.offsetX / _context.renderer.domElement.clientWidth * 2 - 1, -i.offsetY / _context.renderer.domElement.clientHeight * 2 + 1), this.focus())) : "manual" === _context.effectStore.visualEffect.dofFocus && (x.set(0, 0), this.focus()), d = !0, p = !0 }), !1), logger.debug("注册鼠标滑动事件。"), _context.renderer.domElement.addEventListener("pointermove", (i => { _context.pointerDisabled || (p = d, d = !0, d && p && E || f || t.mouseHoverTest(i, e, L)) }), !1), _context.renderer.domElement.addEventListener("wheel", (e => { t.onWheel(e) }), !1), this.on("camerazoomstop", void 0, (() => { this.focus() }), { debounce: !0 }), OverrideMaterialManager.workaroundEnabled = !0, window.rStats && (u.bS = new BrowserStats, u.glS = new glStats, u.tS = new threeStats(_context.renderer), u.rS = new rStats({ userTimingAPI: !0, values: { frame: { caption: "Total frame time (ms)", over: 16, average: !0, avgMs: 100 }, fps: { caption: "Framerate (FPS)", below: 30 }, calls: { caption: "Calls (three.js)", over: 3e3 }, raf: { caption: "Time elapsed (ms)", average: !0, avgMs: 100 }, setup: { caption: "Setup (ms)", average: !0, avgMs: 100 }, rstats: { caption: "rStats update (ms)", average: !0, avgMs: 100 }, focus: { caption: "Focus", average: !0, avgMs: 100 } }, groups: [{ caption: "Framerate", values: ["fps", "raf"] }, { caption: "Frame Budget", values: ["frame", "setup", "render"] }], fractions: [{ base: "frame", steps: ["texture", "setup", "render"] }], plugins: [u.bS, u.tS, u.glS] })), _context.clock = new Clock, s = !1, _context.renderer.info.autoReset = !1, _context.sceneBufferCacheExpired = !0, _context.passiveModeRenderRateFrameCount = 0, _context.passiveModeSkipFrameCount = 0, h || (_context.deltaA = 0, _context.frameTimeLimit = 1 / _context.fpsLimit, _context.frameTimeGap = 0, X()), _context.gisStore = new GISStore, _context.orbitControls.addEventListener("change", t.cameraMove.bind(t)) }, this.focus = () => { logger.debug("focus requested."), _context.effectStore && (_context.effectStore.visualEffect.enableDOF || _context.effectStore.visualEffect.dofQuality <= 0) && (Z(), logger.debug("focus done."), _ > 0 && (_context.effectStore.visualEffect.dofFocusDistance = 1 * _ / (_context.camera.far - _context.camera.near), _context.sceneBufferCacheExpired = !0)) }, this.setToneMapping = (e = LinearToneMapping, t = 1) => { _context.renderer.toneMapping = e, _context.renderer.toneMappingExposure = t; let i = this.getMaterials(); for (let e in i) i[e]._material() && (i[e]._material().needsUpdate = !0) }, this.hideModel = (e, t) => { this.defaultObjectTree.hideItemByName(e, t) }, this.showModel = (e, t) => { this.defaultObjectTree.showItemByName(e, t) }, this.hideNode = (e, t) => { _context.modelStore.hideNode(e, t) }, this.showNode = (e, t) => { _context.modelStore.showNode(e, t) }, this.hideAxesHelper = () => { _context.scene.axesHelper.visible = !1 }, this.showAxesHelper = () => { _context.scene.axesHelper.visible = !0 }, this.getObjectCount = () => A, this.getDefaultObjectTree = () => this.defaultObjectTree, this.playAnimation = (e, t, i) => { _context.modelStore.playAnimation(e, t, i) }, this.stopAnimation = (e, t) => { _context.modelStore.stopAnimation(e, t) }, this._playClip = () => { V = !1 }, this._stopClip = () => { V = !0 }, this.getResolution = () => r ? { width: r.width, height: r.height } : void 0, this.setResolution = (e, t) => { "number" != typeof e || e < WIDTH_MIN || e > WIDTH_MAX || "number" != typeof t || t < HEIGHT_MIN || t > HEIGHT_MAX || (r = { width: e, height: t }, s || (_context.camera.aspect = 1 * e / t, _context.camera.updateProjectionMatrix(), _context.renderer.setSize(e, t), _context.effectStore.setSize(e, t), _context.cameraOrtho.left = -200 * _context.camera.aspect, _context.cameraOrtho.right = 200 * _context.camera.aspect, _context.cameraOrtho.top = 200, _context.cameraOrtho.bottom = -200, _context.cameraOrtho.updateProjectionMatrix(), "number" == typeof _context.fpsLimit && this.setFPSLimit(_context.fpsLimit), _context.sceneBufferCacheExpired = !0)) }, this.changeSize = this.setResolution, this.setAmbientLight = (e, t) => { _context.lightStore.setAmbientLight(e, t) }, this.statsOn = () => { i.domElement.style.display = "block", c = !0 }, this.statsOff = () => { i.domElement.style.display = "none", c = !1 }, this.statsToggle = () => { i.domElement.style.display = c ? "none" : "block", c = !c }, this.switchCameraMode = (e = 0, t = "y", i = {}) => { if (E = 1 === e, E) { _context.scene.models.traverse((e => { e.isWater && (e.paused = !0) })); let e = -1 / 0, r = -1 / 0, n = -1 / 0, a = 1 / 0, o = 1 / 0; if (_context.scene.models.children instanceof Array && _context.scene.models.children.length > 0 ? (_context.scene.models.traverse((t => { if (t.geometry) if (i.boundingSphere) { t.geometry.computeBoundingSphere(), t.updateMatrixWorld(), t.geometry.boundingSphere.center.applyMatrix4(t.matrixWorld); const i = new Vector3(t.geometry.boundingSphere.center.x + t.geometry.boundingSphere.radius, t.geometry.boundingSphere.center.y + t.geometry.boundingSphere.radius, t.geometry.boundingSphere.center.z + t.geometry.boundingSphere.radius); e = Math.max(e, i.x), r = Math.max(r, i.y), n = Math.max(n, i.z); const s = new Vector3(t.geometry.boundingSphere.center.x - t.geometry.boundingSphere.radius, t.geometry.boundingSphere.center.y - t.geometry.boundingSphere.radius, t.geometry.boundingSphere.center.z - t.geometry.boundingSphere.radius); a = Math.min(a, s.y), o = Math.min(o, s.z) } else { t.geometry.computeBoundingBox(), t.updateMatrixWorld(); const i = new Vector3(t.geometry.boundingBox.max.x, t.geometry.boundingBox.max.y, t.geometry.boundingBox.max.z); i.applyMatrix4(t.matrixWorld), e = Math.max(e, i.x), r = Math.max(r, i.y), n = Math.max(n, i.z); const s = new Vector3(t.geometry.boundingBox.min.x, t.geometry.boundingBox.min.y, t.geometry.boundingBox.min.z); s.applyMatrix4(t.matrixWorld), a = Math.min(a, s.y), o = Math.min(o, s.z) } })), e += .2 * Math.abs(e), r += .2 * Math.abs(r), n += .2 * Math.abs(n), a -= .2 * Math.abs(a), o -= .2 * Math.abs(o)) : (e = 1e3, r = 1e3, n = 1e3, a = -1e3, o = -1e3), _context.cameraOrtho.position.x = 0, _context.cameraOrtho.position.y = "y" === t ? r : 0, _context.cameraOrtho.position.y = "-y" === t ? a : _context.cameraOrtho.position.y, _context.cameraOrtho.position.z = "z" === t ? n : 0, _context.cameraOrtho.position.z = "-z" === t ? o : _context.cameraOrtho.position.z, _context.cameraOrtho.lookAt(0, 0, 0), _context.cameraOrtho.updateMatrixWorld(), _context.cameraOrtho.updateProjectionMatrix(), i.fitX) { const t = e / _context.cameraOrtho.right; _context.cameraOrtho.zoom = 1 / t } else _context.cameraOrtho.zoom = 1; _context.cameraOrtho.updateMatrixWorld(), _context.cameraOrtho.updateProjectionMatrix(), _context.orthoCameraControls.target.set(0, 0, 0), "y" === t && (_context.orthoCameraControls.minPolarAngle = Math.PI / -2, _context.orthoCameraControls.maxPolarAngle = Math.PI / -2), "z" === t && (_context.orthoCameraControls.minPolarAngle = -1 / 0, _context.orthoCameraControls.maxPolarAngle = 1 / 0), _context.transformControls.camera = _context.cameraOrtho, _context.activeCamera = _context.cameraOrtho, _context.orbitControls.enabled = !1, _context.orthoCameraControls.enabled = !0 } else _context.scene.models.traverse((e => { e.isWater && (e.paused = !1) })), _context.transformControls.camera = _context.camera, _context.activeCamera = _context.camera, _context.orthoCameraControls.enabled = !1, _context.orbitControls.enabled = !0 }, this.getTextures = () => _context.textureStore ? [..._context.textureStore.getAll(), ..._context.customTextureStore.getAll()] : [], this.getModelTextures = () => _context.textureStore ? _context.textureStore.getAll() : [], this.getTexture = e => _context.textureStore.find(e), this.resetSettings = () => { _context.effectStore._composer && _context.effectStore._composer.reset() }, this.applySettings = async (e, t, i) => { null != e.sceneName && (_context.sceneName = e.sceneName), e.fpsLimit && this.setFPSLimit(e.fpsLimit), this.setColorSpace(e.colorSpace || "linear"); let r = null; r = e.states && e.states.length && e.preview ? JSON.parse(JSON.stringify(e.states.find((e => e.defaultState)).settings.view)) : JSON.parse(JSON.stringify(e.view)); let n = { type: "progress", total: 100, loaded: 0 }; if (this.defaultView.applySettings(r, (() => { }), !0), T = e && e.lights ? e.lights.skybox : "", this.resetSettings(), await _context.textureStore.applySettings(e.texture0 || {}), await _context.customTextureStore.applySettings(e.texture || []), n.loaded = 10, logger.debug("core.applySettings() loadTexture end。"), i && i(n), await _context.cacheStore.applySettings(e.cache), n.loaded = 20, logger.debug("core.applySettings() loadMaterial end。"), i && i(n), !(e.objectTree.children instanceof Array)) return void this.applyEffectSettings(e, t, i); let a = 0, o = [], s = []; for (let e in y.gltfLoader.requestHeader) s.push({ key: e, value: y.gltfLoader.requestHeader[e] }); this.contentLengthPromisesRemove(e.objectTree.children, o, s), Promise.all(o).then((r => { if (r instanceof Array) for (let e of r) a += Number(e); a += .2 * a, logger.debug(a); let n = [], o = [], s = 0; s = .2 * a; for (let t = 0; t < e.objectTree.children.length; t++)n.push(new Promise((r => { if ("ModelItem" === e.objectTree.children[t].type) this.defaultObjectTree.addModel({ name: e.objectTree.children[t].name, modelPath: e.objectTree.children[t].modelPath, modelType: e.objectTree.children[t].modelType || "glb", transform: e.objectTree.children[t].transform, index: e.objectTree.children[t].index, isVisible: null == e.objectTree.children[t].isVisible || e.objectTree.children[t].isVisible, isLock: null != e.objectTree.children[t].isLock && e.objectTree.children[t].isLock }, (e => { r(e) }), (r => { if (i) { var n = { name: e.objectTree.children[t].name, parent: "model", loaded: r.loaded }; for (let e = 0; e < o.length; e++)if (o[e].name === n.name && o[e].parent === n.parent) { var l = n.loaded - o[e].loaded; o.splice(e, 1), e-- } l || (l = n.loaded), o.push(n), s += l, i({ type: "progress", total: a, loaded: s }) } logger.debug("progress", r) })); else if ("IconAsset" === e.objectTree.children[t].type) new IconItem(e.objectTree.children[t], null, (e => { r(e) })); else if ("GroupItem" === e.objectTree.children[t].type) { let n = new GroupItem(e.objectTree.children[t]), l = []; e.objectTree.children[t].children.map((e => { switch (e.type) { case "IconAsset": new IconItem(e, n); break; case "ModelAsset": l.push(new Promise((t => { n.childrenAdd(new InstancedObject(e, n, (e => { t(e) }), (t => { if (i) { var r = { name: e.name, parent: "model", loaded: t.loaded }; for (let e = 0; e < o.length; e++)if (o[e].name === r.name && o[e].parent === r.parent) { var n = r.loaded - o[e].loaded; o.splice(e, 1), e-- } n || (n = r.loaded), o.push(r), s += n, i({ type: "progress", total: a, loaded: s }) } logger.debug("progress", t) }))) }))) } })), l.length ? Promise.all(l).then((() => { r(1) })) : r(1) } else if ("PaintItem" === e.objectTree.children[t].type) { let n = [], l = new PaintItem(e.objectTree.children[t]); e.objectTree.children[t].children.map((e => { switch (e.type) { case "IconAsset": new IconItem(e, l)._setLock(e.isLock); break; case "ModelAsset": case "ModelItem": n.push(new Promise((t => { new ModelItem(e, ((i, r, n) => { util$1.setArticulation(e, n), n.materialStore && n.materialStore.applySettings(e.materials, l.name), t(1) }), (t => { if (i) { var r = { name: e.name, parent: "model", loaded: t.loaded }; for (let e = 0; e < o.length; e++)if (o[e].name === r.name && o[e].parent === r.parent) { var n = r.loaded - o[e].loaded; o.splice(e, 1), e-- } n || (n = r.loaded), o.push(r), s += n, i({ type: "progress", total: a, loaded: s }) } logger.debug("progress", t) }), l) }))) } })); let c = e.objectTree.children[t].iconInstanced; for (let e = 0; e < c.length; e++)new InstancedGroup(c[e].assetObj, l, ((t, i) => { for (let t = 0; t < c[e].points.length; t++) { let r = JSON.parse(JSON.stringify(c[e].assetObj)); r.transform.position.x = c[e].points[t][0], r.transform.position.y = c[e].points[t][1], r.transform.position.z = c[e].points[t][2], c[e].scales && c[e].scales.length > t ? r.transform.scale = c[e].scales[t] : r.transform.scale = { x: 1, y: 1, z: 1 }, r.name = c[e].settings[t].name, r.isVisible = c[e].settings[t].isVisible, r.isLock = c[e].settings[t].isLock; let n = new InstancedItem(r, i, c[e].settings[t].key, c[e].settings[t].index); i.children[t].name = r.name, l.childrenAdd(n), r.isVisible || (n.getGroup().visible = r.isVisible) } })); let h = e.objectTree.children[t].modelInstanced; for (let e = 0; e < h.length; e++)n.push(new Promise((t => { new InstancedObject(h[e], l, ((i, r) => { for (let t = 0; t < h[e].points.length; t++) { let i = JSON.parse(JSON.stringify(h[e])); i.transform = { position: { x: h[e].points[t][0], y: h[e].points[t][1], z: h[e].points[t][2] } }, i.name = h[e].settings[t].name, i.isVisible = h[e].settings[t].isVisible, i.isLock = h[e].settings[t].isLock; let n = new InstancedItem(i, r, h[e].settings[t].key, h[e].settings[t].index); l.childrenAdd(n) } r.materialStore.applySettings(h[e].materials, l.name, r.name), t(i) }), (t => { if (i) { var r = { name: h[e].name, parent: "model", loaded: t.loaded }; for (let e = 0; e < o.length; e++)if (o[e].name === r.name && o[e].parent === r.parent) { var n = r.loaded - o[e].loaded; o.splice(e, 1), e-- } n || (n = r.loaded), o.push(r), s += n, i({ type: "progress", total: a, loaded: s }) } logger.debug("progress", t) })) }))); n.length ? Promise.all(n).then((e => { r(1) })) : r(1) } else if ("BuildingItem" === e.objectTree.children[t].type) { var n = e.objectTree.children[t].children; if (0 === n.length) this.defaultObjectTree.addBuilding(e.objectTree.children[t], (e => { r(e) })); else { for (let e = 0; e < n.length; e++)switch (n[e].type) { case "ModelItem": case "IconAsset": break; case "BuildingFloorItem": if (0 === n[e].children.length); else for (let t = 0; t < n[e].children.length; t++); }this.defaultObjectTree.addBuilding(e.objectTree.children[t], (e => { 1 === e && r(e) }), (e => { if (i) { let t; for (let i = 0; i < o.length; i++)o[i].name === e.name && o[i].parent === e.parent && (t = e.loaded - o[i].loaded, o.splice(i, 1), i--); t || (t = e.loaded), o.push(e), s += t, i({ type: "progress", total: a, loaded: s }) } logger.debug("progress", e) })) } } else "TileSetItem" === e.objectTree.children[t].type ? r({ type: "TileSetItem", item: e.objectTree.children[t] }) : "GisItem" === e.objectTree.children[t].type && r({ type: "GisItem", item: e.objectTree.children[t] }) }))); Promise.all(n).then((r => { i && i({ type: "progress", total: 1, loaded: 1 }); let n = []; n.push(new Promise((t => { this.applyEffectSettings(e, (e => { t(e) })) }))), this.defaultObjectTree.children.forEach((e => { if ("BuildingItem" === e.type && (e.children.forEach((e => { e.level && e.hide() })), e.floor)) { this.cutLevel(e.getGroup().uuid, e.floor); for (let t = 0; t < z.length; t++)z[t].uuid === e.getGroup().uuid && (z.splice(t, 1), t--); z.push({ uuid: e.getGroup().uuid, level: e.floor }) } })), r.forEach((e => { e && "TileSetItem" == e.type && n.push(new Promise((t => { new TileSetItem(e.item, (e => { t(e) })) }))), e && "GisItem" == e.type && n.push(new Promise((t => { new GisItem(e.item, (e => { t(e) })) }))) })), Promise.all(n).then((() => { _context.hasUpgradeSuggest && PerformanceSuggest.checkSuggestOn(), this.defaultObjectTree.applySettings(e.objectTree), t && t() })) })).catch((e => { logger.error(e) })) })) }, this.getResourceScene = async (e, t, i, r, n) => { if (null != e.sceneName && (_context.sceneName = e.sceneName), this.resetSettings(), !(e.objectTree.children instanceof Array)) return void this.applyEffectSettings(e, t, i); let a = 0, o = [], s = []; for (let e in y.gltfLoader.requestHeader) s.push({ key: e, value: y.gltfLoader.requestHeader[e] }); this.contentLengthPromisesRemove(e.objectTree.children, o, s), Promise.all(o).then((o => { if (o instanceof Array) for (let e of o) a += Number(e); logger.debug(a); let s = [], l = [], c = 0; for (let t = 0; t < e.objectTree.children.length; t++)"TileSetItem" !== e.objectTree.children[t].type && s.push(new Promise((o => { if ("ModelItem" === e.objectTree.children[t].type) n.addModel({ name: e.objectTree.children[t].name, modelPath: e.objectTree.children[t].modelPath, modelType: e.objectTree.children[t].modelType || "glb", transform: e.objectTree.children[t].transform, index: e.objectTree.children[t].index, isVisible: null == e.objectTree.children[t].isVisible || e.objectTree.children[t].isVisible, isLock: null != e.objectTree.children[t].isLock && e.objectTree.children[t].isLock }, (e => { o(e) }), (r => { if (i) { var n = { name: e.objectTree.children[t].name, parent: "model", loaded: r.loaded }; for (let e = 0; e < l.length; e++)if (l[e].name === n.name && l[e].parent === n.parent) { var o = n.loaded - l[e].loaded; l.splice(e, 1), e-- } o || (o = n.loaded), l.push(n), c += o, i({ type: "progress", total: a, loaded: c }) } logger.debug("progress", r) }), r); else if ("IconAsset" === e.objectTree.children[t].type) new IconItem(e.objectTree.children[t], r, (e => { o(e) }), n); else if ("GroupItem" === e.objectTree.children[t].type) { let i = new GroupItem(e.objectTree.children[t], null, r, n); e.objectTree.children[t].children.map((e => { switch (e.type) { case "IconAsset": new IconItem(e, i); break; case "ModelAsset": i.childrenAdd(new InstancedObject(e, i)) } })), o(1) } else if ("PaintItem" === e.objectTree.children[t].type) { let i = !0, a = [], s = new PaintItem(e.objectTree.children[t], null, r, n); e.objectTree.children[t].children.map((e => { switch (e.type) { case "IconAsset": new IconItem(e, s)._setLock(e.isLock); break; case "ModelAsset": case "ModelItem": i = !1, a.push(new Promise((t => { new ModelItem(e, (e => { t(e) }), null, s) }))) } })), a.length && Promise.all(a).then((e => { o(1) })); let l = e.objectTree.children[t].iconInstanced; for (let e = 0; e < l.length; e++)new InstancedGroup(l[e].assetObj, s, ((e, t) => { s.addInstanced("IconAsset", t) })); let c = e.objectTree.children[t].modelInstanced; for (let e = 0; e < c.length; e++) { let t = new InstancedObject(c[e], s); s.addInstanced("ModelAsset", t) } i && o(1) } else if ("BuildingItem" === e.objectTree.children[t].type) { var s = e.objectTree.children[t].children; if (0 === s.length) n.addBuilding(e.objectTree.children[t], (e => { o(e) }), (() => { }), r); else { for (let e = 0; e < s.length; e++)switch (s[e].type) { case "ModelItem": case "IconAsset": break; case "BuildingFloorItem": if (0 === s[e].children.length); else for (let t = 0; t < s[e].children.length; t++); }n.addBuilding(e.objectTree.children[t], (e => { 1 === e && o(e) }), (e => { if (i) { let t; for (let i = 0; i < l.length; i++)l[i].name === e.name && l[i].parent === e.parent && (t = e.loaded - l[i].loaded, l.splice(i, 1), i--); t || (t = e.loaded), l.push(e), c += t, i({ type: "progress", total: a, loaded: c }) } logger.debug("progress", e) }), r) } } }))); Promise.all(s).then((() => { i && i({ type: "progress", total: 1, loaded: 1 }), t() })).catch((e => { logger.error(e) })) })) }, this.applyEffectSettings = (e, t, i) => { i && i({ type: "progress", total: 1, loaded: 1 }), _context.sceneSettings = util$1.cloneDeep(e); let r = util$1.cloneDeep(e.view.camera); P.azimuthAngle = r.azimuth, P.inclinationAngle = r.inclination, P.fov = r.fov, P.viewDistance = r.distance, P.near = r.viewDistanceMin, P.far = r.viewDistanceMax, P.targetX = r.targetX, P.targetY = r.targetY, P.targetZ = r.targetZ, P.inclinationAngleMin = r.inclinationAngleMin, P.inclinationAngleMax = r.inclinationAngleMax, e.background && (_context.background.mode = e.background.mode, _context.background.cubeTextureRotationY = e.background.cubeTextureRotationY || 0, _context.background.cubeTextureBlur = e.background.cubeTextureBlur, _context.background.cubeTextureIntensity = e.background.cubeTextureIntensity, _context.background.environmentLuminosity = e.background.environmentLuminosity), _context.background.color = null, _context.background.texture = null, e.background && (e.background.colorCSSValue && this.setBackgroundColor(e.background.colorCSSValue), e.background.textureURL && this.setBackgroundImage(e.background.textureURL), e.background.mode && this.setBackgroundMode(e.background.mode, e)), this.defaultEffectStore.applySettings(e.effects), e.datumShiftModel && this.setDatumShiftModel(e.datumShiftModel), _context.stateStore && _context.stateStore.applySettings(e.states), null != e.sceneModelTransform && null != e.sceneModelTransform.position && (_context.scene.models.position.x = e.sceneModelTransform.position.x, _context.scene.models.position.y = e.sceneModelTransform.position.y, _context.scene.models.position.z = e.sceneModelTransform.position.z, _context.scene.models.rotation._order = e.sceneModelTransform.rotation._order, _context.scene.models.rotation._x = e.sceneModelTransform.rotation._x, _context.scene.models.rotation._y = e.sceneModelTransform.rotation._y, _context.scene.models.rotation._z = e.sceneModelTransform.rotation._z, _context.scene.models.scale.x = e.sceneModelTransform.scale.x, _context.scene.models.scale.y = e.sceneModelTransform.scale.y, _context.scene.models.scale.z = e.sceneModelTransform.scale.z), e.mapWorldRotationY && (B = e.mapWorldRotationY), _context.paintControls && _context.paintControls.updateWorld(), _context.lightStore.applySettings(e.lights, (() => { t && t(1, "applySettings() 加载完毕。") }), e.view.camera.duration), logger.debug("applySettings() 加载完毕。") }, this.contentLengthPromisesRemove = (e, t, i, r = []) => { e.map((e => { if ("ModelItem" === e.type || "ModelAsset" === e.type) { let a = e.modelPath || e.path; if (_context.cacheStore && _context.cacheStore._cache && _context.cacheStore._cache.get(md5(a))) return; if (-1 != a.indexOf("[[origin]]")) var n = a.replace("[[origin]]", _context.origin); else n = a; r.find((e => e === n)) || (r.push(n), t.push(util$1.fetchContentLength(n, i))) } else e.children && e.children.length > 0 && this.contentLengthPromisesRemove(e.children, t, i, r), e.modelInstanced && e.modelInstanced.length > 0 && this.contentLengthPromisesRemove(e.modelInstanced, t, i, r) })) }, this.applySceneSettings = (e, t) => { this.resetSettings(), e.background && (_context.background.mode != e.background.mode && (this.crossfadeFreeze(), this.crossfade(1e3)), _context.background.mode = e.background.mode, _context.background.cubeTextureRotationY = e.background.cubeTextureRotationY, _context.background.cubeTextureBlur = e.background.cubeTextureBlur), _context.background.color = null, _context.background.texture = null, _context.lightStore.applySettings(e.lights, (() => { }), e.view.camera.duration), e.background && (_context.background.cubeTextureRotationY = e.background.cubeTextureRotationY || 0, _context.background.cubeTextureBlur = e.background.cubeTextureBlur, _context.background.cubeTextureIntensity = e.background.cubeTextureIntensity, _context.background.environmentLuminosity = e.background.environmentLuminosity, e.background.colorCSSValue && (this._backgroundColorType != e.background.colorCSSValue.type && (this.crossfadeFreeze(), this.crossfade(1e3)), this._backgroundColorType = e.background.colorCSSValue.type, "single" == e.background.colorCSSValue.type ? (this._backgroundColor1 != e.background.colorCSSValue.color1 && (this.crossfadeFreeze(), this.crossfade(1e3)), this._backgroundColor1 = e.background.colorCSSValue.color1) : "gradient" == e.background.colorCSSValue.type && (this._backgroundColorUrl != e.background.colorCSSValue.dataUrl && (this.crossfadeFreeze(), this.crossfade(1e3)), this._backgroundColorUrl = e.background.colorCSSValue.dataUrl), this.setBackgroundColor(e.background.colorCSSValue)), e.background.textureURL && this.setBackgroundImage(e.background.textureURL), e.background.mode && this.setBackgroundMode(e.background.mode, e)), this.defaultObjectTree.applySettings(e.objectTree, !1, !1, !0), this.defaultEffectStore.applySettings(e.effects), e.datumShiftModel && this.setDatumShiftModel(e.datumShiftModel), this.defaultObjectTree.children.forEach((e => { if ("BuildingItem" === e.type) if (e.children.forEach((e => { e.level && e.hide() })), e.floor) { this.cutLevel(e.getGroup().uuid, e.floor); for (let t = 0; t < z.length; t++)z[t].uuid === e.getGroup().uuid && (z.splice(t, 1), t--); z.push({ uuid: e.getGroup().uuid, level: e.floor }) } else this.cutLevel(e.getGroup().uuid, e.floor) })), this.nextRender((() => { this.setAutoRotate(!1, 0), this.defaultView.applySettings(e.view, (i => { t && t(i, "状态切换成功"), this.focus(), this.nextRender((() => { this.setAutoRotate(e.view.camera.autoRotate, util$1.getAutoRotateTime(e.view.camera.autoRotateSpeed, e.view.camera.autoRotateDirection)) }), 10) })) }), 1), logger.debug("applySceneSettings() 应用完毕。") }, this.saveSceneSettings = e => { _context.sceneSettings = util$1.clone(e) }, this.loadSceneSettings = () => util$1.clone(_context.sceneSettings), this.disableLightProbe = () => { _context.lightStore.disableLightProbe() }, this.enableLightProbe = () => { _context.lightStore.enableLightProbe() }, this.off = (e, i, r) => { t ? t.remove(e, i, r) : logger.error("事件处理管理器错误。") }, this.on = (e, i, r) => { t ? t.add(e, i, r) : logger.error("事件处理管理器错误。") }, this._transformControlKeyUp = function (e) { switch (e.keyCode) { case 16: _context.transformControls.setTranslationSnap(null), _context.transformControls.setRotationSnap(null), _context.transformControls.setScaleSnap(null) } }, this._transformControlKeyDown = function (e) { e.keyCode }, this.enableTransformOnModel = (e, t, i) => { if (!_context.scene) return !1; if (!this.defaultObjectTree.getItemByName(e)) return; let r = this.defaultObjectTree.getItemByName(e).getGroup(); return !!(r && r instanceof Object3D) && (_context.transformControls.attach(r), void 0 !== i && ("translate" === t && _context.transformControls.setTranslationSnap(i), "scale" === t && _context.transformControls.setScaleSnap(i), "rotate" === t && (i = i / 180 * Math.PI, _context.transformControls.setRotationSnap(i))), this.setTransformMode(t), window.addEventListener("keydown", this._transformControlKeyDown), window.addEventListener("keyup", this._transformControlKeyUp), !0) }, this.enableTransformOnNode = (e, t) => { if (!_context.scene) return void logger.debug("_context.scene 为空"); if (this.disableTransform(), !this.defaultObjectTree.getItemByName(e)) return; let i = this.defaultObjectTree.getItemByName(e).getGroup(); if (i && i instanceof Object3D) { let e; if (i.traverse((function (i) { i.name === t && (e = i) })), e) return _context.transformControls.attach(e), this.setTransformMode("translate"), window.addEventListener("keydown", this._transformControlKeyDown), window.addEventListener("keyup", this._transformControlKeyUp), !0 } return _context.effectStore.highlightObject(void 0), !1 }, this.transformControlChangeEvent = e => { let t = e.target.object, i = {}; t && (t instanceof InstancedHelper ? i = this.getModelTransformByUUID(t.uuid) : (i.position = JSON.parse(JSON.stringify(t.position)), i.rotation = JSON.parse(JSON.stringify(t.rotation)), i.rotation.x = i.rotation._x, i.rotation.y = i.rotation._y, i.rotation.z = i.rotation._z, i.scale = JSON.parse(JSON.stringify(t.scale)), i.rotation.x = i.rotation._x = MathUtils.radToDeg(i.rotation._x), i.rotation.y = i.rotation._y = MathUtils.radToDeg(i.rotation._y), i.rotation.z = i.rotation._z = MathUtils.radToDeg(i.rotation._z))), _context.TransformChangeCallback && _context.TransformChangeCallback(e, i) }, this.enableTransformByUUID = (e, t) => { if (!_context.scene) return !1; let i = this.defaultObjectTree.getItemByUUID(e); if (i && "TileSetItem" === i.type) return void logger.debug("TRACE:core.enableTransformByUUID() objectItem.type is TileSetItem transformControls suppress checking"); let r = _context.scene.getObjectByProperty("uuid", e); return !!(r && r instanceof Object3D) && (t && (_context.TransformChangeCallback = t), _context.transformControls.addEventListener("objectChange", this.transformControlChangeEvent), _context.transformControls.attach(r), _context.transformControls.mode || this.setTransformMode("translate"), window.addEventListener("keydown", this._transformControlKeyDown), window.addEventListener("keyup", this._transformControlKeyUp), !0) }, this.enableLightTransform = (e, t) => !(!_context.scene || !_context.lightStore) && _context.lightStore.transformDirectionalLight(e, t), this.setLightTransformMode = e => !(!_context.scene || !_context.lightStore) && _context.lightStore.setTransformMode(e), this.disableLightTransform = () => !(!_context.scene || !_context.lightStore) && _context.lightStore.disableTransformDirectionalLight(), this.getTransformMode = () => _context.scene && _context.transformControls ? _context.transformControls.getMode() : "", this.setTransformMode = e => { if (!_context.scene || !_context.transformControls || "string" != typeof e) return !1; switch (e.toLowerCase()) { case "translate": case "rotate": case "scale": return D || _context.transformControls.setMode(e.toLowerCase()), !0 }return !1 }, this.disableTransform = () => { _context.scene ? D || (_context.transformControls.removeEventListener("objectChange", this.transformControlChangeEvent), _context.transformControls.detach(), window.removeEventListener("keydown", this._transformControlKeyDown), window.removeEventListener("keyup", this._transformControlKeyUp)) : logger.debug("_context.scene 为空") }, this.saveSceneCamera = () => { P = JSON.parse(JSON.stringify(this.getCamera())) }, this.onMapWorld = () => { this.saveSceneCamera(), this.switchCameraMode(1), I = _context.background.mode, this.setBackgroundMode("none"), _context.orthoCameraControls.keyOperate = "translation", _context.transformControls.attach(_context.scene.models), this.setTransformMode("rotate"), _context.transformControls.showX = !1, _context.transformControls.showY = !0, _context.transformControls.showZ = !1, N.rotation = JSON.parse(JSON.stringify(_context.scene.models.rotation)), B && _context.scene.models.rotation.set(0, MathUtils.degToRad(B), 0), D = !0 }, this.offMapWorld = () => { D && (D = !1, this.switchCameraMode(0), I && this.setBackgroundMode(I), I = null, "editor" === _context.pointerMode ? _context.orthoCameraControls.keyOperate = "paint" : _context.orthoCameraControls.keyOperate = null, this.disableTransform(), _context.transformControls.showX = !0, _context.transformControls.showY = !0, _context.transformControls.showZ = !0, _context.transformControls.showE = !1, B = this.getSceneRotationY(), this.notState && (this.notState.datumShiftModel = JSON.parse(JSON.stringify(this.getSettings().datumShiftModel))), _context.scene.models.rotation.order = N.rotation._order, _context.scene.models.rotation.x = N.rotation._x, _context.scene.models.rotation.y = N.rotation._y, _context.scene.models.rotation.z = N.rotation._z) }, this.onXYZCalibrate = () => { this.saveSceneCamera(), this.switchCameraMode(1), I = _context.background.mode, _context.orthoCameraControls.keyOperate = "translation", _context.transformControls.attach(_context.scene.models), this.setTransformMode("rotate"), _context.transformControls.showX = !1, _context.transformControls.showY = !0, _context.transformControls.showZ = !1, N.rotation = JSON.parse(JSON.stringify(_context.scene.models.rotation)), B && _context.scene.models.rotation.set(0, MathUtils.degToRad(B), 0), D = !0 }, this.offXYZCalibrate = () => { D && (D = !1, this.switchCameraMode(0), I = null, "editor" === _context.pointerMode ? _context.orthoCameraControls.keyOperate = "paint" : _context.orthoCameraControls.keyOperate = null, this.disableTransform(), _context.transformControls.showX = !0, _context.transformControls.showY = !0, _context.transformControls.showZ = !0, _context.transformControls.showE = !1, B = this.getSceneRotationY(), this.notState && (this.notState.datumShiftModel = JSON.parse(JSON.stringify(this.getSettings().datumShiftModel))), _context.scene.models.rotation.order = N.rotation._order, _context.scene.models.rotation.x = N.rotation._x, _context.scene.models.rotation.y = N.rotation._y, _context.scene.models.rotation.z = N.rotation._z) }, this.onMapWorld1 = () => { _context.scene.models && !D && (this.switchCameraMode(1), I = _context.background.mode, this.setBackgroundMode("none"), this.leftButtonHandle("translation"), _context.transformControls.attach(_context.scene.models), window.addEventListener("keydown", this._transformControlKeyDown), window.addEventListener("keyup", this._transformControlKeyUp), this.setTransformMode("rotate"), _context.transformControls.showX = !1, _context.transformControls.showY = !1, _context.transformControls.showZ = !1, _context.transformControls.showE = !0, this.on("camerazoom", "", (e => { e.wheelDelta > 0 ? (_context.scene.models.scale.x += .05, _context.scene.models.scale.y += .05, _context.scene.models.scale.z += .05) : (_context.scene.models.scale.x -= .05, _context.scene.models.scale.y -= .05, _context.scene.models.scale.z -= .05) })), N.position = JSON.parse(JSON.stringify(_context.scene.models.position)), N.rotation = JSON.parse(JSON.stringify(_context.scene.models.rotation)), N.scale = JSON.parse(JSON.stringify(_context.scene.models.scale)), _isWorldMapModelTransform && (_context.scene.models.position.x = _isWorldMapModelTransform.position.x, _context.scene.models.position.y = _isWorldMapModelTransform.position.y, _context.scene.models.position.z = _isWorldMapModelTransform.position.z, _context.scene.models.rotation.order = _isWorldMapModelTransform.rotation._order, _context.scene.models.rotation.x = _isWorldMapModelTransform.rotation._x, _context.scene.models.rotation.y = _isWorldMapModelTransform.rotation._y, _context.scene.models.rotation.z = _isWorldMapModelTransform.rotation._z, _context.scene.models.scale.x = _isWorldMapModelTransform.scale.x, _context.scene.models.scale.y = _isWorldMapModelTransform.scale.y, _context.scene.models.scale.z = _isWorldMapModelTransform.scale.z), D = !0) }, this.offMapWorld1 = () => { D && (D = !1, this.switchCameraMode(0), I && this.setBackgroundMode(I), I = null, this.leftButtonHandle(null), this.disableTransform(), _context.transformControls.showX = !0, _context.transformControls.showY = !0, _context.transformControls.showZ = !0, _context.transformControls.showE = !1, this.off("camerazoom", "", ""), _isWorldMapModelTransform.position = JSON.parse(JSON.stringify(_context.scene.models.position)), _isWorldMapModelTransform.rotation = JSON.parse(JSON.stringify(_context.scene.models.rotation)), _isWorldMapModelTransform.scale = JSON.parse(JSON.stringify(_context.scene.models.scale)), _context.scene.models.position.x = N.position.x, _context.scene.models.position.y = N.position.y, _context.scene.models.position.z = N.position.z, _context.scene.models.scale.x = N.scale.x, _context.scene.models.scale.y = N.scale.y, _context.scene.models.scale.z = N.scale.z) }, this.getItemByName = e => this.defaultObjectTree.getItemByName(e), this.findNodeByName = e => this.defaultObjectTree.findNodeByName(e), this.addCubeCamera = (e, t, i) => { let r = t.name; if (_context.ssr.find((t => t.nodeName === r && t.modelName === e && t.materialName === i))) return; let n = new WebGLCubeRenderTarget(256, { format: RGBFormat, generateMipmaps: !0, minFilter: LinearMipmapLinearFilter }), a = new CubeCamera(1, 2e3, n), o = (new Box3).setFromObject(_context.scene.models.getObjectByProperty("uuid", t.uuid || t.id)), s = new Vector3; o.getSize(s), a.position.y = s.y / 2, a.name = util$1.randomString(8), _context.scene.models.getObjectByProperty("uuid", t.uuid || t.id).add(a), o = null, s = null, _context.ssr.push({ cubeRenderTarget: n, cubeCamera: a, nodeName: r, modelName: e, materialName: i }) }, this.materialsInModelItem = (e, t) => { var i = !1; for (let r in e) r === t.material && e[r]._modelName === t.modelName && (i = !0); return i }, this.ssrOn = (e, t) => { var i = null, r = null; if (U) { let t = this.defaultObjectTree.getItemByUUID(U); for (let r = 0; r < t.children.length && !(i = util$1.findModelItemNodeByName(t.children[r], e)); r++); } else if (t) { let r = this.defaultObjectTree.getItemByName(t); for (let t = 0; t < r.children.length && !(i = util$1.findModelItemNodeByName(r.children[t], e)); t++); } else i = this.findNodeByName(e); if (!i) return; if (i.enableSSR = !0, !i.modelName && !t) return; r = t ? this.defaultObjectTree.findModelFromBuilding(void 0, t, "modelName") : this.defaultObjectTree.findModelFromBuilding(void 0, i.modelName, "modelName"); let n = this.defaultObjectTree.children.find((e => e.name === r.name)); if (n) { var a = {}; null != n.getMaterials ? a = n : n.children.forEach((e => { "ModelItem" === e.type ? this.materialsInModelItem(e.materialStore._materials, i) && (a = e) : "BuildingFloorItem" === e.type && e.children.forEach((e => { e.materialStore && this.materialsInModelItem(e.materialStore._materials, i) && (a = e) })) })), a.materialStore && ("string" == typeof i.material ? a.materialStore._materials[i.material].enableSSR && this.addCubeCamera(a.name, i, i.material) : i.material instanceof Array && i.material.map((e => { a.materialStore._materials[e].enableSSR && this.addCubeCamera(a.name, i, e) }))) } }, this.ssrOff = (e, t) => { let i = null; if (U) { let t = this.defaultObjectTree.getItemByUUID(U); for (let r = 0; r < t.children.length && (i = util$1.findModelItemNodeByName(t.children[r], e), !i); r++); } else if (t) { let r = this.defaultObjectTree.getItemByName(t); for (let t = 0; t < r.children.length && (i = util$1.findModelItemNodeByName(r.children[t], e), !i); t++); } else i = this.findNodeByName(e); if (i) { i.enableSSR = !1; for (let t = 0; t < _context.ssr.length; t++)_context.ssr[t].nodeName === e && _context.ssr[t].modelName === i.modelName && (this.findMaterialInModel(_context.ssr[t].modelName, _context.ssr[t].materialName)._material().envMap.dispose(), this.findMaterialInModel(_context.ssr[t].modelName, _context.ssr[t].materialName)._material().envMap = null, _context.ssr.splice(t, 1)) } }, this.snapOn = (e, t) => { switch (e) { case "translation": _context.transformControls.translationSnap = t; break; case "rotation": _context.transformControls.rotationSnap = t / 180 * Math.PI; break; case "scale": _context.transformControls.scaleSnap = t } }, this.snapOff = e => { switch (e) { case "translation": _context.transformControls.translationSnap = null; break; case "rotation": _context.transformControls.rotationSnap = null; break; case "scale": _context.transformControls.scaleSnap = null } }, this.fadeOut = (e, t, i) => { if (_context.renderer && _context.renderer.domElement && t) var r = _context.renderer.domElement.style.opacity || 1, n = (e = e / 100 || 10, setInterval((function () { r > 0 ? _context.renderer.domElement.style.opacity = r = parseFloat(r - .1).toFixed(2) : (clearInterval(n), i && i()) }), e)); else i && i() }, this.fadeIn = (e, t) => { if (!_context.renderer || !_context.renderer.domElement) return; let i = _context.renderer.domElement.style.opacity; if ("" !== i && 1 !== i) var r = _context.renderer.domElement.style.opacity || 0, n = (e = e / 100 || 10, setInterval((function () { r < 1 ? _context.renderer.domElement.style.opacity = r = (parseFloat(r) + .1).toFixed(2) : (clearInterval(n), t && t()) }), e)); else t && t() }, this.clipNode = (e, t, i, r, n) => { _context.clippingController && (_context.clippingController.clear(), delete _context.clippingController), _context.clippingController = new ClippingController({ meshes: [_context.scene.getObjectByName(e)], clippingPlanes: [{ nx: t, ny: i, nz: r, d: n }] }) }, this.cutLevel = (e, t, i, r = !0) => { var n = this.defaultObjectTree.getItemByUUID(e); if (n || (n = this.defaultObjectTree.getItemByName(e), e = n.getGroup().uuid), n || i && i(0, "建筑不存在"), t) { _context.clippingStore.findCutBulidingByUUID(e) && _context.clippingStore.remove(e), n.floor = t, n.children.forEach((i => { if (i.level === Number(t)) { let t = (new Box3).setFromObject(i.getGroup()), r = new Vector3; t.getSize(r), _context.clippingStore.add(e, 0, -1, 0, t.max.y + .02 * r.y), this.defaultObjectTree.getItemByUUID(e).children.forEach((e => { if ("IconAsset" === e.type) { (e.getGroup().position.y || e.transform.position.y) > t.max.y ? e.clipping = !0 : e.clipping = !1 } })) } })), r && (this.defaultObjectTree.getItemByUUID(e) ? this.defaultObjectTree.getItemByUUID(e).children.forEach((e => { e.level === t ? e.show() : e.level && e.hide() })) : this.defaultObjectTree.getItemByName(e).children.forEach((e => { e.level === t ? e.show() : e.level && e.hide() }))); for (let t = 0; t < z.length; t++)z[t].uuid === e && (z.splice(t, 1), t--); let a = { uuid: e, level: t }; z.push(a), i && i(1, "建筑拆解完成") } else { n.floor = t, _context.clippingStore.findCutBulidingByUUID(e) && _context.clippingStore.remove(e), this.defaultObjectTree.getItemByUUID(e) ? this.defaultObjectTree.getItemByUUID(e).children.forEach((t => { if (t.level) { r && t.hide(); let i = (new Box3).setFromObject(t.getGroup()), n = new Vector3; i.getSize(n), this.defaultObjectTree.getItemByUUID(e).children.forEach((e => { if ("IconAsset" === e.type) { (e.getGroup().position.y || e.transform.position.y) > i.max.y && (e.clipping = !1) } })) } })) : r && this.defaultObjectTree.getItemByName(e).children.forEach((e => { e.level && e.hide() })); for (let t = 0; t < z.length; t++)z[t].uuid === e && (z.splice(t, 1), t--); i && i(1, "建筑恢复完成") } }, this.cutLevelByUUID = (e, t = !0) => { let i = this.defaultObjectTree.getItemByUUID(e); if (i) if ("BuildingItem" === i.type) { if (!i.floor && t) return void this.defaultObjectTree.getItemByUUID(e).children.forEach((e => { e.level && e.hide() })); this.cutLevel(e, i.floor, (() => { }), t) } else _context.instance.selectionControls.fromBuildingSelection && _context.instance.selectionControls.fromBuildingSelection.uuid != e && this.cutLevelByUUID(_context.instance.selectionControls.fromBuildingSelection.uuid, t) }, this.setPaintMode = function ({ mode: e = "roam", category: t, size: i = 1, assets: r = [], removeDensity: n = 1, hasLayerDraw: a = !1 }, o, s, l) { _context.paintControls && _context.paintControls.setMode(e, t, i, r, n, a, o, s, l) }, this.setPaintLayerName = function (e) { _context.paintControls && _context.paintControls.setLayerName(e) }, this.setPaintData = function (e) { _context.paintControls && _context.paintControls.setData(e) }, this.setOrbitDamping = e => { "number" == typeof e && (0 === e && (_context.orbitControls.enableDamping = !1), e > 0 && (_context.orbitControls.dampingFactor = e)) }, this.getIconAsset = (e, t) => { if (e) return this.defaultObjectTree.getAsset(e, "IconAsset", t) }, this.objectIsHidedByName = e => { _pitchOnModelName = e; let t = this.defaultObjectTree.children; if (e) z.forEach((e => { _context.clippingStore.remove(e.name) })), F && 0 === F.length && (F = JSON.parse(JSON.stringify({ children: util$1.getSettingsRecursively(t) }))), t.map((e => { switch (e.type) { case "ModelItem": case "IconAsset": e.hide(); break; case "BuildingItem": e.hide(), e.children.map((e => { switch (e.type) { case "ModelItem": e.hide(); break; case "BuildingFloorItem": e.hide(), e.children.map((e => { e.hide() })) } })) } })), t.map((t => { if (t.name === e) switch (t.type) { case "ModelItem": t.show(); break; case "BuildingItem": t.show(), t.children.map((e => { switch (e.type) { case "ModelItem": e.show(); break; case "BuildingFloorItem": e.show(), e.children.map((e => { e.show() })) } })) } else "BuildingItem" === t.type && t.children.map((i => { if (i.name === e) switch (t.show(), i.type) { case "ModelItem": i.show(); break; case "BuildingFloorItem": i.show(), i.children.map((e => { e.show() })) } else "BuildingFloorItem" === i.type && i.children.map((r => { r.name === e && (t.show(), i.show(), r.show()) })) })) })); else { z.forEach((e => { this.defaultObjectTree.getItemByName(e.name).children.forEach((t => { if (t.level === Number(e.level)) { let i = (new Box3).setFromObject(t.getGroup()), r = new Vector3; i.getSize(r), _context.clippingStore.add(e.name, 0, -1, 0, i.max.y + .02 * r.y) } })) })), this.defaultObjectTree.children.map((e => { F.children.map((t => { e.name === t.name && ("ModelItem" === e.type || "IconAsset" === e.type ? t.isVisible ? e.show() : e.hide() : "BuildingItem" === e.type && (t.isVisible ? e.show() : e.hide(), e.children.length > 0 && e.children.map((e => { t.children.map((t => { e.name === t.name && ("ModelItem" === e.type || "IconAsset" === e.type ? t.isVisible ? e.show() : e.hide() : "BuildingFloorItem" === e.type && (t.isVisible ? e.show() : e.hide(), e.children.length > 0 && e.children.map((e => { t.children.map((t => { e.name === t.name && (t.isVisible ? e.show() : e.hide()) })) })))) })) })))) })) })), F = [] } }, this.objectIsHidedByUUID = e => { e && !U && (this.saveSceneCamera(), I = _context.background.mode), U = e; let t = this.defaultObjectTree.children; if (e) z.forEach((e => { _context.clippingStore.remove(e.uuid) })), 0 === F.length && (F = JSON.parse(JSON.stringify({ children: util$1.getSettingsRecursively(t) }))), util$1.setObjectTreeIsHideRecursion(t), util$1.setObjectTreeShowByUUID(t, e); else { z.forEach((e => { var t = this.defaultObjectTree.getItemByUUID(e.uuid); t || (t = this.defaultObjectTree.getItemByName(e.uuid)), t && t.children.forEach((t => { if (t.level === Number(e.level)) { let i = (new Box3).setFromObject(t.getGroup()), r = new Vector3; i.getSize(r), _context.clippingStore.add(e.uuid, 0, -1, 0, i.max.y + .02 * r.y) } })) })); let e = this.defaultObjectTree.children; util$1.recoverIsShowOrHide(F.children, e), F = [] } }, this.crossfadeFreeze = () => { !_context.crossfade && _context.renderer && (_context.markDom || (_context.crossfade = !0, Y(), _context.crossfadeImageElement = document.createElement("img"), _context.crossfadeImageElement.style.position = "absolute", _context.crossfadeImageElement.style.height = _context.renderer.domElement.clientHeight + "px", _context.crossfadeImageElement.style.width = _context.renderer.domElement.clientWidth + "px", _context.crossfadeImageElement.style.left = _context.renderer.domElement.clientLeft + "px", _context.crossfadeImageElement.style.top = _context.renderer.domElement.clientTop + "px", _context.crossfadeImageElement.style.pointerEvents = "none", _context.crossfadeImageElement.src = _context.renderer.domElement.toDataURL(), _context.renderer.domElement.parentElement.appendChild(_context.crossfadeImageElement))) }, this.crossfade = e => { if (!_context.crossfade || _context.onCrossfade) return; _context.onCrossfade = !0; var t = .9; let i; e = e / 100 || 10; let r = (new Date).getTime(); this.nextRender((() => { var n; n = setInterval((function () { _context.crossfadeImageElement && (i = ((new Date).getTime() - r) / (e / 10), (new Date).getTime() - r > 100 && (i = 100 / (e / 10)), r = (new Date).getTime(), t > 0 ? _context.crossfadeImageElement.style.opacity = t -= .001 * i : (clearInterval(n), _context.crossfadeImageElement.parentElement.removeChild(_context.crossfadeImageElement), _context.crossfadeImageElement = null, _context.crossfade = !1, _context.onCrossfade = !1)) }), e) })) }, this.saveCamera = e => { void 0 !== e && (e ? (G = this.getCamera(), _context.instance._notView = JSON.parse(JSON.stringify(this.defaultView.getSettings()))) : G && (G.target = { x: G.targetX, y: G.targetY, z: G.targetZ }, G.distance = G.viewDistance, G.duration = 1.5, G.far = this.getCamera().far, G.fov = this.getCamera().fov, G.near = this.getCamera().near, G.duration = 1.5, this.setCamera(G))) }, this.getSceneRotationY = () => { var e = new Vector3(0, 0, 1); return _context.scene.models.quaternion.setFromEuler(_context.scene.models.rotation), e.applyQuaternion(_context.scene.models.quaternion), (MathUtils.radToDeg(Math.atan2(-e.x, -e.z)) + 180 + 180) % 360 - 180 }, this.setFPSLimit = e => { "number" != typeof e || e < 1 || e > 240 || isNaN(e) || (_context.fpsLimit = e, _context.frameTimeLimit = 1 / e, _context.frameTimeGap = 0) }, this.getSettings = e => { if (e && "" != this.getCurrentState()) return this.notState ? (this.notState.states = _context.stateStore.getSettings(), this.notState) : this.getSettings(); let t = {}; return t.cache = _context.cacheStore.getSettings(), t.texture0 = _context.textureStore.getSettings(), t.texture = _context.customTextureStore.getSettings(), t.objectTree = this.defaultObjectTree.getSettings(), F.children && F.children.length > 0 && util$1.recoverShowGetSettings(F.children, t.objectTree.children), t.states = _context.stateStore.getSettings(), t.effects = { visualEffect: this.defaultEffectStore.visualEffect.getSettings(), spaceEffect: this.defaultEffectStore.spaceEffect.getSettings() }, t.background = { mode: _context.background.mode, colorCSSValue: _context.background.colorCSSValue, textureURL: _context.background.textureURL, cubeTextureRotationY: _context.background.cubeTextureRotationY || 0, cubeTextureBlur: _context.background.cubeTextureBlur, cubeTextureIntensity: _context.background.cubeTextureIntensity, environmentLuminosity: _context.background.environmentLuminosity }, t.lights = _context.lightStore.getSettings(), t.lights.skybox = T, t.datumShiftModel = _context.datumShiftModel, t.view = this.defaultView.getSettings(), (D || U) && (e || (t.view.camera.azimuth = P.azimuthAngle, t.view.camera.inclination = P.inclinationAngle, t.view.camera.distance = P.viewDistance, t.view.camera.targetX = P.targetX, t.view.camera.targetY = P.targetY, t.view.camera.targetZ = P.targetZ, t.view.camera.inclinationAngleMin = P.inclinationAngleMin, t.view.camera.inclinationAngleMax = P.inclinationAngleMax, D && !U && (t.view.camera.viewDistanceMin = P.near, t.view.camera.viewDistanceMax = P.far, t.view.camera.fov = P.fov), t.background.mode = I)), t.sceneModelTransform = {}, D && (t.sceneModelTransform.position = _context.scene.models.position, t.sceneModelTransform.rotation = _context.scene.models.rotation, t.sceneModelTransform.scale = _context.scene.models.scale), t.mapWorldRotationY = !D && B ? B : this.getSceneRotationY(), _context.effectStore.visualEffect._passes.outlinePass.effects[0].time = 0, t.sceneName = _context.sceneName, t.colorSpace = this.getColorSpace(), t.fpsLimit = _context.fpsLimit, t }, this.getPreloadResource = () => _context.cacheStore.preloadResourceStore, this.getSettingsToJSON = e => JSON.stringify(this.getSettings(), 0, e ? 2 : 0), this.highlightMaterial = (e, t) => { if (!_context.scene) return void logger.debug("_context.scene 为空"); _context.highlight || (_context.highlight = { material: void 0 }), e || t || _context.highlight.material && _context.highlight.material._material() instanceof Material$1 && (delete _context.highlight.material._material().onBeforeCompile, _context.highlight.material._material().needsUpdate = !0, _context.highlight.material = void 0); let i = this.defaultObjectTree.findItemByName(e); if (!i) return; let r = i.findMaterial(t); r && r._material() instanceof Material$1 && _context.highlight.material !== r && (_context.highlight.material && _context.highlight.material._material() instanceof Material$1 && (delete _context.highlight.material._material().onBeforeCompile, _context.highlight.material._material().needsUpdate = !0, _context.highlight.material = void 0), _context.highlight.material = r, r._material().onBeforeCompile = e => { e.vertexShader = e.vertexShader.replace("void main() {", ["varying vec2 vUvHighlight;", "void main() {", "  vUvHighlight = uv;"].join("\n")), e.fragmentShader = e.fragmentShader.replace("void main() {", ["varying vec2 vUvHighlight;", "void main() {"].join("\n")), e.fragmentShader = e.fragmentShader.replace("#include <map_fragment>", ["#ifdef USE_MAP", "  vec4 texelColor = mapTexelToLinear( texture2D( map, vUv ) );", "\t diffuseColor = texelColor * diffuseColor;", "#endif", "float fracX = fract(vUvHighlight.x * 10.0);", "float fracY = fract(vUvHighlight.y * 10.0);", "if (abs(fracX - 0.5) <= 0.1 && abs(fracY - 0.5) <= 0.1) {", "  diffuseColor = mix(diffuseColor, vec4(1.0, 0.15, 0.75, 1.0), 0.9);", "}"].join("\n")) }, r._material().needsUpdate = !0) }, this.highlightModel = (e, t) => { if (!_context.scene) return void logger.debug("_context.scene 为空"); if (!e) return _context.effectStore.highlightObject(void 0), !1; if (!this.defaultObjectTree.getItemByName(e)) return; let i = this.defaultObjectTree.getItemByName(e).getGroup(); if (i && i instanceof Object3D) { if ("GroupItem" === i.type) i.getGroup().children.map((e => { "Mesh" === e.type && _context.effectStore.highlightObject(e, !0) })); else _context.effectStore.highlightObject(i, t); return !0 } return _context.effectStore.highlightObject(void 0), !1 }, this.highlightInstancedHelper = (e, t, i) => { e && i || _context.effectStore.cancelLayerHelper(), t && (t.visible = !0) }, this.highlightByUUID = (e, t) => { let i = this.defaultObjectTree.getItemByUUID(e), r = null; if (H instanceof Array ? (r = [], H.forEach((e => { let t = this.defaultObjectTree.getItemByUUID(e); t && r.push(t) }))) : H && (r = this.defaultObjectTree.getItemByUUID(H)), r && r !== [] || (H = null), !_context.scene) return void logger.debug("_context.scene 为空"); if (_context.effectStore.highlightObject(void 0), !e) return r instanceof Array ? r.forEach((e => { e && (e instanceof InstancedItem ? e.disableHighlight() : e.getGroup().children[0].material.uniforms.outline.value = 0) })) : r && (r instanceof InstancedItem ? r.disableHighlight() : r.getGroup().children[0].material.uniforms.outline.value = 0), H = null, !1; if (H) { if (H == e) return; r instanceof Array ? r.forEach((e => { e && (e instanceof InstancedItem ? e.disableHighlight() : e.getGroup().children[0].material.uniforms.outline.value = 0) })) : r && (r instanceof InstancedItem ? r.disableHighlight() : r.getGroup().children[0].material.uniforms.outline.value = 0), H = null } if (!i) return; if ("IconAsset" === i.type) return H = e, i instanceof InstancedItem ? i.highlightInstance() : i.getGroup().children[0].material.uniforms.outline.value = 1, void _context.effectStore.highlightObject(void 0); ("GroupItem" === i.type || "PaintItem" === i.type) && _context.effectStore.highlightObject(void 0); let n = null; return n = _context.scene.models.getObjectByProperty("uuid", e), !!n && (n instanceof Object3D && (H = [], n.traverse((e => { "IconGroup" === e.type && H.push(e.uuid) })), H.length > 0 ? (H.forEach((e => { n.traverse((t => { t.uuid === e && ("InstancedGroup" == t.parent.type ? t.parent.userData.instancedGroup && t.parent.userData.instancedGroup.highlight(t.name, !0) : t.children[0].material.uniforms.outline.value = 1) })) })), _context.effectStore.highlightObject(n)) : _context.effectStore.highlightObject(n)), !0) }, this.highlightSpaceEffect = e => { if (!_context.scene || !this.defaultEffectStore || !this.defaultEffectStore.spaceEffect) return; let t = this.defaultEffectStore.spaceEffect.findEffect(e); t ? t.showHelper() : this.defaultEffectStore.spaceEffect.hideHelpers() }, this.highlightDirectionalLightHelper = (e, t) => { if (!_context.scene) return void logger.debug("_context.scene 为空"); let i = _context.lightStore.findDirectionalLightHelper(e); if (i) { t || _context.effectStore.highlightObject(void 0); for (let e of i.children) _context.effectStore.highlightObject(e, t); return !0 } return _context.effectStore.highlightObject(void 0), !1 }, this.takeSnapshot = e => _context.effectStore.takeSnapshot(e), this.screenshotAuxiliaryLineSwitch = e => { if (e) { this.lineDom && (this.container.removeChild(this.lineDom), this.lineDom = null); let e, t, i, r = 16, n = 9, a = this.container.clientWidth, o = this.container.clientHeight, s = a / o > r / n ? "height" : "width"; "height" === s ? (e = o / 9 * 16, t = o, i = t) : "width" === s && (e = a, t = a / 16 * 9, i = t), this.lineDom = document.createElement("div"), this.lineDom.style = `width: ${e}px;\n                              height: ${t}px;\n                              border: 1px solid rgb(191,64,16);\n                              position: absolute;\n                              top: ${(o - t) / 2}px;\n                              left: ${(a - e) / 2}px;\n                              pointer-events:none;\n                              z-index: 10;\n                              box-sizing:border-box;\n                              display:flex;\n                              align-items:center;\n                              justify-content: center;`; let l = document.createElement("div"); l.style = `width: 0;\n                        height: ${t}px;\n                        border-right: 1px dashed #ffffff;\n                        position:absolute;\n                        left: ${e / 2}px`; let c = document.createElement("div"); c.style = `width: ${e}px;\n                        height: 0;\n                        border-bottom: 1px dashed #ffffff;\n                        position:absolute;\n                        tio: ${t / 2}px`; let h = document.createElement("div"); h.style = `width: ${i}px;\n                          height: ${i}px;\n                          box-sizing:border-box;\n                          border:1px solid rgb(243,244,76)`, this.lineDom.append(l), this.lineDom.append(c), this.lineDom.append(h), this.container.append(this.lineDom) } else this.lineDom && (this.container.removeChild(this.lineDom), this.lineDom = null) }, this.screenshots = (e = 20, t = .7) => { let i, r, n = this.container.clientWidth, a = this.container.clientHeight, o = n / a > 16 / 9 ? "height" : "width"; "height" === o ? (i = a / 9 * 16, r = a) : "width" === o && (i = n, r = n / 16 * 9); let s = new Image, l = document.createElement("canvas"); l.width = 16 * e, l.height = 9 * e; let c = l.getContext("2d"); _context.composer.render(); let h = _context.renderer.domElement.toDataURL("image/jpeg", .65); return s.src = h, new Promise((e => { s.onload = () => { c.drawImage(s, (n - i) / 2, (a - r) / 2, i, r, 0, 0, l.width, l.height); let o = l.toDataURL("image/jpeg", t); e(o) } })) }, this.getStatistics = () => _context.renderer ? _context.rendererInfo : { geometries: 0, textures: 0, calls: 0, faces: 0, vertices: 0 }, this._debug = () => ({ context: _context }), this._setInstancedObject = e => { _context.instancedObject = new InstancedObject(e) }, this.getInstancingProfile = () => { let e = {}; _context.scene.models.traverse((t => { if (!(t instanceof InstancedMesh)) return; let i = `${t.parent.name} - ${t.name}`; "number" == typeof e[i] ? e[i]++ : e[i] = t.count })); let t = 0, i = 0; for (let r in e) i += e[r], t++, logger.debug(`${r} 中的实例计数：${e[r]}`); logger.debug("实例网格（InstancedMesh）计数：", t), logger.debug("一个实例网格（InstancedMesh）中的实例（instance）平均数：", i / t) }, this.previewMaterial = (e, t, i, r) => { this.previewMaterialInstance && (this.previewMaterialInstance.dispose(), this.previewMaterialInstance = null); let n = new PreviewMaterial(e, t, i, r); this.previewMaterialInstance = n }, this.updatePreviewMaterial = (e, t, i) => { this.previewMaterialInstance ? this.previewMaterialInstance.update(e, t, i) : logger.debug("previewMaterialInstance 不存在，无法update") }, this.offPreviewMaterial = () => { this.previewMaterialInstance && (this.previewMaterialInstance.dispose(), this.previewMaterialInstance = null) }, this.setPreviewMaterialTransformMode = e => { this.previewMaterialInstance && this.previewMaterialInstance.showGeometry(e) }, this.setPreviewMaterialResolution = (e, t) => { this.previewMaterialInstance && this.previewMaterialInstance.setResolution(e, t) }, this.updateDrawableRenderOrder = (t, i) => { if ("string" != typeof t) return !1; if ("number" != typeof i || i < 0) return !1; let r = e.find(t); return !!r && (r.renderOrder >= DRAWABLE_RENDER_ORDER_BASE && (r.renderOrder = DRAWABLE_RENDER_ORDER_BASE + i, !0)) }, this.clampToModel = (e, t = !0) => { if (!e) return void console.warn("clampToModel 接口参数无效。"); if ("number" != typeof e.x || "number" != typeof e.y || "number" != typeof e.z) return void console.warn("clampToModel 接口参数无效。"); M.set(new Vector3(e.x, e.y, e.z), new Vector3(0, -1, 0)); const i = _context.scene.models.children.filter((e => "IconGroup" !== e.type)); let r = M.intersectObjects(i, !0); if (0 === r.length) return e; let n = -1; if (t) { for (let e = 0; e < r.length; e++)if (r[e].object.visible) { n = e; break } if (-1 === n) return e } else n = 0; let a = r[n].point.clone(); return { x: a.x, y: a.y, z: a.z } }, this._debugClamp = (e = 10, t = 10, i = 1, r = 10) => { for (let n = -Math.floor(e / 2); n < e - Math.floor(e / 2); n++)for (let e = -Math.floor(t / 2); e < t - Math.floor(t / 2); e++) { let t = { x: n * i, y: r, z: e * i }, a = this.clampToModel(t), o = { path: "./resource/icons/universal/icon_01.png", sizeAttenuation: !1, pos: t, width: 30, height: 30, enableAutoHidebyDistance: !1, pointMinDistance: 10, pointMaxDistance: 1e4, offsetV: .5, offsetH: .5, polygonOffset: !1, polygonOffsetFactor: .1, polygonOffsetUnits: 1, isShow: !0, background: "icon_square", backgroundColor: "#0000ff" }; this.addBillboard(`landmark-${n}-${e}`, o, void 0); let s = { path: "./resource/icons/universal/icon_01.png", sizeAttenuation: !1, pos: a, width: 60, height: 60, enableAutoHidebyDistance: !1, pointMinDistance: 10, pointMaxDistance: 1e4, offsetV: .5, offsetH: .5, polygonOffset: !1, polygonOffsetFactor: .1, polygonOffsetUnits: 1, isShow: !0, background: "icon_square", backgroundColor: "#ff0000" }; this.addBillboard(`landmark2-${n}-${e}`, s, void 0) } }, this.getWorldScale = () => _context.worldScale, this.setSceneEffect = e => { _context.drawableDepthTest = !e.isLayerTopMost }, this.add3DTileSet = (e, t) => { if (TilesRenderer.customTransformEnabled = !0, !TilesRenderer.customTransformOrigin) { const e = this.getDatumShiftModel(); if (e && e.type) switch (e.type.toLowerCase()) { case "surface": TilesRenderer.customTransformOrigin = { lon: e.lon, lat: e.lat, alt: e.alt }; break; case "mercator": TilesRenderer.customTransformOrigin = { lon: e.origin[0], lat: e.origin[1], alt: -e.alt } } } let i = _context.scene.getObjectByName("__tilesGroup"); i || (i = new Group, i.name = "__tilesGroup", i.rotateX(Math.PI / -2), _context._tilesGroup = i, _context.scene.add(i)), this._tilesRenderers instanceof Map || (this._tilesRenderers = new Map), new TileSetItem(e, t) }, this.remove3DTileSet = (e = "") => { if (!(this._tilesRenderers instanceof Map) || 0 === this._tilesRenderers.size) return; if ("" === (e = e.url || e)) return; if (!(this._tilesRenderers instanceof Map) || 0 === this._tilesRenderers.size) return; const t = md5(e); let i = []; this._tilesRenderers.forEach(((e, r) => { if (e.urlHash === t) { e.dispose(), util$1.disposeThreeObject(e.group), e.group.parent.remove(e.group); let t = _context.scene.getObjectByName(e.urlHash); t && (util$1.disposeThreeObject(t), t.parent.remove(t)), _context.instance.defaultObjectTree.getItemByName(params.name) && _context.instance.defaultObjectTree.remove(params.name), i.push(r) } })), i.forEach((e => { this._tilesRenderers.has(e) && this._tilesRenderers.delete(e) })), 0 === this._tilesRenderers.size && this.clear3DTileSets() }, this.remove3DTileByID = (e = "", t) => { if ("" === e) return void (t && t({ result: 0, message: "id不能为空" })); if (!(this._tilesRenderers instanceof Map) || 0 === this._tilesRenderers.size) return void (t && t({ result: 0, message: `id为 ${e} 的 3DTiles 不存在!` })); let i = []; this._tilesRenderers.forEach(((t, r) => { if (t.group.layerId === e) { let e = t.group.name; t.dispose(), util$1.disposeThreeObject(t.group), t.group.parent.remove(t.group); let n = _context.scene.getObjectByName(t.urlHash); n && (util$1.disposeThreeObject(n), n.parent.remove(n)), _context.instance.defaultObjectTree.getItemByName(e) && _context.instance.defaultObjectTree.remove(e), i.push(r) } })), i.length <= 0 ? t && t({ result: 0, message: `id为 ${e} 的 3DTiles 不存在!` }) : (i.forEach((e => { this._tilesRenderers.has(e) && this._tilesRenderers.delete(e) })), 0 === this._tilesRenderers.size && this.clear3DTileSets(), t && t({ result: 1, message: "成功!" })) }, this.clear3DTileSets = () => { this._tilesRenderers instanceof Map && (this._tilesRenderers.forEach(((e, t) => { let i = e.group.name; e.dispose(), util$1.disposeThreeObject(e.group), e.group.parent.remove(e.group); let r = _context.scene.getObjectByName(e.urlHash); r && (util$1.disposeThreeObject(r), r.parent.remove(r)), _context.instance.defaultObjectTree.getItemByName(i) && _context.instance.defaultObjectTree.remove(i) })), this._tilesRenderers = void 0), this._tilesNeedRerender = !1, TilesRenderer.customTransformOrigin && (TilesRenderer.customTransformOrigin = void 0); let e = _context.scene.getObjectByName("__tilesGroup"); e && (util$1.disposeThreeObject(e), _context.scene.remove(e)) }, this.update3DTileStyle = ({ id: e, visible: t, alpha: i }, r) => { if (!(this._tilesRenderers instanceof Map) || 0 === this._tilesRenderers.size) return; if ("" === e) return void (r && r({ result: 0, message: "id不能为空" })); if (!(this._tilesRenderers instanceof Map) || 0 === this._tilesRenderers.size) return; let n = []; this._tilesRenderers.forEach(((i, r) => { i.group.layerId === e && (i.group.visible = null == t || t, n.push(e)) })), n.length <= 0 ? r && r({ result: 0, message: `id为 ${e} 的 3DTiles 不存在!` }) : r && r({ result: 1, message: "成功!" }) }, this.setCameraTo3DTile = (e, t = 0, i = {}, r = !1, n = !1) => { let a = null; if (this._tilesRenderers && this._tilesRenderers.forEach((t => { if (t.group.layerId === e && t.tileSets[t.rootURL] && t.tileSets[t.rootURL].root && t.tileSets[t.rootURL].root.boundingVolume && t.tileSets[t.rootURL].root.boundingVolume.box) { let e = t.tileSets[t.rootURL].root.boundingVolume.box, i = new Vector3(e[0], e[2], -e[1]), r = new Vector3(t.offset.x, t.offset.y, t.offset.z), n = new Vector3(e[3], e[11], e[7]), o = new Vector3(t.absolutePosition.x, t.absolutePosition.y, t.absolutePosition.z), s = o.clone().add(n).add(i).add(r), l = o.clone().sub(n).add(i).add(r); a = new Box3(l, s) } })), !a) return; let o = new Vector3; a.getSize(o), R.x = (a.max.x + a.min.x) / 2, R.y = (a.max.y + a.min.y) / 2, R.z = (a.max.z + a.min.z) / 2; let s = 3 * o.distanceTo(a.max.sub(a.min).divideScalar(2)); (isNaN(s) || s === 1 / 0 || s === -1 / 0) && (s = 100), s <= this.getCamera().near && (s += this.getCamera().near), a = null, o = null, this.nextRender((() => { this.cameraFlyTo(R, util$1.numberOrDefault(i.azimuthAngle, 45), util$1.numberOrDefault(i.inclinationAngle, -45), util$1.numberOrDefault(i.distance, s) * _context.worldScale, util$1.numberOrDefault(t, 0), !0, (() => { this.focus() })), R = new Vector3 }), 1) }, this.testTerrainUniform = () => { _context.gisStore.setFog("#6298b7") }, this.initTerrain = (e, t) => { 0 !== _context.gisStore.terrainState && _context.gisStore && _context.gisStore.disposeTerrain(), _context.gisStore && _context.gisStore.initTerrain(e, t) }, this.destroyTerrain = () => { _context.gisStore && _context.gisStore.disposeTerrain() }, this.updateTerrain = (e, t) => { _context.gisStore && _context.gisStore.updateStyle(e, t) }, this.addTerrain = (e, t) => { new GisItem(e, t) }, this.testGeoJSON = e => { _context.gisStore && _context.gisStore.testGeoJSON(e) }, this.getThree = () => THREE, this.changeScene = ({ name: i }, r, a) => { let o = _context.sceneStore.findScene(i); if (!o) return void (r && r({ result: 0, message: `${i}服务不存在!` })); if (o.scene) _context.scene = o.scene, _context.scene.models.children.forEach((e => { e instanceof Group ? e.children.forEach((e => { util$1.disposeThreeObject(e) })) : util$1.disposeThreeObject(e) })), _context.scene.models.children = []; else { let e = new Scene; if (e.name = "__newAvwCore" + util$1.guid(), e.models = new Group, e.models.name = "__models", e.add(e.models), e.sysObjects = new Group, e.sysObjects.name = "__sysObjects", e.sysObjects.renderOrder = 1 / 0, e.add(e.sysObjects), e.noneModels = new Group, e.noneModels.name = "__noneModels", e.axesHelper = new AxesHelper(50), e.axesHelper.name = "__axesHelper", e.axesHelper.visible = !1, e.add(e.noneModels), e.sysObjects.add(_context.transformControls), !_context.alpha) switch (e.background = new Color$1(BACKGROUND_COLOR_DEFAULT), _context.renderer.outputEncoding) { case sRGBEncoding: e.background.convertSRGBToLinear && e.background.convertSRGBToLinear(); break; case GammaEncoding: e.background.convertGammaToLinear && e.background.convertGammaToLinear() }e.setNodeRotation = this.setNodeRotation, e.setNodeRotating = this.setNodeRotating, e.setNodeScaling = this.setNodeScaling, e.setNodeBreathing = this.setNodeBreathing, e.add(e.axesHelper), _context.scene = e } _context.effectStore.changeScene(_context.scene), _context.background.cubeTexture && _context.background.cubeTexture instanceof CubeTexture && _context.background.cubeTexture.dispose(), _context.modelStore.dispose && _context.modelStore.dispose(), _context.modelStore = null, _context.modelStore = new ModelStore(_context.scene), _context.objectStore.dispose && _context.objectStore.dispose(), e.dispose && e.dispose(), e = null, _context.objectStore = null, e = new ObjectStore(_context.scene), _context.objectStore = e, this.objectStore = e, _context.sysObjectStore.dispose && _context.sysObjectStore.dispose(), _context.sysObjectStore = null, _context.sysObjectStore = new SysObjectStore(_context.scene), _context.textureStore.dispose && _context.textureStore.dispose(), _context.textureStore = null, _context.textureStore = new TextureStore("textureStore"), _context.customTextureStore.dispose && _context.customTextureStore.dispose(), _context.customTextureStore = null, _context.customTextureStore = new TextureStore("customTextureStore"), this.customTextureStore = _context.customTextureStore, _context.materialStore.dispose && _context.materialStore.dispose(), _context.materialStore = null, _context.materialStore = new MaterialStore(_context.textureStore, this), _context.lightStore.dispose && _context.lightStore.dispose(), _context.lightStore = null, _context.lightStore = new LightStore(_context.scene, this), n = new PMREMGenerator(_context.renderer), _context.stateStore.dispose && _context.stateStore.dispose(), _context.stateStore = null, _context.stateStore = new StateStore, this.defaultNodeSelection.dispose && this.defaultNodeSelection.dispose(), this.defaultNodeSelection = null, this.defaultNodeSelection = new NodeSelection(_context.scene, this), _context.animationStore.dispose && _context.animationStore.dispose(), _context.animationStore = null, _context.animationStore = new AnimationStore, _context.animationMixers = [], _context.clippingStore.dispose && _context.clippingStore.dispose(), _context.clippingStore = null, _context.clippingStore = new ClippingStore; const s = t.handlers; t.dispose && t.dispose(), _context.eventHandlerStore.dispose && _context.eventHandlerStore.dispose(), t = null, _context.eventHandlerStore = null, t = new EventHandlerStore(_context.renderer, _context.scene, _context.camera), _context.eventHandlerStore = t, t.handlers = s, _context.defaultObjectTree.dispose && _context.defaultObjectTree.dispose(), this.defaultObjectTree.dispose && this.defaultObjectTree.dispose(), _context.defaultObjectTree = null, this.defaultObjectTree = null, this.defaultObjectTree = new ObjectTree(_context.scene), _context.defaultObjectTree = this.defaultObjectTree, this.loadScene({ serviceName: i, scenePath: o.scenePath }, (e => { 1 == e ? (W = null, r && r({ result: 1, message: "场景切换成功!" }), a && a({ name: i, default: o.defaultScene })) : r && r({ result: 0, message: "场景切换失败!" }) })) }, this.getServicesInfo = e => { e && e({ result: 1, message: "成功。", mode: "scene", services: _context.sceneStore.getScenes() }) }, this.addGround = (e, t) => { t = t || "#cfcfcf"; const i = new PlaneGeometry; i.scale(e || 2e3, e || 2e3, 1); let r = new Mesh(i, new MeshStandardMaterial({ color: new Color$1(t), fog: !0 })); r.rotateX(Math.PI / -2), r.name = "__groundPlane", r.receiveShadow = !0, r.visible = !0, _context.scene.sysObjects.add(r) }, this.getColorSpace = () => { switch (_context.renderer.outputEncoding) { case LinearEncoding: return "linear"; case sRGBEncoding: return "srgb"; case GammaEncoding: return "gamma" } }, this.setColorSpace = e => { if (e !== this.getColorSpace()) switch (e.toLowerCase()) { case "linear": if (_context.scene.background instanceof Color$1) switch (_context.renderer.outputEncoding) { case sRGBEncoding: _context.scene.background.convertLinearToSRGB && _context.scene.background.convertLinearToSRGB(); break; case GammaEncoding: _context.scene.background.convertLinearToGamma && _context.scene.background.convertLinearToGamma() }if (_context.scene.fog instanceof Fog && _context.scene.background.isCOlor) switch (_context.renderer.outputEncoding) { case sRGBEncoding: _context.scene.fog.color.convertLinearToSRGB && _context.scene.fog.color.convertLinearToSRGB(); break; case GammaEncoding: _context.scene.fog.color.convertLinearToGamma && _context.scene.fog.color.convertLinearToGamma() }_context.scene.background instanceof Texture$1 && (_context.scene.background.encoding = LinearEncoding), _context.renderer.outputEncoding = LinearEncoding; break; case "srgb": if (_context.scene.background instanceof Color$1) switch (_context.renderer.outputEncoding) { case LinearEncoding: _context.scene.background.convertSRGBToLinear && _context.scene.background.convertSRGBToLinear(); break; case GammaEncoding: _context.scene.background.convertLinearToGamma && _context.scene.background.convertLinearToGamma(), _context.scene.background.convertSRGBToLinear && _context.scene.background.convertSRGBToLinear() }if (_context.scene.fog instanceof Fog && _context.scene.background.isCOlor) switch (_context.renderer.outputEncoding) { case LinearEncoding: _context.scene.fog.color.convertSRGBToLinear && _context.scene.fog.color.convertSRGBToLinear(); break; case GammaEncoding: _context.scene.fog.color.convertLinearToGamma && _context.scene.fog.color.convertLinearToGamma(), _context.scene.fog.color.convertSRGBToLinear && _context.scene.fog.color.convertSRGBToLinear() }_context.scene.background instanceof Texture$1 && (_context.scene.background.encoding = sRGBEncoding), _context.renderer.outputEncoding = sRGBEncoding; break; case "gamma": if (_context.scene.background instanceof Color$1) switch (_context.renderer.outputEncoding) { case LinearEncoding: _context.scene.background.convertGammaToLinear && _context.scene.background.convertGammaToLinear(); break; case sRGBEncoding: _context.scene.background.convertLinearToSRGB && _context.scene.background.convertLinearToSRGB(), _context.scene.background.convertGammaToLinear && _context.scene.background.convertGammaToLinear() }if (_context.scene.fog instanceof Fog && _context.scene.background.isCOlor) switch (_context.renderer.outputEncoding) { case LinearEncoding: _context.scene.fog.color.convertGammaToLinear && _context.scene.fog.color.convertGammaToLinear(); break; case sRGBEncoding: _context.scene.fog.color.convertLinearToSRGB && _context.scene.fog.color.convertLinearToSRGB(), _context.scene.fog.color.convertGammaToLinear && _context.scene.fog.color.convertGammaToLinear() }_context.scene.background instanceof Texture$1 && (_context.scene.background.encoding = GammaEncoding), _context.renderer.outputEncoding = GammaEncoding } }, this.syncScene = (e, t) => { if (!_context.instance.notState) return void logger.warn("notState undefined"); let i = JSON.parse(JSON.stringify(_context.instance.notState)); "object" === e ? (i.objectTree.children.forEach((e => { "BuildingItem" === e.type ? e.children.forEach((e => { "ModelItem" === e.type ? e.articulationAnimations && e.articulationAnimations.forEach((e => { e.isEnable = !1 })) : "BuildingFloorItem" === e.type && e.children.forEach((e => { "ModelItem" === e.type && e.articulationAnimations && e.articulationAnimations.forEach((e => { e.isEnable = !1 })) })) })) : "ModelItem" === e.type || "ModelAsset" === e.type ? e.articulationAnimations && e.articulationAnimations.forEach((e => { e.isEnable = !1 })) : "PaintItem" === e.type && (e.children.forEach((e => { "ModelItem" === e.type && e.articulationAnimations && e.articulationAnimations.forEach((e => { e.isEnable = !1 })) })), e.modelInstanced.forEach((e => { e.articulationAnimations && e.articulationAnimations.forEach((e => { e.isEnable = !1 })) }))) })), this.defaultObjectTree.applySettings(i.objectTree, !1, !1, !0), this.defaultObjectTree.children.forEach((e => { if ("BuildingItem" === e.type) if (e.children.forEach((e => { e.level && e.hide() })), e.floor) { this.cutLevel(e.getGroup().uuid, e.floor); for (let t = 0; t < z.length; t++)z[t].uuid === e.getGroup().uuid && (z.splice(t, 1), t--); z.push({ uuid: e.getGroup().uuid, level: e.floor }) } else this.cutLevel(e.getGroup().uuid, e.floor) }))) : "light" === e ? (this.setSkyboxRotationY(180 * (i.background.cubeTextureRotationY || 0) / Math.PI), _context.lightStore.applySettings(i.lights, t, i.view.camera.duration)) : "effect" === e ? this.defaultEffectStore.applySettings(i.effects) : "background" === e ? (i.background && (_context.background.mode != i.background.mode && (this.crossfadeFreeze(), this.crossfade(1e3)), _context.background.mode = i.background.mode, _context.background.cubeTextureRotationY = i.background.cubeTextureRotationY, _context.background.cubeTextureBlur = i.background.cubeTextureBlur), _context.background.color = null, _context.background.texture = null, i.background && (_context.background.cubeTextureRotationY = i.background.cubeTextureRotationY || 0, _context.background.cubeTextureBlur = i.background.cubeTextureBlur, _context.background.cubeTextureIntensity = i.background.cubeTextureIntensity, _context.background.environmentLuminosity = i.background.environmentLuminosity, i.background.colorCSSValue && (this._backgroundColorType != i.background.colorCSSValue.type && (this.crossfadeFreeze(), this.crossfade(1e3)), this._backgroundColorType = i.background.colorCSSValue.type, "single" == i.background.colorCSSValue.type ? (this._backgroundColor1 != i.background.colorCSSValue.color1 && (this.crossfadeFreeze(), this.crossfade(1e3)), this._backgroundColor1 = i.background.colorCSSValue.color1) : "gradient" == i.background.colorCSSValue.type && (this._backgroundColorUrl != i.background.colorCSSValue.dataUrl && (this.crossfadeFreeze(), this.crossfade(1e3)), this._backgroundColorUrl = i.background.colorCSSValue.dataUrl), this.setBackgroundColor(i.background.colorCSSValue)), i.background.textureURL && this.setBackgroundImage(i.background.textureURL), i.background.mode && this.setBackgroundMode(i.background.mode, i))) : "all" === e && this.applySceneSettings(i, t) }, this.rotatingModel = e => { e && (_context.scene.models.traverse((t => { if (t.name === e.id) { let i = _context.animationStore.findNodeAnimation(t, NodeRotationAnimationController.type); i && (i.reset(), _context.animationStore.remove(i)); let r = 0; 0 !== e.durationX && (r = MathUtils.degToRad(60 / e.durationX), "clockwise" == e.directionX && (r = -r)); let n = 0; 0 !== e.durationY && (n = MathUtils.degToRad(60 / e.durationY), "clockwise" == e.directionY && (n = -n)); let a = 0; 0 !== e.durationZ && (a = MathUtils.degToRad(60 / e.durationZ), "clockwise" == e.directionZ && (a = -a)), i = new NodeRotationAnimationController(t, 0 !== e.durationX, 0 !== e.durationY, 0 !== e.durationZ, r, n, a), _context.animationStore.add(i) } })), this.nextRender((() => { this.cutLevelByUUID(e.id, !1) }))) }, this.getImageBitMapCache = () => ImageBitMapCache } } class MaterialPrintScreen { constructor(e) { this.container = e, this.materialPreview = {}, this.materialPreview.renderer = new WebGLRenderer({ antialias: !0, alpha: !0 }), this.materialPreview.scene = new Scene, this.materialPreview.renderer.setClearAlpha(0); const t = new AmbientLight(16777215, 1); this.materialPreview.scene.add(t); let i = new DirectionalLight(16777215, 1), r = new DirectionalLight(16777215, .8), n = new DirectionalLight(16777215, .6); i.position.set(10, 7, 10), r.position.set(-10, 2, 10), n.position.set(0, 0, -10), i.target.position.set(0, 0, 0), r.target.position.set(0, 0, 0), n.target.position.set(0, 0, 0), this.materialPreview.scene.add(i), this.materialPreview.scene.add(r), this.materialPreview.scene.add(n), this.materialPreview.camera = new PerspectiveCamera(50, e.getBoundingClientRect().width / e.getBoundingClientRect().height, .1, 1e3), this.materialPreview.camera.position.set(0, 0, 2.37), this.materialPreview.renderer.setSize(e.getBoundingClientRect().width, e.getBoundingClientRect().height), e.appendChild(this.materialPreview.renderer.domElement), this.scene = this.materialPreview.scene, this.showType = null, this.models = new Group, this.scene.add(this.models), this.createSpherePreview() } createSpherePreview(e) { let t = new Mesh(new SphereGeometry(1, 40, 40), e); this.sphere = t, this.showType = "sphere", this.models.add(t) } printScreen(e, t, i) { return new Promise((r => { _context.scene = this.materialPreview.scene, _context.instance = {}, _context.instance.resourceBasePath = "." == window.SCENE_RESOURCE_BASE_PATH ? "./lib/scene/" : window.SCENE_RESOURCE_BASE_PATH, _context.defaultObjectTree = { children: [] }, _context.defaultObjectTree.getItemByUUID = () => null, _context.animationStore = new AnimationStore; let n = Material._fromThreeObject(e); this.sphere.material = e, this.sphere.material.needsUpdate = !0, util$1.setMaterialParam(t, n, i), util$1.markObjectsNeedsUpdate(), _context.animationStore.update(.136), this.materialPreview.renderer.render(this.materialPreview.scene, this.materialPreview.camera), this.materialPreview.renderer.domElement.toBlob((e => { r(e) })) })) } dispose() { for (util$1.disposeThreeObject(this.models), this.models.remove(this.sphere), this.models.remove(this.cylinder), this.models.remove(this.plane), this.models.remove(this.box), this.materialPreview.scene.traverse((function (e) { if (e.isMesh) if (_objectCount--, e.geometry.dispose(), e.material instanceof Array) for (let t of e.material) t.dispose(); else e.material.dispose(); e.isSprite && e.material.dispose() })); this.materialPreview.scene.children.length;)this.materialPreview.scene.remove(this.materialPreview.scene.children[0]); this.materialPreview.renderer.domElement && this.container.removeChild(this.materialPreview.renderer.domElement), this.materialPreview.scene = null, this.materialPreview.camera = null, this.materialPreview.renderer.dispose(), this.materialPreview.renderer.forceContextLoss(), this.materialPreview.renderer.content = null; let e = this.materialPreview.renderer.domElement.getContext("webgl"); e && e.getExtension("WEBGL_lose_context").loseContext(), this.materialPreview.renderer = null, this.materialPreview = null, _context.scene = null, _context.instance = null, _context.animationStore = null, _context.objectsNeedsUpdate = null } } let gltfExporter = new GLTFExporter, materialPrintScreen = null, _arrayBufferToBlob = e => new Blob([e], { type: "application/octet-stream" }), setMaterialParam = (e, t, i) => { for (let r in e) if (t[r] instanceof Map$1) { for (let t in e[r]) if (e[r][t.replace("_", "")] = e[r][t], e[r][t.replace("_", "")] instanceof Array); else if (e[r][t.replace("_", "")] instanceof Object) for (let i in e[r][t.replace("_", "")]) e[r][t.replace("_", "")][i.replace("_", "")] = e[r][t.replace("_", "")][i]; switch (e[r].type) { case "imagebitmap": let n = "undefined" != typeof ImageBitmap && e[r].source instanceof ImageBitmap ? e[r].source : void 0 !== e[r].name ? i.get(e[r].name) || _context.customTextureStore.find(e[r].name) : i.get(t.name + "#" + r); if (("metalnessMap" === r || "roughnessMap" === r) && !n) { let t = "", a = ""; e.roughnessMap && (a = e.roughnessMap.name || e.roughnessMap._name || ""), e.metalnessMap && (t = e.metalnessMap.name || e.metalnessMap._name || ""), n = i.get(t + a), n || (n = i.get(a + t)), i.forEach((t => { t.name.indexOf(e[r].name) > -1 && t.name.indexOf("#MetalnessAndRoughness#") > -1 && (n = t) })) } if (!n && e[r].name && 0 === e[r].name.indexOf("[[origin]]")) { _context.customTextureStore.loadTexture({ url: e[r].name, name: e[r].name, onLoad: () => { let n = "undefined" != typeof ImageBitmap && e[r].source instanceof ImageBitmap ? e[r].source : void 0 !== e[r].name ? i.get(e[r].name) || _context.customTextureStore.find(e[r].name) : i.get(t.name + "#" + r); t[r] = { type: "imagebitmap", source: n, reset: !0 } } }), console.log("可能加载的模型引用了自定义贴图，自定义贴图需要重新load"); break } t[r] = { type: "imagebitmap", source: n, reset: !0 }; break; case "color": e[r].reset = !0, t[r] = e[r]; break; case "file": break; default: t[r] = e[r] } } else switch (r) { case "normalMapType": t[r] = "normal"; break; case "type": case "mapType": t[r] = "metalness"; break; default: t[r] = e[r] }e.color && (t.color = e.color) }; class LoadSettings { constructor(e, t, i, r) { this.loadedState = !1, this.progress = { total: 0, loaded: 0 }, this.loading = !1; let n = new DHLoader, a = []; if (n.setRequestHeader) { let t = {}; t.Authorization = "Bearer " + e.tokenValue, n.setRequestHeader(t) } for (let e in n.requestHeader) a.push({ key: e, value: n.requestHeader[e] }); this.then = async () => { let o = [], s = [], l = new Map, c = new Map; await _context.customTextureStore.applySettings(e.texture || []), e.objectTree.children.forEach((e => { if ("ModelItem" == e.type) { let r = e.modelPath.replace("[[origin]]", t); o.push(util$1.fetchContentLength(r, a)), s.push(new Promise((t => { n.load(r, (i => { let r = new Map; i.scene.traverse((e => { if (e.material) { r.set(e.material.name, e.material); for (let t in e.material) e.material[t] instanceof Texture$1 && e.material[t].image && l.set(e.material[t].name || `${e.material.name}#${t}`, Texture._fromThreeObject(e.material[t])) } })), t({ gltf: i, objectItem: e, materialMap: r }) }), (e => { c.set(r, e.loaded); let t = 0; c.forEach((e => { t += e })), this.progress.loaded = t, i && i(this.progress) }), (() => { })) }))), c.set(r, 0) } })), this.loading = !0, Promise.all(o).then((e => { if (e instanceof Array) for (let t of e) this.progress.total += Number(t); Promise.all(s).then((e => { let t = []; e.forEach((e => { t.push(new Promise((t => { if (e.objectItem.materials) for (var i in e.objectItem.materials) { let t = e.materialMap.get(i), r = new Material({ materialOfThree: t, id: t.uuid, name: t.name, type: "metalness", mapType: "metalness", color: t.color, map: t.map, mapIntensit: t.mapIntensit, metalnessMap: t.metalnessMap, metalnessIntensity: t.metalness, roughnessMap: t.roughnessMap, roughnessIntensity: t.roughness, enableSpecularMap: !!t.envMap, specularMapType: t.envMap ? "custom" : "envmap", specularMap: t.envMap, specularMapIntensity: t.envMapIntensity / ENVMAP_FACTOR, enableNormalMap: !!t.normalMap, normalMapType: "", normalMap: t.normalMap, normalMapFlipY: t.normalMapFlipY, normalMapIntensity: t.normalScale ? t.normalScale.x : 1, enableDisplacement: !!t.displacementMap, displacementMap: t.displacementMap, displacementIntensity: t.displacementScale, enableOpacity: t.transparent || !!t.alphaMap, opacityType: "blend", opacityMap: t.alphaMap, opacityIntensity: t.opacity, opacityInverted: !1, emissive: t.emissive, enableEmissive: !!t.emissiveMap || 0 !== t.emissive.r || 0 !== t.emissive.g || 0 !== t.emissive.b, emissiveMap: t.emissiveMap, emissiveIntensity: t.emissiveIntensity, enableLightMap: !!t.lightMap, lightMap: t.lightMap, lightMapIntensity: t.lightMapIntensity, enableSSR: t.enableSSR, envMapIntensity: t.envMapIntensity, side: t.side, depth: t.depthTest && t.depthWrite ? 2 : t.depthTest || t.depthWrite ? 1 : 0 }); setMaterialParam(e.objectItem.materials[r.name], r, l) } e.gltf.scene.userData.dhAsset = JSON.parse(JSON.stringify(e.objectItem)), e.gltf.scene.traverse((e => { e.geometry && (e.geometry = new PlaneGeometry) })); let r = { trs: !0, onlyVisible: !1, truncateDrawRange: !0, binary: !0, forcePowerOfTwoTextures: !0, includeCustomExtensions: !0, maxTextureSize: 1 / 0 }; gltfExporter.parse(e.gltf.scene, (async i => { if (i instanceof ArrayBuffer) { let n = _arrayBufferToBlob(i), a = null; if (1 === e.materialMap.size) for (var r in e.objectItem.materials) a = await materialPrintScreen.printScreen(e.materialMap.get(r), e.objectItem.materials[r], l); util$1.disposeThreeObject(e.gltf.scene), t({ blob: n, name: e.objectItem.name, image: a }) } }), r) }))) })), Promise.all(t).then((e => { this.loadedState = !0, this.loading = !1, r && r(e) })) })) })) } } } function materialExporter({ settingsList: e = [], baseOrigin: t, onProgress: i, onLoad: r }) { let n = document.createElement("div"); n.style.width = "200px", n.style.height = "200px", document.body.append(n), _context.origin = t, _context.cacheStore || (_context.cacheStore = new CacheStore), _context.customTextureStore || (_context.customTextureStore = new TextureStore("customTextureStore")), _context.loaders || (_context.loaders = {}), _context.loaders.textureLoader = new TextureLoader, materialPrintScreen = new MaterialPrintScreen(n); let a = []; var o = []; e.forEach((e => { e && e.objectTree && e.objectTree.children && a.push(new LoadSettings(e, t, (e => { e.allProgress = { total: a.length, loaded: a.filter((e => e.loadedState)).length + 1 }, i && i(e) }), (t => { if (t.forEach((t => { o.push({ ...t, settings: e }) })), !a.find((e => !0 === e.loading))) { let e = a.find((e => !1 === e.loadedState)); e ? e.then() : (ImageBitMapCache.clear(), _context.customTextureStore = null, _context.cacheStore = null, _context.loaders = {}, _context.origin = null, r && r(o)) } }))) })); let s = a.find((e => !1 === e.loadedState)); s && s.then() } const scene = {}; scene.Core = Core, scene.core = { Model: Model, Node: Node, NodeSelection: NodeSelection, Map: Map$1, Material: Material, Texture: Texture, materialExporter: materialExporter }; class Bar extends Drawable { constructor(e, t) { super(e), this.alpha = e.alpha < 0 || e.alpha > 1 ? 1 : e.alpha, this.altOffset = e.altOffset || 0, this.barStyle = e.barStyle || "矩形", this.brightness = e.brightness || .5, this.color = e.color || "#ffffff", this.enableAutoHidebyDistance = e.enableAutoHidebyDistance || !1, this.heightRatio = e.heightRatio || 1, this.isShow = 0 != e.isShow && 1 != e.isShow || e.isShow, this.label = e.label || !1, this.labelBackground = e.labelBackground || "#00000055", this.labelCanvas = e.labelCanvas || "", this.labelColor = e.labelColor || "#ffffff", this.labelEnableItalic = e.labelEnableItalic || !1, this.labelFontBold = e.labelFontBold || !1, this.labelFontFamily = e.labelFontFamily || "微软雅黑, Microsoft Yahei, PingFang SC, Helvetica, Noto Sans CJK SC, Source Han Sans SC, SimHei, sans-serif", this.labelFontSize = e.labelFontSize || 5, this.labelText = e.labelText || "", this.labelXOffset = e.labelXOffset || .5, this.labelYOffset = e.labelYOffset || 0, this.latOffset = e.latOffset || 0, this.lonOffset = e.lonOffset || 0, this.maxDistance = e.maxDistance || 1e6, this.minDistance = e.minDistance || 0, this.offset = e.offset || !1, this.position = e.position, this.sizeAttenuation = !(0 == e.sizeAttenuation || !e.sizeAttenuation), this.value = e.value, null == this.value && (this.value = e.values, null != this.value && logger.warn("检测到错误的柱图属性：'values' 。")), this.widthRatio = e.widthRatio || 1, this.columnPaint = e.columnPaint || "solid", this.colorMax = e.colorMax || "#FF2626", this.colorMin = e.colorMin || "#FFFF00", this.context && this.context.addBar(this.getFullName(), this.getBarParam(), this.getTextParam()), t && t(1) } getBarParam() { var e; e = "矩形" == this.barStyle ? "bar" : "cylinder"; let t = { lonOffset: this.lonOffset, latOffset: this.latOffset, altOffset: this.altOffset }, i = JSON.parse(JSON.stringify(this.position)); return i = this.convertLLAToXYZ(i, this.offset, t), { type: e, pos: i, offsetX: this.lonOffset, offsetY: this.latOffset, offsetZ: this.altOffset, color: this.color, brightness: this.brightness, maxDistance: Number(this.maxDistance), minDistance: Number(this.minDistance), enableAutoHidebyDistance: this.enableAutoHidebyDistance, alpha: this.alpha, width: this.widthRatio, value: this.value * this.heightRatio, isShow: this.isShow, renderOrder: this.zLevel, columnPaint: this.columnPaint, colorMax: this.colorMax, colorMin: this.colorMin } } getTextParam() { if (null != this.labelCanvas && this.labelCanvas) var e = this.labelCanvas; else e = this.generateLableCanvas(this.labelFontFamily, this.labelFontSize, this.labelFontBold, this.labelEnableItalic, this.labelBackground, this.labelColor, this.labelText); let t; return t = null != e ? { enableText: this.label, canvas: e, sizeAttenuation: this.sizeAttenuation, width: this.sizeAttenuation ? .09 * e.width : 414e-6 * e.width, height: this.sizeAttenuation ? .09 * e.height : 414e-6 * e.height, offsetV: this.labelXOffset, offsetH: this.labelYOffset } : { enableText: !1, canvas: e, sizeAttenuation: this.sizeAttenuation, width: this.sizeAttenuation ? .09 * e.width : 414e-6 * e.width, height: this.sizeAttenuation ? .09 * e.height : 414e-6 * e.height, offsetV: this.labelXOffset, offsetH: this.labelYOffset }, t } removeBar() { this.context.removeLayer(this.getFullName()) } toString() { return JSON.stringify(this) } updateBar(e) { for (let t in e) null != this[t] && (this[t] = e[t], "values" == t && (this.value = e.values, logger.warn("检测到错误的柱图属性：'values'，现已改为 value 属性。"))); this.context.removeLayer(this.getFullName()), this.context.addBar(this.getFullName(), this.getBarParam(), this.getTextParam()) } } class Bubble extends Drawable { constructor(e, t) { if (super(e), this.alpha = null != e.alpha ? e.alpha : 1, this.altOffset = e.altOffset || 0, this.animationSpeed = e.animationSpeed || 1, this.brightness = e.brightness || 1, this.bubbleColor = e.bubbleColor || "0xffffff", this.bubbleScale = e.bubbleScale >= 0 ? e.bubbleScale : 1, this.enableAutoHidebyDistance = e.enableAutoHidebyDistance || !1, this.isShow = 0 != e.isShow && 1 != e.isShow || e.isShow, this.label = e.label || !1, this.labelBackground = e.labelBackground || "#00000055", this.labelCanvas = e.labelCanvas || "", this.labelColor = e.labelColor || "#ffffff", this.labelEnableItalic = e.labelEnableItalic || !1, this.labelFontBold = e.labelFontBold || !1, this.labelFontFamily = e.labelFontFamily || "微软雅黑, Microsoft Yahei, PingFang SC, Helvetica, Noto Sans CJK SC, Source Han Sans SC, SimHei, sans-serif", this.labelFontSize = e.labelFontSize || 18, this.labelText = e.labelText || "默认值", this.labelXOffset = e.labelXOffset || 0, this.labelYOffset = e.labelYOffset || 0, this.latOffset = e.latOffset || 0, this.lonOffset = e.lonOffset || 0, this.maxDistance = e.maxDistance || 1e8, this.minDistance = e.minDistance || 0, this.offset = e.offset || !1, this.position = e.position || "", this.repeatMode = e.repeatMode || "repeat", this.sizeAttenuation = !(0 == e.sizeAttenuation || !e.sizeAttenuation), this.value = e.value || 1, this.context) { let e = { lonOffset: this.lonOffset, latOffset: this.latOffset, altOffset: this.altOffset }; this.position = this.convertLLAToXYZ(this.position, this.offset, e), this.context.addBubble(this.getFullName(), this.getBubbleParam(), this.getTextParam(), (function () { t && t(...arguments) })) } else t && t(0) } getBubbleParam() { return { pos: this.position, offsetX: this.lonOffset, offsetY: this.latOffset, offsetZ: this.altOffset, value: Number(this.value) * Number(this.bubbleScale), diffSpeed: this.animationSpeed, repeatMode: this.repeatMode, color: this.bubbleColor, alpha: this.alpha, brightness: this.brightness, maxDistance: Number(this.maxDistance), minDistance: Number(this.minDistance), enableAutoHidebyDistance: this.enableAutoHidebyDistance, isShow: this.isShow, renderOrder: this.zLevel } } getTextParam() { if (null != this.labelCanvas && this.labelCanvas) var e = this.labelCanvas; else e = this.generateLableCanvas(this.labelFontFamily, this.labelFontSize, this.labelFontBold, this.labelEnableItalic, this.labelBackground, this.labelColor, this.labelText); let t; return t = null != e ? { enableText: this.label, canvas: e, sizeAttenuation: this.sizeAttenuation, width: this.sizeAttenuation ? .01 * e.width : 45e-6 * e.width, height: this.sizeAttenuation ? .01 * e.height : 45e-6 * e.height, offsetV: this.labelXOffset, offsetH: this.labelYOffset } : { enableText: !1, canvas: e, sizeAttenuation: this.sizeAttenuation, width: this.sizeAttenuation ? .01 * e.width : 45e-6 * e.width, height: this.sizeAttenuation ? .01 * e.height : 45e-6 * e.height, offsetV: this.labelXOffset, offsetH: this.labelYOffset }, t } removeBubble() { this.context.removeLayer(this.getFullName()) } toString() { return JSON.stringify(this) } updateBubble(e, t) { let i = { lonOffset: e.lonOffset, latOffset: e.latOffset, altOffset: e.altOffset }; null != e.position && (e.position = this.convertLLAToXYZ(e.position, e.offset, i)); for (let t in e) null != this[t] && (this[t] = e[t]); this.context.removeLayer(this.getFullName()), this.context.addBubble(this.getFullName(), this.getBubbleParam(), this.getTextParam(), (function () { t && t(...arguments) })) } } class FlashMarker extends Drawable { constructor(e, t, i) { if (super(e), this.autoStart = !!e.autoStart, this.duration = e.duration || 1e4, this.height = e.height || "", this.icons = e.icons || ["", ""], this.interval = e.interval || 500, this.position = e.position || "", this.sizeAttenuation = !1 !== e.sizeAttenuation, this.width = e.width || "", this.context) { let e = { lonOffset: 0, latOffset: 0, altOffset: 0 }; this.position = this.convertLLAToXYZ(this.position, this.offset, e), this.context.addFlashSpriteXYZ(`${t}/${this.name}`, this.icons, { x: this.position.x, y: this.position.y + this.height / 2, z: this.position.z }, this.width, this.height, this.sizeAttenuation, this.interval, this.duration, this.autoStart), i && i(1) } i && i(1) } toString() { return JSON.stringify(this) } } class HeatMap extends Drawable { constructor(e, t) { super(e), e.points && e.points instanceof Array ? (this.enableAutoHidebyDistance = e.enableAutoHidebyDistance || !1, this.gradient = e.gradient || { 1: "rgb(255,0,0)", .25: "rgb(0,0,255)", .55: "rgb(0,255,0)", .85: "rgb(255, 255, 0)" }, this.isShow = 0 != e.isShow && 1 != e.isShow || e.isShow, this.maxDistance = e.maxDistance || 1e6, this.minDistance = e.minDistance || 0, this.offset = e.offset || [0, 0, 0], this.opacity = Number(e.opacity) < 0 ? .6 : Number(e.opacity), this.points = e.points || [], this.pointsType = e.pointsType || "xyz", this.radius = e.radius || 10, this.style = e.style || "none", this.valueMax = e.valueMax, this.valueMin = e.valueMin, this.position = e.position || "", this.context && (this.prepareCoreData(), this.context.addHeatMapLayer(this.getFullName(), this.getHeatMapParam()), this.context.updateHeatMapData(this.getFullName(), this.valueMin, this.valueMax, this._t, this._zoomFactor)), t && t(1)) : t && t(0, "HeatMap() 参数错误。") } getHeatMapParam() { return { pos: this._positionXYZ, rotation: { x: 0, y: 0, z: 0 }, width: this._width, height: this._height, gradient: this.gradient, opacity: this.opacity, style: this.style, maxDistance: Number(this.maxDistance), minDistance: Number(this.minDistance), enableAutoHidebyDistance: this.enableAutoHidebyDistance, isShow: this.isShow, renderOrder: this.zLevel } } hide() { this.hidden = !1, this.context } isHidden() { return this.isHidden } prepareCoreData() { let e = -200, t = 200, i = -100, r = 100, n = -6e6, a = 6e7, o = 0, s = 0, l = 0, c = Number.MAX_SAFE_INTEGER, h = 0 - Number.MAX_SAFE_INTEGER; "lla" == this.pointsType ? (e = Math.max(...this.points.map((e => e.lon))), t = Math.min(...this.points.map((e => e.lon))), i = Math.max(...this.points.map((e => e.lat))), r = Math.min(...this.points.map((e => e.lat))), n = Math.max(...this.points.map((e => e.alt))), a = Math.min(...this.points.map((e => e.alt))), h = Math.max(...this.points.map((e => e.value))), c = Math.min(...this.points.map((e => e.value)))) : (e = Math.max(...this.points.map((e => e.x))), t = Math.min(...this.points.map((e => e.x))), i = Math.max(...this.points.map((e => e.z))), r = Math.min(...this.points.map((e => e.z))), n = Math.max(...this.points.map((e => e.y))), a = Math.min(...this.points.map((e => e.y))), h = Math.max(...this.points.map((e => e.value))), c = Math.min(...this.points.map((e => e.value)))); for (let e of this.points) if ("lla" == this.pointsType) { e.type = "lla"; let t = this.context.convertLLAToXYZ({ x: e.lon, y: e.lat, z: e.alt }); e.x = t.x, e.y = t.y, e.z = t.z; let i = this.radius; 1 !== this.context.getWorldScale() && (i *= this.context.getWorldScale()), e.radius = i } else { let t = this.radius; 1 !== this.context.getWorldScale() && (t *= this.context.getWorldScale()), e.radius = t } o = (e + t) / 2, s = (i + r) / 2, l = (n + a) / 2, this.offset && 3 === this.offset.length && (o += this.offset[0], s += this.offset[1], l += this.offset[2]), this.ignoreAlt && logger.warn("HeatMap.ignoreAlt = true (热力图贴地): to be implemented."), this._positionXYZ = {}, "lla" == this.pointsType ? (this.position = new Position("lla").set(o, s, l), this._positionXYZ = this.context.convertLLAToXYZ({ x: this.position.lon, y: this.position.lat, z: this.position.alt })) : (this.position = { lon: o, alt: s, lat: l }, this._positionXYZ = { x: this.position.lon, y: this.position.lat, z: this.position.alt }), this.valueMax = h, this.valueMin = c, this._t = [], this._xMax = Math.max(...this.points.map((e => e.x))), this._yMax = Math.max(...this.points.map((e => e.z))), this._xMin = Math.min(...this.points.map((e => e.x))), this._yMin = Math.min(...this.points.map((e => e.z))); let u = this.radius; 1 !== this.context.getWorldScale() && (u *= this.context.getWorldScale()), this._radiusMax = u; for (let e of this.points) this._t.push({ x: (e.x - this._xMin + this._radiusMax * this.context.getWorldScale()) / this.context.getWorldScale(), y: (e.z - this._yMin + this._radiusMax * this.context.getWorldScale()) / this.context.getWorldScale(), value: e.value, radius: e.radius }); this._width = (this._radiusMax * this.context.getWorldScale() * 2 + this._xMax - this._xMin) / this.context.getWorldScale(), this._height = (this._radiusMax * this.context.getWorldScale() * 2 + this._yMax - this._yMin) / this.context.getWorldScale(), this._zoomFactor = 1; let d = this._width > this._height ? this._width : this._height; if (d > 4096) { this._zoomFactor = d / 4096, this._width = this._width / this._zoomFactor, this._height = this._height / this._zoomFactor; for (let e of this._t) e.x = Math.ceil(e.x / this._zoomFactor), e.y = Math.ceil(e.y / this._zoomFactor), e.radius = Math.ceil(e.radius / this._zoomFactor) } } removeHeatmap() { this.context && this.context.removeLayer(this.getFullName()) } show() { this.hidden = !0, this.context } toString() { return JSON.stringify(this) } updateHeatMapData(e) { for (let t in e) null != this[t] && (this[t] = e[t]); this.context.removeLayer(this.getFullName()), this.prepareCoreData(), this.context.addHeatMapLayer(this.getFullName(), this.getHeatMapParam()), this.context.updateHeatMapData(this.getFullName(), this.valueMin, this.valueMax, this._t, this._zoomFactor) } } class InfoPanel extends Drawable { constructor(e, t, i, r, n, a) { super(e), this.content = e.content || "", this.enableAutoPan = !!e.enableAutoPan, this.exclusive = !!e.exclusive, this.height = e.height || "", this.offset = e.offset || [0, 0, 0], this.position = e.position || "", this.width = e.width || ""; var o = this; let s = { lonOffset: this.offset[0], latOffset: this.offset[1], altOffset: this.offset[2] }; 3 == this.offset.length ? this.position = this.convertLLAToXYZ(this.position, !0, s) : this.position = this.convertLLAToXYZ(this.position, !1, s); let l = {}; l.x = this.position.x, l.y = this.position.y, l.z = this.position.z, this.saveXyz(l); let c = this.context.convertWorldToScreen(l), h = document.createElement("div"); if (this.content = this.content.replace('data-close="popup"', `data-close="popup-${this.name}"`), h.setAttribute("id", `${i}_${this.name}`), h.className = i, h.innerHTML = this.content.substring(0, 4194304), h.style = `position: absolute;\n                            width: ${this.width}px; \n                            height: ${this.height}${"auto" === this.height ? "" : "px"}; \n                            left: ${c.x - this.width / 2}px; \n                            top: ${c.y - ("auto" === this.height ? 0 : this.height)}px; `, this.exclusive) for (let e = t.container.childNodes.length - 1; e >= 0; e--)t.container.childNodes[e].className === i && t.container.removeChild(t.container.childNodes[e]); if (t.container.appendChild(h), this.context.off(r.CAMERA_MOVE), this.context.on(r.CAMERA_MOVE, "", (function (e) { let r = o.getLayer(n, i).getDrawables(); if (r && r.length > 0) for (let e of r) { let r = o.context.convertWorldToScreen(e.getXyz()); for (let n = 0; n < t.container.childNodes.length; n++)if (t.container.childNodes[n].getAttribute("id") === `${i}_${e.name}`) { t.container.childNodes[n].style.left = r.x - t.container.childNodes[n].clientWidth / 2 + "px", t.container.childNodes[n].style.top = r.y - t.container.childNodes[n].clientHeight + "px"; break } } })), this.closeButton = document.querySelector(`[data-close="popup-${this.name}"]`), this.closeButton && (o.closeEventListener = o.closeButton.addEventListener("click", (function () { logger.debug("close handler triggered."), o.removeInfoPanel(o.name, "_sys_layer_info_panel_", t, "EVENTS", n) }))), o.enableAutoPan && (c.x < o.width / 2 || c.y < h.clientHeight || c.x - o.width / 2 > t.container.offsetWidth || c.y - h.clientHeight > t.container.offsetHeight)) { let e = o.getCamera(); o.context.cameraFlyTo(l, e.posture[2], e.posture[1] > 0 ? -15 : e.posture[1], e.distance, 3, !0) } a && a(1) } getLayer(e, t) { if (e instanceof Array) for (let i of e) if (i.name === t) return i } removeDrawable(e, t, i) { if (!this.getLayer(t, i)) return this; if (t instanceof Array) for (var r = 0; r < t.length; r++)t[r].name === i && t[r]._drawables.map(((i, n) => { i.name == e && t[r]._drawables.splice(n, 1) })) } removeInfoPanel(e, t, i, r, n, a) { for (let r = i.container.childNodes.length - 1; r >= 0; r--)i.container.childNodes[r].getAttribute("id") === `${t}_${e}` && (i.container.removeChild(i.container.childNodes[r]), this.removeDrawable(e, n, t)); a && a(1, "成功") } } class InstancedBubble extends Drawable { constructor(e, t) { if (super(e), this.isShow = 0 != e.isShow && 1 != e.isShow || e.isShow, this.label = e.label || !1, this.labelBackground = e.labelBackground || "#00000055", this.labelCanvas = e.labelCanvas || "", this.labelColor = e.labelColor || "#ffffff", this.labelEnableItalic = e.labelEnableItalic || !1, this.labelFontBold = e.labelFontBold || !1, this.labelFontFamily = e.labelFontFamily || "微软雅黑, Microsoft Yahei, PingFang SC, Helvetica, Noto Sans CJK SC, Source Han Sans SC, SimHei, sans-serif", this.labelFontSize = e.labelFontSize || 18, this.labelText = e.labelText || "默认值", this.labelXOffset = e.labelXOffset || 0, this.labelYOffset = e.labelYOffset || 0, this.sizeAttenuation = !(0 == e.sizeAttenuation || !e.sizeAttenuation), this.fillArea = e.fillArea || "none", this.context) { var i = { points: [], repeatMode: "repeat", isShow: this.isShow, renderOrder: this.zLevel, fillArea: this.fillArea }; for (let t of e.points) t.position = this.convertLLAToXYZ(t.position), i.points.push({ name: t.name, position: t.position, offsetX: 0, offsetY: 0, offsetZ: 0, value: t.value, diffSpeed: t.animationSpeed, repeatMode: "repeat", color: t.bubbleColor, alpha: 1, brightness: 1, enableAutoHidebyDistance: !1, isShow: t.isShow, textParam: { enableText: !1 } }); this.context.addInstancedBubble(this.getFullName(), i, void 0, t), this.points = i.points } else t && t(0) } removeBubble() { this.context.removeLayer(this.getFullName()) } toString() { return JSON.stringify(this) } updateInstancedBubble(e = {}, t) { this.context.removeInstancedBubble(this.getFullName()); var i = { points: this.points, repeatMode: "repeat", isShow: void 0 === e.isShow ? this.isShow : e.isShow, renderOrder: this.zLevel, fillArea: e.fillArea || "none" }; if (e.points) { i.points = []; for (let t of e.points) t.position = this.convertLLAToXYZ(t.position), i.points.push({ name: t.name, position: t.position, offsetX: 0, offsetY: 0, offsetZ: 0, value: t.value, diffSpeed: t.animationSpeed, repeatMode: "repeat", color: t.bubbleColor, alpha: 1, brightness: 1, enableAutoHidebyDistance: !1, isShow: t.isShow, textParam: { enableText: !1 } }) } this.context.addInstancedBubble(this.getFullName(), i, void 0, t), this.points = i.points } } class Landmark$1 extends Drawable { constructor(e, t) { if (super(e), this.altOffset = e.altOffset || 0, this.enableAutoHidebyDistance = e.enableAutoHidebyDistance || !1, this.height = e.height || "", this.icon = e.icon || "default", this.iconXOffset = e.iconXOffset || 0, this.iconYOffset = e.iconYOffset || 0, this.isShow = 0 != e.isShow && 1 != e.isShow || e.isShow, this.label = e.label || !1, this.labelBackground = e.labelBackground || "#00000055", this.labelCanvas = e.labelCanvas || "", this.labelColor = e.labelColor || "#ffffff", this.labelEnableItalic = e.labelEnableItalic || !1, this.labelFontBold = e.labelFontBold || !1, this.labelFontFamily = e.labelFontFamily || "微软雅黑, Microsoft Yahei, PingFang SC, Helvetica, Noto Sans CJK SC, Source Han Sans SC, SimHei, sans-serif", this.labelFontSize = e.labelFontSize || 18, this.labelText = e.labelText || "", this.labelXOffset = e.labelXOffset || 0, this.labelYOffset = e.labelYOffset || 0, this.latOffset = e.latOffset || 0, this.lonOffset = e.lonOffset || 0, this.labelAlignment = e.labelAlignment || "", this.maxDistance = e.maxDistance || 1e8, e.hasOwnProperty("maxDistance") || e.hasOwnProperty("pointMaxDistance") && (this.maxDistance = e.pointMaxDistance, logger.error("检测到错误的地标点属性：'pointMaxDistance' 。")), this.minDistance = e.minDistance || 0, e.hasOwnProperty("minDistance") || e.hasOwnProperty("pointMinDistance") && (this.maxDistance = e.pointMinDistance, logger.error("检测到错误的地标点属性：'pointMinDistance' 。")), this.offset = e.offset || !1, this.position = e.position, this.polygonOffset = e.polygonOffset || !1, this.polygonOffsetFactor = e.polygonOffsetFactor || 0, this.polygonOffsetUnits = e.polygonOffsetUnits || 0, this.sizeAttenuation = !(0 == e.sizeAttenuation || !e.sizeAttenuation), this.width = e.width || "", this.background = e.background || "", this.backgroundColor = e.backgroundColor || "#ffffff", this.useIconAsset = e.useIconAsset, this.iconAssetName = e.iconAssetName, this.zLevel = e.zLevel || 1, this.context) { let e = { lonOffset: this.lonOffset, latOffset: this.latOffset, altOffset: this.altOffset }; this.position = this.convertLLAToXYZ(this.position, this.offset, e), this.useIconAsset ? this.context.addBillboardAsset(this.getFullName(), { iconAssetName: this.iconAssetName, pos: { x: this.position.x, y: this.position.y, z: this.position.z }, labelText: this.labelText, labelColor: this.labelColor, isShow: this.isShow, renderOrder: this.zLevel }, t) : this.context.addBillboard(this.getFullName(), this.getBillboardParam(), this.getTextParam(), t) } } generateLabelCanvas() { let e = document.createElement("canvas"), t = e.getContext("2d"); return t.font = `${this.labelFontSize}px ${this.fontfamily}`, t.textAlign = "center", t.textBaseline = "middle", e.width = 2 * (t.measureText(this.labelText).width + this.labelFontSize), e.height = 3.6 * this.labelFontSize, t.fillStyle = this.labelBackground, t.fillRect(0, 0, e.width, e.height), t.font = `${2 * this.labelFontSize}px ${this.fontfamily}`, t.fillStyle = this.labelForeground, t.textAlign = "center", t.textBaseline = "middle", t.fillText(this.labelText, e.width / 2, e.height / 2), e } generateTooltipCanvas() { let e = document.createElement("canvas").getContext("2d"); return e.width = w, e.height = h, e.fillStyle = "#fff", e.fillRect(0, 0, w, h), e.strokeStyle = "#c00", e.shadowBlur = 20, e.shadowColor = "#c99", e.strokeWidth = 30, e.beginPath(), e.moveTo(w / 2, 0), e.lineTo(0, h), e.lineTo(w, h), e.closePath(), e.stroke(), e } getBillboardParam() { let e = 0, t = 1e6; return isNaN(Number(this.minDistance)) || (e = Number(this.minDistance)), isNaN(Number(this.maxDistance)) || (t = Number(this.maxDistance)), { path: this.icon, sizeAttenuation: this.sizeAttenuation, pos: { x: this.position.x, y: this.position.y, z: this.position.z }, width: this.width, height: this.height, enableAutoHidebyDistance: this.enableAutoHidebyDistance, pointMinDistance: Number(e), pointMaxDistance: Number(t), offsetV: this.iconXOffset, offsetH: this.iconYOffset, polygonOffset: this.polygonOffset, polygonOffsetFactor: this.polygonOffsetFactor, polygonOffsetUnits: this.polygonOffsetUnits, isShow: this.isShow, background: this.background, backgroundColor: this.backgroundColor, renderOrder: this.zLevel } } getTextParam() { if (null != this.labelCanvas && this.labelCanvas) var e = this.labelCanvas; else e = this.generateLableCanvas(this.labelFontFamily, this.labelFontSize, this.labelFontBold, this.labelEnableItalic, this.labelBackground, this.labelColor, this.labelText); let t; return t = null != e ? { enableText: this.label, canvas: e, sizeAttenuation: this.sizeAttenuation, width: this.sizeAttenuation ? .01 * e.width : 45e-6 * e.width, height: this.sizeAttenuation ? .01 * e.height : 45e-6 * e.height, offsetV: this.labelXOffset, offsetH: this.labelYOffset, labelAlignment: this.labelAlignment } : { enableText: !1, canvas: e, sizeAttenuation: this.sizeAttenuation, width: this.sizeAttenuation ? .01 * e.width : 45e-6 * e.width, height: this.sizeAttenuation ? .01 * e.height : 45e-6 * e.height, offsetV: this.labelXOffset, offsetH: this.labelYOffset, labelAlignment: this.labelAlignment }, t } removeLandmark() { this.context.removeLayer(this.getFullName()) } toString() { return JSON.stringify(this) } updateLandmark(e, t) { if (null != e.position) { let t = { lonOffset: e.lonOffset, latOffset: e.latOffset, altOffset: e.altOffset }; e.position = this.convertLLAToXYZ(e.position, e.offset, t) } for (let t in e) this[t] = e[t], "pointMaxDistance" == t && (e.hasOwnProperty("maxDistance") || (this.maxDistance = e.pointMaxDistance, logger.error("检测到错误的地标点属性：'pointMaxDistance' 。"))), "pointMinDistance" == t && (e.hasOwnProperty("minDistance") || (this.maxDistance = e.pointMinDistance, logger.error("检测到错误的地标点属性：'pointMinDistance' 。"))); this.useIconAsset ? this.context.updateBillboardAsset(this.getFullName(), { iconAssetName: this.iconAssetName, pos: { x: this.position.x, y: this.position.y, z: this.position.z }, labelText: this.labelText, labelColor: this.labelColor, isShow: this.isShow, renderOrder: this.zLevel }, t) : this.context.updateBillboard(this.getFullName(), this.getBillboardParam(), this.getTextParam(), t) } } class Marker extends Drawable { constructor(e, t, i) { if (super(e), this.height = e.height || "", this.icon = e.icon || "", this.position = e.position || "", this.sizeAttenuation = !1 !== e.sizeAttenuation, this.width = e.width || "", this.context) { let e = { lonOffset: 0, latOffset: 0, altOffset: 0 }; this.position = this.convertLLAToXYZ(this.position, this.offset, e), this.context.addSpriteXYZ(`${t}/${this.name}`, this.icon, { x: this.position.x, y: this.position.y + this.height / 2, z: this.position.z }, this.width, this.height, this.sizeAttenuation), i && i(1) } } toString() { return JSON.stringify(this) } } class Model$1 { constructor(e, t) { this.name = e.name || "", this.nodes = [], this.src = e.src || "", this.tags = e.tags || [], t && t(1) } hide() { return this } load(e, t) { return t && t(1), this } show() { return this } toString() { return "" } } class ODLine extends Drawable { constructor(e, t) { super(e), this.alpha = e.alpha || 1, this.altOffset = e.altOffset, this.animationSpeed = e.animationSpeed || 1, this.color = e.color || "#FFFFFF", this.curvatureCoefficient = e.curvatureCoefficient, this.enableAutoHidebyDistance = e.enableAutoHidebyDistance || !1, this.endPos = e.endPos, this.imageType = e.imageType || "default", this.isShow = 0 != e.isShow && 1 != e.isShow || e.isShow, this.label = e.label || !1, this.labelBackground = e.labelBackground || "#00000055", this.labelCanvas = e.labelCanvas || "", this.labelColor = e.labelColor || "#ffffff", this.labelEnableItalic = e.labelEnableItalic || !1, this.labelFontBold = e.labelFontBold || !1, this.labelFontFamily = e.labelFontFamily || "微软雅黑, Microsoft Yahei, PingFang SC, Helvetica, Noto Sans CJK SC, Source Han Sans SC, SimHei, sans-serif", this.labelFontSize = e.labelFontSize || 5, this.labelText = e.labelText || "默认值", this.labelXOffset = e.labelXOffset || .5, this.labelYOffset = e.labelYOffset || .1, this.latOffset = e.latOffset, this.lineWidth = e.lineWidth || 1, this.lonOffset = e.lonOffset, this.maxDistance = e.maxDistance || 1e8, this.minDistance = e.minDistance || 0, this.offset = e.offset, this.roundrobinModel = e.roundrobinModel || "circulation", this.sizeAttenuation = 0 != e.sizeAttenuation && 1 != e.sizeAttenuation || e.sizeAttenuation, this.startPos = e.startPos, this.tensileCoefficient = e.tensileCoefficient || 10, this.type = e.type, this.position = void 0, this.context ? (this.getStartConvertLLAToXYZ(), this.getEndConvertLLAToXYZ(), this.context.addODLine(this.getFullName(), this.getODLineInfo(), this.getTextParam(), ((e, i) => { this.position = (new Position).set(i.x, i.y, i.z), t && t(e) }))) : t && t(1) } getEndConvertLLAToXYZ() { if ("lla" === this.endPos.type.toLowerCase()) if (this.offset) { let e = this.context.convertLLAToXYZ({ x: this.endPos.lon + Number(this.lonOffset), y: this.endPos.lat + Number(this.latOffset), z: this.endPos.alt + Number(this.altOffset) }); this.endPos.x = e.x, this.endPos.y = e.y, this.endPos.z = e.z } else { let e = this.context.convertLLAToXYZ({ x: this.endPos.lon, y: this.endPos.lat, z: this.endPos.alt }); this.endPos.x = e.x, this.endPos.y = e.y, this.endPos.z = e.z } } getODLineInfo() { return { maxDistance: Number(this.maxDistance), minDistance: Number(this.minDistance), enableAutoHidebyDistance: this.enableAutoHidebyDistance, startPos: this.startPos, endPos: this.endPos, curvatureCoefficient: this.curvatureCoefficient, animationSpeed: this.animationSpeed, useMap: !0, depthWrite: !1, depthTest: !1, alphaTest: 0, sizeAttenuation: !1, dashRatio: 0, repeat: { x: 1, y: this.tensileCoefficient }, lineWidth: this.lineWidth, color: this.color, dashArray: 1, dashOffset: this.animationSpeed, transparent: !0, isShow: this.isShow, roundrobinModel: this.roundrobinModel, imageType: this.imageType, alpha: Number(this.alpha), renderOrder: this.zLevel } } getStartConvertLLAToXYZ() { if ("lla" === this.startPos.type.toLowerCase()) if (this.offset) { let e = this.context.convertLLAToXYZ({ x: this.startPos.lon + Number(this.lonOffset), y: this.startPos.lat + Number(this.latOffset), z: this.startPos.alt + Number(this.altOffset) }); this.startPos.x = e.x, this.startPos.y = e.y, this.startPos.z = e.z } else { let e = this.context.convertLLAToXYZ({ x: this.startPos.lon, y: this.startPos.lat, z: this.startPos.alt }); this.startPos.x = e.x, this.startPos.y = e.y, this.startPos.z = e.z } } getTextParam() { if (null != this.labelCanvas && this.labelCanvas) var e = this.labelCanvas; else e = this.generateLableCanvas(this.labelFontFamily, this.labelFontSize, this.labelFontBold, this.labelEnableItalic, this.labelBackground, this.labelColor, this.labelText); let t; return t = null != e ? { enableText: this.label, canvas: e, sizeAttenuation: this.sizeAttenuation, width: this.sizeAttenuation ? .09 * e.width : 405e-6 * e.width, height: this.sizeAttenuation ? .09 * e.height : 405e-6 * e.height, offsetV: this.labelXOffset, offsetH: this.labelYOffset } : { enableText: !1, canvas: e, sizeAttenuation: this.sizeAttenuation, width: this.sizeAttenuation ? .09 * e.width : 405e-6 * e.width, height: this.sizeAttenuation ? .09 * e.height : 405e-6 * e.height, offsetV: this.labelXOffset, offsetH: this.labelYOffset }, t } removeODLine() { this.context.removeLayer(this.getFullName()) } toString() { return JSON.stringify(this) } updateODLine(e, t) { for (let t in e) null != this[t] && (this[t] = e[t]); this.getStartConvertLLAToXYZ(), this.getEndConvertLLAToXYZ(), this.context.removeLayer(this.getFullName()), this.context.addODLine(this.getFullName(), this.getODLineInfo(), this.getTextParam(), ((e, i) => { this.position = (new Position).set(i.x, i.y, i.z), t && t(e) })) } } class Trail$2 extends Drawable { constructor(e, t) { if (super(e), this.altOffset = e.altOffset, this.color = e.color, this.duration = e.duration, this.enableAutoHidebyDistance = e.enableAutoHidebyDistance || !1, this.height = e.height || 0, this.icon = e.icon || "", this.iconXOffset = e.iconXOffset || 0, this.iconYOffset = e.iconYOffset || 0, this.isShow = 0 != e.isShow && 1 != e.isShow || e.isShow, this.label = e.label || !1, this.labelBackground = e.labelBackground || "#00000055", this.labelCanvas = e.labelCanvas || "", this.labelColor = e.labelColor || "#ffffff", this.labelEnableItalic = e.labelEnableItalic || !1, this.labelFontBold = e.labelFontBold || !1, this.labelFontFamily = e.labelFontFamily || "微软雅黑, Microsoft Yahei, PingFang SC, Helvetica, Noto Sans CJK SC, Source Han Sans SC, SimHei, sans-serif", this.labelFontSize = e.labelFontSize || 18, this.labelText = e.labelText || "默认值", this.labelXOffset = e.labelXOffset || 0, this.labelYOffset = e.labelYOffset || 0, this.latOffset = e.latOffset || 0, this.lineShowHidden = e.lineShowHidden || !0, this.lineWidth = e.lineWidth || 0, this.lonOffset = e.lonOffset || 0, this.maxDistance = e.maxDistance || 1e8, e.hasOwnProperty("maxDistance") || e.hasOwnProperty("pointMaxDistance") && (this.maxDistance = e.pointMaxDistance, logger.error("检测到错误的地标点属性：'pointMaxDistance' 。")), this.minDistance = e.minDistance || 0, this.travelingTime = void 0 === e.travelingTime ? 1 : e.travelingTime, e.hasOwnProperty("minDistance") || e.hasOwnProperty("pointMinDistance") && (this.maxDistance = e.pointMinDistance, logger.error("检测到错误的地标点属性：'pointMinDistance' 。")), this.offset = e.offset || 0, this.position = e.position, this.sizeAttenuation = !(0 == e.sizeAttenuation || !e.sizeAttenuation), this.width = e.width, this.background = e.background || "", this.backgroundColor = e.backgroundColor || "#ffffff", this.labelAlignment = e.labelAlignment || "", this.useIconAsset = e.useIconAsset || !1, this.iconAssetName = e.iconAssetName, this.context) { let e = { lonOffset: this.lonOffset, latOffset: this.latOffset, altOffset: this.altOffset }; this.position = this.convertLLAToXYZ(this.position, this.offset, e), this.context.addTrail(this.getFullName(), this.getTrailParam(), this.getTextParam(), t) } } getTextParam() { if (null != this.labelCanvas && this.labelCanvas) var e = this.labelCanvas; else e = this.generateLableCanvas(this.labelFontFamily, this.labelFontSize, this.labelFontBold, this.labelEnableItalic, this.labelBackground, this.labelColor, this.labelText); let t; return t = null != e ? { enableText: this.label, canvas: e, sizeAttenuation: this.sizeAttenuation, width: this.sizeAttenuation ? .01 * e.width : 45e-6 * e.width, height: this.sizeAttenuation ? .01 * e.height : 45e-6 * e.height, offsetV: this.labelXOffset, offsetH: this.labelYOffset, labelAlignment: this.labelAlignment, labelText: this.labelText } : { enableText: !1, canvas: e, sizeAttenuation: this.sizeAttenuation, width: this.sizeAttenuation ? .01 * e.width : 45e-6 * e.width, height: this.sizeAttenuation ? .01 * e.height : 45e-6 * e.height, offsetV: this.labelXOffset, offsetH: this.labelYOffset, labelAlignment: this.labelAlignment, labelText: this.labelText }, t } getTrailParam() { let e = 0, t = 1e6; return isNaN(Number(this.minDistance)) || (e = Number(this.minDistance)), isNaN(Number(this.maxDistance)) || (t = Number(this.maxDistance)), { pos: this.position, color: this.color, duration: this.duration, lineWidth: this.lineWidth, lineShowHidden: this.lineShowHidden, pointMaxDistance: Number(t), pointMinDistance: Number(e), enableAutoHidebyDistance: this.enableAutoHidebyDistance, width: this.width, height: this.height, offsetV: this.iconXOffset, offsetH: this.iconYOffset, sizeAttenuation: this.sizeAttenuation, path: this.icon, useIconAsset: this.useIconAsset, iconAssetName: this.iconAssetName, isShow: this.isShow, background: this.background, backgroundColor: this.backgroundColor, travelingTime: this.travelingTime, renderOrder: this.zLevel } } removeTrail() { this.labelCanvas = null, this.context.removeLayer(this.getFullName()) } toString() { return JSON.stringify(this) } updateTrail(e) { if (null != e.position) { let t = { lonOffset: e.lonOffset, latOffset: e.latOffset, altOffset: e.altOffset }; e.position = this.convertLLAToXYZ(e.position, e.offset, t) } for (let t in e) this[t] = e[t], "pointMaxDistance" == t && (e.hasOwnProperty("maxDistance") || (this.maxDistance = e.pointMaxDistance, logger.error("检测到错误的地标点属性：'pointMaxDistance' 。"))), "pointMinDistance" == t && (e.hasOwnProperty("minDistance") || (this.maxDistance = e.pointMinDistance, logger.error("检测到错误的地标点属性：'pointMinDistance' 。"))); this.context.updateTrail(this.getFullName(), this.getTrailParam(), this.getTextParam()) } } const _fontFamily = "微软雅黑, Microsoft Yahei, PingFang SC, Helvetica, Noto Sans CJK SC, Source Han Sans SC, SimHei, sans-serif"; class Area$1 extends Drawable { constructor(e, t) { super(e), this.alpha = e.alpha >= 0 ? e.alpha : 1, this.altOffset = e.altOffset || 0, this.color = e.color || "#ffffff", this.depth = e.depth || 1, this.enableAutoHidebyDistance = e.enableAutoHidebyDistance || !1, this.followAreaColor = "boolean" != typeof e.followAreaColor || e.followAreaColor, this.isShow = 0 != e.isShow && 1 != e.isShow || e.isShow, this.label = 0 != e.label && 1 != e.label || e.label, this.labelBackground = e.labelBackground || "#00000055", this.labelCanvas = e.labelCanvas || "", this.labelColor = e.labelColor || "#ffffff", this.labelEnableItalic = e.labelEnableItalic || !1, this.labelFontBold = e.labelFontBold || !1, this.labelFontFamily = e.labelFontFamily || _fontFamily, this.labelFontSize = e.labelFontSize || 18, this.labelText = e.labelText || "默认值", this.labelXOffset = e.labelXOffset || 0, this.labelYOffset = e.labelYOffset || 0, this.latOffset = e.latOffset || 0, this.lineAlpha = e.lineAlpha || 1, this.lineColor = e.lineColor || "#ffffff", this.lineFlag = !(0 == e.lineFlag || !e.lineFlag), this.lineWidth = e.lineWidth || 1, this.lonOffset = e.lonOffset || 0, this.maxDistance = e.maxDistance || 1e8, this.minDistance = e.minDistance || 0, this.offset = 0 != e.offset && 1 != e.offset || e.offset, this.points = e.points || [], this.fillArea = e.fillArea || "", this.areaType = e.areaType || "", this.fillType = e.fillType || "top", this.position = void 0, this.sizeAttenuation = !(0 == e.sizeAttenuation || !e.sizeAttenuation), this.context ? this.points && this.points.length >= 3 ? this.context.addArea(this.getFullName(), this.getAreaInfo(), this.getTextParam(), t) : (logger.warn("点位不够，绘制区域图失败。"), t && t(1)) : t && t(1) } updatePosition(e) { let t = e.point[0], i = e.point[0], r = e.point[1], n = e.point[1]; for (let a = 0; a < e.point.length; a += 2)e.point[a] < t && (t = e.point[a]), e.point[a] > i && (i = e.point[a]), e.point[a + 1] < r && (r = e.point[a + 1]), e.point[a + 1] > n && (n = e.point[a + 1]); let a = (t + i) / 2 + e.lonOffset, o = this.depth / 2 + e.altOffset, s = -(r + n) / 2 + e.latOffset; this.position = (new Position).set(a, o, s) } getAreaInfo() { let e = 0; var t = []; const i = []; for (var r = 0; r < this.points.length; r++)if (this.points[r] && "lla" === this.points[r].type.toLowerCase()) { var n = this.context.convertLLAToXYZ({ x: this.points[r].lon, y: this.points[r].lat, z: this.points[r].alt }); t.push(n.x), t.push(-n.z), e = n.y, i.push({ x: n.x, y: n.y, z: n.z }) } else t.push(this.points[r].x), t.push(-this.points[r].z), e = this.points[r].y, i.push({ x: this.points[r].x, y: this.points[r].y, z: this.points[r].z }); i.push(JSON.parse(JSON.stringify(i[0]))); let a = { point: t, depth: this.depth, areaType: this.areaType, color: this.color, alpha: this.alpha, fillArea: this.fillArea, fillType: this.fillType, followAreaColor: this.followAreaColor, lineAlpha: this.lineAlpha, lineColor: this.lineColor, lineWidth: this.lineWidth, maxDistance: Number(this.maxDistance), minDistance: Number(this.minDistance), enableAutoHidebyDistance: this.enableAutoHidebyDistance, offset: this.offset, lonOffset: Number(this.lonOffset), latOffset: Number(this.latOffset), altOffset: Number(this.altOffset), alt: e, isShow: this.isShow, lineFlag: this.lineFlag, renderOrder: this.zLevel, vectors: i }, o = this.getUvAnimation(this.areaType, this.fillArea); return Object.assign(a, o), a.fillAlpha *= this.alpha, this.updatePosition(a), a } getUvAnimation(e, t) { let i = { u: !1, v: !1, uSpeed: 0, vSpeed: 0, fillU: !1, fillV: !1, fillUSpeed: 0, fillVSpeed: 0, fillColor: this.color, fillAlpha: 1 }; switch (e.toLowerCase()) { case "arrow01": i.u = !0, i.v = !1, i.uSpeed = -.3, i.vSpeed = 0; break; case "gradient02": i.u = !1, i.v = !0, i.uSpeed = 0, i.vSpeed = .3; break; case "gradient03": case "grid01": i.u = !1, i.v = !1, i.uSpeed = 0, i.vSpeed = 0; break; case "grid03": i.u = !1, i.v = !0, i.uSpeed = 0, i.vSpeed = .2; break; case "grid05": i.u = !1, i.v = !0, i.uSpeed = 0, i.vSpeed = .3; break; case "segment01": i.u = !0, i.v = !1, i.uSpeed = -1, i.vSpeed = 0; break; case "segment02": i.u = !1, i.v = !0, i.uSpeed = 0, i.vSpeed = .1; break; case "segment03": i.u = !0, i.v = !1, i.uSpeed = -.3, i.vSpeed = 0 }switch (t.toLowerCase()) { case "gradient01": case "gradient02": i.fillU = !0, i.fillV = !1, i.fillUSpeed = -.4, i.fillVSpeed = 0; break; case "grid01": i.fillU = !0, i.fillV = !1, i.fillUSpeed = -.2, i.fillVSpeed = 0; break; case "grid02": case "segment01": i.fillU = !0, i.fillV = !1, i.fillUSpeed = -.1, i.fillVSpeed = 0; break; case "segment02": i.fillU = !0, i.fillV = !1, i.fillUSpeed = -.1, i.fillVSpeed = 0, i.fillColor = this.lightenDarkenColor(this.color, 200), i.fillAlpha = .8 }return i } lightenDarkenColor(e, t) { "#" == e[0] && (e = e.slice(1)); var i = parseInt(e, 16), r = (i >> 16) + t; r > 255 ? r = 255 : r < 0 && (r = 0); var n = (i >> 8 & 255) + t; n > 255 ? n = 255 : n < 0 && (n = 0); var a = (255 & i) + t; return a > 255 ? a = 255 : a < 0 && (a = 0), "#" + (a | n << 8 | r << 16).toString(16) } getTextParam() { if (null != this.labelCanvas && this.labelCanvas) var e = this.labelCanvas; else e = this.generateLableCanvas(this.labelFontFamily, this.labelFontSize, this.labelFontBold, this.labelEnableItalic, this.labelBackground, this.labelColor, this.labelText); let t; return t = null != e ? { enableText: this.label, canvas: e, sizeAttenuation: this.sizeAttenuation, width: this.sizeAttenuation ? .01 * e.width : 45e-6 * e.width, height: this.sizeAttenuation ? .01 * e.height : 45e-6 * e.height, offsetV: this.labelXOffset, offsetH: this.labelYOffset } : { enableText: !1, canvas: e, sizeAttenuation: this.sizeAttenuation, width: this.sizeAttenuation ? .1 * e.width : 45e-6 * e.width, height: this.sizeAttenuation ? .1 * e.height : 45e-6 * e.height, offsetV: this.labelXOffset, offsetH: this.labelYOffset }, t } removeArea() { this.context.removeLayer(this.getFullName()) } toString() { return JSON.stringify(this) } updateArea(e, t) { for (let t in e) null != this[t] && (this[t] = e[t]); this.context.removeLayer(this.getFullName()), this.points && this.points.length >= 3 ? this.context.addArea(this.getFullName(), this.getAreaInfo(), this.getTextParam(), t) : (logger.warn("点位不够，绘制区域图失败。"), t && t(1)) } } class Path$1$1 extends Drawable { constructor(e, t) { super(e), this.points = e.points, this.color = e.color, this.colorPass = e.colorPass, this.pass = e.pass || 0, this.passRange = e.passRange || 0, this.pathType = e.pathType, this.width = e.width, this.pathType = e.pathType || "segment06", this.alpha = null != e.alpha ? e.alpha : 1, this.isShow = null == e.isShow || e.isShow, this.position = void 0, this.context && (this.getPointsConvertLLAToXYZ(), this.points.length > 1 ? this.context.addPath(this.getFullName(), this.getPathInfo(), t) : t && t(1)) } getPathInfo() { var e = { points: this.points, color: this.color, colorPass: this.colorPass, pass: this.pass, passRange: this.passRange, pathType: this.pathType, width: this.width, alpha: this.alpha, isShow: this.isShow, renderOrder: this.zLevel }; return this.updatePosition(), e } updatePosition() { if (this.points.length <= 0) return; if (1 === this.points.length) return void (this.position = this.points[0]); let e = 0; for (let t = 0; t < this.points.length - 1; t++) { let i = this.points[t], r = this.points[t + 1]; e += this.context.getDistanceByPositions(i, r) } e /= 2; let t = 0, i = 0; for (let r = 0; r < this.points.length - 1; r++) { let n = this.points[r], a = this.points[r + 1]; if (t += this.context.getDistanceByPositions(n, a), t > e) { i = r; break } } let r = t - e, n = this.points[i], a = this.points[i + 1], o = r / this.context.getDistanceByPositions(n, a), s = this.context.positionLerp(n, a, 1 - o); this.position = (new Position).set(s.x, s.y, s.z) } getPointsConvertLLAToXYZ() { this.points.forEach((e => { if ("lla" === e.type.toLowerCase()) { let t = this.context.convertLLAToXYZ({ x: e.lon, y: e.lat, z: e.alt }); e.x = t.x, e.y = t.y, e.z = t.z } })) } updatePath(e, t) { for (let t in e) null != this[t] && (this[t] = e[t]); this.getPointsConvertLLAToXYZ(), this.context.removeLayer(this.getFullName()), this.points.length > 1 ? this.context.addPath(this.getFullName(), this.getPathInfo(), t) : t && t(0) } updatePathPass({ colorPass: e, pass: t }) { void 0 !== e && (this.colorPass = e), void 0 !== t && (this.pass = t), this.points.length > 1 && this.context.updatePathPass(this.getFullName(), { colorPass: this.colorPass, pass: this.pass }) } removePath() { this.context.removeLayer(this.getFullName()) } toString() { return JSON.stringify(this) } } class SolidBillboard extends Drawable { constructor(e) { super(e), this.depthTest = !0, this.enableAutoHidebyDistance = !0, this.iconBrightness = 1, this.iconHeight = 5, this.iconIsShow = !0, this.iconOffset = { x: 0, y: 0, z: 0 }, this.iconScale = 1, this.iconUrl = "./texture/pin.png", this.iconWidth = 5, this.isShow = !0, this.maxDistance = 1e6, this.minDistance = 0, this.position = Position.Zero(), this.rotation = { x: 0, y: 0, z: 0 }, this.scale = 1, this.textAlignment = "居中", this.textBrightness = 1, this.textColor = "#ffffff", this.textContent = "无文本", this.textFont = "./texture/fonts/Noto Sans CJK Black.otf", this.textIsShow = !0, this.textOffset = { x: 0, y: 0, z: 0 }, this.textSize = 20, this._params = e, this._checkMustParam(), this._updateProperty(), this._createBillboard() } _checkMustParam() { let e = "立体标牌：未检测到以下必要属性：", t = !1; this._params.hasOwnProperty("name") || (e += " name ", t = !0), this._params.hasOwnProperty("position") || (e += " position ", t = !0), this._params.hasOwnProperty("iconUrl") || (e += " iconUrl ", t = !0), t && (e += "，将使用默认值替代。", logger.warn(e)) } _updateProperty() { if (!this._params) return; if ("object" != typeof this._params) return; let e = "检测到以下无效属性：", t = !1; for (let i in this._params) this.hasOwnProperty(i) || (t = !0, e += ` ${i} `); t && (e += "。", logger.warn(e)), this._setProperty("position", 3), this._setProperty("rotation", 3), this._setProperty("scale", 2), this._setProperty("enableAutoHidebyDistance", 1), this._setProperty("maxDistance", 2), this._setProperty("minDistance", 2), this._setProperty("depthTest", 1), this._setProperty("isShow", 1), this._setProperty("iconUrl", 4), this._setProperty("iconWidth", 4), this._setProperty("iconHeight", 4), this._setProperty("iconBrightness", 2), this._setProperty("iconOffset", 3), this._setProperty("iconScale", 2), this._setProperty("iconIsShow", 1), this._setProperty("textContent", 4), this._setProperty("textFont", 4), this._setProperty("textSize", 2), this._setProperty("textBrightness", 2), this._setProperty("textColor", 4), this._setProperty("textAlignment", 4), this._setProperty("textOffset", 3), this._setProperty("textIsShow", 1) } _setProperty(e, t) { if (null == this[e]) return; if (!this._params.hasOwnProperty(e)) return; let i = this._params[e]; if (null == i || null == i) return; let r = 1 == t ? "boolean" : 2 == t ? "number" : 3 == t ? "object" : 4 == t ? "string" : "any"; if ("any" != r) if (r != typeof i) if ("string" != r) { if ("number" == r) { let t = Number(i); if (!isNaN(t)) return void (this[e] = t) } (r = "boolean") && (this[e] = !!i) } else this[e] = i.toString(); else this[e] = i; else this[e] = i } _createBillboard() { if (!this.context) return; let e = this.getBillboardParam(), t = this.getIconParam(), i = this.getTextParam(); this.context.addBillboard3D(e, t, i) } updateSolidBillboard(e) { if (this._params = e, !e) return; this._updateProperty(); let t = this.getBillboardParam(), i = this.getIconParam(), r = this.getTextParam(); this.context.updateBillboard3D(t, i, r) } removeSolidBillboard() { this.context.removeLayer(this.getFullName()) } getBillboardParam() { return this.position = this.convertLLAToXYZ(this.position, !1), { name: this.getFullName(), position: this.position, rotation: this.rotation, scale: this.scale, enableAutoHidebyDistance: this.enableAutoHidebyDistance, maxVisibleDistance: this.maxDistance, minVisibleDistance: this.minDistance, depthTest: this.depthTest, isShow: this.isShow } } getIconParam() { return { path: this.iconUrl, width: this.iconWidth, height: this.iconHeight, brightness: this.iconBrightness, offset: this.iconOffset, scale: this.iconScale, isShow: this.iconIsShow } } getTextParam() { let e = { content: this.textContent, font: this.textFont, size: this.textSize / 10, brightness: this.textBrightness, color: this.textColor, offset: this.textOffset, isShow: this.textIsShow, alignment: "center" }; return "居左" == this.textAlignment ? e.alignment = "right" : "居友" == this.textAlignment && (e.alignment = "left"), e } } class ModelLandmark$2 extends Drawable { constructor(e, t) { super(e), this.altOffset = e.altOffset || 0, this.enableAutoHidebyDistance = e.enableAutoHidebyDistance || !1, this.height = e.height || "", this.icon = e.icon || "default", this.iconXOffset = e.iconXOffset || 0, this.iconYOffset = e.iconYOffset || 0, this.isShow = 0 != e.isShow && 1 != e.isShow || e.isShow, this.label = e.label || !1, this.labelBackground = e.labelBackground || "#00000055", this.labelCanvas = e.labelCanvas || "", this.labelColor = e.labelColor || "#ffffff", this.labelEnableItalic = e.labelEnableItalic || !1, this.labelFontBold = e.labelFontBold || !1, this.labelFontFamily = e.labelFontFamily || "微软雅黑, Microsoft Yahei, PingFang SC, Helvetica, Noto Sans CJK SC, Source Han Sans SC, SimHei, sans-serif", this.labelFontSize = e.labelFontSize || 18, this.labelText = e.labelText || "", this.labelXOffset = e.labelXOffset || 0, this.labelYOffset = e.labelYOffset || 0, this.latOffset = e.latOffset || 0, this.lonOffset = e.lonOffset || 0, this.labelAlignment = e.labelAlignment || "", this.maxDistance = e.maxDistance || 1e8, this.minDistance = e.minDistance || 0, this.offset = e.offset || !1, this._position = e.position, this.polygonOffset = e.polygonOffset || !1, this.polygonOffsetFactor = e.polygonOffsetFactor || 0, this.polygonOffsetUnits = e.polygonOffsetUnits || 0, this.sizeAttenuation = !(0 == e.sizeAttenuation || !e.sizeAttenuation), this.width = e.width || "", this.background = e.background || "", this.backgroundColor = e.backgroundColor || "#ffffff", this.useIconAsset = e.useIconAsset, this.iconAssetName = e.iconAssetName, this.zLevel = e.zLevel || 1, this.snapSurface = e.snapSurface, this.alpha = e.alpha, this.modelMaxDistance = e.modelMaxDistance, this.iconMaxDistance = e.iconMaxDistance, this.rotation = e.rotation || [0, 0, 0], this.modelType = e.modelType, this.scale = e.scale, this.add(t) } get position() { return void 0 !== this.snapSurfacePosition ? this.snapSurfacePosition : this._position } set position(e) { this._position = e } add(e) { if (!this.context) return void (e && e(0)); let t = { lonOffset: this.lonOffset, latOffset: this.latOffset, altOffset: this.altOffset }; this._position = this.convertLLAToXYZ(this._position, this.offset, t); const i = this.getFullName(), r = this.getParams(); this.context.addModelLandmark(i, r, e) } update(e, t) { if (!this.context) return void (t && t(0)); for (let t in e) this[t] = e[t]; if (null != e.position) { let e = { lonOffset: this.lonOffset, latOffset: this.latOffset, altOffset: this.altOffset }; this._position = this.convertLLAToXYZ(this._position, this.offset, e) } const i = this.getFullName(), r = this.getParams(); this.context.updateModelLandmark(i, r, t) } remove() { this.context.removeLayer(this.getFullName()) } getParams() { const e = {}; this.snapSurface ? this.snapSurfacePosition = this.context.clampToModel(this._position) : this.snapSurfacePosition = void 0, e.position = { ...this.position }, e.enableAutoHidebyDistance = this.enableAutoHidebyDistance, e.maxDistance = this.maxDistance, e.minDistance = this.minDistance, e.sizeAttenuation = this.sizeAttenuation, e.renderOrder = this.zLevel, e.isShow = this.isShow, e.snapSurface = this.snapSurface, e.alpha = this.alpha, e.scale = this.scale, e.modelMaxDistance = this.modelMaxDistance, e.iconMaxDistance = this.iconMaxDistance, e.useIconAsset = this.useIconAsset, e.iconAssetName = this.iconAssetName, e.iconPath = this.icon, e.iconWidth = this.width, e.iconHeight = this.height, e.iconXOffset = this.iconXOffset, e.iconYOffset = this.iconYOffset, e.polygonOffset = this.polygonOffset, e.polygonOffsetFactor = this.polygonOffsetFactor, e.polygonOffsetUnits = this.polygonOffsetUnits, e.iconBackground = this.background, e.iconBackgroundColor = this.backgroundColor; let t = this.labelCanvas; return t || (t = this.generateLableCanvas(this.labelFontFamily, this.labelFontSize, this.labelFontBold, this.labelEnableItalic, this.labelBackground, this.labelColor, this.labelText)), e.enableLabel = this.label, e.labelCanvas = t, e.labelXOffset = this.labelXOffset, e.labelYOffset = this.labelYOffset, e.labelAlignment = this.labelAlignment, e.labelColor = this.labelColor, e.labelBackground = this.labelBackground, e.labelText = this.labelText, e.modelType = this.modelType, e.rotation = { x: this.rotation ? this.rotation[0] : 0, y: this.rotation ? this.rotation[1] : 0, z: this.rotation ? this.rotation[2] : 0 }, e } toString() { return JSON.stringify(this) } } class ModelTrail$2 extends Drawable { constructor(e, t) { super(e), this.altOffset = e.altOffset || 0, this.enableAutoHidebyDistance = e.enableAutoHidebyDistance || !1, this.height = e.height || "", this.icon = e.icon || "default", this.iconXOffset = e.iconXOffset || 0, this.iconYOffset = e.iconYOffset || 0, this.isShow = 0 != e.isShow && 1 != e.isShow || e.isShow, this.label = e.label || !1, this.labelBackground = e.labelBackground || "#00000055", this.labelCanvas = e.labelCanvas || "", this.labelColor = e.labelColor || "#ffffff", this.labelEnableItalic = e.labelEnableItalic || !1, this.labelFontBold = e.labelFontBold || !1, this.labelFontFamily = e.labelFontFamily || "微软雅黑, Microsoft Yahei, PingFang SC, Helvetica, Noto Sans CJK SC, Source Han Sans SC, SimHei, sans-serif", this.labelFontSize = e.labelFontSize || 18, this.labelText = e.labelText || "", this.labelXOffset = e.labelXOffset || 0, this.labelYOffset = e.labelYOffset || 0, this.latOffset = e.latOffset || 0, this.lonOffset = e.lonOffset || 0, this.labelAlignment = e.labelAlignment || "", this.maxDistance = e.maxDistance || 1e8, this.minDistance = e.minDistance || 0, this.offset = e.offset || !1, this._position = e.position, this.polygonOffset = e.polygonOffset || !1, this.polygonOffsetFactor = e.polygonOffsetFactor || 0, this.polygonOffsetUnits = e.polygonOffsetUnits || 0, this.sizeAttenuation = !(0 == e.sizeAttenuation || !e.sizeAttenuation), this.width = e.width || "", this.background = e.background || "", this.backgroundColor = e.backgroundColor || "#ffffff", this.useIconAsset = e.useIconAsset, this.iconAssetName = e.iconAssetName, this.zLevel = e.zLevel || 1, this.iconIsShow = !!e.iconIsShow, this.snapSurface = e.snapSurface, this.duration = e.duration, this.modelMaxDistance = e.modelMaxDistance, this.iconMaxDistance = e.iconMaxDistance, this.trackStyle = e.trackStyle, this.trackDuration = e.trackDuration, this.trackWidth = e.trackWidth, this.rotation = e.rotation || [0, 0, 0], this.modelType = e.modelType, this.scale = e.scale, this.add(t) } get position() { return void 0 !== this.snapSurfacePosition ? this.snapSurfacePosition : this._position } set position(e) { this._position = e } add(e) { if (!this.context) return void (e && e(0)); let t = { lonOffset: this.lonOffset, latOffset: this.latOffset, altOffset: this.altOffset }; this._position = this.convertLLAToXYZ(this._position, this.offset, t); const i = this.getFullName(), r = this.getParams(); this.context.addModelTrail(i, r, e) } update(e, t) { if (!this.context) return void (t && t(0)); for (let t in e) this[t] = e[t]; if (null != e.position) { let e = { lonOffset: this.lonOffset, latOffset: this.latOffset, altOffset: this.altOffset }; this._position = this.convertLLAToXYZ(this._position, this.offset, e) } const i = this.getFullName(), r = this.getParams(); this.context.updateModelTrail(i, r, t) } remove() { this.context.removeLayer(this.getFullName()) } getParams() { const e = {}; this.snapSurface ? this.snapSurfacePosition = this.context.clampToModel(this._position) : this.snapSurfacePosition = void 0, e.position = { ...this.position }, e.enableAutoHidebyDistance = this.enableAutoHidebyDistance, e.maxDistance = this.maxDistance, e.minDistance = this.minDistance, e.sizeAttenuation = this.sizeAttenuation, e.renderOrder = this.zLevel, e.isShow = this.isShow, e.snapSurface = this.snapSurface, e.scale = this.scale, e.modelMaxDistance = this.modelMaxDistance, e.iconMaxDistance = this.iconMaxDistance, e.duration = this.duration, e.trackStyle = this.trackStyle, e.trackDuration = this.trackDuration, e.trackWidth = this.trackWidth, e.useIconAsset = this.useIconAsset, e.iconAssetName = this.iconAssetName, e.iconPath = this.icon, e.iconWidth = this.width, e.iconHeight = this.height, e.iconXOffset = this.iconXOffset, e.iconYOffset = this.iconYOffset, e.polygonOffset = this.polygonOffset, e.polygonOffsetFactor = this.polygonOffsetFactor, e.polygonOffsetUnits = this.polygonOffsetUnits, e.iconBackground = this.background, e.iconBackgroundColor = this.backgroundColor; let t = this.labelCanvas; return t || (t = this.generateLableCanvas(this.labelFontFamily, this.labelFontSize, this.labelFontBold, this.labelEnableItalic, this.labelBackground, this.labelColor, this.labelText)), e.enableLabel = this.label, e.labelCanvas = t, e.labelXOffset = this.labelXOffset, e.labelYOffset = this.labelYOffset, e.labelAlignment = this.labelAlignment, e.labelColor = this.labelColor, e.labelBackground = this.labelBackground, e.labelText = this.labelText, e.modelType = this.modelType, e.rotation = { x: this.rotation ? this.rotation[0] : 0, y: this.rotation ? this.rotation[1] : 0, z: this.rotation ? this.rotation[2] : 0 }, e } toString() { return JSON.stringify(this) } } class MarkerLandmark$2 extends Drawable { constructor(e, t) { super(e), this.altOffset = e.altOffset || 0, this.enableAutoHidebyDistance = e.enableAutoHidebyDistance || !1, this.height = e.height || "", this.icon = e.icon || "default", this.iconXOffset = e.iconXOffset || 0, this.iconYOffset = e.iconYOffset || 0, this.isShow = 0 != e.isShow && 1 != e.isShow || e.isShow, this.label = e.label || !1, this.labelBackground = e.labelBackground || "#00000055", this.labelCanvas = e.labelCanvas || "", this.labelColor = e.labelColor || "#ffffff", this.labelEnableItalic = e.labelEnableItalic || !1, this.labelFontBold = e.labelFontBold || !1, this.labelFontFamily = e.labelFontFamily || "微软雅黑, Microsoft Yahei, PingFang SC, Helvetica, Noto Sans CJK SC, Source Han Sans SC, SimHei, sans-serif", this.labelFontSize = e.labelFontSize || 5, this.labelText = e.labelText || "", this.labelXOffset = e.labelXOffset || 0, this.labelYOffset = e.labelYOffset || 0, this.latOffset = e.latOffset || 0, this.lonOffset = e.lonOffset || 0, this.labelAlignment = e.labelAlignment || "", this.maxDistance = e.maxDistance || 1e8, this.minDistance = e.minDistance || 0, this.offset = e.offset || !1, this._position = e.position, this.polygonOffset = e.polygonOffset || !1, this.polygonOffsetFactor = e.polygonOffsetFactor || 0, this.polygonOffsetUnits = e.polygonOffsetUnits || 0, this.sizeAttenuation = !(0 == e.sizeAttenuation || !e.sizeAttenuation), this.width = e.width || "", this.background = e.background || "", this.backgroundColor = e.backgroundColor || "#ffffff", this.useIconAsset = e.useIconAsset, this.iconAssetName = e.iconAssetName, this.zLevel = e.zLevel || 1, this.iconIsShow = e.iconIsShow || !0, this.snapSurface = e.snapSurface, this.alpha = e.alpha, this.modelMaxDistance = e.modelMaxDistance, this.iconMaxDistance = e.iconMaxDistance, this.rotation = e.rotation || [0, 0, 0], this.asset = e.asset, this.scale = e.scale, this.add(t) } get position() { return void 0 !== this.snapSurfacePosition ? this.snapSurfacePosition : this._position } set position(e) { this._position = e } add(e) { if (!this.context) return void (e && e(0)); let t = { lonOffset: this.lonOffset, latOffset: this.latOffset, altOffset: this.altOffset }; this._position = this.convertLLAToXYZ(this._position, this.offset, t); const i = this.getFullName(), r = this.getParams(); this.context.addMarkerLandmark(i, r, e) } update(e, t) { if (!this.context) return void (t && t(0)); for (let t in e) this[t] = e[t]; if (null != e.position) { let e = { lonOffset: this.lonOffset, latOffset: this.latOffset, altOffset: this.altOffset }; this._position = this.convertLLAToXYZ(this._position, this.offset, e) } const i = this.getFullName(), r = this.getParams(); this.context.updateMarkerLandmark(i, r, t) } remove() { this.context.removeLayer(this.getFullName()) } getParams() { const e = {}; this.snapSurface ? this.snapSurfacePosition = this.context.clampToModel(this._position) : this.snapSurfacePosition = void 0, e.position = { ...this.position }, e.enableAutoHidebyDistance = this.enableAutoHidebyDistance, e.maxDistance = this.maxDistance, e.minDistance = this.minDistance, e.sizeAttenuation = this.sizeAttenuation, e.renderOrder = this.zLevel, e.isShow = this.isShow, e.snapSurface = this.snapSurface, e.alpha = this.alpha, e.scale = this.scale, e.modelMaxDistance = this.modelMaxDistance, e.iconMaxDistance = this.iconMaxDistance, e.useIconAsset = this.useIconAsset, e.iconAssetName = this.iconAssetName, e.iconPath = this.icon, e.iconWidth = this.width, e.iconHeight = this.height, e.iconXOffset = this.iconXOffset, e.iconYOffset = this.iconYOffset, e.polygonOffset = this.polygonOffset, e.polygonOffsetFactor = this.polygonOffsetFactor, e.polygonOffsetUnits = this.polygonOffsetUnits, e.iconBackground = this.background, e.iconBackgroundColor = this.backgroundColor, e.iconIsShow = this.iconIsShow; let t = this.labelCanvas; return t || (t = this.generateLableCanvas(this.labelFontFamily, this.labelFontSize, this.labelFontBold, this.labelEnableItalic, this.labelBackground, this.labelColor, this.labelText)), e.enableLabel = this.label, e.labelCanvas = t, e.labelXOffset = this.labelXOffset, e.labelYOffset = this.labelYOffset, e.labelAlignment = this.labelAlignment, e.labelColor = this.labelColor, e.labelBackground = this.labelBackground, e.labelText = this.labelText, e.asset = this.asset, e.rotation = { x: this.rotation ? this.rotation[0] : 0, y: this.rotation ? this.rotation[1] : 0, z: this.rotation ? this.rotation[2] : 0 }, e } toString() { return JSON.stringify(this) } } class Marker3D$1 extends Drawable { constructor(e, t) { super(e), this.name = e.name, this.opacity = e.opacity, this.size = e.size, this.position = e.position, this.titleText = e.titleText, this.titleColor = e.titleColor, this.titleBackgroundColor = e.titleBackgroundColor, this.isShow = e.isShow, this.zLevel = e.zLevel, this.path = e.path, this.color = e.color, this.titleHeight = e.titleHeight, this.animations = e.animations, this.isExplosion = !!e.isExplosion, this.url = e.url, this.loop = e.loop, this.autoPlay = e.autoPlay, this.depthTest = e.depthTest, this.destroyOnFinish = e.destroyOnFinish, this.duration = e.duration, this.dimension = e.dimension, this.center = e.center, this.fadeOutFrame = e.fadeOutFrame, this.rotation = e.rotation, this.add(t) } add(e) { if (this.context) if (this.position = this.convertLLAToXYZ(this.position), !0 === this.isExplosion) { const t = this.getExplosionParameters(); this.context.addAnimatedSprite(t, e) } else { const t = this.getParameters(); this.context.add3DMarker(t, e) } else e && e(0) } update(e, t) { if (!this.context) return void (t && t(0)); const i = this.isExplosion; for (let t in e) this[t] = e[t]; if (void 0 !== e.position && (this.position = this.convertLLAToXYZ(this.position)), i && this.isExplosion || !i && this.isExplosion) { this.remove(); const e = this.getExplosionParameters(); this.context.addAnimatedSprite(e, t) } else if (i && !this.isExplosion) { this.remove(); const e = this.getParameters(); this.context.add3DMarker(e, t) } else if (!i && !this.isExplosion) { const e = this.getParameters(); this.context.update3DMarker(e.name, e, t) } } remove() { this.context && this.context.removeLayer(this.getFullName()) } getParameters() { let e; return this.titleText && (e = this.generateLableCanvas("微软雅黑", 5, !1, !1, this.titleBackgroundColor, this.titleColor, this.titleText)), { name: this.getFullName(), opacity: this.opacity, size: this.size, titleText: this.titleText, titleColor: this.titleColor, titleBackgroundColor: this.titleBackgroundColor, path: this.path, color: this.color, titleHeight: this.titleHeight, animations: this.animations, pos: this.position, position: [this.position.x, this.position.y, this.position.z], canvas: e, isShow: this.isShow, zLevel: this.zLevel } } getExplosionParameters() { let e; return this.titleText && (e = this.generateLableCanvas("微软雅黑", 5, !1, !1, this.titleBackgroundColor, this.titleColor, this.titleText)), { name: this.getFullName(), url: this.context.resourceBasePath + this.url, position: this.position, scale: this.size, duration: this.duration, depthTest: this.depthTest, loop: this.loop, autoPlay: this.autoPlay, destroyOnFinish: this.destroyOnFinish, dimension: this.dimension, center: this.center, fadeOutFrame: this.fadeOutFrame, rotation: this.rotation, titleHeight: this.titleHeight, canvas: e, isShow: this.isShow, zLevel: this.zLevel } } toString() { return JSON.stringify(this) } } var _layers$2 = [], _layerZLevel = 1, _modelTips = {}, _overlayTips = {}, _models = Symbol("models"), _core = Symbol("core"), _camera$2 = Symbol("camera"), _showStats = Symbol("showStats"), _isPerfTesting = !1, _sceneApiUrl = "", _sceneConfigPath = "", _sceneName = "", _defaultModelConfigPath = "", _defaultModelPath = "", _eventHandler = { lodchange: { default: [] }, cameramove: { default: [] }, camerazoom: { default: [] }, click: { default: [], byType: { sprite: [], billboard: [], landmark: [], bubble: [], bar: [], odLine: [], trail: [], area: [], drawable: [], model: [], building: [], scene: [] }, dblclick: { default: void 0, byType: { marker: void 0, building: void 0, scene: void 0 } }, mousedown: { default: void 0, byType: { marker: void 0, building: void 0, scene: void 0 } }, mousehover: { default: void 0, byType: { marker: void 0, building: void 0, scene: void 0 } }, mouseup: { default: void 0, byType: { marker: void 0, building: void 0, scene: void 0 } } }, mousehover: { default: [], byType: { sprite: [], billboard: [], landmark: [], bubble: [], bar: [], odLine: [], trail: [], area: [], drawable: [], model: [], building: [], scene: [] }, dblclick: { default: void 0, byType: { marker: void 0, building: void 0, scene: void 0 } }, mousedown: { default: void 0, byType: { marker: void 0, building: void 0, scene: void 0 } }, mousehover: { default: void 0, byType: { marker: void 0, building: void 0, scene: void 0 } }, mouseup: { default: void 0, byType: { marker: void 0, building: void 0, scene: void 0 } } }, unmousehover: { default: [], byType: { sprite: [], billboard: [], landmark: [], bubble: [], bar: [], odLine: [], trail: [], area: [], drawable: [], model: [], building: [], scene: [] }, dblclick: { default: void 0, byType: { marker: void 0, building: void 0, scene: void 0 } }, mousedown: { default: void 0, byType: { marker: void 0, building: void 0, scene: void 0 } }, mousehover: { default: void 0, byType: { marker: void 0, building: void 0, scene: void 0 } }, mouseup: { default: void 0, byType: { marker: void 0, building: void 0, scene: void 0 } } }, trailmove: { default: [] } }, _watermarks = {}; const _SYS_MODEL_TIP = "_sys_model_tip_", _SYS_OVERLAY_TIP = "_sys_overlay_tip_", _DISTANCE_MAX = Number.MAX_SAFE_INTEGER, _DISTANCE_MIN = 0, _SYS_LAYER_INFO_PANEL = "_sys_layer_info_panel_", _SYS_LAYER_HEAT_MAP = "_sys_layer_heat_map_", _SYS_LAYER_SOLID_BILLBOARD = "_sys_layer_solid_billboard_", _SYS_POPUP = "_sys_popup_", _EVENTS = { LOD_CHANGE: "lodchange", MOUSE_DOWN: "mousedown", MOUSE_UP: "mouseup", MOUSE_HOVER: "mousehover", UNMOUSE_HOVER: "unmousehover", CLICK: "click", DOUBLE_CLICK: "dblclick", CAMERA_MOVE: "cameramove", CAMERA_ZOOM: "camerazoom", TRAIL_MOVE: "trailmove" }, _SCENE_CONFIG_FILE_NAME = "SceneConfig.json", _ACCESS_TOKEN_LENGTH_MIN = 20; class Scene$1 { constructor(e, t) { this.additionalInfo = e.additionalInfo || {}, this.author = e.author || "", this.name = e.name || "", this.options = {}, this.type = e.type || "", this.url = e.url || "", logger.debug("附加信息"), logger.debug(this.additionalInfo), _layers$2 = [], _models = [], _core = {}, _showStats = !1; var i = this; window.addEventListener("resize", (function () { i.options && i.options.container && _core.changeSize(i.options.container.offsetWidth, i.options.container.offsetHeight) }), !1), t && t(1) } get domElement() { return _core.domElement() } pickScreenToWorld(e, t) { let i = _core.pickScreenToWorld(e); i = _core.convertWorldToSceneLocal(i); const r = _core.convertXYZToLLA({ x: i.x, y: i.y, z: i.z }), n = { result: 1, message: "成功。", data: [{ coordType: 0, coord: [r.x, r.y], coordZ: r.z }, { coordType: 1, coord: [i.x, i.z], coordZ: i.y }] }; return t && t(n), i } setMark(e) { _core.setMark(e) } setModelMaterial(e, t) { _core.setModelMaterial(e, t) } highlightModel(e, t = !0) { return _core.highlightModel(e, t) } cancleHighlightModel(e) { return _core.cancleHighlightModel(e) } enableTransformOnModel(e, t, i, r, n) { t && "transform" !== t || (t = "translate"), "rotation" === t && (t = "rotate"), _core.defaultModelSelection.selectObjectByUUID(e, !0), _core.defaultModelSelection.enableTransformControl(), void 0 !== r && ("translate" === t && _core.transformControls.setTranslationSnap(r), "scale" === t && _core.transformControls.setScaleSnap(r), "rotate" === t && (r = r / 180 * Math.PI, _core.transformControls.setRotationSnap(r))), _core.transformControls.setMode(t), void 0 !== n && ("all" === n ? (_core.transformControls.showX = !0, _core.transformControls.showY = !0, _core.transformControls.showZ = !0) : (_core.transformControls.showX = -1 !== n.indexOf("x"), _core.transformControls.showY = -1 !== n.indexOf("y"), _core.transformControls.showZ = -1 !== n.indexOf("z"))), "rotate" === t && _core.defaultModelSelection.setAxisType(i) } disableTransformOnModel() { _core.defaultModelSelection.disableTransformControl(), _core.defaultModelSelection.selectObjectByUUID([]) } addTerrain(e, t) { let i; e.terrainUrl && (i = { urlFormat: `${e.terrainUrl}`, attribution: e.terrainType, apiKey: e.terrainToken || "KEY", pixelEncoding: e.pixelEncoding }); const r = { urlFormat: `${e.maps[0].mapUrl}`, apiKey: e.maps[0].mapTokenValue || "KEY", maxZoom: e.maps[0].mapLOD || 2, flipY: !!e.flipY }; void 0 !== e.maps[1] && (r.urlFormat = [`${e.maps[0].mapUrl}`, `${e.maps[1].mapUrl}`]), _core.initTerrain({ id: e.id, place: e.place, imagery: r, elevation: i, alpha: e.alpha }, t) } updateTerrainStyle(e, t) { _core.updateTerrain(e, t) } removeTerrain(e) { _core.destroyTerrain(), e && e({ result: 1, message: "成功。" }) } setCameraFollowingState(e, t) { _core.cameraFollowingStState(e, t) } setCameraFollowingByModel({ modelName: e, distance: t, pitch: i, heading: r }) { _core.cameraFollowing({ type: "model", name: e, distance: t, pitch: i, heading: r }) } setCameraFollowingByDrawable({ layerName: e, drawableName: t, distance: i, pitch: r, heading: n }) { const a = this.getLayer(e); if (!a) return; const o = a.getDrawable(t); o && _core.cameraFollowing({ type: "drawable", name: o.getFullName(), distance: i, pitch: r, heading: n }) } selectDrawable(e, t) { const i = this.getLayer(e); if (void 0 === i) return; const r = i.getDrawable(t); if (void 0 === r) return; const n = r.type.toLowerCase(); if ("landmark" === n || "trail" === n) _core.selectBillboard(r.getFullName(), { path: "texture/ui/highlight-landmark.png" }); else if ("modellandmark" === n) _core.setModelLandmarkHighlight(r.getFullName(), !0); else if ("modeltrail" === n) _core.setModelTrailHighlight(r.getFullName(), !0); else if ("bar" === n) { r.label = !!r.labelText, !0 === r.label && r.updateBar(); const e = _core.objectStore.find(r.getFullName()); e && _core.defaultEffectStore.highlightObject(e.children[0], !0) } else { const e = _core.objectStore.find(r.getFullName()); e && _core.defaultEffectStore.highlightObject(e.children[0], !0) } } deselectDrawable(e, t) { const i = this.getLayer(e); if (void 0 === i) return; const r = i.getDrawable(t); if (void 0 === r) return; const n = r.type.toLowerCase(); if ("landmark" === n || "trail" === n) _core.deselectBillboard(r.getFullName()); else if ("modellandmark" === n) _core.setModelLandmarkHighlight(r.getFullName(), !1); else if ("modeltrail" === n) _core.setModelTrailHighlight(r.getFullName(), !1); else if ("bar" === n) { !0 == !!r.label && (r.label = !1, r.updateBar()); const e = _core.objectStore.find(r.getFullName()); e && _core.defaultEffectStore.cancleHighlightObject(e.children[0]) } else { const e = _core.objectStore.find(r.getFullName()); e && _core.defaultEffectStore.cancleHighlightObject(e.children[0]) } } selectInstancedBubble(e, t, i) { const r = this.getLayer(e); if (!r) return !1; const n = r.getDrawable(t); if (!n) return !1; if (!(n instanceof InstancedBubble)) return !1; const a = n.points.find((e => e.name === i)); if (!a) return !1; this.addBubble(e, { name: a.name + "/bubbleSelector", position: a.position, value: a.value, bubbleColor: a.color, animationSpeed: a.diffSpeed, isShow: a.isShow }, (e => { a.selector = e, _core.defaultEffectStore.highlightObject(e.children[0], !0), 1 == a.isShow && (a.isShow = !1, n.updateInstancedBubble()) })) } deselectInstancedBubble(e, t, i) { const r = this.getLayer(e); if (!r) return !1; const n = r.getDrawable(t); if (!n) return !1; if (!(n instanceof InstancedBubble)) return !1; const a = n.points.find((e => e.name === i)); if (!a) return !1; void 0 !== a.selector && (_core.defaultEffectStore.cancleHighlightObject(a.selector.children[0]), this.removeBubble(e, i + "/bubbleSelector"), !!a.isShow != !!a.selector.visible && (a.isShow = !!a.selector.visible, n.updateInstancedBubble())) } addModelTrail(e, t, i) { return new Promise((r => { if (!t) return i && i(0), void r(); t.type = "modeltrail", this.addDrawable(e, t, (e => { i && i(e), r(e) })) })) } updateModelTrail(e, t, i, r) { const n = this; return new Promise((function (a) { const o = n.getDrawable(e, t); o ? o.update(i, (function () { const i = e + "_" + t; void 0 !== _overlayTips[i] && n.tipFollowingMaster(), r && r(...arguments), a() })) : r && r(0) })) } addModelLandmark(e, t, i) { return new Promise((r => { if (!t) return i && i(0), void r(); t.type = "modellandmark", this.addDrawable(e, t, (e => { i && i(e), r(e) })) })) } updateModelLandmark(e, t, i, r) { const n = this; return new Promise((function (a) { const o = n.getDrawable(e, t); o ? o.update(i, (function () { const i = e + "_" + t; void 0 !== _overlayTips[i] && n.tipFollowingMaster(), r && r(...arguments), a() })) : r && r(0) })) } removeModelLandmark(e, t) { const i = this.getLayer(e); i || logger.warn("未找到图层名为：" + e + "，绘制物名称为：" + landmarkName + "的绘制物。"); const r = i.getDrawable(t); r || logger.warn("未找到图层名为：" + e + "，绘制物名称为：" + landmarkName + "的绘制物。"), this.spliceDrawable(e, t), r.remove() } addMarkerLandmark(e, t, i) { return new Promise((r => { if (!t) return i && i(0), void r(); t.type = "markerlandmark", this.addDrawable(e, t, (e => { i && i(e), r(e) })) })) } updateMarkerLandmark(e, t, i, r) { const n = this; return new Promise((function (a) { const o = n.getDrawable(e, t); o ? o.update(i, (function () { const i = e + "_" + t; void 0 !== _overlayTips[i] && n.tipFollowingMaster(), r && r(...arguments), a() })) : r && r(0) })) } setMarkerLandmarkBillboardVisible(e, t, i) { const r = this.getDrawable(e, t); r && r.setBillboardVisible(i) } removeMarkerLandmark(e, t) { const i = this.getLayer(e); i || logger.warn("未找到图层名为：" + e + "，绘制物名称为：" + landmarkName + "的绘制物。"); const r = i.getDrawable(t); r || logger.warn("未找到图层名为：" + e + "，绘制物名称为：" + landmarkName + "的绘制物。"), this.spliceDrawable(e, t), r.remove() } addExplosion({ url: e, position: t, scale: i, duration: r, depthTest: n, loop: a, autoPlay: o, destroyOnFinish: s, dimension: l, center: c, fadeOutFrame: h, rotation: u, callback: d }) { "lla" === t.type && (t = _core.convertLLAToXYZ({ x: t.lon, y: t.lat, z: t.alt })), _core.addAnimatedSprite({ name: "explosion_" + util.randomString(8), url: this.additionalInfo.resourceBasePath + e, position: { x: t.x, y: t.y, z: t.z }, scale: { x: i, y: i, z: i }, duration: r, depthTest: n, loop: a, autoPlay: o, destroyOnFinish: s, dimension: l, center: c, fadeOutFrame: h, rotation: u }, d) } transformDrawable(e, t, i, r, n) { const a = this.getLayer(e); if (!a) return void (n && n({ result: 0, message: "失败，没有对应绘制物。" })); const o = a.getDrawable(t); if (!o) return void (n && n({ result: 0, message: "失败，没有对应绘制物。" })); const s = o.getFullName(); return _core.transformObject(s, i, n), void 0 !== r && ("all" === r ? (_core.transformControls.showX = !0, _core.transformControls.showY = !0, _core.transformControls.showZ = !0) : (_core.transformControls.showX = -1 !== r.indexOf("x"), _core.transformControls.showY = -1 !== r.indexOf("y"), _core.transformControls.showZ = -1 !== r.indexOf("z"))), !0 } untransformDrawable(e) { _core && _core.untransformObject(), e && e({ result: 1, message: "成功。" }) } addEventListener() { _core.addEventListener(...arguments) } removeEventListener() { _core.removeEventListener(...arguments) } setCompass(e, t) { return new Promise((i => { let r = {}; r.hor = e.dockHorizontal, r.ver = e.dockVertical, r.offset = e.offset, r.size = e.size, r.isShow = e.visible, _core.setCompass(r), t && t(1, "完成。"), i(1, "完成。") })) } addWatermark(e, t, i) { return new Promise((r => { if (_watermarks[e]) return i && i(0, `已存在 ${e} 水印。`), void r({ result: 0, message: `已存在 ${e} 水印。` }); const n = JSON.parse(JSON.stringify(_watermarks)); n[e] = t; let a = []; for (const e in n) { const t = n[e]; a.push({ src: t.url, hor: t.dockHorizontal, ver: t.dockVertical, offset: t.offset, scale: t.scale, alpha: t.alpha }) } _core.setWatermark(a, ((n, a) => { 1 === n && (_watermarks[e] = t), i && i(n, a), r({ result: n, message: a }) })) })) } removeWatermark(e, t) { return new Promise((i => { if (!_watermarks[e]) return t && t(0, `不存在 ${e} 水印。`), void i({ result: 0, message: `不存在 ${e} 水印。` }); delete _watermarks[e]; let r = []; for (const e in _watermarks) { if (void 0 === e) continue; const t = _watermarks[e]; r.push({ src: t.url, hor: t.dockHorizontal || "left", ver: t.dockVertical || "top", offset: t.offset || [0, 0], scale: t.scale || 1, alpha: t.alpha || 1 }) } _core.setWatermark(r, ((e, r) => { t && t(e, r), i({ result: e, message: r }) })) })) } takeSnapshot(e, t, i = .92) { return void 0 === e && (e = this.options.container.offsetWidth), void 0 === t && (t = this.options.container.offsetHeight), _core.takeSnapshot({ targetWidth: e, targetHeight: t, targetEncoder: i }) } endSelectOverlay() { _core.endSelectDrawable(...arguments) } selectOverlay(e, t) { _core.selectDrawable(e, (e => { if (!t) return; let i = []; for (const t of e) { let e = t.name.split("/"), r = this.getLayer(e[0]); if (!r) continue; let n = r.getDrawable(e[1]); if (t.isInstancedMesh) { if ("instancedbubble" === n.type) { const r = n.points[t.index]; r && i.push({ parent: e[0], name: r.name }) } } else { !i.find((e => e == n)) && i.push(n) } } t(i) })) } getModelBox(e) { return _core.getModelBox(e) } restrictCamera(e, t) { e ? ((e = JSON.parse(JSON.stringify(e))).limitHeight = e.limitCoordZ, e.center = [e.center.x, e.center.z]) : e = {}, _core.restrictCamera(e, t) } setCameraRestrictionState(e, t) { _core.setCameraRestrictionState(e, t) } setResolution({ width: e, height: t, fpsMax: i }) { _core.setResolution(e, t), "number" == typeof i && _core.setFPSLimit(i) } getSceneName() { return _core.getSceneName() } isContentAssets() { return _core.isContentAssets(...arguments) } getIconAssetInfo(e) { return _core.defaultObjectTree.children.find((t => "IconAsset" == t.type && t.name == e)) } interruptCameraFly() { _core.interruptCameraFly() } getCameraDetailed() { return _core.getCamera() } drawableIsSelected(e, t) { let i = this.getLayer(e); if (!i) return !1; let r = i.getDrawable(t); return !!r && _core.drawableIsSelected(r.type, r.getFullName()) } setCameraToModel() { _core.setCameraToModel(...arguments) } getAngleByPositions(e, t) { if ("lla" === e.type.toLowerCase()) { let t = this.convertLLAToXYZ(e); e.x = t.x, e.y = t.y, e.z = t.z } if ("lla" === t.type.toLowerCase()) { let e = this.convertLLAToXYZ(t); t.x = e.x, t.y = e.y, t.z = e.z } return _core.getAngleByPositions(e, t) } getDistanceByPositions(e, t) { if (e.type && "lla" === e.type.toLowerCase()) { let t = this.convertLLAToXYZ(e); e.x = t.x, e.y = t.y, e.z = t.z } if (t.type && "lla" === t.type.toLowerCase()) { let e = this.convertLLAToXYZ(t); t.x = e.x, t.y = e.y, t.z = e.z } return _core.getDistanceByPositions(e, t) / _core.getWorldScale() } setWeather({ name: e, size: t, density: i, type: r, direction: n = 0, offset: a = { x: 0, y: 0, z: 0 }, followCamera: o }, s) { let l = { name: e, size: t, density: i, direction: n, offset: a, followCamera: o }; if ("snow" == r) _core.removeSnow(e), _core.addSnow(l); else { if ("rain" != r) return void (s && s({ result: 0, message: `失败，天气 ${e} 暂未实现。` })); _core.removeRain(e), _core.addRain(l) } s && s({ result: 1, message: "成功。" }) } async add3DMarker(e, t, i) { return new Promise((r => { if (!t) return i && i(0, "Scene.addLandmark(layerName, markerInfo, callback) 传入参数有误。"), void r(); t.type = "3dmarker", this.addDrawable(e, t, (() => { i && i(this), r() })) })) } update3DMarker(e, t, i, r) { return new Promise((n => { let a = this.getDrawable(e, t); a && null != a ? a.update(i, (() => { void 0 !== _overlayTips[e + "_" + t] && this.tipFollowingMaster(), r && r(), n() })) : (r && r(0, "未找到图层名为：" + e + "，绘制物名称为：" + t + "的绘制物！"), n()) })) } remove3DMarker(e) { e = `_sys_3dmarker_layer_/${e}/3dmarker`, _core.removeLayer(e) } show3DMarker(e) { e = `_sys_3dmarker_layer_/${e}/3dmarker`, _core.showLayer(e) } hide3DMarker(e) { e = `_sys_3dmarker_layer_/${e}/3dmarker`, _core.hideLayer(e) } showFPSPanel(e) { e ? _core.fpsPanelOn() : _core.fpsPanelOff() } getStatistics() { return _core.getStatistics() } addModelTip(e, t) { let i = _core.defaultObjectTree.getItemByName(e.id); if (!i) return void t({ result: 0, message: `失败，模型 ${e.id} 不存在。` }); let r = i.getGroup().position, n = _core.convertWorldToScreen(r), a = `${_SYS_MODEL_TIP}_${e.id}`; if (document.getElementById(a)) return void t({ result: 0, message: `失败，模型 ${e.id} 的提示框已存在。` }); let o = document.createElement("div"); o.style = `\n      position: absolute;\n      left: ${n.x + e.offset[0]}px; \n      top: ${n.y - e.size[1] - e.offset[1]}px; \n    `; const s = document.createElement("div"); s.style = `\n      position: absolute;\n      width: ${e.size[0]}px; \n      height: ${e.size[1]}px; \n      overflow: hidden;\n    `, o.appendChild(s); let l = null; e.isShowClose && (l = document.createElement("div"), o.appendChild(l), l.style = `\n        height: 18px;\n        width: 18px;\n        position: absolute;\n        top: 2px;\n        left: ${e.size[0] + 2}px;\n        cursor: pointer;\n        background-image: url('${this.additionalInfo.resourceBasePath}/texture/ui/close.png');\n      `, l.onmouseenter = () => { l.style.backgroundImage = `url('${this.additionalInfo.resourceBasePath}/texture/ui/close-hover.png')` }, l.onmouseleave = () => { l.style.backgroundImage = `url('${this.additionalInfo.resourceBasePath}/texture/ui/close.png')` }); let c = e.layer + "_" + e.id; if (e.divId) { let t = document.getElementById(e.divId); s.appendChild(t); let i = o.querySelector("[data-close]"); i && i.addEventListener("click", (e => { this.options.container.removeChild(o), delete _overlayTips[c] })) } else { let t = document.createElement("iframe"); t.setAttribute("src", e.url), t.setAttribute("id", a), t.setAttribute("frameborder", 0), s.appendChild(t), t.onload = () => { if (t.style = `\n          width: ${e.size[0]}px;\n          height: ${e.size[1]}px;\n        `, t.contentDocument) { let i = t.contentDocument.querySelector("[data-close]"); i && i.addEventListener("click", (t => { this.options.container.removeChild(o), delete _modelTips[e.id] })) } } } e.isShowClose && l.addEventListener("click", (() => { this.options.container.removeChild(o), delete _modelTips[e.id] })), this.options.container.appendChild(o), _modelTips[e.id] = e, _modelTips[e.id].dom = o, _modelTips[e.id].container = s, _modelTips[e.id].model = i, this.tipFollowingMaster(), t({ result: 1, message: "成功。" }) } removeModelTip(e, t) { _modelTips[e.id] ? (this.options.container.removeChild(_modelTips[e.id].dom), delete _modelTips[e.id], t && t({ result: 1, message: "成功。" })) : t && t({ result: 0, message: `失败，没有找到 ${e.id} 的标牌。` }) } addModelForApi(e, t) { if (e.position && "lla" === e.position.type.toLowerCase()) { let t = this.convertLLAToXYZ(e.position); e.position.x = t.x, e.position.y = t.y, e.position.z = t.z } e.titleText && (e.titleColor = e.titleColor || "#ffffff", e.titleBackgroundColor = e.titleBackgroundColor || "#333333", e.titleFontSize = e.titleFontSize || 5, e.canvas = this._generateLableCanvas("微软雅黑", e.titleFontSize, !1, !1, e.titleBackgroundColor, e.titleColor, e.titleText)), _core.addModelForApi(e, t) } removeModelForApi(e, t) { _core.removeModelForApi(e, t) } addOverlayTip(e, t) { let i = this.getLayer(e.layer); if (!i) return void (t && t(0, `绘制物 ${e.id} 不存在。`)); let r = i.getDrawablePosition(e.id); if (!r) return void (t && t(0, `绘制物 ${e.id} 不存在。`)); if (!r.position) return void (t && t(0, `绘制物 ${e.id} 没有中心点。`)); let n = `${_SYS_OVERLAY_TIP}_${e.layer}_${e.id}`; if (document.getElementById(n)) return void (t && t(0, `绘制物 ${e.id} 的提示框已存在。`)); if ("lla" == r.position.type) { let e = _core.convertLLAToXYZ({ x: r.position.lon, y: r.position.lat, z: r.position.alt }); r.position.x = e.x, r.position.y = e.y, r.position.z = e.z } let a = _core.convertWorldToScreen(r.position), o = document.createElement("div"); o.style = `\n      position: absolute;\n      left: ${a.x + e.offset[0]}px; \n      top: ${a.y - e.size[1] - e.offset[1]}px; \n    `; const s = document.createElement("div"); s.style = `\n      position: absolute;\n      width: ${e.size[0]}px; \n      height: ${e.size[1]}px; \n      overflow: hidden;\n    `, o.appendChild(s); let l = null; e.isShowClose && (l = document.createElement("div"), o.appendChild(l), l.style = `\n        height: 18px;\n        width: 18px;\n        position: absolute;\n        top: 2px;\n        left: ${e.size[0] + 2}px;\n        cursor: pointer;\n        background-image: url('${this.additionalInfo.resourceBasePath}/texture/ui/close.png');\n      `, l.onmouseenter = () => { l.style.backgroundImage = `url('${this.additionalInfo.resourceBasePath}/texture/ui/close-hover.png')` }, l.onmouseleave = () => { l.style.backgroundImage = `url('${this.additionalInfo.resourceBasePath}/texture/ui/close.png')` }); let c = e.layer + "_" + e.id; if (e.divId) { let t = document.getElementById(e.divId); s.appendChild(t); let i = o.querySelector("[data-close]"); i && i.addEventListener("click", (e => { this.options.container.removeChild(o), delete _overlayTips[c] })) } else { let t = document.createElement("iframe"); t.setAttribute("src", e.url), t.setAttribute("id", n), t.setAttribute("frameborder", 0), s.appendChild(t), t.onload = () => { if (t.style = `\n          width: ${e.size[0]}px;\n          height: ${e.size[1]}px;\n        `, t.contentDocument) { let i = t.contentDocument.querySelector("[data-close]"); i && i.addEventListener("click", (t => { this.options.container.removeChild(o), delete _modelTips[e.id] })) } } } e.isShowClose && l.addEventListener("click", (() => { this.options.container.removeChild(o), delete _overlayTips[c] })), this.options.container.appendChild(o), _overlayTips[c] = e, _overlayTips[c].dom = o, _overlayTips[c].container = s, _overlayTips[c].drawable = r, this.tipFollowingMaster(), t && t(1, "已添加标牌。") } tipFollowingMaster() { for (let e in _overlayTips) { let t = _overlayTips[e]; if ("lla" == t.drawable.position.type) { let e = _core.convertLLAToXYZ({ x: t.drawable.position.lon, y: t.drawable.position.lat, z: t.drawable.position.alt }); t.drawable.position.x = e.x, t.drawable.position.y = e.y, t.drawable.position.z = e.z } let i = _core.convertWorldToScreen(t.drawable.position); t.dom.style.left = `${i.x + t.offset[0]}px`, t.dom.style.top = i.y - t.size[1] - t.offset[1] + "px" } for (let e in _modelTips) { let t = _modelTips[e], i = t.model.getGroup().position, r = _core.convertWorldToScreen(i); t.dom.style.left = `${r.x + t.offset[0]}px`, t.dom.style.top = r.y - t.size[1] - t.offset[1] + "px" } } removeOverlayTip(e, t) { let i = e.layer + "_" + e.id; _overlayTips[i] ? (this.options.container.removeChild(_overlayTips[i].dom), delete _overlayTips[i], t && t({ result: 1, message: "成功。" })) : t && t({ result: 0, message: `失败，没有找到 ${e.id} 的标牌。` }) } addPath(e, t, i) { if (null != t || null != t.points) return t.type = "path", this.addDrawable(e, t, i); i && i(0, "绘制路径失败") } addArea(e, t, i) { return new Promise((r => { if (null == t && null == t.points && t.points.length < 3) return i && i(0, "绘制区域图失败"), void r(); t.type = "area", this.addDrawable(e, t, (function () { i && i(1), r() })) })) } addBar(e, t, i) { if (t) return t.type = "bar", this.addDrawable(e, t, i); i && i(0, "Scene.addBar(layerName, barInfo, callback) 传入参数有误。") } addBubble(e, t, i) { return new Promise((r => { if (!t) return i && i(0, "Scene.addBubble(layerName, bubbleInfo, callback) 传入参数有误。"), void r(); t.type = "bubble", this.addDrawable(e, t, (function () { i && i(...arguments), r() })) })) } addInstancedBubble(e, t, i) { if (t) return new Promise((r => { t.name = e, t.type = "instancedbubble", this.addDrawable(e, t, (function () { i && i(...arguments), r() })) })); i && i(0, "Scene.addInstancedBubble(layerName, bubbleInfo, callback) 传入参数有误。") } addDrawable(e, t, i) { e && "string" == typeof e && "" !== e || (e = util.randomString(4)); let r, n = this.getLayer(e); if (n || (this.addLayer({ name: e, type: "instancedbubble" == t.type ? "instanced" : "", zLevel: t.zLevel }), n = this.getLayer(e)), n.getDrawable(t.name)) i ? i(0, "Scene.addDrawable(layerName, drawableInfo, callback) 已存在指定图层和名称的绘制物。") : logger.warn("Scene.addDrawable(layerName, drawableInfo, callback) 已存在指定图层和名称的绘制物。"); else { switch (t.instance = this.toString(), t.context = _core, t.parent = e, t.zLevel = n.zLevel, t.type.toLowerCase()) { case "area": r = new Area$1(t, i); break; case "bar": r = new Bar(t); break; case "bubble": r = new Bubble(t, i); break; case "instancedbubble": r = new InstancedBubble(t, i); break; case "flashmarker": r = new FlashMarker(t, e); break; case "heatmap": r = new HeatMap(t); break; case "infopanel": r = new InfoPanel(t, this.options, _SYS_LAYER_INFO_PANEL, _EVENTS, _layers$2); break; case "landmark": r = new Landmark$1(t, i); break; case "marker": r = new Marker(t, e); break; case "odline": r = new ODLine(t, i); break; case "path": r = new Path$1$1(t, i); break; case "solidbillboard": r = new SolidBillboard(t); break; case "trail": r = new Trail$2(t, i); break; case "modellandmark": r = new ModelLandmark$2(t, i); break; case "modeltrail": r = new ModelTrail$2(t, i); break; case "markerlandmark": r = new MarkerLandmark$2(t, i); break; case "3dmarker": r = new Marker3D$1(t, i) }if (r) return this.getLayer(e).addDrawable(r, (function () { })), this; i && i(0, "Scene.addDrawable(layerName, drawableInfo, callback) 传入参数有误。") } } addFirefly(e) { if (e.position && "lla" === e.position.type.toLowerCase()) { let t = _core.convertLLAToXYZ({ x: e.position.lon, y: e.position.lat, z: e.position.alt }); e.position.x = t.x, e.position.y = t.y, e.position.z = t.z } _core.addFireFly(e) } addFireworks(e) { if (e.position && "lla" === e.position.type.toLowerCase()) { let t = _core.convertLLAToXYZ({ x: e.position.lon, y: e.position.lat, z: e.position.alt }); e.position.x = t.x, e.position.y = t.y, e.position.z = t.z } _core.addFireworks(e) } addHeatMap(e, t, i) { if (e && "" !== e || (e = _SYS_LAYER_HEAT_MAP), t) { if (t.type = "heatmap", t.points && t.points instanceof Array) return this.addDrawable(e, t, i); i ? i(0, "Scene.addHeatMap(heatMapInfo, callback) 传入参数有误。") : logger.warn("Scene.addHeatMap(heatMapInfo, callback) 传入参数有误。") } else i ? i(0, "Scene.addHeatMap(heatMapInfo, callback) 传入参数有误。") : logger.warn("Scene.addHeatMap(heatMapInfo, callback) 传入参数有误。") } addInfoPanel(e, t) { if (e) return e.exclusive && this.getLayer(_SYS_LAYER_INFO_PANEL) && this.getLayer(_SYS_LAYER_INFO_PANEL).clearDrawables(), e.type = "infopanel", this.addDrawable(_SYS_LAYER_INFO_PANEL, e, t); t && t(0, "Scene.addInfoPanel(infoPanelInfo, callback) 传入参数有误。") } async addLandmark(e, t, i) { return new Promise((r => { if (!t) return i && i(0, "Scene.addLandmark(layerName, landmarkInfo, callback) 传入参数有误。"), void r(); t.type = "landmark", this.addDrawable(e, t, (() => { i && i(this), r() })) })) } addLayer(e, t) { return e.name && "" !== e.name || (e.name = util.randomString(8)), this.getLayer(e.name) ? (t(0, `已存在同名图层（${e.name}) 。`), this) : (e.zLevel || (e.zLevel = _layerZLevel++), _layers$2.push(new Layer$1(e, t)), this) } addODLine(e, t, i) { return new Promise((r => { if (!t) return i && i(0, "Scene.addODLine(layerName, odLineInfo, callback) 传入参数有误。"), void r(); t.type = "odline", this.addDrawable(e, t, (function () { i && i(...arguments), r() })) })) } addPopup(e, t) { if (e) return e.name = _SYS_POPUP, e.exclusive = !0, e.exclusive && this.getLayer(_SYS_LAYER_INFO_PANEL) && this.getLayer(_SYS_LAYER_INFO_PANEL).clearDrawables(), this.addDrawable(_SYS_LAYER_INFO_PANEL, e, t); t && t(0, "Scene.addPopup(popupInfo, callback) 传入参数有误。") } addRain(e) { _core.addRain(e) } addRainline(e) { if (e.position && "lla" === e.position.type.toLowerCase()) { let t = _core.convertLLAToXYZ({ x: e.position.lon, y: e.position.lat, z: e.position.alt }); e.position.x = t.x, e.position.y = t.y, e.position.z = t.z } _core.addRainline(e) } addSnow(e) { _core.addSnow(e) } addSolidBillboard(e, t) { if (e) return e.type = "solidbillboard", this.addDrawable(_SYS_LAYER_SOLID_BILLBOARD, e, t); t && t(0, "addSolidBillboard(info, callback) 传入参数有误。") } async addTrail(e, t, i) { if (t) return t.type = "trail", new Promise(((i, r) => this.addDrawable(e, t, (e => { e ? i(e) : r() })))); i && i(0, "Scene.addTrail(layerName, trailInfo, callback) 传入参数有误。") } buildingReset(e) { if (e && "" !== e.toString() || (e = ""), !this.options.buildingIndex || !this.options.buildingIndex.length || this.options.buildingIndex.length <= 0) return logger.warn("未加载有效的建筑物信息，无法切换到室内视图，请联系场景提供者。"), this; if ("" === e) for (let e of this.options.buildingIndex) this.buildingReset(e.id); else { let t; for (let i of this.options.buildingIndex) if (i.id === e.toString()) { t = i; break } if (!t) return logger.warn(`未找到指定的楼宇：${e}。`), this; if (!t.floors || !t.floors.length || t.floors.length <= 0) return logger.warn(`楼宇 ${e} 未加载有效的楼层信息，无法切换到室内视图，请联系场景提供者。`), this; for (let e of t.floors) this.resetNode("main", e.nodeName) } return this } buildingSlideOut(e) { let t, i = "main"; if (!e) return logger.warn(`Scene.buildingSlideOut() params - ${e || void 0}`), this; if (!e.buildingId || "" === e.buildingId.toString()) return logger.warn(`Scene.buildingSlideOut() 传入参数无效：params.buildingId - ${e.buildingId || void 0}`), this; if (!e.floorIds || !e.floorIds.length || e.floorIds.length <= 0 || e.floorIds.length > 999) return logger.warn(`Scene.buildingSlideOut() 传入参数无效：params.floorIds - ${e.floorIds || void 0}`), this; if (!this.options.buildingIndex || !this.options.buildingIndex.length || this.options.buildingIndex.length <= 0) return logger.warn("Scene.buildingSlideOut() 未加载有效的楼宇信息，无法高亮显示楼层，请联系场景提供者。"), this; for (let i of this.options.buildingIndex) if (i.id === e.buildingId.toString()) { t = i; break } if (!t) return logger.warn(`Scene.buildingSlideOut() 未找到指定的楼宇：${e.buildingId}。`), this; if (!t.floors || !t.floors.length || t.floors.length <= 0) return logger.warn("Scene.buildingSlideOut() 未加载有效的楼层信息，无法高亮显示楼层，请联系场景提供者。"), this; this.buildingReset(t.id); let r = e.floorIds; for (let n of t.floors) for (let t = r.length - 1; t >= 0; t--)n.id === r[t] && (this.translateNode(i, { nodeName: n.nodeName, color: e.color || "#0096FF", opacity: e.opacity || .65 }, !0), this.translateNode(i, { nodeName: n.nodeName, offset: e.offset }), r.splice(t, 1)); return r && r.length > 0 ? (logger.warn(`Scene.buildingSlideOut() 未找到指定的楼层：${r}。`), this) : this } camera(e, t, i) { return this.setCamera(e, t, i), this } cameraFlyTo(e, t, i) { if (!e || !e.target || !e.posture || 3 !== e.posture.length || Number(e.distance) < _DISTANCE_MIN || Number(e.distance) > _DISTANCE_MAX) return void logger.warn("摄像机设置参数有误。"); let r; r = "lla" === e.target.type ? _core.convertLLAToXYZ({ x: e.target.lon, y: e.target.lat, z: e.target.alt }) : e.target, _camera$2 = e; let n = 0, a = 0; return n = Number(e.posture[2]), a = Number(e.posture[1]), 90 === a && (a = 89.99999), -90 === a && (a = -89.99999), 0 === e.distance && (e.distance = 1e-5), _core.cameraFlyTo(r, Number(n), Number(a), Number(e.distance), t, !0, i || void 0), this } clearBackgroundImage() { _core.clearBackground() } clearFog() { _core.clearFog() } clearHeatMap(e, t) { if (e && "" !== e || (e = _SYS_LAYER_HEAT_MAP), !this.getLayer(e) || !this.getLayer(e).getDrawables() || this.getLayer(e).getDrawables().length <= 0) t && t(1, "无热力图需要清除。"); else for (let t = this.getLayer(e).getDrawables().length - 1; t >= 0; t--) { let i = this.getLayer(e).getDrawables()[t]; this.getLayer(e).removeDrawable(i.name, (function (e, t) { 1 === e && i.removeHeatmap() })) } } clearInfoPanels(e) { var t = this; this.getLayer(_SYS_LAYER_INFO_PANEL) && this.getLayer(_SYS_LAYER_INFO_PANEL).clearDrawables((function (i, r) { if (1 === i) { for (let e = t.options.container.childNodes.length - 1; e >= 0; e--)t.options.container.childNodes[e].className === _SYS_LAYER_INFO_PANEL && t.options.container.removeChild(t.options.container.childNodes[e]); _core.off(_EVENTS.CAMERA_MOVE), e && e(1, "成功。") } else e && e(0, r) })), e && e(1, "成功") } clearLayer(e, t) { if (e === _SYS_LAYER_INFO_PANEL) return this.clearInfoPanels(), this; let i = this.getLayer(e); if (i) { for (let t = i.getDrawables().length - 1; t >= 0; t--)this.removeDrawable(e, i.getDrawables()[t].name); return t && t(1, "成功清除图层中的绘制物。"), this } return t && t(0, `未找到名为 ${e} 的图层。`), this } clearODLine() { _core.clearODLine() } clearOverlays() { for (let e = _layers$2.length - 1; e >= 0; e--)this.removeLayer(_layers$2[e].name); return this } clearSkyBox() { _core.clearBackground() } closePopup(e) { this.clearInfoPanels(e) } convertLLAToXYZ(e) { return _core.convertLLAToXYZ({ x: e.lon, y: e.lat, z: e.alt }) } convertScreenToWorld(e) { let t = _core.convertScreenToWorld(e), i = _core.convertXYZToLLA({ x: t.x, y: t.y, z: t.z }); return { x: t.x, y: t.y, z: t.z, lon: i.x, lat: i.y, alt: i.z } } convertWorldToScreen(e) { return _core.convertWorldToScreen(e) } convertXYZToLLA(e) { return _core.convertXYZToLLA(e) } convertXYZToLLAByCoordinate(e, t) { return _core.convertXYZTOLLAByCoordinate(e, t) } deselectAllLandmark() { _core.deselectAllBillboard() } deselectLandmark(e, t) { if (this.getLayer(e)) { let i = this.getLayer(e).getDrawable(t); if (!i || "landmark" !== i.type.toLowerCase() && "trail" !== i.type.toLowerCase()) return; _core.deselectBillboard(i.getFullName()) } } destroy(e) { this.url = null, this.name = null, this.author = null, this.type = null, this.additionalInfo = null, _layers$2 = null, _models = null, _core.destroy(), _core = null, _showStats = null; for (let e = this.options.container.children.length - 1; e >= 0; e--)this.options.container.removeChild(this.options.container.children[e]); this.options = null, e && e(1) } fpsPanelOff() { _core.fpsPanelOff() } fpsPanelOn() { _core.fpsPanelOn() } getAdditionalInfo() { return this.additionalInfo } getBar(e, t) { if (this.getLayer(e)) { let i = this.getLayer(e).getDrawable(t); return i && "bar" === i.type.toLowerCase() ? i : void 0 } } getBubble(e, t) { if (this.getLayer(e)) { let i = this.getLayer(e).getDrawable(t); return i && "bubble" === i.type.toLowerCase() ? i : void 0 } } getBuildingInfo(e, t) { if (!e || "" === e.toString()) return logger.warn("Scene.getBuildingInfo() 无效的参数。"), t && t(0, void 0), this; if (!this.options.buildingIndex || !this.options.buildingIndex.length || this.options.buildingIndex.length <= 0) return logger.warn("Scene.getBuildingInfo() 未加载有效的建筑物信息，无法获取建筑信息，请联系场景提供者。"), t && t(0, void 0), this; let i; for (let t of this.options.buildingIndex) if (t.id === e.toString()) { i = t; break } return i ? (t && t(1, i), this) : (logger.warn(`Scene.getBuildingInfo() 未找到指定的楼宇：${e}。`), t && t(0, void 0), this) } getCamera() { let e = _core.getCamera(); return e ? { target: { type: "xyz", x: e.targetX, y: e.targetY, z: e.targetZ }, posture: [0, e.inclinationAngle, e.azimuthAngle], distance: e.viewDistance } : void logger.warn("获取摄像机参数失败。") } getDatumShiftModel() { return _core.getDatumShiftModel() } getDrawable(e, t) { return this.getLayer(e) ? this.getLayer(e).getDrawable(t) : void 0 } getDrawables() { return _layers$2 } getInfoPanel(e) { let t = "不存在的infoPanel"; var i = this; for (let r = i.options.container.childNodes.length - 1; r >= 0; r--)i.options.container.childNodes[r].getAttribute("id") === `${_SYS_LAYER_INFO_PANEL}_${e}` && (t = i.options.container.childNodes[r]); return t } getInfoPanels() { return this.getLayer(_SYS_LAYER_INFO_PANEL) ? this.getLayer(_SYS_LAYER_INFO_PANEL).getDrawables() : [] } getLandmark(e, t) { if (this.getLayer(e)) { let i = this.getLayer(e).getDrawable(t); return i && "landmark" === i.type.toLowerCase() ? i : void 0 } } getLayer(e) { if (_layers$2 instanceof Array) for (let t of _layers$2) if (t.name === e) return t } getLayers() { return _layers$2 } getModelParam(e) { return _core.getModelParam(e) } getName() { return this.name } getUrl() { return this.url } getView() { _camera$2 = this.getCamera(); let e = _core.convertXYZToLLA({ x: _camera$2.target.x, y: _camera$2.target.y, z: _camera$2.target.z }); return { center: [e.x, e.y, e.z], rph: _camera$2.posture, distance: _camera$2.distance } } hideAllModels() { for (let e of _models) e.name && _core.hideModelByName(e.name) } hideDrawable(e, t, i) { if (this.getLayer(e)) { let r = this.getLayer(e).getDrawable(t); if (null == r) return void logger.warn(`绘制物 ${t} 不存在。`); let n = r.getFullName(); const a = n.substr(n.lastIndexOf("/") + 1, n.length - n.lastIndexOf("/")); return "trail" === a || "modeltrail" === a ? (_core.hideLayer(n + "Line"), _core.hideLayer(n)) : _core.hideLayer(n), r.isShow = !1, void (i && i(0, `成功隐藏 ${e} 图层的绘制物。`)) } i && i(0, `未找到名为 ${e} 图层的绘制物。`); let r = e + "_" + t; if (_overlayTips[r]) { _overlayTips[r].dom.style.display = "none" } return this } hideFirefly(e) { _core.hideFireFly(e) } hideFireworks(e) { _core.hideFireworks(e) } hideInfoPanel() { var e = this; if (null != e.getLayer(_SYS_LAYER_INFO_PANEL)) { let t = e.getLayer(_SYS_LAYER_INFO_PANEL).getDrawables(); if (t && t.length > 0) for (let i of t) for (let t = 0; t < e.options.container.childNodes.length; t++)if (e.options.container.childNodes[t].getAttribute("id") === `${_SYS_LAYER_INFO_PANEL}_${i.name}`) { e.options.container.childNodes[t].style.display = "none"; break } } } hideLayer(e, t) { let i = this.getLayer(e); if (i) { for (let e = i.getDrawables().length - 1; e >= 0; e--) { let t = i.getDrawables()[e]; if (t) { let e = t.getFullName(); const r = e.substr(e.lastIndexOf("/") + 1, e.length - e.lastIndexOf("/")); "trail" === r || "modeltrail" === r ? (_core.hideLayer(e + "Line"), _core.hideLayer(e)) : _core.hideLayer(e), t.isShow = !1; let n = i.name + "_" + t.name; if (_overlayTips[n]) { _overlayTips[n].dom.style.display = "none" } } } return t && t(1, "成功隐藏图层中的绘制物。"), this } } hideModelByName(e, t) { _core.hideModel(e, t) } hideNode(e, t) { return _core.setNodeVisibility(e, t, !1), this } hideRain(e) { _core.hideRain(e) } hideRainline(e) { _core.hideRainline(e) } hideSnow(e) { _core.hideSnow(e) } init(e, t, i) { if (this.options = e, this.url && e.container) { if (!this.options.container) return logger.warn(`模型加载出错。无效的容器名称（${this.options.container}）。`), void (t && t(0)); _core = new scene.Core, this.additionalInfo && this.additionalInfo.resourceBasePath && (_core.resourceBasePath = this.additionalInfo.resourceBasePath), !0 === e.editMode && (e.pointerMode = "editor"), _core.init(e), this.options.accessToken && this.options.accessToken.length > 64 && _core.setAvwToken("header", "authorization:bearer", this.options.accessToken), _core.loadScene({ scenePath: this.url, serviceName: e.serviceName, token: e.accessToken, serviceName: e.name || "默认服务", default: !0 }, ((i, r) => { if (1 == i) { var n = {}; if (null == e.coordinateSystem && null != e.center && 3 == e.center.length && (e.coordinateSystem = Scene$1.SURFACE), e.center && 3 == e.center.length && null != e.coordinateSystem) { switch (e.coordinateSystem) { case Scene$1.SURFACE: e.center[0] > 180 || e.center[0] < -180 || e.center[1] > 90 || e.center[1] < -90 ? (n.type = "xyz", e.center[0] = 0, e.center[1] = 0, e.center[2] = 0) : n.type = "surface"; break; case Scene$1.XYZ: n.type = "xyz"; break; case Scene$1.ECEF: n.type = "ecef"; break; case Scene$1.PLANAR_LOCAL: n.type = "planarlocal"; break; case Scene$1.MERCATOR: n.type = "mercator"; break; case Scene$1.WGS84: n.type = "surface" }n.lon = e.center[0], n.lat = e.center[1], n.alt = e.center[2], e.scale && 3 == e.scale.length ? (n.scaleX = e.scale[0], n.scaleY = e.scale[1], n.scaleZ = e.scale[2]) : (n.scaleX = 1, n.scaleY = 1, n.scaleZ = 1), _core.setDatumShiftModel(n) } e.camera && this.cameraFlyTo(e.camera, 0), t && t(1) } else t && t(0, r) }), (e => { "progress" === e.type && e.total < e.loaded ? i && i({ type: "progress", total: e.loaded, loaded: e.loaded }) : i && i(e) })), _core.on(_EVENTS.CAMERA_MOVE, "", this.tipFollowingMaster), document.addEventListener("pointerdown", (function () { for (const e in _overlayTips) { _overlayTips[e].container.style.pointerEvents = "none" } for (const e in _modelTips) { _overlayTips[e].container.style.pointerEvents = "none" } })), document.addEventListener("pointerup", (function () { for (const e in _overlayTips) { _overlayTips[e].container.style.pointerEvents = "unset" } for (const e in _modelTips) { _overlayTips[e].container.style.pointerEvents = "unset" } })) } return this } loadService(e, t, i) { _core.preloadScene({ scenePath: e.url, serviceName: e.name, token: e.token }, t, void 0, i) } switchService(e, t, i) { _core.changeScene(e, t, i) } getServicesInfo(e) { _core.getServicesInfo(e) } loadScene(e, t, i) { _core.loadScene(e, t, i) } off(e, t, i) { t && "" !== t ? (void 0 === i && (_eventHandler[_EVENTS.CLICK].byType[t] = [], _core.off(e, t, "")), _eventHandler[_EVENTS.CLICK].byType[t].map(((r, n) => { r.callback === i && (_core.off(e, t, r.coreCallback), _eventHandler[_EVENTS.CLICK].byType[t].splice(n, 1)) }))) : (void 0 === i && (_eventHandler[_EVENTS.CLICK].default = [], _core.off(e, t, "")), _eventHandler[_EVENTS.CLICK].default.map(((r, n) => { r.callback === i && (_core.off(e, t, r.coreCallback), _eventHandler[_EVENTS.CLICK].default.splice(n, 1)) }))) } on(e, t, i) { if (e && i) { var r = this; switch (e) { case _EVENTS.LOD_CHANGE: "" === t.toLowerCase() && (_eventHandler[e].default = i, _core.on("lodchange", "", (t => { _eventHandler[e].default(t) }))); break; case _EVENTS.CLICK: if (null == _eventHandler[e].byType[t.toLowerCase()]) return; if ("model" === t.toLowerCase()) { let r = { callback: i, coreCallback: function (e, t, i) { if (t) { var r = { name: t.name, type: "model", position: t.position, positionLla: t.positionLla, _name: t._name }; _eventHandler[_EVENTS.CLICK].byType.model[i].callback(e, r) } } }; _eventHandler[e].byType[t.toLowerCase()].push(r), _core.on(e, "model", r.coreCallback) } if ("building" === t.toLowerCase()) { let r = { callback: i, coreCallback: function (e, t, i) { if (t) { var r = { name: t.name, type: "building", position: t.position, positionLla: t.positionLla, selectedType: t.selectedType }; _eventHandler[_EVENTS.CLICK].byType.building[i].callback(e, r) } } }; _eventHandler[e].byType[t.toLowerCase()].push(r), _core.on(e, "building", r.coreCallback) } if ("scene" === t.toLowerCase()) { let r = { callback: i, coreCallback: function (e, t, i) { if (t) if ("background" === t.type) _eventHandler[_EVENTS.CLICK].byType.scene[i].callback(e, t); else { var r = { name: t.name, type: "model", position: t.position, positionLla: t.positionLla }; _eventHandler[_EVENTS.CLICK].byType.scene[i].callback(e, r) } } }; _eventHandler[e].byType[t.toLowerCase()].push(r), _core.on(e, "scene", r.coreCallback) } if ("landmark" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let r = a.getDrawable(n[1]); r.positionLla = t.positionLla, _eventHandler[_EVENTS.CLICK].byType.landmark[i].callback(e, r) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "landmark", n.coreCallback) } if ("bubble" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.CLICK].byType.bubble[i].callback(e, t) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "bubble", n.coreCallback) } if ("bar" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.CLICK].byType.bar[i].callback(e, t) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "bar", n.coreCallback) } if ("trail" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.CLICK].byType.trail[i].callback(e, t) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "trail", n.coreCallback) } if ("odline" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { _core.convertXYZToLLA({ x: t.position.x, y: t.position.y, z: t.position.z }); let r = a.getDrawable(n[1]); _eventHandler[_EVENTS.CLICK].byType.odline[i].callback(e, r) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "odline", n.coreCallback) } if ("area" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.CLICK].byType.area[i].callback(e, t) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "area", n.coreCallback) } if ("drawable" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) if ("odline" == n[2]) { _core.convertXYZToLLA({ x: t.position.x, y: t.position.y, z: t.position.z }); let r = a.getDrawable(n[1]); _eventHandler[_EVENTS.CLICK].byType.drawable[i].callback(e, r) } else if ("instancedbubble" == n[2]) { let r = t.userData.names[t.instanceId], o = a.getDrawable(n[1]); _eventHandler[_EVENTS.CLICK].byType.drawable[i].callback(e, o, r) } else { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.CLICK].byType.drawable[i].callback(e, t) } else { let r = t.parent.name.split("/"); t.parent.parent && (r = t.parent.parent.name.split("/")), 3 != r.length || "3dmarker" !== r[2] && "modellandmark" !== r[2] || _eventHandler[_EVENTS.CLICK].byType.drawable[i].callback(e, { parent: r[0], name: r[1] }) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "drawable", n.coreCallback) } break; case _EVENTS.DOUBLE_CLICK: case _EVENTS.MOUSE_DOWN: _core.on(e, t, i); break; case _EVENTS.MOUSE_HOVER: if (null == _eventHandler[e].byType[t.toLowerCase()]) return; if ("model" === t.toLowerCase()) { let r = { callback: i, coreCallback: function (e, t, i) { if (t) { var r = { name: t.name, type: "model", position: t.position, positionLla: t.positionLla }; _eventHandler[_EVENTS.MOUSE_HOVER].byType.model[i].callback(e, r) } } }; _eventHandler[e].byType[t.toLowerCase()].push(r), _core.on(e, "model", r.coreCallback) } if ("building" === t.toLowerCase()) { let r = { callback: i, coreCallback: function (e, t, i) { if (t) { var r = { name: t.name, type: "building", position: t.position, positionLla: t.positionLla, selectedType: t.selectedType }; _eventHandler[_EVENTS.MOUSE_HOVER].byType.building[i].callback(e, r) } } }; _eventHandler[e].byType[t.toLowerCase()].push(r), _core.on(e, "building", r.coreCallback) } if ("scene" === t.toLowerCase()) { let r = { callback: i, coreCallback: function (e, t, i) { if (t) if ("background" === t.type) _eventHandler[_EVENTS.MOUSE_HOVER].byType.scene[i].callback(e, t); else { var r = { name: t.name, type: "model", position: t.position, positionLla: t.positionLla }; _eventHandler[_EVENTS.MOUSE_HOVER].byType.scene[i].callback(e, r) } } }; _eventHandler[e].byType[t.toLowerCase()].push(r), _core.on(e, "scene", r.coreCallback) } if ("landmark" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let r = a.getDrawable(n[1]); r.positionLla = t.positionLla, _eventHandler[_EVENTS.MOUSE_HOVER].byType.landmark[i].callback(e, r) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "landmark", n.coreCallback) } if ("bubble" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.MOUSE_HOVER].byType.bubble[i].callback(e, t) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "bubble", n.coreCallback) } if ("bar" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.MOUSE_HOVER].byType.bar[i].callback(e, t) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "bar", n.coreCallback) } if ("trail" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.MOUSE_HOVER].byType.trail[i].callback(e, t) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "trail", n.coreCallback) } if ("odline" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { _core.convertXYZToLLA({ x: t.position.x, y: t.position.y, z: t.position.z }); let r = a.getDrawable(n[1]); _eventHandler[_EVENTS.MOUSE_HOVER].byType.odline[i].callback(e, r) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "odline", n.coreCallback) } if ("area" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.MOUSE_HOVER].byType.area[i].callback(e, t) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "area", n.coreCallback) } if ("drawable" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) if ("odline" == n[2]) { _core.convertXYZToLLA({ x: t.position.x, y: t.position.y, z: t.position.z }); let r = a.getDrawable(n[1]); _eventHandler[_EVENTS.MOUSE_HOVER].byType.drawable[i].callback(e, r) } else if ("instancedbubble" == n[2]) { let r = t.userData.names[t.instanceId], o = a.getDrawable(n[1]); _eventHandler[_EVENTS.MOUSE_HOVER].byType.drawable[i].callback(e, o, r) } else { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.MOUSE_HOVER].byType.drawable[i].callback(e, t) } else { let r = t.parent.name.split("/"); t.parent.parent && (r = t.parent.parent.name.split("/")), 3 != r.length || "3dmarker" !== r[2] && "modellandmark" !== r[2] || _eventHandler[_EVENTS.MOUSE_HOVER].byType.drawable[i].callback(e, { parent: r[0], name: r[1] }) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "drawable", n.coreCallback) } break; case _EVENTS.UNMOUSE_HOVER: if (null == _eventHandler[e].byType[t.toLowerCase()]) return; if ("model" === t.toLowerCase()) { let r = { callback: i, coreCallback: function (e, t, i) { if (t) { var r = { name: t.name, type: "model", position: t.position, positionLla: t.positionLla }; _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.model[i].callback(e, r) } } }; _eventHandler[e].byType[t.toLowerCase()].push(r), _core.on(e, "model", r.coreCallback) } if ("building" === t.toLowerCase()) { let r = { callback: i, coreCallback: function (e, t, i) { if (t) { var r = { name: t.name, type: "building", position: t.position, positionLla: t.positionLla, selectedType: t.selectedType }; _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.building[i].callback(e, r) } } }; _eventHandler[e].byType[t.toLowerCase()].push(r), _core.on(e, "building", r.coreCallback) } if ("scene" === t.toLowerCase()) { let r = { callback: i, coreCallback: function (e, t, i) { if (t) if ("background" === t.type) _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.scene[i].callback(e, t); else { var r = { name: t.name, type: "model", position: t.position, positionLla: t.positionLla }; _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.scene[i].callback(e, r) } } }; _eventHandler[e].byType[t.toLowerCase()].push(r), _core.on(e, "scene", r.coreCallback) } if ("landmark" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let r = a.getDrawable(n[1]); r.positionLla = t.positionLla, _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.landmark[i].callback(e, r) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "landmark", n.coreCallback) } if ("bubble" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.bubble[i].callback(e, t) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "bubble", n.coreCallback) } if ("bar" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.bar[i].callback(e, t) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "bar", n.coreCallback) } if ("trail" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.trail[i].callback(e, t) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "trail", n.coreCallback) } if ("odline" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { _core.convertXYZToLLA({ x: t.position.x, y: t.position.y, z: t.position.z }); let r = a.getDrawable(n[1]); _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.odline[i].callback(e, r) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "odline", n.coreCallback) } if ("area" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.area[i].callback(e, t) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "area", n.coreCallback) } if ("drawable" === t.toLowerCase()) { let n = { callback: i, coreCallback: function (e, t, i) { if (t) { let n = t.name.split("/"), a = r.getLayer(n[0]); if (a) if ("odline" == n[2]) { _core.convertXYZToLLA({ x: t.position.x, y: t.position.y, z: t.position.z }); let r = a.getDrawable(n[1]); _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.drawable[i].callback(e, r) } else if ("instancedbubble" == n[2]) { let r = t.userData.names[t.instanceId], o = a.getDrawable(n[1]); _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.drawable[i].callback(e, o, r) } else { let t = a.getDrawable(n[1]); _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.drawable[i].callback(e, t) } else { let r = t.parent.name.split("/"); t.parent.parent && (r = t.parent.parent.name.split("/")), 3 != r.length || "3dmarker" !== r[2] && "modellandmark" !== r[2] || _eventHandler[_EVENTS.UNMOUSE_HOVER].byType.drawable[i].callback(e, { parent: r[0], name: r[1] }) } } } }; _eventHandler[e].byType[t.toLowerCase()].push(n), _core.on(e, "drawable", n.coreCallback) } break; case _EVENTS.MOUSE_UP: case _EVENTS.CAMERA_MOVE: case _EVENTS.CAMERA_ZOOM: _core.on(e, t, i); break; case _EVENTS.TRAIL_MOVE: let n = { callback: i, coreCallback: function (e, t) { if (e) { var i = [], r = []; for (var n in e) i.push(e[n]); i.map((e => { var t = _core.convertXYZToLLA({ x: e.position.x, y: e.position.y, z: e.position.z }); e.position.lon = t.x, e.position.lat = t.y, e.position.alt = t.z; let i = { name: e.name.substring(e.name.indexOf("/") + 1, e.name.lastIndexOf("/")), position: e.position, type: "trail" }; r.push(i) })), _eventHandler[_EVENTS.TRAIL_MOVE].default[t].callback(r) } } }; _eventHandler[e].default.push(n), _core.on(e, "", n.coreCallback); break; default: logger.warn("注册事件处理函数参数有误。") } } else logger.warn("注册事件处理函数参数有误。") } removeArea(e, t) { if (this.getLayer(e)) { let i = this.getLayer(e).getDrawable(t); null != i && i ? (this.spliceDrawable(e, t), i.removeArea()) : logger.warn("未找到图层名为：" + e + "，绘制物名称为：" + t + "的绘制物。") } } removeBar(e, t) { if (this.getLayer(e)) { let i = this.getLayer(e).getDrawable(t); null != i && i ? (this.spliceDrawable(e, t), i.removeBar()) : logger.warn("未找到图层名为：" + e + "，绘制物名称为：" + t + "的绘制物。") } } removeBubble(e, t) { if (this.getLayer(e)) { let i = this.getLayer(e).getDrawable(t); null != i && i ? (this.spliceDrawable(e, t), i.removeBubble()) : logger.warn("未找到图层名为：" + e + "，绘制物名称为：" + t + "的绘制物。") } } removeDrawable(e, t, i) { if (this.getLayer(e)) { let r = this.getLayer(e).getDrawable(t); if (!r) return this; this.spliceDrawable(e, t), _core.removeLayer(r.getFullName()), i && i(0, `成功删除 ${e} 图层的绘制物。`) } else i && i(0, `未找到名为 ${e} 图层的绘制物。`); let r = e + "_" + t; if (_overlayTips[r]) { let e = _overlayTips[r]; this.options.container.removeChild(e.dom), delete _overlayTips[r] } return this } removeFirefly(e) { _core.removeFireFly(e) } removeFireworks(e) { _core.removeFireworks(e) } removeHeatMap(e, t, i) { e && "" !== e || (e = _SYS_LAYER_HEAT_MAP); let r = this.getLayer(e).getDrawable(t); null != r && r ? (this.spliceDrawable(e, t), r.removeHeatmap()) : logger.warn("未找到指定图层下指定名称的绘制物。") } removeInfoPanel(e, t) { if (this.getLayer(_SYS_LAYER_INFO_PANEL)) { var i = this.getLayer(_SYS_LAYER_INFO_PANEL).getDrawable(e); null != i && i && i.removeInfoPanel(e, _SYS_LAYER_INFO_PANEL, this.options, _EVENTS, _layers$2, t) } else logger.warn("目前没有绘制信息标牌") } removeLandmark(e, t) { if (this.getLayer(e)) { let i = this.getLayer(e).getDrawable(t); null != i && i ? (this.spliceDrawable(e, t), i.removeLandmark()) : logger.warn("未找到图层名为：" + e + "，绘制物名称为：" + t + "的绘制物。") } } removeLayer(e, t) { e === _SYS_LAYER_INFO_PANEL && this.clearInfoPanels(), e === _SYS_LAYER_HEAT_MAP && this.clearHeatMap(); for (let i = _layers$2.length - 1; i >= 0; i--)if (_layers$2[i].name === e) { for (let t = _layers$2[i].getDrawables().length - 1; t >= 0; t--) { let r = _layers$2[i].getDrawables()[t]; _core.removeLayer(r.getFullName()); let n = e + "_" + r.name; if (_overlayTips[n]) { let e = _overlayTips[n]; this.options.container.removeChild(e.dom), delete _overlayTips[n] } } return _layers$2.splice(i, 1), t && t(1, "成功移除图层。"), this } return t && t(0, `未找到名为 ${e} 的图层。`), this } removeODLine(e, t) { if (this.getLayer(e)) { let i = this.getLayer(e).getDrawable(t); null != i && i ? (this.spliceDrawable(e, t), i.removeODLine()) : logger.warn("未找到指定图层下指定名称的绘制物。") } } removePopup(e) { var t = this.getLayer(_SYS_LAYER_INFO_PANEL).getDrawable(_SYS_POPUP); null != t && t && t.removeInfoPanel(_SYS_POPUP, _SYS_LAYER_INFO_PANEL, this.options, _EVENTS, _layers$2, e) } removeRain(e) { _core.removeRain(e) } removeRainline(e) { _core.removeRainline(e) } removeSnow(e) { _core.removeSnow(e) } removeSolidBillboard(e, t) { let i = this.getLayer(_SYS_LAYER_SOLID_BILLBOARD).getDrawable(e); null != i && null != i ? (i.removeSolidBillboard(), this.getLayer(_SYS_LAYER_SOLID_BILLBOARD).removeDrawable(e)) : t && t(0, "未找到对应的立体标牌") } removeTrail(e, t, i) { let r = this.getLayer(e).getDrawable(t); null != r && null != r ? (r.removeTrail(), this.getLayer(e).removeDrawable(t)) : i && i(0, "未找到对应的trail") } resetNode(e, t) { return _core.resetNodeParamRecursive(e, { nodeName: t }), this } resetNodeParam(e, t) { _core.resetNodeParam(e, t) } selectLandmark(e, t) { if (this.getLayer(e)) { let i = this.getLayer(e).getDrawable(t); if (!i || "landmark" !== i.type.toLowerCase() && "trail" !== i.type.toLowerCase()) return; _core.selectBillboard(i.getFullName(), { path: "texture/ui/highlight-landmark.png" }) } } setAutoRotate(e, t, i, r) { void 0 === i && (i = !0), e ? _core.autoRotate(t, i, r) : _core.autoRotate(0) } setBackgroundColor(e) { _core.setBackgroundColor(e) } setBackgroundImage(e) { _core.setBackgroundImage(e) } setCamera(e, t, i) { if (null != t && null != t || (t = 0), !e) return void logger.warn("摄像机设置参数有误：不能为空。"); if (!e.target) return void logger.warn("摄像机设置参数有误：target 不能为空。", JSON.stringify(e.target)); if (!e.posture) return void logger.warn("摄像机设置参数有误：posture 不能为空。"); if (3 !== e.posture.length) return void logger.warn("摄像机设置参数有误：posture 必须为长度为 3 的数组。"); if (Number(e.distance) < _DISTANCE_MIN || Number(e.distance) > _DISTANCE_MAX) return void logger.warn(`摄像机设置参数有误：distance 只能在 ${_DISTANCE_MIN} ~ ${_DISTANCE_MAX} 之间。`); _camera$2 = e; let r = 0, n = 0; var a = null; r = Number(e.posture[2]), n = Number(e.posture[1]), a = e.target.type && "lla" === e.target.type ? _core.convertLLAToXYZ({ x: e.target.lon, y: e.target.lat, z: e.target.alt }) : e.target, 90 == n && (n = 89.99999), -90 == n && (n = -89.99999), 0 == e.distance && (e.distance = 1e-5), _core.cameraFlyTo(a, Number(r), Number(n), Number(e.distance), t, !0, i || void 0) } getCameraAutoRotate() { return _core.getCameraAutoRotate() } setEnvTime(e) { var t = e.envTime.split(/:|：| |-|\//); return null == t[0] || t[0] >= 24 || null == t[1] || t[1] >= 60 || null != t[1] && t[1] >= 60 ? { result: 0, message: `时间 ${e.envTime} 格式错误。` } : (e.envTime = t.join(":"), e.duration < 0 ? { result: 0, message: "duration 属性必须大于等于 0。" } : (_core.setEnvTime(e), { result: 1 })) } setDatumShiftModel(e) { _core.setDatumShiftModel(e) } setModelTransform(e, t, i) { if (_core.defaultObjectTree.getItemByName(e)) { if (t.position && "lla" === t.position.type.toLowerCase()) { let e = this.convertLLAToXYZ(t.position); t.position.x = e.x, t.position.y = e.y, t.position.z = e.z } null != t.rotation && (t.position && "lla" === t.position.type.toLowerCase() ? t.rotation = { x: t.rotation[0], y: t.rotation[1], z: t.rotation[2] } : t.rotation = { x: t.rotation[0], y: t.rotation[2], z: t.rotation[1] }), null != t.scale && (t.scale = { x: t.scale[0], y: t.scale[1], z: t.scale[2] }), _core.setModelTransform(e, t), i && i({ result: 1, message: "成功。" }) } else i && i({ result: 0, message: `失败，模型 ${e} 不存在。` }) } setModelTransform2(e, t) { if (e.position && "lla" === e.position.type.toLowerCase()) { let t = this.convertLLAToXYZ(e.position); e.position.x = t.x, e.position.y = t.y, e.position.z = t.z } e.position && "lla" === e.position.type.toLowerCase() ? (e.rotation = { x: e.rotationX, y: e.rotationY, z: e.rotationZ }, e.scale = { x: e.scaleX, y: e.scaleY, z: e.scaleZ }) : (e.rotation = { x: e.rotationX, y: e.rotationZ, z: e.rotationY }, e.scale = { x: e.scaleX, y: e.scaleZ, z: e.scaleY }), _core.setModelTransform2(e, t) } setModelOpacity(e, t) { _core.setModelOpacity(e, t) } setModelVisible(e, t) { let i = _core.defaultObjectTree.getItemByName(e); if (i && (t ? i.show() : i.hide()), _modelTips[e]) { _modelTips[e].dom.style.display = t ? "unset" : "none" } } setModelStyle(e, t, i) { _core.defaultObjectTree.getItemByName(e) ? (_core.setModelStyle(e, t), i && i({ result: 1, message: "成功。" })) : i({ result: 0, message: `失败，模型 ${e} 不存在。` }) } showAllModels() { for (let e of _models) e.name && _core.showModel(e.name) } showDrawable(e, t, i) { if (this.getLayer(e)) { let r = this.getLayer(e).getDrawable(t); if (null == r) return void logger.warn(`绘制物 ${t} 不存在。`); let n = r.getFullName(); const a = n.substr(n.lastIndexOf("/") + 1, n.length - n.lastIndexOf("/")); return "trail" === a || "modeltrail" === a ? (_core.showLayer(n + "Line"), _core.showLayer(n)) : _core.showLayer(n), r.isShow = !0, void (i && i(0, `成功显示绘制物 ${t}。 `)) } i && i(0, `绘制物 ${e} 不存在。`); let r = e + "_" + t; if (_overlayTips[r]) { _overlayTips[r].dom.style.display = "unset" } return this } showFirefly(e) { _core.showFireFly(e) } showFireworks(e) { _core.showFireworks(e) } showHeatMap(e, t) { return this.clearHeatMap(), this.addHeatMap(_SYS_LAYER_HEAT_MAP, e, t) } showInfoPanel() { var e = this; if (null != e.getLayer(_SYS_LAYER_INFO_PANEL)) { let t = e.getLayer(_SYS_LAYER_INFO_PANEL).getDrawables(); if (t && t.length > 0) for (let i of t) for (let t = 0; t < e.options.container.childNodes.length; t++)if (e.options.container.childNodes[t].getAttribute("id") === `${_SYS_LAYER_INFO_PANEL}_${i.name}`) { e.options.container.childNodes[t].style.display = "block"; break } } } showLayer(e, t) { let i = this.getLayer(e); if (i) { for (let e = i.getDrawables().length - 1; e >= 0; e--) { let t = i.getDrawables()[e]; if (t) { let e = t.getFullName(); const r = e.substr(e.lastIndexOf("/") + 1, e.length - e.lastIndexOf("/")); "trail" === r || "modeltrail" === r ? (_core.showLayer(e + "Line"), _core.showLayer(e)) : _core.showLayer(e), t.isShow = !0; let n = i.name + "_" + t.name; if (_overlayTips[n]) { _overlayTips[n].dom.style.display = "unset" } } } return t && t(1, "成功隐藏图层中的绘制物。"), this } } showModelByName(e, t) { _core.showModel(e, t) } showNode(e, t) { return _core.setNodeVisibility(e, t, !0), this } showRain(e) { _core.showRain(e) } showRainline(e) { _core.showRainline(e) } showSnow(e) { _core.showSnow(e) } statsOff() { _showStats = !0, _core.statsOff() } statsOn() { _showStats = !0, _core.statsOn() } statsToggle() { _showStats ? (_showStats = !1, _core.statsOff()) : (_showStats = !0, _core.statsOn()) } switchIndoor(e) { let t, i; if (!e) return logger.warn(`Scene.switchIndoor() params - ${e || void 0}`), this; if (!e.buildingId || "" === e.buildingId.toString()) return logger.warn(`Scene.switchIndoor() 传入参数无效：params.buildingId - ${e.buildingId || void 0}`), this; if (!e.floorId || "" === e.floorId.toString()) return logger.warn(`Scene.switchIndoor() 传入参数无效：params.floorId - ${e.floorId || void 0}`), this; if (!this.options.buildingIndex || !this.options.buildingIndex.length || this.options.buildingIndex.length <= 0) return logger.warn("Scene.switchIndoor() 未加载有效的建筑物信息，无法切换到室内视图，请联系场景提供者。"), this; for (let i of this.options.buildingIndex) if (i.id === e.buildingId.toString()) { t = i; break } if (!t) return logger.warn(`Scene.switchIndoor() 未找到指定的楼宇：${e.buildingId}。`), this; if (!t.floors || !t.floors.length || t.floors.length <= 0) return logger.warn(`Scene.switchIndoor() 未找到指定的楼层：${e.floorId}。`), this; for (let r of t.floors) if (r.id === e.floorId.toString()) { i = r; break } if (!i) return logger.warn(`Scene.switchIndoor() 未找到指定的楼层：${e.floorId}。`), this; for (let e of t.floors) e.order > i.order && this.hideNode("main", e.nodeName); return this } switchOutdoor(e) { if (e && "" !== e.toString() || (e = ""), !this.options.buildingIndex || !this.options.buildingIndex.length || this.options.buildingIndex.length <= 0) return logger.warn("Scene.switchOutdoor() 未加载有效的建筑物信息，无法切换到室外视图，请联系场景提供者。"), this; if ("" === e) for (let e of this.options.buildingIndex) this.switchOutdoor(e.id); else { let t; for (let i of this.options.buildingIndex) if (i.id === e.toString()) { t = i; break } if (!t) return logger.warn(`Scene.switchOutdoor() 未找到指定的楼宇：${e}。`), this; if (!t.floors || !t.floors.length || t.floors.length <= 0) return logger.warn(`Scene.switchOutdoor() 楼宇 ${e} 未加载有效的楼层信息，无法切换到室外视图，请联系场景提供者。`), this; for (let e of t.floors) this.showNode("main", e.nodeName) } return this } translateNode(e, t, i) { return e && t.nodeName ? (i ? _core.translateNodeParamRecursive(e, t) : _core.translateNodeParam(e, t), this) : (logger.warn("translateNode() 参数无效。"), this) } translateNodeParam(e, t) { _core.translateNodeParam(e, t) } updateArea(e, t, i, r) { return new Promise((n => { let a = this.getLayer(e).getDrawable(t); a && null != a ? a.updateArea(i, (() => { void 0 !== _overlayTips[e + "_" + t] && this.tipFollowingMaster(), r && r(1), n() })) : (r && r(0, "未找到图层名为：" + e + "，绘制物名称为：" + t + "的绘制物！"), n()) })) } updatePath(e, t, i, r) { return new Promise((n => { let a = this.getLayer(e); if (!a) return r && r(0, "未找到图层：" + e + "！"), void n(); let o = a.getDrawable(t); if (!o) return r && r(0, "未找到绘制物：" + e + "！"), void n(); o.updatePath(i, (() => { void 0 !== _overlayTips[e + "_" + t] && this.tipFollowingMaster(), r && r(1, "已更新绘制物：" + e + "！"), n() })) })) } updatePathPass(e, t, i, r) { let n = this.getLayer(e); if (!n) return void (r && r(0, "未找到图层：" + e + "！")); let a = n.getDrawable(t); a ? (a.updatePathPass(i), r && r(1, "已更新绘制物：" + e + "！")) : r && r(0, "未找到绘制物：" + e + "！") } addPath(e, t, i) { return new Promise((r => { if (null == t && null == t.points) return i && i(0, "绘制路径失败"), void r(obj); t.type = "path", this.addDrawable(e, t, (e => { i && i(this), r(e) })) })) } updateBar(e, t, i, r) { let n = this.getLayer(e).getDrawable(t); if (n && null != n) { n.updateBar(i); void 0 !== _overlayTips[e + "_" + t] && this.tipFollowingMaster() } else r && r(0, "未找到图层名为：" + e + "，绘制物名称为：" + t + "的绘制物！") } updateBubble(e, t, i, r) { return new Promise((n => { let a = this.getDrawable(e, t); a && null != a ? a.updateBubble(i, (() => { void 0 !== _overlayTips[e + "_" + t] && this.tipFollowingMaster(), r && r(...arguments), n() })) : (r && r(0, "未找到图层名为：" + e + "，绘制物名称为：" + t + "的绘制物！"), n()) })) } updateInstancedBubble(e, t, i) { let r = e, n = this.getDrawable(e, r); if (n) return new Promise((function (e) { n.updateInstancedBubble(t, (function () { i && i(...arguments), e() })) })); i && i(0, "未找到图层名为：" + e + "，绘制物名称为：" + r + "的绘制物！") } updateFirefly(e, t) { if (t.position && "lla" === t.position.type.toLowerCase()) { let e = _core.convertLLAToXYZ({ x: t.position.lon, y: t.position.lat, z: t.position.alt }); t.position.x = e.x, t.position.y = e.y, t.position.z = e.z } _core.updateFireFly(e, t) } updateFireworks(e, t) { if (t.position && "lla" === t.position.type.toLowerCase()) { let e = _core.convertLLAToXYZ({ x: t.position.lon, y: t.position.lat, z: t.position.alt }); t.position.x = e.x, t.position.y = e.y, t.position.z = e.z } _core.updateFireworks(e, t) } updateHeatMapData(e, t, i) { e && "" !== e || (e = _SYS_LAYER_HEAT_MAP); let r = this.getDrawable(e, t); if (r && "heatmap" === r.type) return null != i.opacity && (r.opacity = i.opacity), r.points = i.points || r.points, r.radius = i.radius || r.radius, r.gradient = i.gradient || r.gradient, r.offset = i.offset || r.offset, r.style = i.style || r.style, r.enableViewDistance = i.enableViewDistance || !1, r.maxVisibleDistance = i.maxVisibleDistance || r.maxVisibleDistance, r.minVisibleDistance = i.minVisibleDistance || r.minVisibleDistance, this.removeHeatMap(e, t), this.addDrawable(e, r); logger.warn("Scene.updateHeatMapData(layerName, heatMapName, params)) 未找到指定的热力图。") } updateLandmark(e, t, i, r) { return new Promise((n => { let a = this.getDrawable(e, t); a && null != a ? a.updateLandmark(i, (() => { void 0 !== _overlayTips[e + "_" + t] && this.tipFollowingMaster(), r && r(), n() })) : (r && r(0, "未找到图层名为：" + e + "，绘制物名称为：" + t + "的绘制物！"), n()) })) } updateODLine(e, t, i, r) { return new Promise((n => { let a = this.getDrawable(e, t); a && null != a ? a.updateODLine(i, (() => { void 0 !== _overlayTips[e + "_" + t] && this.tipFollowingMaster(), r && r(...arguments), n() })) : (r && r(0, "未找到图层名为：" + e + "，绘制物名称为：" + t + "的绘制物！"), n()) })) } updateRain(e, t) { _core.updateRain(e, t) } updateRainline(e, t) { if (t.position && "lla" === t.position.type.toLowerCase()) { let e = _core.convertLLAToXYZ({ x: t.position.lon, y: t.position.lat, z: t.position.alt }); t.position.x = e.x, t.position.y = e.y, t.position.z = e.z } _core.updateRainline(e, t) } updateSnow(e, t) { _core.updateSnow(e, t) } updateSolidBillboard(e, t, i) { if (this.getLayer(_SYS_LAYER_SOLID_BILLBOARD)) { let r = this.getLayer(_SYS_LAYER_SOLID_BILLBOARD).getDrawable(e); r && null != r ? r.updateSolidBillboard(t) : i && i(0, "未找到名为：" + e + "的立体标牌！") } else logger.warn("名为" + e + "的立体标牌不存在") } updateTrail(e, t, i, r) { if (this.getLayer(e)) { let n = this.getLayer(e).getDrawable(t); if (n && null != n) { n.updateTrail(i); void 0 !== _overlayTips[e + "_" + t] && this.tipFollowingMaster() } else r && r(0, "未找到图层名为：" + e + "，绘制物名称为：" + t + "的绘制物！") } else logger.warn("名为" + e + "的图层不存在") } view(e) { if (!e || !e.center || !e.rph || Number(e.distance) < 0) return logger.warn("视图设置参数有误。"), this; if (3 !== e.center.length || 3 !== e.rph.length) return logger.warn("视图设置参数有误。"), this; let t = new Position("lla").set(e.center[0], e.center[1], e.center[2]), i = _core.convertLLAToXYZ({ x: t.lon, y: t.lat, z: t.alt }); return i.type = "xyz", this.setCamera({ target: i, posture: e.rph, distance: e.distance }, 0), this } zoomIn(e) { let t = _core.getCamera(); t && (t.viewDistance = t.viewDistance / 2, _core.cameraFlyTo({ x: t.targetX, y: t.targetY, z: t.targetZ }, t.azimuthAngle, t.inclinationAngle, t.viewDistance, e ? 1 : 0, !0)) } zoomOut(e) { let t = _core.getCamera(); t && (t.viewDistance = 2 * t.viewDistance, _core.cameraFlyTo({ x: t.targetX, y: t.targetY, z: t.targetZ }, t.azimuthAngle, t.inclinationAngle, t.viewDistance, e ? 1 : 0, !0)) } getSceneObjects() { return _core.defaultObjectTree.children.map((e => ({ name: e.name, type: e.type, isVisible: e.isVisible, isCustom: e.isCustom }))) } async getSceneIconAssets() { let e = _core.defaultObjectTree.children.filter((e => "IconAsset" == e.type)), t = [], i = e.map((e => ({ name: e.name, type: e.type, isVisible: e.isVisible, isCustom: e.isCustom }))); return e.forEach((e => { t.push(util.syntheticImage(e.backgroundMap, e.param.backgroundColor, e.map)) })), (await Promise.all(t)).forEach(((e, t) => { i[t].src = e })), i } getSceneModelAssets() { return _core.defaultObjectTree.children.filter((e => "ModelItem" == e.type || "BuildingItem" == e.type)).map((e => ({ name: e.name, type: e.type, isVisible: e.isVisible, isCustom: !0 }))) } getStates() { return _core.getStates() } switchState(e, t, i) { _core.getStates() ? _core.nextRender((() => { _core.setCurrentState(e, t, i) })) : logger.warn("状态列表为空") } showBuildingFloor(e, t, i, r) { if (!e) return; let n = _core.defaultObjectTree.getItemByName(e); n ? _core.cutLevel(n.getGroup().uuid, i, r) : r(!1, `模型${e}不存在`) } resetNodeParam(e, t) { _core.resetNodeParam(e, t) } invokeCore(e) { if ("function" != typeof _core[e]) return; let t = []; for (let e = 1; e < arguments.length; e++)t.push(arguments[e]); return _core[e](...t) } _debugCore() { return _core } _resolveScenePaths() { return -1 !== this.url.indexOf("/", this.url.length - 1) && (this.url = this.url.substring(0, this.url.length - 1)), _sceneName = this.url.substring(this.url.lastIndexOf("/") + 1, this.url.length), _sceneConfigPath = this.url + `/${_SCENE_CONFIG_FILE_NAME}`, _defaultModelPath = this.url + `/model/${_sceneName}.avwm`, _defaultModelConfigPath = this.url + `/model/${_sceneName}.avwc`, new Promise(((e, t) => { if (this.options.accessToken && this.options.accessToken.length > _ACCESS_TOKEN_LENGTH_MIN) { _sceneApiUrl = this.url.substring(0, this.url.lastIndexOf("/")); let i = util.fetchJSON(_sceneApiUrl, "POST", [{ key: "content-type", value: "application/json" }, { key: "authorization", value: "Bearer " + this.options.accessToken }], { modelKey: `/${_sceneName}/${_SCENE_CONFIG_FILE_NAME}` }), r = util.fetchJSON(_sceneApiUrl, "POST", [{ key: "content-type", value: "application/json" }, { key: "authorization", value: "Bearer " + this.options.accessToken }], { modelKey: `/${_sceneName}/model/${_sceneName}.avwm` }), n = util.fetchJSON(_sceneApiUrl, "POST", [{ key: "content-type", value: "application/json" }, { key: "authorization", value: "Bearer " + this.options.accessToken }], { modelKey: `/${_sceneName}/model/${_sceneName}.avwc` }); Promise.all([i, r, n]).then((i => { try { for (let e in i) i[e] = JSON.parse(i[e]) } catch (e) { t(e) } _sceneConfigPath = i[0].success ? i[0].modelUrl : "", _defaultModelPath = i[1].success ? i[1].modelUrl : "", _defaultModelConfigPath = i[2].success ? i[2].modelUrl : "", _defaultModelPath.startsWith("http://") && (_defaultModelPath = _defaultModelPath.replace("http://", "//")), _defaultModelPath.startsWith("https://") && (_defaultModelPath = _defaultModelPath.replace("https://", "//")), _defaultModelConfigPath.startsWith("http://") && (_defaultModelConfigPath = _defaultModelConfigPath.replace("http://", "//")), _defaultModelConfigPath.startsWith("https://") && (_defaultModelConfigPath = _defaultModelConfigPath.replace("https://", "//")), _sceneConfigPath.startsWith("http://") && (_sceneConfigPath = _sceneConfigPath.replace("http://", "//")), _sceneConfigPath.startsWith("https://") && (_sceneConfigPath = _sceneConfigPath.replace("https://", "//")), e() })).catch((e => { t(e) })) } else e() })) } _generateLableCanvas(e, t, i, r, n, a, o) { let s = document.createElement("canvas"), l = s.getContext("2d"); var c = 8 * t, h = ""; i && (h = "bold"); var u = ""; return r && (u = "italic"), l.font = `${u} ${h} ${c}px ${e}`, s.width = l.measureText(o).width + c, s.height = 2 * c, l.fillStyle = n, l.fillRect(0, 0, s.width, s.height), l.font = `${u} ${h} ${c}px ${e}`, l.fillStyle = a, l.textAlign = "center", l.textBaseline = "middle", l.fillText(o, s.width / 2, s.height / 2), s } rotatingModel(e, t) { _core.defaultObjectTree.getItemByName(e.id) ? (_core.rotatingModel(e), t && t({ result: 1, message: "成功。" })) : t({ result: 0, message: `失败，模型 ${e.id} 不存在。` }) } setModelRotationState(e, t) { _core.defaultObjectTree.getItemByName(e.id) ? (_core.setModelRotationState(e), t && t({ result: 1, message: "成功。" })) : t({ result: 0, message: `失败，模型 ${e.id} 不存在。` }) } blinkingModel(e, t) { _core.defaultObjectTree.getItemByName(e.id) ? (_core.blinkingModel(e), t && t({ result: 1, message: "成功。" })) : t({ result: 0, message: `失败，模型 ${e.id} 不存在。` }) } setModelBlinkState(e, t) { _core.defaultObjectTree.getItemByName(e.id) ? (_core.setModelBlinkState(e), t && t({ result: 1, message: "成功。" })) : t({ result: 0, message: `失败，模型 ${e.id} 不存在。` }) } movingModel(e, t) { if (_core.defaultObjectTree.getItemByName(e.id)) { if (0 == e.coordType) { let t = []; e.points && e.points.forEach((e => { let i = this.convertLLAToXYZ(e); i.speed = e.speed, t.push(i) })), e.points = t } _core.movingModel({ id: e.id, loopMode: e.loopMode, reverse: e.reverse, direction: e.direction, offset: e.offset, points: e.points }), t && t({ result: 1, message: "成功。" }) } else t({ result: 0, message: `失败，模型 ${e.id} 不存在。` }) } setModelMoveState(e, t) { _core.defaultObjectTree.getItemByName(e.id) ? (_core.setModelMoveState(e), t && t({ result: 1, message: "成功。" })) : t({ result: 0, message: `失败，模型 ${e.id} 不存在。` }) } pathingModel(e, t) { _core.defaultObjectTree.getItemByName(e.id) ? (_core.pathingModel(e), t && t({ result: 1, message: "成功。" })) : t({ result: 0, message: `失败，模型 ${e.id} 不存在。` }) } updatePathingModel({ layer: e, setPathPass: t } = {}) { let i = e.getPositions(), r = e.id; _core.updatePathingModel(r, i, t) } deletePathingModel({ layerIds: e }) { e.forEach((e => { _core.deletePathingModel(e) })) } setModelPathingState(e, t) { _core.defaultObjectTree.getItemByName(e.id) ? (_core.setModelPathingState(e), t && t({ result: 1, message: "成功。" })) : t({ result: 0, message: `失败，模型 ${e.id} 不存在。` }) } selectModel(e, t) { _core.selectModel(e, t) } endSelectModel(e) { _core.endSelectModel(e) } pickModel(e, t) { _core.pickModel(e, t) } endPickModel(e) { _core.endPickModel(e) } clickModel(e, t, i) { _core.defaultObjectTree.getItemByName(e.id) ? _core.clickModel(e, t, i) : t({ result: 0, message: `失败，模型 ${e.id} 不存在。` }) } clickModelType(e, t) { _core.clickModelType(e, t) } clearModelSelected(e) { _core.clearModelSelected(e) } highlightBuilding(e, t) { _core.highlightBuilding(e, t) } highlightFloor(e, t) { _core.highlightFloor(e, t) } highlightRoom(e, t) { _core.highlightRoom(e, t) } getBuildings(e, t) { _core.getBuildings(e, t) } focusFloor(e, t, i) { _core.focusFloor(e, t, i) } getModelArticulation(e, t) { _core.getModelArticulation(e, t) } setModelArticulation(e, t) { _core.setModelArticulation(e, t) } getModelAnimation(e, t) { _core.getModelAnimation(e, t) } playModelAnimation(e, t) { _core.playModelAnimation(e, t) } setModelAnimation(e, t) { _core.setModelAnimation(e, t) } getWorldScale() { return _core.getWorldScale() } removeMarker(e, t, i) { e !== _SYS_LAYER_INFO_PANEL && e !== _SYS_LAYER_HEAT_MAP ? this.removeDrawable(e, t, i) : i && i(0, "参数错误。") } triggerMarker(e, t, i) { let r = this.getDrawable(e, t); switch (void 0 === r && logger.warn("Scene.triggerMarker(layerName, markerName, action) 未找到指定的散点。", e, t, i), i) { case Scene$1.MARKER_ACTION.FLASH_START: _core.startFlashSprite(r.parent + "/" + r.name); break; case Scene$1.MARKER_ACTION.FLASH_STOP: _core.stopFlashSprite(r.parent + "/" + r.name); break; default: logger.warn("Scene.triggerMarker(layerName, markerName, action) 传入参数有误。", e, t, i) }return this } triggerMarkerByFullName(e, t) { if (!e || "" === e) return void logger.warn("Scene.triggerMarkerByFullName(markerFullName, action) 传入参数有误。", e, t); let i = e.split("/"); if (i && i.length && 2 == i.length) return this.triggerMarker(i[0], i[1], t); logger.warn("Scene.triggerMarkerByFullName(markerFullName, action) 传入参数有误。", e, t) } removeFireFly(e) { _core.removeFireFly(e) } addMarker(e, t, i) { if (t) return t.type = "marker", this.addDrawable(e, t, i); i && i(0, "Scene.addMarker(markerInfo, callback) 传入参数有误。") } addMarkers(e, t) { if (t && t instanceof Array) { for (let i of t) i.type = "marker", this.addDrawable(e, i); return this } callback && callback(0, "Scene.addMarkers(layerName, markers, callback) 传入参数有误。") } addFlashMarker(e, t, i) { if (t) if (t.icons instanceof Array) { if (!(t.icons.length <= 0 || t.icons.length > 64)) return t.type = "flashmarker", this.addDrawable(e, t, i); i && i(0, "Scene.addFlashMarker(markerInfo, callback) 传入参数有误。闪烁图片个数在 1 - 64 之间。") } else i && i(0, "Scene.addFlashMarker(markerInfo, callback) 传入参数有误。"); else i && i(0, "Scene.addFlashMarker(markerInfo, callback) 传入参数有误。") } addFlashMarkers(e, t) { if (t && t instanceof Array) { for (let i of t) i.type = "flashmarker", this.addDrawable(e, i); return this } callback && callback(0, "Scene.addMarkers(layerName, markers, callback) 传入参数有误。") } isMarkerFlashing(e, t) { let i = this.getDrawable(e, t); if (void 0 !== i) return _core.isSpriteFlashing(i.parent + "/" + i.name); logger.warn("Scene.isMarkerFlashing(layerName, markerName) 未找到指定的散点。", e, t) } isMarkerFlashingByFullName(e) { if (!e || "" === e) return void logger.warn("Scene.isMarkerFlashingByFullName(markerFullName) 传入参数有误。", e); let t = e.split("/"); if (t && t.length && 2 == t.length) return this.isMarkerFlashing(t[0], t[1]); logger.warn("Scene.isMarkerFlashingByFullName(markerFullName) 传入参数有误。", e) } addFireFly(e) { if (e.position && "lla" === e.position.type.toLowerCase()) { let t = _core.convertLLAToXYZ({ x: e.position.lon, y: e.position.lat, z: e.position.alt }); e.position.x = t.x, e.position.y = t.y, e.position.z = t.z } _core.addFireFly(e) } additionalInfo(e) { return this.additionalInfo = e, this } author(e) { return this.author = e, this } changeScene(e) { let t = this.lodSceneConfig.find((t => t.model === e)); if (t) { for (let t of this.lodSceneConfig) t.model !== e ? this.hideModelByName(t.model) : this.showModelByName(t.model); t.config && this.loadSceneConfig(t.config) } } clearPerfLog() { _core.clearPerfLog() } getAuthor() { return this.author } getLastPerfLog() { return _core.getLastPerfLog() } getSceneConfig() { } getType() { return this.type } getTypeText() { switch (this.type) { case Scene$1.TYPE.NATIVE: return "Digihail"; case Scene$1.TYPE.HW_PARK: return "Huawei Park"; default: return "Unknown" } } hideFireFly(e) { _core.hideFireFly(e) } initMulti(e, t) { switch (this.options = e, this.options.coordinateSystem || (this.options.coordinateSystem = Scene$1.COORDINATE_SYSTEM.SURFACE), this.options.coordinateSystem) { case Scene$1.COORDINATE_SYSTEM.SURFACE: case Scene$1.COORDINATE_SYSTEM.ECEF: case Scene$1.COORDINATE_SYSTEM.PLANAR_GLOBAL: case Scene$1.COORDINATE_SYSTEM.PLANAR_LOCAL: break; case Scene$1.COORDINATE_SYSTEM.WGS84: this.options.coordinateSystem = Scene$1.COORDINATE_SYSTEM.SURFACE; break; case Scene$1.COORDINATE_SYSTEM.XYZ: break; default: this.options.coordinateSystem = Scene$1.COORDINATE_SYSTEM.SURFACE }switch (this.options.angleUnit || (this.options.angleUnit = Scene$1.ANGLE_UNIT.DEGREE), this.options.angleUnit) { case Scene$1.ANGLE_UNIT.DEGREE: case Scene$1.ANGLE_UNIT.RAD: break; default: this.options.angleUnit = Scene$1.ANGLE_UNIT.DEGREE }if (this.url && e.container) { -1 !== this.url.indexOf("/", this.url.length - 1) && (this.url = this.url.substring(0, this.url.length - 1)), this.url.startsWith("http://") && (this.url = this.url.replace("http://", "//")), this.url.startsWith("https://") && (this.url = this.url.replace("https://", "//")); let a = this.url + `/${_SCENE_CONFIG_FILE_NAME}`; try { let o = { fogEnable: !1, fogColor: "#00aaff", fogNear: 200, fogFar: 2e4, clearPassEnable: !0, clearColor: "#00aaff", clearAlpha: 1, texturePassEnable: !1, texturePassImagePath: "texture/backgroundImage.png", texturePassOpacity: 1, cubeTexturePassEnable: !1, cubeTextureFolderPath: "texture/cubemap/day/", cubeTexturePostFix: ".png", cubeTexturePassOpacity: 1, renderPassEnable: !0, ssaoPassEnable: !1, kernelRadius: 16, minDistance: .001, maxDistance: .3, bloomPassEnable: !1, exposure: 1, bloomStrength: 1.5, bloomThreshold: 1, bloomRadius: .01, taaRenderPassEnable: !1, smaaPassEnable: !0, fxaaPassEnable: !1, filmPassEnable: !1, noiseIntensity: .8, scanlinesIntensity: .325, scanlinesCount: 256, grayscale: !1, glitchPassEnable: !1, halftonePassEnable: !1, pixelPassEnable: !1, pixelSize: 16, blurPassEnable: !0, blurExposure: .02, showSky: !1, oceanEnable: !1, oceanVerticalOffset: 1, fireflyEnable: !1, resourceBasePath: "", isManaged: !1 }; if (this.type === Scene$1.TYPE.GIS_3D && (o.isManaged = !0), this.additionalInfo && this.additionalInfo.resourceBasePath && (o.resourceBasePath = this.additionalInfo.resourceBasePath), !this.options.container) return logger.warn(`模型加载出错。无效的容器名称（${this.options.container}）。`), void (t && t(0)); o.width = this.options.container.offsetWidth || window.innerWidth, o.height = this.options.container.offsetHeight || window.innerHeight, this.options.container.style.width = o.width + "px", this.options.container.style.height = o.height + "px", this.options.container.style.backgroundColor = "#303f50", this.options.container.style.outline = "0 none !important", this.options.container.style.blur = "expression(this.onFocus=this.blur())"; try { var i = new XMLHttpRequest, r = this; i.onreadystatechange = function () { if (4 == i.readyState) { if (200 == i.status || 304 == i.status) try { let e = JSON.parse(i.responseText); if (e) { logger.debug("已读取场景配置（可选）。"); for (let t in e) o[t] = e[t] } } catch (e) { logger.debug(`场景配置（可选）内容无效，已忽略：${e}`) } else logger.debug("未找到场景配置（可选），已忽略。"); let a = []; if (o.models && o.models.length > 0) for (let e of o.models) e.name && e.type && (e.pathModel = `${r.url}/model/${e.name}.${e.type}`, "avwm" === e.type.toLowerCase() ? e.pathConfig = `${r.url}/model/${e.name}.avwc` : e.pathConfig = "", e.lastUpdated > -1 && (e.pathModel += `^lastUpdated=${e.lastUpdated}`), a.push(e)); if (0 === a.length && (a = [{ name: "main", type: "avwm", lastUpdated: -1, offset: [0, 0, 0], rotation: [0, 0, 0], pathModel: `${r.url}/model/main.avwm`, pathConfig: `${r.url}/model/main.avmc` }]), _models = [], (_core = new avw.AVW.Core(e.container, o)).LoadModel(a[0].name, a[0].pathModel, o, (function (e, n) { if (1 === e) { "boolean" != typeof a[0].visible || a[0].visible || _core.hideModelByName(a[0].name); try { i.onreadystatechange = function () { if (4 == i.readyState) { if (200 == i.status || 204 == i.status) try { let e = JSON.parse(i.responseText); if (e) { if (logger.debug("已读取模型节点配置（可选）。"), e.nodeSettings && e.nodeSettings.length && e.nodeSettings.length > 0) for (let t of e.nodeSettings) _core.setNodeParam(a[0].name, t); if (e.materialSettings && e.materialSettings.length && e.materialSettings.length > 0) for (let t of e.materialSettings) _core.setMaterialParam(a[0].name, t); e.buildingIndex && e.buildingIndex.length && e.buildingIndex.length > 0 && (r.options.buildingIndex = e.buildingIndex) } } catch (e) { logger.debug(`模型节点配置（可选）内容无效，已忽略：${e}。`) } else logger.debug("未找到模型节点配置（可选），已忽略。"); t && t(1, "完成。") } }, logger.debug(`寻找模型节点配置（可选）：“${a[0].pathConfig}”。`), i.open("GET", a[0].pathConfig, !0), i.send() } catch (e) { logger.debug("未找到模型节点配置（可选），已忽略。") } } else t && t(e, n) }), (function (e, t) { logger.debug("onProgress", e, t) })), _models.push(new Model$1({ name: a[0].name, src: a[0].pathModel })), a.length > 1) { logger.debug("读取到多个模型请求。", a); for (let e = 1; e < a.length; e++)_core.LoadModel(a[e].name, a[e].pathModel, void 0, (function (t, i) { 1 === t && ("boolean" != typeof a[e].visible || a[e].visible || _core.hideModelByName(a[e].name), _models.push(new Model$1({ name: a[e].name, src: a[e].pathModel }))) })) } !r.options.accessToken && (r.url.indexOf("sip") >= 0 || r.url.indexOf("ark") >= 0 && r.url.indexOf("ou") >= 0 && r.url.indexOf("uz") >= 0) && (_core.LoadModel("misc01", r.url + "/model/misc01.avwm"), _core.LoadModel("misc02", r.url + "/model/misc02.avwm"), _models.push(new Model$1({ name: "misc01", src: r.url + "/model/misc01.avwm" })), _models.push(new Model$1({ name: "misc02", src: r.url + "/model/misc01.avwm" }))), (r.url.indexOf("china") >= 0 || r.url.indexOf("black") >= 0 && r.url.indexOf("blue") >= 0) && (_core.LoadModel("beijing", r.url + "/model/beijing.avwm"), _core.LoadModel("hebei", r.url + "/model/hebei.avwm"), _models.push(new Model$1({ name: "beijing", src: r.url + "/model/beijing.avwm" })), _models.push(new Model$1({ name: "hebei", src: r.url + "/model/hebei.avwm" }))); var n = {}; if (r.options.center && 3 === r.options.center.length ? (n.lon = r.options.center[0], n.lat = r.options.center[1], n.alt = r.options.center[2], n.scaleX = 1, n.scaleY = 1, n.scaleZ = 1) : o.center && 3 === o.center.length ? (n.lon = o.center[0], n.lat = o.center[1], n.alt = o.center[2], n.scaleX = 1, n.scaleY = 1, n.scaleZ = 1) : (r.options.coordinateSystem = Scene$1.COORDINATE_SYSTEM.XYZ, logger.warn("未设置基准经纬度，将无法使用经度、纬度、海拔高度作为坐标。已自动将场景坐标系统设置为“XYZ（右手坐标系）”。")), r.options.view ? r.view(r.options.view) : r.options.camera && r.setCamera(r.options.camera), o.lighting) { let e = o.lighting; if (e.skyLight && e.directLights && e.directLights[0] && (_core.setDefaultLight(e.skyLight, e.directLights[0]), e.directLights.length > 1)) for (let t = 1; t < e.directLights.length; t++)_core.addDirLight(e.directLights[t]) } } }; var n = a; logger.debug(`寻找场景配置（可选）：${n}`), i.open("GET", n, !0), i.send() } catch (e) { logger.debug("未找到场景配置（可选），已忽略。") } } catch (e) { logger.warn(`模型加载出错。${e}`), _models = [], t && t(0, `模型加载出错。${e}`) } } return this } leftButtonHandle(e) { _core.leftButtonHandle(e) } name(e) { return this.name = e, this } loadSceneConfig(e, t) { } perfTest(e, t, i) { e && e.start && e.phrases instanceof Array ? (e.start && this.setCamera(new Camera$1({ target: new Position(e.positionType).set(e.start.target[0], e.start.target[1], e.start.target[2]), posture: e.start.posture, distance: e.start.distance })), this.perfTestFlyTo(e.phrases, 0, e.positionType, t, i)) : logger.warn("perfTest(testing) 参数错误。", e) } perfTestFlyTo(e, t, i, r, n) { if (_isPerfTesting) { var a = this; if (n && n(t / e.length), t >= e.length) { if (this.stopPerfLog(), r) { let e = this.getLastPerfLog(); r(e) } } else switch (e[t].type.toLowerCase()) { case "flyto": this.flyTo({ center: e[t].target, rph: e[t].posture, distance: e[t].distance }, e[t].duration, 0, 0, (function () { a.perfTestFlyTo(e, ++t, i, r, n) })); break; case "sleep": setTimeout((function () { a.perfTestFlyTo(e, ++t, i, r, n) }), 1e3 * e[t].duration) } } } render() { _core.render() } setBackgroundTransparent() { _core.setBackgroundTransparent() } setDefaultBackgroundImage() { _core.setDefaultBackgroundImage() } setDefaultFog() { _core.setDefaultFog() } setDefaultSkyBox() { _core.setDefaultSkyBox() } setFog(e) { } setMaterialParam(e, t) { _core.setMaterialParam(e, t) } setNodeParam(e, t) { _core.setNodeParam(e, t) } setOcean(e) { _core.initOcean(e) } setSceneConfig(e) { _core.setSceneConfig(e) } setSize(e, t) { _core.changeSize(e, t) } setSky(e) { _core.initSky(e) } setSkybox(e, t, i = "#ffffff") { _core.setSkybox(e, t, i) } showFireFly(e) { _core.showFireFly(e) } skybox(e) { let t; switch (e) { case Scene$1.SKYBOX.NIGHT: t = { cubeTexturePassEnable: !0, cubeTextureFolderPath: "texture/cubemap/night/", cubeTexturePostFix: ".png", cubeTexturePassOpacity: 1, fogColor: "0x1f517b", showSky: !1 }; break; case Scene$1.SKYBOX.DUSK: t = { cubeTexturePassEnable: !0, cubeTextureFolderPath: "texture/cubemap/dusk/", cubeTexturePostFix: ".png", cubeTexturePassOpacity: 1, fogColor: "0xbe6769", showSky: !1 }; break; case Scene$1.SKYBOX.DAY: t = { cubeTexturePassEnable: !0, cubeTextureFolderPath: "texture/cubemap/day/", cubeTexturePostFix: ".png", cubeTexturePassOpacity: 1, fogColor: "0xa4dae6", showSky: !1 }; break; case Scene$1.SKYBOX.SIMPLE: default: t = { cubeTexturePassEnable: !1, showSky: !0 } }return _core.setSkyBox({ skyboxPath: t.cubeTextureFolderPath, filetype: t.cubeTexturePostFix, enabled: !0 }), _core.setFog({ fogColor: Number(t.fogColor), fogAppearDist: 0, fogDisAppearDist: 1e3, enabled: !0 }), this } spliceDrawable(e, t) { this.getLayer(e)._drawables.map(((i, r) => { i.name == t && this.getLayer(e)._drawables.splice(r, 1) })) } startPerfLog() { _isPerfTesting = !0, _core.startPerfLog() } stopPerfLog() { _isPerfTesting = !1, _core.stopPerfLog() } switch(e, t, i, r) { this.destroy(), this.url = e.url || "", this.name = e.name || "", this.author = e.author || "", this.type = e.type || "", this.additionalInfo = e.additionalInfo || {}, this.options = t || this.options, _layers$2 = [], _models = [], _core = {}, _showStats = !1, this.init(t, (function (e) { r(e) })) } toJson() { return JSON.stringify(_layers$2) } type(e) { return this.type = e, this } updateFireFly(e, t) { if (t.position && "lla" === t.position.type.toLowerCase()) { let e = _core.convertLLAToXYZ({ x: t.position.lon, y: t.position.lat, z: t.position.alt }); t.position.x = e.x, t.position.y = e.y, t.position.z = e.z } _core.updateFireFly(e, t) } url(e) { return this.url = e, this } setSceneEffect(e) { _core.setSceneEffect(e) } add3DTile(e, t) { _core.add3DTileSet(e, t) } remove3DTileSet(e) { _core.remove3DTileSet(e) } remove3DTileByID(e, t) { _core.remove3DTileByID(e, t) } clear3DTileSets() { _core.clear3DTileSets() } update3DTile(e, t) { let { id: i } = e; e.isApi = !0, e.isVisible = e.visible, _core.remove3DTileByID(i, (i => { 1 == i.result ? _core.add3DTileSet(e, t) : t && t(i) })) } update3DTileStyle(e, t) { _core.update3DTileStyle(e, t) } setCameraTo3DTile(e) { _core.setCameraTo3DTile(...arguments) } } Scene$1.TYPE = { NATIVE: Symbol("NATIVE"), HW_PARK: Symbol("HW_PARK"), GIS_3D: Symbol("GIS_3D") }, Scene$1.XYZ = Symbol("XYZ"), Scene$1.SURFACE = Symbol("SURFACE"), Scene$1.ECEF = Symbol("ECEF"), Scene$1.PLANAR_LOCAL = Symbol("PLANAR_LOCAL"), Scene$1.MERCATOR = Symbol("MERCATOR"), Scene$1.WGS84 = Symbol("WGS84"), Scene$1.ANGLE_UNIT = { DEGREE: Symbol("DEGREE"), RAD: Symbol("RAD") }, Scene$1.TRANS_TYPE = { LINEAR: Symbol("LINEAR"), SINE: Symbol("SINE"), CUBIC: Symbol("CUBIC") }, Scene$1.EASE_TYPE = { IN: Symbol("IN"), OUT: Symbol("OUT"), IN_OUT: Symbol("IN_OUT") }, Scene$1.SKYBOX = { DAY: Symbol("DAY"), DUSK: Symbol("DUSK"), NIGHT: Symbol("NIGHT") }, Scene$1.MARKER_ACTION = { FLASH_START: Symbol("FLASH_START"), FLASH_STOP: Symbol("FLASH_STOP") }, window.logger = { debug: function () { }, info: function () { }, warn: function () { }, error: function () { }, dir: function () { }, time: function () { }, timeEnd: function () { } }, window.isDebug && (window.logger = { debug: console.debug.bind(window.console), info: console.info.bind(window.console), warn: console.warn.bind(window.console), error: console.error.bind(window.console), dir: console.dir.bind(window.console), time: console.time.bind(window.console), timeEnd: console.timeEnd.bind(window.console) }); const scene$1 = function (e, t) { return new Scene$1(e, t) }, debug = function (e) { window.logger = e ? { debug: console.debug.bind(window.console), info: console.info.bind(window.console), warn: console.warn.bind(window.console), error: console.error.bind(window.console), dir: console.dir.bind(window.console), time: console.time.bind(window.console), timeEnd: console.timeEnd.bind(window.console) } : { debug: function () { }, info: function () { }, warn: function () { }, error: function () { }, dir: function () { }, time: function () { }, timeEnd: function () { } } }; class BaseComponent { constructor() { this.isComponent = !0, this.type = "baseComponent", this.scene = null, this.interfaceList = [] } setScene(e) { this.scene = e } getInterface() { return this.interfaceList || [] } deepCopy(e) { let t; void 0 !== e.tag && (t = e.tag, delete e.tag); const i = JSON.parse(JSON.stringify(e)); return i.tag = t, i } checkString(e) { return !new RegExp("[`~!@#$^&*()=|{}':;',\\[\\].<>《》/?~！@#￥……&*（）——|{}【】‘；：”“'。，、？]").test(e) } checkIsColor(e) { let t = ""; if (/^rgb\(/.test(e)) t = "^[rR][gG][Bb][(]([\\s]*(2[0-4][0-9]|25[0-5]|[01]?[0-9][0-9]?)[\\s]*,){2}[\\s]*(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)[\\s]*[)]{1}$"; else if (/^rgba\(/.test(e)) t = "^[rR][gG][Bb][Aa][(]([\\s]*(2[0-4][0-9]|25[0-5]|[01]?[0-9][0-9]?)[\\s]*,){3}[\\s]*(1|1.0|0|0.[0-9])[\\s]*[)]{1}$"; else if (/^#/.test(e)) t = "^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$"; else if (/^hsl\(/.test(e)) t = "^[hH][Ss][Ll][(]([\\s]*(2[0-9][0-9]|360｜3[0-5][0-9]|[01]?[0-9][0-9]?)[\\s]*,)([\\s]*((100|[0-9][0-9]?)%|0)[\\s]*,)([\\s]*((100|[0-9][0-9]?)%|0)[\\s]*)[)]$"; else { if (!/^hsla\(/.test(e)) return !1; t = "^[hH][Ss][Ll][Aa][(]([\\s]*(2[0-9][0-9]|360｜3[0-5][0-9]|[01]?[0-9][0-9]?)[\\s]*,)([\\s]*((100|[0-9][0-9]?)%|0)[\\s]*,){2}([\\s]*(1|1.0|0|0.[0-9])[\\s]*)[)]$" } return null !== e.match(new RegExp(t)) } addEventListener(e, t) { void 0 === this._listeners && (this._listeners = {}); const i = this._listeners; void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t) } removeEventListener(e, t) { if (void 0 === this._listeners) return; const i = this._listeners[e]; if (void 0 !== i) { const e = i.indexOf(t); -1 !== e && i.splice(e, 1) } } dispatchEvent(e) { if (void 0 === this._listeners) return; const t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; const i = t.slice(0); for (let t = 0, r = i.length; t < r; t++)i[t].call(this, e); e.target = null } } } class Resource extends BaseComponent { constructor() { super(), this.isResource = !0, this.type = "Resource", this.resourceFileName = "resource.json", this.areaType = ["arrow01", "gradient01", "gradient02", "gradient03", "grid01", "grid02", "grid03", "grid04", "grid05", "segment01", "segment02", "segment03"], this.areaFillType = ["gradient01", "gradient02", "grid01", "grid02", "segment01", "segment02"], this.pathType = ["arrow01", "arrow02", "arrow03", "arrow04", "arrow05", "arrow06", "segment01", "segment02", "segment03", "segment04", "segment05", "segment06"] } setScene(e) { super.setScene(e), this.resourcePath = "/", this.resource = {} } setResourcePath(e) { return this.resourcePath = e, new Promise(((t, i) => { let r = new XMLHttpRequest; r.onreadystatechange = () => { 4 === r.readyState && (200 == r.status || 204 == r.status || 304 == r.status ? (this.resource = JSON.parse(r.responseText), void 0 !== this.resource.clusters && this.resource.icons.push(...this.resource.clusters), t("已加载资源库配置。")) : i("加载资源库配置错误。")) }, r.open("GET", `${e}\\${this.resourceFileName}`, !0), r.send(null) })) } isContainIconAsset(e) { let t = this.scene.isContentAssets(e); return t || (e = e.toLowerCase(), t = -1 !== this.resource.icons.findIndex((t => t.name == e))), t } isContainAreaType(e) { return e = e.toLowerCase(), -1 !== this.areaType.indexOf(e) } isContainAreaFillType(e) { return e = e.toLowerCase(), -1 !== this.areaFillType.indexOf(e) } isContainPathType(e) { return e = e.toLowerCase(), -1 !== this.pathType.indexOf(e) } isContainModelAsset(e) { return this.scene.isContentAssets(e, "ModelItem") } getIconAsset(e) { if (this.scene.isContentAssets(e)) return { useIconAsset: !0, iconAssetName: e.indexOf("custom-") > -1 ? e.replace("custom-", "") : e }; e = e.toLowerCase(); const t = this.resource.icons.find((t => t.name == e)); return void 0 !== t.asset ? JSON.parse(JSON.stringify(t.asset)) : new Promise(((e, i) => { let r = new XMLHttpRequest; r.onreadystatechange = () => { if (4 === r.readyState) if (200 == r.status || 204 == r.status || 304 == r.status) { let i = JSON.parse(r.responseText); i.icon = `${this.resourcePath}${t.path}`, i.useIconAsset = !1, t.asset = i, e(JSON.parse(JSON.stringify(i))) } else logger.error(`图标样式资源 ${t.style} 读取失败，错误码:${r.status}`), i({}) }, r.open("GET", `${this.resourcePath}${t.style}`, !0), r.send(null) })) } getMarkerAsset(e) { e = e.toLowerCase(); let t = this.resource.markers.find((t => t.name == e)); if (t) return t = this.deepCopy(t), t.path = `${this.resourcePath}${t.path}`, t } getIconAssetInfo(e) { return this.scene.getIconAssetInfo(e) } getTerrains() { return this.resource.terrain } } const resource = new Resource; var shapefile$1 = { exports: {} }; !function (e, t) { !function (e) { var t = function () { return this._array = null, Promise.resolve() }, i = function () { var e = this._array; return this._array = null, Promise.resolve(e ? { done: !1, value: e } : { done: !0, value: void 0 }) }; function r(e) { return new n(e instanceof Uint8Array ? e : new Uint8Array(e)) } function n(e) { this._array = e } n.prototype.read = i, n.prototype.cancel = t; var a = function (e) { return fetch(e).then((function (e) { return e.body && e.body.getReader ? e.body.getReader() : e.arrayBuffer().then(r) })) }, o = function (e) { return new Promise((function (t, i) { var n = new XMLHttpRequest; n.responseType = "arraybuffer", n.onload = function () { t(r(n.response)) }, n.onerror = i, n.ontimeout = i, n.open("GET", e, !0), n.send() })) }; function s(e) { return ("function" == typeof fetch ? a : o)(e) } function l(e) { return "function" == typeof e.read ? e : e.getReader() } var c = new Uint8Array(0), h = function () { return this._source.cancel() }; function u(e, t) { if (!e.length) return t; if (!t.length) return e; var i = new Uint8Array(e.length + t.length); return i.set(e), i.set(t, e.length), i } var d = function () { var e = this, t = e._array.subarray(e._index); return e._source.read().then((function (i) { return e._array = c, e._index = 0, i.done ? t.length > 0 ? { done: !1, value: t } : { done: !0, value: void 0 } : { done: !1, value: u(t, i.value) } })) }, p = function (e) { if ((e |= 0) < 0) throw new Error("invalid length"); var t = this, i = this._array.length - this._index; if (this._index + e <= this._array.length) return Promise.resolve(this._array.subarray(this._index, this._index += e)); var r = new Uint8Array(e); return r.set(this._array.subarray(this._index)), function n() { return t._source.read().then((function (a) { return a.done ? (t._array = c, t._index = 0, i > 0 ? r.subarray(0, i) : null) : i + a.value.length >= e ? (t._array = a.value, t._index = e - i, r.set(a.value.subarray(0, e - i), i), r) : (r.set(a.value, i), i += a.value.length, n()) })) }() }; function f(e) { return "function" == typeof e.slice ? e : new m("function" == typeof e.read ? e : e.getReader()) } function m(e) { this._source = e, this._array = c, this._index = 0 } m.prototype.read = d, m.prototype.slice = p, m.prototype.cancel = h; var g = function () { return this._source.cancel() }, y = function (e) { return !(e = e.trim()) || isNaN(e = +e) ? null : e }, v = { B: y, C: function (e) { return e.trim() || null }, D: function (e) { return new Date(+e.substring(0, 4), e.substring(4, 6) - 1, +e.substring(6, 8)) }, F: y, L: function (e) { return !/^[nf]$/i.test(e) && (!!/^[yt]$/i.test(e) || null) }, M: y, N: y }, _ = function () { var e = this, t = 1; return e._source.slice(e._recordLength).then((function (i) { return i && 26 !== i[0] ? { done: !1, value: e._fields.reduce((function (r, n) { return r[n.name] = v[n.type](e._decode(i.subarray(t, t += n.length))), r }), {}) } : { done: !0, value: void 0 } })) }, b = function (e) { return new DataView(e.buffer, e.byteOffset, e.byteLength) }, x = function (e, t) { return (e = f(e)).slice(32).then((function (i) { var r = b(i); return e.slice(r.getUint16(8, !0) - 32).then((function (i) { return new w(e, t, r, b(i)) })) })) }; function w(e, t, i, r) { this._source = e, this._decode = t.decode.bind(t), this._recordLength = i.getUint16(10, !0), this._fields = []; for (var n = 0; 13 !== r.getUint8(n); n += 32) { for (var a = 0; a < 11 && 0 !== r.getUint8(n + a); ++a); this._fields.push({ name: this._decode(new Uint8Array(r.buffer, r.byteOffset + n, a)), type: String.fromCharCode(r.getUint8(n + 11)), length: r.getUint8(n + 16) }) } } var S = w.prototype; function M() { return this._source.cancel() } S.read = _, S.cancel = g; var T = function (e) { var t, i = 40, r = e.getInt32(36, !0), n = new Array(r); for (t = 0; t < r; ++t, i += 16)n[t] = [e.getFloat64(i, !0), e.getFloat64(i + 8, !0)]; return { type: "MultiPoint", coordinates: n } }, A = function (e) { return { type: "Point", coordinates: [e.getFloat64(4, !0), e.getFloat64(12, !0)] } }, E = function (e) { var t, i = 44, r = e.getInt32(36, !0), n = e.getInt32(40, !0), a = new Array(r), o = new Array(n), s = [], l = []; for (t = 0; t < r; ++t, i += 4)a[t] = e.getInt32(i, !0); for (t = 0; t < n; ++t, i += 16)o[t] = [e.getFloat64(i, !0), e.getFloat64(i + 8, !0)]; return a.forEach((function (e, t) { var i = o.slice(e, a[t + 1]); C(i) ? s.push([i]) : l.push(i) })), l.forEach((function (e) { s.some((function (t) { if (L(t[0], e)) return t.push(e), !0 })) || s.push([e]) })), 1 === s.length ? { type: "Polygon", coordinates: s[0] } : { type: "MultiPolygon", coordinates: s } }; function C(e) { if ((t = e.length) < 4) return !1; for (var t, i = 0, r = e[t - 1][1] * e[0][0] - e[t - 1][0] * e[0][1]; ++i < t;)r += e[i - 1][1] * e[i][0] - e[i - 1][0] * e[i][1]; return r >= 0 } function L(e, t) { for (var i, r = -1, n = t.length; ++r < n;)if (i = R(e, t[r])) return i > 0; return !1 } function R(e, t) { for (var i = t[0], r = t[1], n = -1, a = 0, o = e.length, s = o - 1; a < o; s = a++) { var l = e[a], c = l[0], h = l[1], u = e[s], d = u[0], p = u[1]; if (D(l, u, t)) return 0; h > r != p > r && i < (d - c) * (r - h) / (p - h) + c && (n = -n) } return n } function D(e, t, i) { var r = i[0] - e[0], n = i[1] - e[1]; if (0 === r && 0 === n) return !0; var a = t[0] - e[0], o = t[1] - e[1]; if (0 === a && 0 === o) return !1; var s = (r * a + n * o) / (a * a + o * o); return !(s < 0 || s > 1) && (0 === s || 1 === s || s * a === r && s * o === n) } var P = function (e) { var t, i = 44, r = e.getInt32(36, !0), n = e.getInt32(40, !0), a = new Array(r), o = new Array(n); for (t = 0; t < r; ++t, i += 4)a[t] = e.getInt32(i, !0); for (t = 0; t < n; ++t, i += 16)o[t] = [e.getFloat64(i, !0), e.getFloat64(i + 8, !0)]; return 1 === r ? { type: "LineString", coordinates: o } : { type: "MultiLineString", coordinates: a.map((function (e, t) { return o.slice(e, a[t + 1]) })) } }, O = function (e, t) { var i = new Uint8Array(e.length + t.length); return i.set(e, 0), i.set(t, e.length), i }, I = function () { var e = this; return ++e._index, e._source.slice(12).then((function (t) { if (null == t) return { done: !0, value: void 0 }; var i = b(t); function r() { return e._source.slice(4).then((function (a) { return null == a ? { done: !0, value: void 0 } : (i = b(t = O(t.slice(4), a))).getInt32(0, !1) !== e._index ? r() : n() })) } function n() { var n = 2 * i.getInt32(4, !1) - 4, a = i.getInt32(8, !0); return n < 0 || a && a !== e._type ? r() : e._source.slice(n).then((function (i) { return { done: !1, value: a ? e._parse(b(O(t.slice(8), i))) : null } })) } return n() })) }, k = { 0: function () { return null }, 1: A, 3: P, 5: E, 8: T, 11: A, 13: P, 15: E, 18: T, 21: A, 23: P, 25: E, 28: T }, B = function (e) { return (e = f(e)).slice(100).then((function (t) { return new N(e, b(t)) })) }; function N(e, t) { var i = t.getInt32(32, !0); if (!(i in k)) throw new Error("unsupported shape type: " + i); this._source = e, this._type = i, this._index = 0, this._parse = k[i], this.bbox = [t.getFloat64(36, !0), t.getFloat64(44, !0), t.getFloat64(52, !0), t.getFloat64(60, !0)] } var F = N.prototype; function U() { } F.read = I, F.cancel = M; var z = function () { return Promise.all([this._dbf && this._dbf.cancel(), this._shp.cancel()]).then(U) }, G = function () { var e = this; return Promise.all([e._dbf ? e._dbf.read() : { value: {} }, e._shp.read()]).then((function (e) { var t = e[0], i = e[1]; return i.done ? i : { done: !1, value: { type: "Feature", properties: t.value, geometry: i.value } } })) }, H = function (e, t, i) { return Promise.all([B(e), t && x(t, i)]).then((function (e) { return new V(e[0], e[1]) })) }; function V(e, t) { this._shp = e, this._dbf = t, this.bbox = e.bbox } var j = V.prototype; function W(e, t, i) { return "string" == typeof t ? (/\.dbf$/.test(t) || (t += ".dbf"), t = s(t)) : t instanceof ArrayBuffer || t instanceof Uint8Array ? t = r(t) : null != t && (t = l(t)), "string" == typeof e ? (/\.shp$/.test(e) || (e += ".shp"), void 0 === t && (t = s(e.substring(0, e.length - 4) + ".dbf").catch((function () { }))), e = s(e)) : e = e instanceof ArrayBuffer || e instanceof Uint8Array ? r(e) : l(e), Promise.all([e, t]).then((function (e) { var t = e[0], r = e[1], n = "windows-1252"; return i && null != i.encoding && (n = i.encoding), H(t, r, r && new TextDecoder(n)) })) } function $(e, t) { return "string" == typeof e ? (/\.shp$/.test(e) || (e += ".shp"), e = s(e)) : e = e instanceof ArrayBuffer || e instanceof Uint8Array ? r(e) : l(e), Promise.resolve(e).then(B) } function Y(e, t) { var i = "windows-1252"; return t && null != t.encoding && (i = t.encoding), i = new TextDecoder(i), "string" == typeof e ? (/\.dbf$/.test(e) || (e += ".dbf"), e = s(e)) : e = e instanceof ArrayBuffer || e instanceof Uint8Array ? r(e) : l(e), Promise.resolve(e).then((function (e) { return x(e, i) })) } function X(e, t, i) { return W(e, t, i).then((function (e) { var t = [], i = { type: "FeatureCollection", features: t, bbox: e.bbox }; return e.read().then((function r(n) { return n.done ? i : (t.push(n.value), e.read().then(r)) })) })) } j.read = G, j.cancel = z, e.open = W, e.openShp = $, e.openDbf = Y, e.read = X, Object.defineProperty(e, "__esModule", { value: !0 }) }(t) }(0, shapefile$1.exports); var shapefile = getDefaultExportFromCjs(shapefile$1.exports); class Layer { constructor(e, t = {}, i = []) { this.isLayer = !0, this.id = e || (new Date).toLocaleString({ hour12: !1 }), this.source = JSON.parse(JSON.stringify(t)), this.data = i, this.isShow = null == t.visible || t.visible, this.allowClickSelected = !1, this.allowHoverSelected = !1, this.allowMultipleSelected = !1 } getData(e) { return this.data.find((t => t.id == e)) } addData(e, t) { if (!0 === t) return this.data.push(e), void (e.parent = this); this.getData(e.id) ? logger.warn(`TGApp.Layer: 已经存在数据对象 ${e.id}。`) : this.data.push(e) } getPositions() { let e = []; for (const t of this.data) e.push(...t.getPositions()); return e } getPositionsByDataId(e) { let t = [], i = this.getData(e); return i && t.push(...i.getPositions()), t } getPositionsByLegend(e) { let t = []; for (const i of this.data) i.legendEquals(e) && t.push(...i.getPositions()); return t } } class Data { constructor(e, t = {}) { this.isData = !0, this.id = e || (new Date).toLocaleString({ hour12: !1 }), this.positions = [], this.source = JSON.parse(JSON.stringify(t)), this.parent = null, this.legend = void 0, this.area = void 0, this.segment = void 0, this.isSelected = !1 } setSource(e) { this.source = JSON.parse(JSON.stringify(e)) } getPositions() { return this.positions || [] } legendEquals(e) { return this.legend === e } } let _layers$1 = {}; class BaseOverlay extends BaseComponent { constructor() { super(), this.isOverlay = !0, this.type = "baseOverlay", this.layers = [], this.allowClickSelected = !1, this.allowHoverSelected = !1, this.allowMultipleSelected = !1, this.isShowDecorator = !0; let e = Object.getOwnPropertyNames(resource.__proto__); for (const t of e) this[t] || (this[t] = resource[t].bind(resource)) } get _layers() { return _layers$1 } setScene(e) { this.onDrawableMouseClick = this._onDrawableMouseEvent.bind(this, "click"), this.onDrawableMouseHover = this._onDrawableMouseEvent.bind(this, "hover"), this.onDrawableUnmouseHover = this._onDrawableMouseEvent.bind(this, "unhover"), super.setScene(e), this.layers = [], this.scene.on("click", "drawable", this.onDrawableMouseClick), this.scene.addEventListener("transformControls", "mouseDown", (e => this._onDrawableTransformStart(e))), this.scene.addEventListener("transformControls", "translate", (e => this._onDrawableTransform(e))), this.scene.addEventListener("transformControls", "mouseUp", (e => this._onDrawableTransformEnd(e))); const t = this.scene.tgapp.events; for (const e in t) { t[e].length > 0 && this.addSceneEventListener(e) } _layers$1 = [] } layerIdIsUsed(e) { return !!_layers$1[e] } getLayers() { return this.layers || [] } getLayer(e) { return this.layers.find((t => t.id == e)) } getLayerByDataId(e) { for (let t of this.layers) { if (t.getData(e)) return t } } addLayer(e) { this.getLayer(e.id) ? logger.warn(`TGApp.Overlay: 已经存在图层 ${e.id}。`) : (this.layers.push(e), _layers$1[e.id] = e) } createLayer(e, t = {}, i = []) { let r = new Layer(e, t, i); return r.allowClickSelected = this.allowClickSelected, r.allowHoverSelected = this.allowHoverSelected, this.addLayer(r), r } createData(e, t, i) { let r = new Data(e, t); return i && (i.addData(r), r.parent = i), r } showLayer(e) { let t = this.getLayer(e); return !!t && (t.isShow = !0, this.scene.showLayer(e), this.dispatchEvent({ type: "showLayer", layerIds: [e] }), !0) } hideLayer(e) { let t = this.getLayer(e); return !!t && (t.isShow = !1, this.scene.hideLayer(e), this.dispatchEvent({ type: "hideLayer", layerIds: [e] }), !0) } showAllLayer() { let e = []; for (const t of this.layers) !0 !== t.isPlot && (t.isShow = !0, this.scene.showLayer(t.id), e.push(t.id)); return this.dispatchEvent({ type: "showLayer", layerIds: e }), !0 } hideAllLayer() { let e = []; for (const t of this.layers) !0 !== t.isPlot && (t.isShow = !1, this.scene.hideLayer(t.id), e.push(t.id)); return this.dispatchEvent({ type: "hideLayer", layerIds: e }), !0 } removeLayer(e) { let t = this.layers.findIndex((t => t.id == e)); return -1 != t && (this.layers.splice(t, 1), delete _layers$1[e], this.scene.removeLayer(e), this.dispatchEvent({ type: "removeLayer", layerIds: [e] }), !0) } removeAllLayer() { if (this.layers.length <= 0) return !1; let e = []; for (let t = this.layers.length - 1; t >= 0; t--) { const i = this.layers[t]; !0 !== i.isPlot && (this.layers.splice(t, 1), delete _layers$1[i.id], this.scene.removeLayer(i.id), e.push(i.id)) } return this.dispatchEvent({ type: "removeLayer", layerIds: e }), !0 } openMouseSelection(e, t, i, r) { void 0 !== r && (this.isShowDecorator = !!r); let n = void 0 === e; n && ("click" === t && (this.allowClickSelected = !0), "hover" === t && (this.allowHoverSelected = !0), this.allowMultipleSelected = i); let a = []; if (n) a = this.getLayers(); else { let t = this.getLayer(e); t && a.push(t) } for (const e of a) "click" === t && (e.allowClickSelected = !0), "hover" === t && (e.allowHoverSelected = !0), e.allowMultipleSelected = i; this.selectionData() } closeMouseSelection(e, t) { let i = void 0 === e; i && ("click" === t && (this.allowClickSelected = !1), "hover" === t && (this.allowHoverSelected = !1), void 0 === t && (this.allowClickSelected = !1, this.allowHoverSelected = !1)); let r = []; if (i) r = this.getLayers(); else { let t = this.getLayer(e); t && r.push(t) } for (const e of r) { "click" === t && (e.allowClickSelected = !1), "hover" === t && (e.allowHoverSelected = !1), void 0 === t && (e.allowClickSelected = !1, e.allowHoverSelected = !1); for (const t of e.data) t.isSelected = !1 } this.selectionData() } selectionData(e, t) { if (void 0 !== e && e.length > 0) { e = e.map((e => ({ dataId: e.id, layerId: e.parent.id }))); for (const e of this.getLayers()) if (!0 !== e.allowMultipleSelected) for (const t of e.data) !0 === t.isSelected && (t.isSelected = !1, this.scene.deselectDrawable(e.id, t.id)); for (const i of e) { this.getLayer(i.layerId).getData(i.dataId).isSelected = t } this.scene.tgapp.triggerEvent.onClickOverlayResult({ type: this.type, id: e[0].layerId, ids: e.map((e => e.dataId)), selected: t }) } this.asyncSelectionState() } asyncSelectionState() { for (const e of this.getLayers()) for (const t of e.data) t.isSelected && this.isShowDecorator ? this.scene.selectDrawable(e.id, t.id) : this.scene.deselectDrawable(e.id, t.id) } onMouseSelection(e, t) { "click" === e && t.parent.allowClickSelected && this.selectionData([t], !t.isSelected), "hover" === e && t.parent.allowHoverSelected && this.selectionData([t], !0), "unhover" === e && t.parent.allowHoverSelected && this.selectionData([t], !1) } addSceneEventListener() { } removeSceneEventListener() { } _onDrawableMouseEvent(e, t, i, r) { if (!i) return; let n, a = this.layers.find((e => e.id == i.parent)); a && (n = r ? a.data.find((e => e.id == r)) : a.data.find((e => e.id == i.name)), n && (this.dispatchEvent({ type: "mouseEvent", option: e, layer: a, data: n, event: t, obj: i }), this.onMouseSelection(e, n), this.onMouseEvent({ type: e, layer: a, data: n, event: t, obj: i }))) } onMouseEvent({ } = {}) { } onFocusEvent({ } = {}) { } _onDrawableTransformStart({ target: e }) { const t = e.object, i = t.name.split("/")[0], r = t.name.split("/")[1], n = this.getLayer(i); if (!n) return; const a = n.getData(r); a && this.onTransformAxisDragStart({ target: e, object: t, layer: n, data: a }) } _onDrawableTransform({ target: e }) { const t = e.object, i = t.name.split("/")[0], r = t.name.split("/")[1], n = this.getLayer(i); if (!n) return; const a = n.getData(r); a && "translate" === e.mode && this.onTransformAxisDrag({ target: e, object: t, layer: n, data: a }) } _onDrawableTransformEnd({ target: e }) { const t = e.object, i = t.name.split("/")[0], r = t.name.split("/")[1], n = this.getLayer(i); if (!n) return; const a = n.getData(r); a && "translate" === e.mode && this.onTranslateDragEndEvent({ target: e, object: t, layer: n, data: a }) } onTransformAxisDragStart({ target: e, data: t, layer: i }) { } onTransformAxisDrag({ object: e, layer: t, data: i } = {}) { } onTranslateDragEndEvent({ object: e, layer: t, data: i } = {}) { } } let store = { zLevel: 1 }; class Path extends BaseOverlay { constructor() { super(), this.type = "path", this.interfaceList = ["addPath", "updatePathCoord", "updatePathStyle", "addPathShp", "setPathPass"] } addPath({ id: e, name: t, color: i, colorPass: r, points: n, pass: a, type: o, width: s, isPlot: l } = {}, c) { if (this.layerIdIsUsed(e)) return void (c && c({ result: 0, message: `失败，${e} 已存在。` })); let h = this.deepCopy(arguments[0]); h.data = [{ id: e, points: n }], null == a && (h.pass = 0); let u = this._convertLayer(h); u.zLevel = store.zLevel++, void 0 !== l && (u.isPlot = !0), this._drawLayer(u, c), this.dispatchEvent({ type: "addPath", layer: u }) } updatePathCoord({ id: e, points: t, isAppend: i } = {}, r) { if (!this.getLayer(e)) return void (r && r({ result: 0, message: `失败，未找到 ${e} 路径。` })); let n = this.deepCopy(arguments[0]); n.data = [{ id: e, points: t }]; let a = this._convertLayer(n); this._drawLayer(a, r), this.dispatchEvent({ type: "updatePathCoord", layer: a, setPathPass: this.setPathPass }) } updatePathStyle({ id: e, color: t, colorPass: i, type: r, width: n } = {}, a) { if (!this.getLayer(e)) return void (a && a({ result: 0, message: `失败，未找到 ${e} 路径。` })); let o = this.deepCopy(arguments[0]), s = this._convertLayer(o); this._drawLayer(s, a), this.dispatchEvent({ type: "updatePathStyle", layer: s }) } setPathPass({ id: e, pass: t, ratio: i = 1 }, r) { let n = path, a = n.getLayer(e); if (!a) return void (r && r({ result: 0, message: `失败，未找到 ${e} 路径。` })); let o = a.getData(e); if (!o) return void (r && r({ result: 0, message: `失败，未找到 ${e} 路径。` })); if (!o.inView) return void (r && r({ result: 0, message: `失败，${e} 路径未绘制。` })); let s = a.getPositions(), l = s.length; if (t >= l || t < 0) return; let c = 0, h = 0; for (let e = 0; e < l - 1; e++) { let i = s[e], r = s[e + 1], a = n.scene.getDistanceByPositions(i, r); c += a, t >= e + 1 && (h += a) } h += n.scene.getDistanceByPositions(s[t], s[t + 1]) * i, t = h / c, n.scene.updatePathPass(a.id, o.id, { pass: t }) } async addPathShp({ id: e, shpPath: t, coordZ: i } = {}, r) { if (this.getLayer(e)) return void (r && r({ result: 0, message: `失败，已存在 ${e} 路径。` })); let n = this.deepCopy(arguments[0]); n.data = [], await shapefile.open(t).then((t => t.read().then((async function r(a) { if (a.done) return; let o = { id: e + "-" + n.data.length, points: [] }; for (const e of a.value.geometry.coordinates) !e || e.length < 2 || o.points.push({ coord: e, coordZ: i }); return n.data.push(o), await t.read().then(r) })))).catch((e => logger.error(e.stack))); let a = this._convertLayer(n); this._drawLayer(a, r), this.dispatchEvent({ type: "addPathShp", layer: a }) } _convertLayer({ id: e, name: t, coordType: i, coordTypeZ: r, type: n, color: a, pass: o, colorPass: s, width: l, tag: c, isAppend: h = !0, data: u = [] } = {}) { let d = this.getLayer(e); d || (d = this.createLayer(e, arguments[0]), d.source.data = []), h || (d.source.data = [], d.data.forEach((e => this.scene.removeDrawable(d.id, e.id))), d.data = []), null != t && (d.source.name = t), null != i && (d.source.coordType = i), null != r && (d.source.coordTypeZ = r), null != n && (d.source.type = n), null != a && (d.source.color = a), null != s && (d.source.colorPass = s), null != l && (d.source.width = l), null != o && (d.source.pass = o), void 0 !== c && (d.source.tag = c); for (const e of u) { if (null == e.id) continue; e.coordType = d.source.coordType; let t = d.source.data.findIndex((t => t.id === e.id)); -1 == t ? d.source.data.push(e) : d.source.data[t].points.push(...e.points) } for (const e of d.source.data) { let t = d.getData(e.id); t || (t = this.createData(e.id, e, d)); let i = 0 == e.coordType ? "lla" : "xyz", r = e.points.map((e => { let t = new Position(i); return t.source = e, "lla" === i ? t.set(e.coord[0], e.coord[1], e.coordZ) : "xyz" === i && t.set(e.coord[0], e.coordZ, e.coord[1]), t })); t.positions = r, t.color = d.source.color, t.colorPass = d.source.colorPass, t.type = d.source.type, t.width = d.source.width, t.pass = d.source.pass } return d } async _drawLayer(e, t) { if (this.scene) { for (const t of e.data) { let i = {}; i.name = t.id, i.points = t.positions, i.color = t.color, i.colorPass = t.colorPass, i.pass = t.pass, i.pathType = t.type, i.width = t.width, i.isShow = e.isShow, i.zLevel = e.zLevel, t.inView ? await this.scene.updatePath(e.id, t.id, i) : (await this.scene.addPath(e.id, i), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } } addSceneEventListener(e) { "onPathHover" !== e && "onPathUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onPathHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onPathUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onPathHover" !== e && "onPathUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onPathHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onPathUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.onPathClick({ id: i.id, selected: i.isSelected, tag: void 0 === t.source.tag ? "" : t.source.tag, coord: [r.longitude, r.latitude], label: i.label, type: i.source.type }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.onPathHover({ id: i.id, tag: void 0 === t.source.tag ? "" : t.source.tag, coord: [r.longitude, r.latitude] }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onPathUnhover({ id: i.id, tag: void 0 === t.source.tag ? "" : t.source.tag }) } onFocusEvent({ type: e, layerId: t } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e || this.scene.tgapp.triggerEvent.onFocusAllPathEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllPathStart({}) : this.scene.tgapp.triggerEvent.onFocusPathEnd({ id: t }) : this.scene.tgapp.triggerEvent.onFocusPathStart({ id: t }) } onTransformAxisDragStart({ target: e, data: t, layer: i }) { "translate" === e.mode && this.scene.tgapp.triggerEvent.onTransformAxisDragStart({ idObj: t.id, idLayer: i.id, overlayType: this.type }) } onTransformAxisDrag({ object: e, layer: t, data: i } = {}) { const r = e.position, n = e.userData.center, a = { idObj: i.id, idLayer: t.id, overlayType: this.type, data: [] }, o = r.x - n.x, s = r.y - n.y, l = r.z - n.z; if (0 === t.source.coordType) { a.coordType = 0; for (const e of i.positions) { let t = e.x + o, i = e.y + s, r = e.z + l; if ("lla" === e.type) { const n = this.scene.convertLLAToXYZ(e); t = n.x + o, i = n.y + s, r = n.z + l } const n = this.scene.convertXYZToLLA({ x: t, y: i, z: r }); a.data.push({ coord: [n.x, n.y], coordZ: n.z }) } } else { a.coordType = t.source.coordType; for (const e of i.positions) { let t = e.x + o, i = e.y + s, r = e.z + l; a.data.push({ coord: [t, r], coordZ: i }) } } this.scene.tgapp.triggerEvent.onTransformAxisDrag(a) } onTranslateDragEndEvent({ object: e, layer: t, data: i } = {}) { const r = e.position, n = e.userData.center, a = { idObj: i.id, idLayer: t.id, overlayType: this.type, data: [] }, o = r.x - n.x, s = r.y - n.y, l = r.z - n.z; if (0 === t.source.coordType) { a.coordType = 0; for (const e of i.positions) { let t = e.x + o, i = e.y + s, r = e.z + l; if ("lla" === e.type) { const n = this.scene.convertLLAToXYZ(e); t = n.x + o, i = n.y + s, r = n.z + l } const n = this.scene.convertXYZToLLA({ x: t, y: i, z: r }); a.data.push({ coord: [n.x, n.y], coordZ: n.z }), e.source.coord = [n.x, n.y], e.source.coordZ = n.z } } else { a.coordType = t.source.coordType; for (const e of i.positions) { let t = e.x + o, i = e.y + s, r = e.z + l; a.data.push({ coord: [t, r], coordZ: i }), e.source.coord = [t, r], e.source.coordZ = i } } this.scene.tgapp.triggerEvent.onTransformAxisDragEnd(a) } } const path = new Path; class Agg extends BaseComponent { constructor() { super(), this.type = "Agg", this.interfaceList = ["addAggData", "updateAggData", "countAggData", "searchDataByPoint", "searchDataByArea", "searchDataByPath", "removeAggData", "removeAllAggData"], this.serverHost = "http://127.0.0.1:9696/V3.1" } addAggData(e, t) { this.postRequest("addAggData", e, (({ code: e, message: i }) => { 1 === e ? t && t({ result: 1, message: "成功。" }) : t && t({ result: 0, message: `失败，${i}` }) })) } updateAggData(e, t) { this.postRequest("updateAggData", e, (({ code: e, message: i }) => { 1 === e ? t && t({ result: 1, message: "成功。" }) : t && t({ result: 0, message: `失败，${i}` }) })) } countAggData({ id: e }, t) { this.getRequest(`countAggData/${e}`, (({ code: e, message: i, data: r }) => { 1 === e ? t && t({ result: 1, message: "成功。", count: r }) : t && t({ result: 0, message: `失败，${i}` }) })) } searchDataByPoint(e, t) { this.postRequest("searchDataByPoint", e, (({ code: e, message: i, data: r }) => { 1 === e ? t && t({ result: 1, message: "成功。", data: r }) : t && t({ result: 0, message: `失败，${i}` }) })) } searchDataByArea(e, t) { this.postRequest("searchDataByArea", e, (({ code: e, message: i, data: r }) => { 1 === e ? t && t({ result: 1, message: "成功。", data: r }) : t && t({ result: 0, message: `失败，${i}` }) })) } searchDataByPath(e, t) { this.postRequest("searchDataByPath", e, (({ code: e, message: i, data: r }) => { 1 === e ? t && t({ result: 1, message: "成功。", data: r }) : t && t({ result: 0, message: `失败，${i}` }) })) } removeAggData(e, t) { this.postRequest("removeAggData", e, (({ code: e, message: i, data: r }) => { 1 === e ? t && t({ result: 1, message: "成功。", data: r }) : t && t({ result: 0, message: `失败，${i}` }) })) } removeAllAggData({ id: e }, t) { let i = `removeAllAggData/${e}`; this.deleteRequest(i, (({ code: e, message: i, data: r }) => { 1 === e ? t && t({ result: 1, message: "成功。", count: r }) : t && t({ result: 0, message: `失败，${i}` }) })) } postRequest(e, t, i) { return new Promise((r => { let n = new XMLHttpRequest; n.open("post", `${this.serverHost}/${e}`, !0), n.setRequestHeader("Content-Type", "application/json"), n.onreadystatechange = () => { 4 === n.readyState && (200 == n.status || 204 == n.status || 304 == n.status ? (i && i(JSON.parse(n.responseText)), r(JSON.parse(n.responseText))) : (i && i({ code: 0, message: "服务连接超时！" }), r())) }, n.send(JSON.stringify(t)) })) } getRequest(e, t) { return new Promise((i => { let r = new XMLHttpRequest; r.open("get", `${this.serverHost}/${e}`, !0), r.onreadystatechange = () => { 4 === r.readyState && (200 == r.status || 204 == r.status || 304 == r.status ? (t && t(JSON.parse(r.responseText)), i(JSON.parse(r.responseText))) : (t && t({ code: 0, message: "服务连接超时！" }), i())) }, r.send() })) } deleteRequest(e, t) { return new Promise((i => { let r = new XMLHttpRequest; r.open("delete", `${this.serverHost}/${e}`, !0), r.onreadystatechange = () => { 4 === r.readyState && (200 == r.status || 204 == r.status || 304 == r.status ? (t && t(JSON.parse(r.responseText)), i(JSON.parse(r.responseText))) : (t && t({ code: 0, message: "服务连接超时！" }), i())) }, r.send() })) } } const agg = new Agg; class ModelLandmarkLayer extends BaseOverlay { constructor() { super(), this.type = "modelLandmarkLayer", this.interfaceList = ["addModelLandmarkLayer", "updateModelLandmarkLayerCoord", "updateModelLandmarkLayerStyle"] } addModelLandmarkLayer({ id: e, modelLandmarkDataId: t } = {}, i) { const r = this.deepCopy(arguments[0]); r.zLevel = store.zLevel++, "" === t && (t = void 0), this.layerIdIsUsed(e) ? i && i({ result: 0, message: `失败，${e} 已存在。` }) : this._updateLayer(r, i) } updateModelLandmarkLayerCoord({ id: e } = {}, t) { const i = this.deepCopy(arguments[0]); void 0 !== this.getLayer(e) ? this._updateLayer(i, t) : t && t({ result: 0, message: `失败，未找到 ${e} 模型地标图。` }) } updateModelLandmarkLayerStyle({ id: e } = {}, t) { const i = this.deepCopy(arguments[0]); void 0 !== this.getLayer(e) ? this._updateLayer(i, t) : t && t({ result: 0, message: `失败，未找到 ${e} 模型地标图。` }) } _updateLayer({ id: e, coordType: t, coordTypeZ: i, snapSurface: r, alpha: n, modelMaxDistance: a, iconMaxDistance: o, legends: s = [], data: l = [] }, c) { let h = this.getLayer(e); void 0 === h && (h = this.createLayer(e, arguments[0]), h.zLevel = h.source.zLevel), null != t && (h.source.coordType = t), null != i && (h.source.coordTypeZ = i), null != r && (h.source.snapSurface = r), null != n && (h.source.alpha = n), null != a && (h.source.modelMaxDistance = a), null != o && (h.source.iconMaxDistance = o); for (const e of s) { let t = h.source.legends.findIndex((t => t.name == e.name)); -1 == t ? h.source.legends.push(e) : h.source.legends[t] = e } const u = 0 == h.source.coordType ? "lla" : "xyz"; for (const e of l) { e.position = new Position(u), e.position.set(e.coord[0], e.coord[1], e.coordZ), "xyz" === u && e.position.set(e.coord[0], e.coordZ, e.coord[1]); let t = h.source.data.findIndex((t => t.id === e.id)); -1 == t ? h.source.data.push(e) : h.source.data[t] = e } for (const e of h.source.data) { if (!Array.isArray(e.rotation) || 3 !== e.rotation.length || "number" != typeof e.rotation[0] || "number" != typeof e.rotation[1] || "number" != typeof e.rotation[2]) return void (c && c({ result: 0, message: `失败，rotation 属性值错误：${JSON.stringify(e.rotation)}。` })); let t = h.getData(e.id); void 0 === t ? t = this.createData(e.id, e, h) : t.setSource(e), t.positions = [e.position]; let i = h.source.legends.find((e => e.name == t.source.type)); i ? (t.legend = i.name, t.modelType = i.modelType, t.scale = i.scale, t.iconName = i.iconName, t.labelColor = i.labelColor, t.labelBackgroundColor = i.labelBackgroundColor) : t.legend = void 0, t.snapSurface = h.source.snapSurface, t.alpha = h.source.alpha, t.modelMaxDistance = h.source.modelMaxDistance, t.iconMaxDistance = h.source.iconMaxDistance, t.label = e.label, t.rotation = e.rotation } this._drawData(h, c) } async _drawData(e, t) { if (!this.scene) return; let i = [], r = [], n = []; for (const t of e.data) { if (void 0 === t.legend) { i.push(t.source.type); continue } if (!this.isContainIconAsset(t.iconName)) { r.push(t.iconName); continue } if (!this.isContainModelAsset(t.modelType)) { n.push(t.modelType); continue } let a = await this.getIconAsset(t.iconName); a.name = t.id, a.position = t.positions[0], a.label = !!t.label, a.labelText = t.label, a.labelColor = t.labelColor, a.labelBackground = t.labelBackgroundColor, a.snapSurface = t.snapSurface, a.alpha = t.alpha, a.modelMaxDistance = t.modelMaxDistance, a.iconMaxDistance = t.iconMaxDistance, a.modelType = t.modelType, a.scale = t.scale, a.isShow = e.isShow, a.zLevel = e.zLevel; let o = t.rotation[0]; o += 180; let s = t.rotation[1], l = t.rotation[2]; a.rotation = [s, o, l], t.inView ? await this.scene.updateModelLandmark(e.id, t.id, a) : (await this.scene.addModelLandmark(e.id, a), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } addSceneEventListener(e) { "onModelLandmarkLayerHover" !== e && "onModelLandmarkLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onModelLandmarkLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onModelLandmarkLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onModelLandmarkLayerHover" !== e && "onModelLandmarkLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onModelLandmarkLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onModelLandmarkLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.onModelLandmarkLayerClick({ idObj: i.id, idLayer: t.id, selected: i.isSelected }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.onModelLandmarkLayerHover({ idObj: i.id, idLayer: t.id }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onModelLandmarkLayerUnhover({ idObj: i.id, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t, dataId: i, legend: r } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e ? "focusLayerStart" !== e ? "focusLayerEnd" !== e || this.scene.tgapp.triggerEvent.onFocusModelLandmarkLayerObjEnd({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusModelLandmarkLayerObjStart({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusAllModelLandmarkLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllModelLandmarkLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusModelLandmarkLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusModelLandmarkLayerStart({ idLayer: t }) } onTransformAxisDragStart({ target: e, data: t, layer: i }) { "translate" === e.mode && this.scene.tgapp.triggerEvent.onTransformAxisDragStart({ idObj: t.id, idLayer: i.id, overlayType: this.type }) } onTransformAxisDrag({ object: e, layer: t, data: i } = {}) { const r = e.position, n = { idObj: i.id, idLayer: t.id, overlayType: this.type }; if (0 === t.source.coordType) { const e = this.scene.convertXYZToLLA({ x: r.x, y: r.y, z: r.z }); n.coordType = 0, n.data = [{ coord: [e.x, e.y], coordZ: e.z }] } else n.coordType = t.source.coordType, n.data = [{ coord: [r.x, r.z], coordZ: r.y }]; this.scene.tgapp.triggerEvent.onTransformAxisDrag(n) } onTranslateDragEndEvent({ object: e, layer: t, data: i } = {}) { const r = e.position, n = { idObj: i.id, idLayer: t.id, overlayType: this.type }; if (0 === t.source.coordType) { const e = this.scene.convertXYZToLLA({ x: r.x, y: r.y, z: r.z }); n.coordType = 0, n.data = [{ coord: [e.x, e.y], coordZ: e.z }], i.source.position.lon = e.x, i.source.position.lat = e.y, i.source.position.alt = e.z, i.source.coord = [e.x, e.y], i.source.coordZ = e.z } else n.coordType = t.source.coordType, n.data = [{ coord: [r.x, r.z], coordZ: r.y }], i.source.position.x = r.x, i.source.position.y = r.z, i.source.position.z = r.y, i.source.coord = [r.x, r.z], i.source.coordZ = r.y; this.scene.tgapp.triggerEvent.onTransformAxisDragEnd(n) } } const modelLandmarkLayer = new ModelLandmarkLayer; class ModelTrailLayer extends BaseOverlay { constructor() { super(), this.type = "modelTrailLayer", this.interfaceList = ["addModelTrailLayer", "updateModelTrailLayerCoord", "updateModelTrailLayerStyle"], this.objLifeTimer = null } setScene(e) { super.setScene(e), null !== this.objLifeTimer && clearInterval(this.objLifeTimer), this.objLifeTimer = setInterval(this._objLifeTest.bind(this), 1e3) } _objLifeTest() { if (!this.layers || this.layers.length <= 0) return; let e = new Date; for (let t = this.layers.length - 1; t >= 0; t--) { const i = this.layers[t]; if (void 0 === i) continue; if (!i.data || i.data.length <= 0) { this.removeLayer(i.id); continue } for (let t = i.data.length - 1; t >= 0; t--) { const r = i.data[t]; if (!r.timestamp) continue; if ((e - r.timestamp - 1e3) / 1e3 >= i.source.objLife) { let e = i.source.data.findIndex((e => e.id === r.id)); i.source.data.splice(e, 1), i.data.splice(t, 1), this.scene.removeDrawable(i.id, r.id) } } } } addModelTrailLayer({ id: e, modelTrailDataId: t } = {}, i) { const r = this.deepCopy(arguments[0]); r.zLevel = store.zLevel++, "" === t && (t = void 0), this.layerIdIsUsed(e) ? i && i({ result: 0, message: `失败，${e} 已存在。` }) : this._updateLayer(r, i) } updateModelTrailLayerCoord({ id: e } = {}, t) { const i = this.deepCopy(arguments[0]); void 0 !== this.getLayer(e) ? this._updateLayer(i, t) : t && t({ result: 0, message: `失败，未找到 ${e} 模型轨迹图。` }) } updateModelTrailLayerStyle({ id: e } = {}, t) { const i = this.deepCopy(arguments[0]); void 0 !== this.getLayer(e) ? this._updateLayer(i, t) : t && t({ result: 0, message: `失败，未找到 ${e} 模型轨迹图。` }) } _updateLayer({ isAppend: e = !0, legends: t = [], data: i = [] }, r) { const n = this._createOrGetLayer(arguments[0]); this._updateLayerSource(n, arguments[0]); for (const e of t) { let t = n.source.legends.findIndex((t => t.name == e.name)); -1 == t ? n.source.legends.push(e) : n.source.legends[t] = e } if (!0 !== e) { n.source.data = []; for (const e of n.data) this.scene.removeDrawable(n.id, e.id); n.data = [] } for (const e of i) { let t = n.source.data.findIndex((t => t.id === e.id)); -1 == t ? n.source.data.push(e) : n.source.data[t] = e } for (const e of n.source.data) { let t = n.getData(e.id); void 0 === t ? t = this.createData(e.id, e, n) : t.setSource(e); const i = 0 == n.source.coordType ? "lla" : "xyz", r = new Position(i); r.set(e.coord[0], e.coord[1], e.coordZ), "xyz" === i && r.set(e.coord[0], e.coordZ, e.coord[1]), t.positions = [r]; let a = n.source.legends.find((e => e.name == t.source.type)); a ? (t.legend = a.name, t.modelType = a.modelType, t.scale = a.scale, t.iconName = a.iconName, t.labelColor = a.labelColor, t.labelBackgroundColor = a.labelBackgroundColor) : t.legend = void 0, t.snapSurface = n.source.snapSurface, t.duration = n.source.duration, t.modelMaxDistance = n.source.modelMaxDistance, t.iconMaxDistance = n.source.iconMaxDistance, t.trackStyle = n.source.trackStyle, t.trackDuration = n.source.trackDuration, t.trackWidth = n.source.trackWidth, t.objLife = n.source.objLife, t.label = e.label, t.rotation = e.rotation } this._drawData(n, r) } _createOrGetLayer({ id: e }) { let t = this.getLayer(e); return void 0 === t && (t = this.createLayer(e, arguments[0]), t.zLevel = t.source.zLevel), t } _updateLayerSource(e, t) { null != t.name && (e.source.name = t.name), null != t.coordType && (e.source.coordType = t.coordType), null != t.coordTypeZ && (e.source.coordTypeZ = t.coordTypeZ), null != t.snapSurface && (e.source.snapSurface = t.snapSurface), null != t.duration && (e.source.duration = t.duration), null != t.modelMaxDistance && (e.source.modelMaxDistance = t.modelMaxDistance), null != t.iconMaxDistance && (e.source.iconMaxDistance = t.iconMaxDistance), null != t.trackStyle && (e.source.trackStyle = t.trackStyle), null != t.trackDuration && (e.source.trackDuration = t.trackDuration), null != t.trackWidth && (e.source.trackWidth = t.trackWidth), null != t.objLife && (e.source.objLife = t.objLife) } async _drawData(e, t) { if (!this.scene) return; let i = [], r = [], n = []; for (const t of e.data) { if (void 0 === t.legend) { i.push(t.source.type); continue } if (!this.isContainIconAsset(t.iconName)) { r.push(t.iconName); continue } if (!this.isContainModelAsset(t.modelType)) { n.push(t.modelType); continue } let a = await this.getIconAsset(t.iconName); a.name = t.id, a.position = t.positions[0], a.label = !!t.label, a.labelText = t.label, a.labelColor = t.labelColor, a.labelBackground = t.labelBackgroundColor, a.snapSurface = t.snapSurface, a.duration = t.duration, a.modelMaxDistance = t.modelMaxDistance, a.iconMaxDistance = t.iconMaxDistance, a.trackStyle = t.trackStyle, a.trackDuration = t.trackDuration, a.trackWidth = t.trackWidth, a.rotation = t.rotation, a.modelType = t.modelType, a.scale = t.scale, a.isShow = e.isShow, a.zLevel = e.zLevel, t.inView ? await this.scene.updateModelTrail(e.id, t.id, a) : (await this.scene.addModelTrail(e.id, a), t.inView = !0), t.timestamp = new Date } t && t({ result: 1, message: "成功。" }) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.onModelTrailLayerClick({ idObj: i.id, idLayer: t.id, selected: i.isSelected }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.onModelTrailLayerHover({ idObj: i.id, idLayer: t.id }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onModelTrailLayerUnhover({ idObj: i.id, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t, dataId: i, legend: r } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e ? "focusLayerStart" !== e ? "focusLayerEnd" !== e ? "focusLegendStart" !== e ? "focusLegendEnd" !== e || this.scene.tgapp.triggerEvent.onFocusModelTrailLayerLegendEnd({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusModelTrailLayerLegendStart({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusModelTrailLayerObjEnd({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusModelTrailLayerObjStart({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusAllModelTrailLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllModelTrailLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusModelTrailLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusModelTrailLayerStart({ idLayer: t }) } addSceneEventListener(e) { "onModelTrailLayerHover" !== e && "onModelTrailLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onModelTrailLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onModelTrailLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onModelTrailLayerHover" !== e && "onModelTrailLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onModelTrailLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onModelTrailLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onTransformAxisDragStart({ target: e, data: t, layer: i }) { "translate" === e.mode && this.scene.tgapp.triggerEvent.onTransformAxisDragStart({ idObj: t.id, idLayer: i.id, overlayType: this.type }) } onTransformAxisDrag({ object: e, layer: t, data: i } = {}) { const r = e.position, n = { idObj: i.id, idLayer: t.id, overlayType: this.type }; if (0 === t.source.coordType) { const e = this.scene.convertXYZToLLA({ x: r.x, y: r.y, z: r.z }); n.coordType = 0, n.data = [{ coord: [e.x, e.y], coordZ: e.z }] } else n.coordType = t.source.coordType, n.data = [{ coord: [r.x, r.z], coordZ: r.y }]; this.scene.tgapp.triggerEvent.onTransformAxisDrag(n) } onTranslateDragEndEvent({ object: e, layer: t, data: i } = {}) { const r = e.position, n = { idObj: i.id, idLayer: t.id, overlayType: this.type }; if (0 === t.source.coordType) { const e = this.scene.convertXYZToLLA({ x: r.x, y: r.y, z: r.z }); n.coordType = 0, n.data = [{ coord: [e.x, e.y], coordZ: e.z }], i.source.coord = [e.x, e.y], i.source.coordZ = e.z } else n.coordType = t.source.coordType, n.data = [{ coord: [r.x, r.z], coordZ: r.y }], i.source.coord = [r.x, r.z], i.source.coordZ = r.y; this.scene.tgapp.triggerEvent.onTransformAxisDragEnd(n) } } const modelTrailLayer = new ModelTrailLayer; class Camera extends BaseComponent { constructor() { super(), this.type = "Camera", this.interfaceList = ["setCamera", "getCameraInfo", "rotateCamera", "restrictCamera", "setCameraRestrictionState", "pathingCamera", "setCameraPathingState", "roamingCamera", "setCameraRoamingState", "followingCamera", "setCameraFollowingState"] } setScene(e) { super.setScene(e), this.cameraState = "free", this.roamingParams = {}, this.pathingParams = {}, this.restrict = { limitPitch: [0, 180], limitYaw: [-1 / 0, 1 / 0], limitDistance: [0, 999999], state: "restricted" }, this.scene.on("cameramove", "", Util.throttle((() => { if (this.scene.tgapp.triggerEvent.onCameraMove) { let e = this.scene.getView(), t = 360 - (e.rph[2] + 360) % 360, i = { coordType: 0, coordTypeZ: 0, centerCoord: [Math.round(1e7 * e.center[0]) / 1e7, Math.round(1e7 * e.center[1]) / 1e7], coordZ: Math.round(100 * e.center[2]) / 100, distance: Math.round(100 * e.distance) / 100, pitch: -Math.round(100 * e.rph[1]) / 100, heading: Math.round(100 * t) / 100 }; this.scene.tgapp.triggerEvent.onCameraMove(i) } }), 500)) } setCamera({ duration: e, coordType: t, centerCoord: i, coordZ: r, pitch: n, heading: a, distance: o, fly: s } = {}, l) { let c = []; if (e <= 0 && c.push("duration"), (n < 5 || n > 89) && c.push("pitch"), (a < 0 || a > 359) && c.push("heading"), c.length > 0) return void (l && l({ result: 0, message: `错误，属性：${c.join("、")} 值错误` })); this.scene.getCameraAutoRotate() && (this.scene.interruptCameraFly(), this.cameraState = "free"); let h = 0 == t ? "lla" : "xyz"; const u = new Position(h).set(i[0], i[1], r); "xyz" === h && u.set(i[0], r, i[1]); let d = new Camera$1({ target: u, posture: [0, -n, a], distance: o }); this.cameraState = "flying", this.scene.tgapp.triggerEvent.onSetCameraStart({}), this.scene.setCamera(d, s ? e : 0, (() => { this.cameraState = "free", this.scene.tgapp.triggerEvent.onSetCameraEnd({}) })), l && l({ result: 1, message: "成功。" }) } getCameraInfo({ }, e) { let t = this.scene.getView(), i = (t.rph[2] + 360) % 360, r = { coordType: 0, coordTypeZ: 0, centerCoord: [Math.round(1e7 * t.center[0]) / 1e7, Math.round(1e7 * t.center[1]) / 1e7], coordZ: Math.round(100 * t.center[2]) / 100, distance: Math.round(100 * t.distance) / 100, pitch: -Math.round(100 * t.rph[1]) / 100, heading: Math.round(100 * i) / 100, status: this.cameraState }; e && e({ result: 1, message: "成功。", ...r }) } rotateCamera({ duration: e, direction: t, enabled: i, interruptable: r }, n) { if (e <= 0) return void (n && n({ result: 0, message: "失败，飞行时间无效。" })); this.scene.interruptCameraFly(), this.cameraState = "orbiting"; let a = 60 / Math.abs(e); "counterclockwise" == t && (a = -a), this.scene.setAutoRotate(i, a, r, (() => { this.scene.tgapp.triggerEvent.onCameraRotateEnd({}) })), this.scene.tgapp.triggerEvent.onCameraRotateStart({}), n && n({ result: 1, message: "成功。" }) } restrictCamera(e, t) { let i = 0 == (e = JSON.parse(JSON.stringify(e))).coordType ? "lla" : "xyz", r = new Position(i); r.set(e.center[0], e.center[1], 0), "xyz" === i && r.set(e.center[0], 0, e.center[1]), e.center = r, this.restrict = e, this.scene.restrictCamera(this.restrict, t) } setCameraRestrictionState(e, t) { this.restrict.state = e.state, this.scene.setCameraRestrictionState("restricted" === e.state, t) } roamingCamera(e, t) { this.roamingParams = JSON.parse(JSON.stringify(e)), this.roamingParams.loopMode = this.roamingParams.loopMode.toLowerCase(), this.roamingParams.index = 0; let i = this.roamingParams.points, r = 0 == this.roamingParams.coordType ? "lla" : "xyz"; for (const e of i) e.target = new Position(r), e.target.set(e.coord[0], e.coord[1], e.coordZ), "xyz" === r && e.target.set(e.coord[0], e.coordZ, e.coord[1]); this.cameraState = "roaming", this.scene.tgapp.triggerEvent.onCameraRoamingStart({}); let n = JSON.parse(JSON.stringify(i[this.roamingParams.index])); n.speed = 0, this._cameraRoamingFly(n, this._roamingTraverse), t && t({ result: 1, message: "成功。" }) } setCameraRoamingState({ state: e = "stop" } = {}, t) { "roaming" == this.cameraState ? ("stop" == e.toLowerCase() && (this.scene.interruptCameraFly(), this.roamingParams = {}, this.cameraState = "free", this.scene.tgapp.triggerEvent.onCameraRoamingEnd({})), "pause" == e.toLowerCase() && this.scene.interruptCameraFly(), "continue" == e.toLowerCase() && null != this.roamingParams.index && (this.roamingParams.index > 0 && this.roamingParams.index--, this._roamingTraverse()), t && t({ result: 1, message: "成功。" })) : t && t({ result: 0, message: "失败，摄像机没有处于漫游状态。" }) } _roamingTraverse() { if (null == this.roamingParams.index) return; this.roamingParams.index++; let e = this.roamingParams.points, t = this.roamingParams.index, i = this.roamingParams.loopMode; if ("none" != i) { if ("round" == i) return t >= e.length && (this.roamingParams.points = e.reverse(), this.roamingParams.index = 1, t = 1), void this._cameraRoamingFly(e[t], this._roamingTraverse); if ("repeat" != i); else if (t >= e.length) { this.roamingParams.index = 0; let t = JSON.parse(JSON.stringify(e[0])); t.speed = 0, this._cameraRoamingFly(t, this._roamingTraverse) } else this._cameraRoamingFly(e[t], this._roamingTraverse) } else t >= e.length ? (this.roamingParams = {}, this.cameraState = "free", this.scene.tgapp.triggerEvent.onCameraRoamingEnd({})) : this._cameraRoamingFly(e[t], this._roamingTraverse) } _cameraRoamingFly({ target: e, pitch: t, yaw: i, distance: r, speed: n } = {}, a) { if (0 != n) { let t = this.scene.getCameraDetailed(), i = (new Position).set(t.positionX, t.positionY, t.positionZ); n = this.scene.getDistanceByPositions(i, e) / n } a = a.bind(this), this.scene.setCamera({ target: e, posture: [0, -t, i], distance: r }, n, (({ isInterrupt: e } = {}) => { e || setTimeout(a, 5) })) } pathingCamera(e, t) { if (this.pathingParams = this.deepCopy(e), this.pathingParams.index = 0, this.pathingParams.positions = [], !this._readPathData()) return t && t({ result: 0, message: `失败，不存在 ${this.pathingParams.pathId} 路径点。` }), void (this.pathingParams = {}); path.removeEventListener("updatePathCoord", this._onUpdatePathCoord), path.addEventListener("updatePathCoord", this._onUpdatePathCoord), path.removeEventListener("removeLayer", this._onRemovePath), path.addEventListener("removeLayer", this._onRemovePath), this.cameraState = "pathing", this.scene.tgapp.triggerEvent.onCameraToMoveStart({}), this._cameraPathingFly(this._pathingTraverse, 0), t && t({ result: 1, message: "成功。" }) } _onUpdatePathCoord({ layer: e }) { let t = camera; e.id === t.pathingParams.pathId && (t.scene.interruptCameraFly(), t.pathingCamera(t.pathingParams)) } _onRemovePath({ layerIds: e }) { let t = camera; e.find((e => e === t.pathingParams.pathId)) && (t.scene.interruptCameraFly(), t.pathingParams = {}, t.cameraState = "free", t.scene.tgapp.triggerEvent.onCameraToMoveEnd({})) } setCameraPathingState({ state: e = "stop" } = {}, t) { "pathing" == this.cameraState ? ("stop" == e.toLowerCase() && (this.scene.interruptCameraFly(), this.pathingParams = {}, this.cameraState = "free", this.scene.tgapp.triggerEvent.onCameraToMoveEnd({})), "pause" == e.toLowerCase() && this.scene.interruptCameraFly(), "continue" == e.toLowerCase() && null != this.pathingParams.index && (this.pathingParams.index > 0 && this.pathingParams.index--, this._pathingTraverse()), t && t({ result: 1, message: "成功。" })) : t && t({ result: 0, message: "失败，摄像机没有处于路径移动状态。" }) } _readPathData() { let e = path.getLayer(this.pathingParams.pathId); return !!e && (this.pathingParams.positions = e.getPositions(), !(this.pathingParams.positions <= 0) && (this.pathingParams.reverse && (this.pathingParams.positions = this.pathingParams.positions.reverse()), !0)) } _pathingTraverse() { if (null == this.pathingParams.index) return; this.pathingParams.index++; let e = this.pathingParams.positions, t = this.pathingParams.index, i = this.pathingParams.loopMode; "none" != i ? "round" != i ? "repeat" != i || (t >= e.length ? (this.pathingParams.index = 0, this._cameraPathingFly(this._pathingTraverse, 0)) : this._cameraPathingFly(this._pathingTraverse)) : t >= e.length ? (this.pathingParams.positions = e.reverse(), this.pathingParams.index = 0, this._cameraPathingFly(this._pathingTraverse, 0)) : this._cameraPathingFly(this._pathingTraverse) : t >= e.length ? (this.pathingParams = {}, this.cameraState = "free", this.scene.tgapp.triggerEvent.onCameraToMoveEnd({})) : this._cameraPathingFly(this._pathingTraverse) } _cameraPathingFly(e, t) { const i = this.pathingParams.pitch, r = this.pathingParams.distance; void 0 === t && (t = this.pathingParams.speed), e = e.bind(this); const n = this.scene.getCameraDetailed(), a = this.pathingParams.positions[this.pathingParams.index]; if (this.convertLLAToXYZ(a), this.pathingParams.positions.length === this.pathingParams.index + 1) { const o = (new Position).set(n.targetX, n.targetY, n.targetZ), s = this.scene.getDistanceByPositions(o, a) / t; return void this.scene.setCamera({ target: a, posture: [0, -i, n.azimuthAngle], distance: r }, s, (() => { setTimeout(e, 0) })) } const o = this.pathingParams.positions[this.pathingParams.index + 1]; if (this.convertLLAToXYZ(o), 0 === t) { const t = 180 * Math.atan2(a.x - o.x, a.z - o.z) / Math.PI; return void this.scene.setCamera({ target: a, posture: [0, -i, t], distance: r }, 0, (() => { setTimeout(e, 0) })) } const s = (new Position).set(n.targetX, n.targetY, n.targetZ), l = this.scene.getDistanceByPositions(s, a); function c() { const t = 180 * Math.atan2(a.x - o.x, a.z - o.z) / Math.PI; this.scene.setCamera({ target: a, posture: [0, -i, t], distance: r }, .3, (() => { setTimeout(e, 0) })) } (function () { const e = l / t - .3, o = l - .3 * t, h = s, u = a; h.x += (u.x - h.x) / l * o, h.y += (u.y - h.y) / l * o, h.z += (u.z - h.z) / l * o, this.scene.setCamera({ target: h, posture: [0, -i, n.azimuthAngle], distance: r }, e, (() => { c.call(this) })) }).call(this) } convertLLAToXYZ(e) { if ("lla" == e.type) { const t = this.scene.convertLLAToXYZ(e); e.x = t.x, e.y = t.y, e.z = t.z } return e } followingCamera({ modelId: e, distance: t, pitch: i, heading: r }, n) { let a = []; if (t <= 0 && a.push("distance"), (i < 1 || i > 89) && a.push("pitch"), (r < 0 || r > 359) && a.push("heading"), a.length > 0) return void (n && n({ result: 0, message: `错误，属性：${a.join("、")} 值错误` })); if (void 0 !== this.scene.getSceneModelAssets().find((t => t.name === e))) this.scene.setCameraFollowingByModel({ modelName: e, distance: t, pitch: -i, heading: -r }); else { let a = modelLandmarkLayer.getLayerByDataId(e); if (void 0 === a && (a = modelTrailLayer.getLayerByDataId(e)), void 0 === a) return void (n && n({ result: 0, message: "失败，未找到对应的模型。" })); this.scene.setCameraFollowingByDrawable({ layerName: a.id, drawableName: e, distance: t, pitch: -i, heading: -r }) } n && n({ result: 1, message: "成功。" }) } setCameraFollowingState({ state: e }, t) { this.scene.setCameraFollowingState(e, t) } } const camera = new Camera; class Landmark extends BaseOverlay { constructor() { super(), this.type = "landmark", this.interfaceList = ["addLandmark", "updateLandmarkCoord", "updateLandmarkStyle", "getLandmarkScreenPosition"] } addLandmark({ id: e, iconName: t, label: i, coord: r, coordZ: n, coordType: a, coordTypeZ: o, isPlot: s } = {}, l) { if (!this.isContainIconAsset(t)) return void (l && l({ result: 0, message: `失败，不存在 ${t} 图标资源。` })); if (this.layerIdIsUsed(e)) return void (l && l({ result: 0, message: `失败，${e} 已存在。` })); let c = this.deepCopy(arguments[0]); c.data = [{ id: e, coord: r, coordZ: n }]; let h = this._convertLayer(c); void 0 !== s && (h.isPlot = !0), h.zLevel = store.zLevel++, this._drawLayer(h, l) } updateLandmarkCoord({ id: e, coord: t, coordZ: i, coordType: r, coordTypeZ: n } = {}, a) { if (!this.getLayer(e)) return void (a && a({ result: 0, message: `失败，未找到 ${e} 地标点。` })); let o = this.deepCopy(arguments[0]); o.data = [{ id: e, coord: t, coordZ: i }]; let s = this._convertLayer(o); this._drawLayer(s, a) } updateLandmarkStyle({ id: e, iconName: t, label: i } = {}, r) { if (!this.isContainIconAsset(t)) return void (r && r({ result: 0, message: `失败，不存在 ${t} 图标资源。` })); if (!this.getLayer(e)) return void (r && r({ result: 0, message: `失败，未找到 ${e} 地标点。` })); let n = this.deepCopy(arguments[0]), a = this._convertLayer(n); this._drawLayer(a, r) } getLandmarkScreenPosition({ id: e }, t) { if (!this.getLayer(e)) return void (t && t({ result: 0, message: `失败，未找到 ${e} 地标点。` })); let i = this.scene.getDrawable(e, e); if (!i) return void (t && t({ result: 0, message: `失败，未找到 ${e} 地标点。` })); let r = this.scene.convertWorldToScreen(i.position), n = [r.x / this.scene.tgapp.container.scrollWidth, r.y / this.scene.tgapp.container.scrollHeight], a = [r.x, r.y]; t && t({ result: 1, message: "成功。", id: e, ndc: n, screenPosition: a }) } _convertLayer({ id: e } = {}) { let t = this.getLayer(e); return t || (t = this.createLayer(e, arguments[0])), this._updateLayer(t, arguments[0]), this._updateData(t), t } _updateLayer(e, { coordType: t, coordTypeZ: i, iconName: r, tag: n, label: a, data: o = [] } = {}) { null != t && (e.source.coordType = t), null != i && (e.source.coordTypeZ = i), null != r && (e.source.iconName = r), null != a && (e.source.label = a), null != n && (e.source.tag = n); let s = 0 == e.source.coordType ? "lla" : "xyz"; for (const t of o) { t.position = new Position(s), "lla" === s ? t.position.set(t.coord[0], t.coord[1], t.coordZ) : "xyz" === s && t.position.set(t.coord[0], t.coordZ, t.coord[1]); let i = e.source.data.findIndex((e => e.id === t.id)); -1 == i ? e.source.data.push(t) : e.source.data[i] = t } } _updateData(e) { for (const t of e.source.data) { let i = e.getData(t.id); i ? i.setSource(t) : i = this.createData(t.id, t, e), i.positions = [i.source.position], i.label = e.source.label, i.iconName = e.source.iconName } } async _drawLayer(e, t) { if (this.scene) { for (const t of e.data) { let i = await this.getIconAsset(t.iconName); i.name = t.id, i.position = t.positions[0], i.label = !!t.label, i.labelText = t.label, i.isShow = e.isShow, i.zLevel = e.zLevel, t.inView ? await this.scene.updateLandmark(e.id, t.id, i) : (await this.scene.addLandmark(e.id, i), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } } addSceneEventListener(e) { "onLandmarkHover" !== e && "onLandmarkUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onLandmarkHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onLandmarkUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onLandmarkHover" !== e && "onLandmarkUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onLandmarkHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onLandmarkUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i } = {}) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.onLandmarkClick({ id: i.id, label: i.label, tag: void 0 === t.source.tag ? "" : t.source.tag, selected: i.isSelected }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.onLandmarkHover({ id: i.id, tag: void 0 === t.source.tag ? "" : t.source.tag }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onLandmarkUnhover({ id: i.id, tag: void 0 === t.source.tag ? "" : t.source.tag }) } onFocusEvent({ type: e, layerId: t } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e || this.scene.tgapp.triggerEvent.onFocusAllLandmarkEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllLandmarkStart({}) : this.scene.tgapp.triggerEvent.onFocusLandmarkEnd({ id: t }) : this.scene.tgapp.triggerEvent.onFocusLandmarkStart({ id: t }) } onTransformAxisDragStart({ target: e, data: t, layer: i }) { "translate" === e.mode && this.scene.tgapp.triggerEvent.onTransformAxisDragStart({ idObj: t.id, idLayer: i.id, overlayType: this.type }) } onTransformAxisDrag({ object: e, layer: t, data: i } = {}) { const r = e.position, n = { idObj: i.id, idLayer: t.id, overlayType: this.type }; if (0 === t.source.coordType) { const e = this.scene.convertXYZToLLA({ x: r.x, y: r.y, z: r.z }); n.coordType = 0, n.data = [{ coord: [e.x, e.y], coordZ: e.z }] } else n.coordType = t.source.coordType, n.data = [{ coord: [r.x, r.z], coordZ: r.y }]; this.scene.tgapp.triggerEvent.onTransformAxisDrag(n) } onTranslateDragEndEvent({ object: e, layer: t, data: i } = {}) { const r = e.position, n = { idObj: i.id, idLayer: t.id, overlayType: this.type }; if (0 === t.source.coordType) { const e = this.scene.convertXYZToLLA({ x: r.x, y: r.y, z: r.z }); n.coordType = 0, n.data = [{ coord: [e.x, e.y], coordZ: e.z }], i.source.position.lon = e.x, i.source.position.lat = e.y, i.source.position.alt = e.z, t.source.coord = [e.x, e.y], t.source.coordZ = e.z } else n.coordType = t.source.coordType, n.data = [{ coord: [r.x, r.z], coordZ: r.y }], i.source.position.x = r.x, i.source.position.y = r.z, i.source.position.z = r.y, t.source.coord = [r.x, r.z], t.source.coordZ = r.y; this.scene.tgapp.triggerEvent.onTransformAxisDragEnd(n) } } const landmark = new Landmark; class Area extends BaseOverlay { constructor() { super(), this.type = "area", this.interfaceList = ["addArea", "updateAreaCoord", "updateAreaStyle", "addAreaShp"] } addArea({ id: e, type: t, points: i, isPlot: r } = {}, n) { if (!this.isContainAreaType(t)) return n && n({ result: 0, message: `失败，不存在 ${t} 区域类型。` }), !1; if (this.layerIdIsUsed(e)) return void (n && n({ result: 0, message: `失败，${e} 已存在。` })); let a = this.deepCopy(arguments[0]); a.data = [{ id: e, points: i }]; let o = this._convertLayer(a); void 0 !== r && (o.isPlot = !0), o.zLevel = store.zLevel++, this._drawLayer(o, n) } updateAreaCoord({ id: e, points: t } = {}, i) { if (!this.getLayer(e)) return void (i && i({ result: 0, message: `失败，未找到 ${e} 区域轮廓。` })); let r = this.deepCopy(arguments[0]); r.data = [{ id: e, points: t }]; let n = this._convertLayer(r); this._drawLayer(n, i) } updateAreaStyle({ id: e } = {}, t) { if (!this.getLayer(e)) return void (t && t({ result: 0, message: `失败，未找到 ${e} 区域轮廓。` })); let i = this.deepCopy(arguments[0]), r = this._convertLayer(i); this._drawLayer(r, t) } async addAreaShp({ id: e, shpPath: t } = {}, i) { if (this.getLayer(e)) return void (i && i({ result: 0, message: `失败，已存在 ${e} 区域轮廓。` })); let r = this.deepCopy(arguments[0]); r.data = [{ id: e, points: [] }], null == r.coordZ && (r.coordZ = 0), await shapefile.open(t).then((async e => e.read().then((async function t(i) { if (i.done) return; let n = e => { if (!(e.length <= 0)) if ("number" == typeof e[0]) r.data[0].points.push({ coord: e }); else for (const t of e) n(t) }; return n(i.value.geometry.coordinates), await e.read().then(t) })))).catch((e => logger.error(e.stack))); let n = this._convertLayer(r); this._drawLayer(n, i) } _convertLayer({ id: e } = {}) { let t = this.getLayer(e); return t || (t = this.createLayer(e, arguments[0])), this._updateLayer(t, arguments[0]), this._updateData(t), t } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, coordZ: n, type: a, color: o, areaHeight: s, fillArea: l, fillPosition: c, tag: h, data: u = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r), null != n && (e.source.coordZ = n), null != a && (e.source.type = a), null != o && (e.source.color = o), null != s && (e.source.areaHeight = s), null != l && (e.source.fillArea = l), null != c && (e.source.fillPosition = c), void 0 !== h && (e.source.tag = h); for (const t of u) { let i = e.source.data.findIndex((e => e.id === t.id)); -1 == i ? e.source.data.push(t) : e.source.data[i] = t } } _updateData(e) { for (const t of e.source.data) { let i = e.getData(t.id); i ? i.setSource(t) : i = this.createData(t.id, t, e); let r = 0 == e.source.coordType ? "lla" : "xyz", n = t.points.map((t => { let i = new Position(r); return i.source = t, "lla" === r ? i.set(t.coord[0], t.coord[1], e.source.coordZ) : "xyz" === r && i.set(t.coord[0], e.source.coordZ, t.coord[1]), i })); i.positions = n, i.fillArea = e.source.fillArea, i.type = e.source.type, i.areaHeight = e.source.areaHeight, i.color = e.source.color, i.fillPosition = e.source.fillPosition } } async _drawLayer(e, t) { if (this.scene) { for (const t of e.data) { let i = {}; i.name = t.id, i.points = t.positions, i.fillArea = t.fillArea, i.areaType = t.type, i.depth = t.areaHeight, i.lineColor = t.color, i.color = t.color, i.fillType = t.fillPosition, i.label = !1, i.isShow = e.isShow, i.zLevel = e.zLevel, t.inView ? await this.scene.updateArea(e.id, t.id, i) : (await this.scene.addArea(e.id, i), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } } addSceneEventListener(e) { "onAreaHover" !== e && "onAreaUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onAreaHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onAreaUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onAreaHover" !== e && "onAreaUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onAreaHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onAreaUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.onAreaClick({ id: i.id, selected: i.isSelected, tag: void 0 === t.source.tag ? "" : t.source.tag, coord: [r.longitude, r.latitude], label: i.label, type: i.source.type }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.onAreaHover({ id: i.id, tag: void 0 === t.source.tag ? "" : t.source.tag, coord: [r.longitude, r.latitude] }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onAreaUnhover({ id: i.id, tag: void 0 === t.source.tag ? "" : t.source.tag }) } onFocusEvent({ type: e, layerId: t } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e || this.scene.tgapp.triggerEvent.onFocusAllAreaEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllAreaStart({}) : this.scene.tgapp.triggerEvent.onFocusAreaEnd({ id: t }) : this.scene.tgapp.triggerEvent.onFocusAreaStart({ id: t }) } onTransformAxisDragStart({ target: e, data: t, layer: i }) { "translate" === e.mode && this.scene.tgapp.triggerEvent.onTransformAxisDragStart({ idObj: t.id, idLayer: i.id, overlayType: this.type }) } onTransformAxisDrag({ object: e, layer: t, data: i } = {}) { const r = e.position, n = e.userData.center, a = { idObj: i.id, idLayer: t.id, overlayType: this.type, data: [] }, o = r.x - n.x, s = r.y - n.y, l = r.z - n.z; if (0 === t.source.coordType) { a.coordType = 0; for (const e of i.positions) { let t = e.x + o, i = e.y + s, r = e.z + l; if ("lla" === e.type) { const n = this.scene.convertLLAToXYZ(e); t = n.x + o, i = n.y + s, r = n.z + l } const n = this.scene.convertXYZToLLA({ x: t, y: i, z: r }); a.data.push({ coord: [n.x, n.y], coordZ: n.z }) } } else { a.coordType = t.source.coordType; for (const e of i.positions) { let t = e.x + o, i = e.y + s, r = e.z + l; a.data.push({ coord: [t, r], coordZ: i }) } } this.scene.tgapp.triggerEvent.onTransformAxisDrag(a) } onTranslateDragEndEvent({ object: e, layer: t, data: i } = {}) { const r = e.position, n = e.userData.center, a = { idObj: i.id, idLayer: t.id, overlayType: this.type, data: [] }, o = r.x - n.x, s = r.y - n.y, l = r.z - n.z; if (0 === t.source.coordType) { a.coordType = 0; for (const e of i.positions) { let i = e.x + o, r = e.y + s, n = e.z + l; if ("lla" === e.type) { const t = this.scene.convertLLAToXYZ(e); i = t.x + o, r = t.y + s, n = t.z + l } const c = this.scene.convertXYZToLLA({ x: i, y: r, z: n }); a.data.push({ coord: [c.x, c.y], coordZ: c.z }), e.source.coord = [c.x, c.y], t.source.coordZ = c.z } } else { a.coordType = t.source.coordType; for (const e of i.positions) { let i = e.x + o, r = e.y + s, n = e.z + l; a.data.push({ coord: [i, n], coordZ: r }), e.source.coord = [i, n], t.source.coordZ = r } } this.scene.tgapp.triggerEvent.onTransformAxisDragEnd(a) } } const area = new Area; class LandmarkLayer extends BaseOverlay { constructor() { super(), this.type = "landmarkLayer", this.interfaceList = ["addLandmarkLayer", "updateLandmarkLayerCoord", "updateLandmarkLayerStyle"] } addLandmarkLayer({ id: e, coordType: t, coordTypeZ: i } = {}, r) { if (this.layerIdIsUsed(e)) return void (r && r({ result: 0, message: `失败，${e} 已存在。` })); let n = this.deepCopy(arguments[0]); this._drawLayer(n, r) } updateLandmarkLayerCoord({ id: e, coordType: t, coordTypeZ: i, data: r, isAppend: n } = {}, a) { if (!this.getLayer(e)) return void (a && a({ result: 0, message: `失败，未找到 ${e} 地标图。` })); let o = this.deepCopy(arguments[0]); o.dataAppend = n ?? !0, this._drawLayer(o, a) } updateLandmarkLayerStyle({ id: e, isAppend: t } = {}, i) { if (!this.getLayer(e)) return void (i && i({ result: 0, message: `失败，未找到 ${e} 地标图。` })); let r = this.deepCopy(arguments[0]); r.legendAppend = t ?? !0, this._drawLayer(r, i) } async _drawLayer(e, t) { const { id: i } = e; let r = this.getLayer(i); r || (r = this.createLayer(i, e), r.zLevel = store.zLevel++); const { dataAppend: n = !0 } = e; if (!n) { r.source.data = []; for (const e of r.data) this.scene.removeDrawable(r.id, e.id); r.data = [] } const { legendAppend: a = !0 } = e; if (!a) { r.source.legends = []; for (const e of r.data) this.scene.removeDrawable(r.id, e.id); r.data = [] } const { name: o, coordType: s, coordTypeZ: l, autoScale: c } = e; null != o && (r.source.name = o), null != s && (r.source.coordType = s), null != l && (r.source.coordTypeZ = l), null != c && (r.source.autoScale = c); const { legends: h = [] } = e; for (const e of h) { let t = r.source.legends.findIndex((t => t.name == e.name)); -1 == t ? r.source.legends.push(e) : r.source.legends[t] = e } const { data: u = [] } = e, d = 0 == r.source.coordType ? "lla" : "xyz"; for (const e of u) { e.position = new Position(d), "lla" === d ? e.position.set(e.coord[0], e.coord[1], e.coordZ) : e.position.set(e.coord[0], e.coordZ, e.coord[1]); let t = r.source.data.findIndex((t => t.id === e.id)); -1 == t ? r.source.data.push(e) : r.source.data[t] = e } const p = [], f = [], m = []; for (const e of r.source.data) { let t = r.getData(e.id); t ? t.setSource(e) : t = this.createData(e.id, e, r); const i = r.source.legends.find((e => e.name == t.source.type)); if (null == i) { p.push(e.type), t.legend = void 0, t.color = void 0, t.iconName = void 0; continue } if (!this.isContainIconAsset(i.iconName)) { f.push(i.iconName); continue } t.legend = i.name, t.color = i.color, t.iconName = i.iconName, t.positions = [t.source.position], t.label = t.source.label, t.autoScale = r.source.autoScale; const n = await this.getIconAsset(t.iconName); n.name = t.id, n.position = t.positions[0], n.label = !!t.label, n.labelText = t.label, n.labelColor = t.color, n.sizeAttenuation = t.autoScale, n.isShow = r.isShow, n.zLevel = r.zLevel, t.inView ? await this.scene.updateLandmark(r.id, t.id, n) : (await this.scene.addLandmark(r.id, n), t.inView = !0) } if (t) if (f.length > 0 || p.length > 0 || m.length > 0) { let e = "错误，"; p.length > 0 && (e += `图例 ${p.join("、")} 不存在。`), f.length > 0 && (e += `图标 ${f.join("、")} 不存在。`), m.length > 0 && (e += `图标 ${m.join("、")} 等属性存在非法字符。`), t({ result: 0, message: e }) } else t({ result: 1, message: "成功。" }) } addSceneEventListener(e) { "onLandmarkLayerHover" !== e && "onLandmarkLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onLandmarkLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onLandmarkLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onLandmarkLayerHover" !== e && "onLandmarkLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onLandmarkLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onLandmarkLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i } = {}) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.onLandmarkLayerClick({ idObj: i.id, idLayer: t.id, selected: i.isSelected, label: i.label, type: i.source.type }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.onLandmarkLayerHover({ idObj: i.id, idLayer: t.id }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onLandmarkLayerUnhover({ idObj: i.id, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t, dataId: i, legend: r } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e ? "focusLayerStart" !== e ? "focusLayerEnd" !== e ? "focusLegendStart" !== e ? "focusLegendEnd" !== e || this.scene.tgapp.triggerEvent.onFocusLandmarkLayerLegendEnd({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusLandmarkLayerLegendStart({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusLandmarkLayerObjEnd({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusLandmarkLayerObjStart({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusAllLandmarkLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllLandmarkLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusLandmarkLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusLandmarkLayerStart({ idLayer: t }) } } const landmarkLayer = new LandmarkLayer; class RoadSgHeatLayer extends BaseOverlay { constructor() { super(), this.type = "roadSgHeatLayer", this.interfaceList = ["addRoadSgHeatLayerCoord", "updateRoadSgHeatLayerCoord", "updateRoadSgHeatLayerStyle", "updateRoadSgHeatLayerSegment"] } addRoadSgHeatLayerCoord({ id: e, alpha: t }, i) { if (this.layerIdIsUsed(e)) return void (i && i({ result: 0, message: `失败，${e} 已存在。` })); let r = this.deepCopy(arguments[0]), n = this._convertLayer(r); n.zLevel = store.zLevel++, this._drawLayer(n, i) } updateRoadSgHeatLayerCoord({ id: e, isAppend: t }, i) { let r = this.getLayer(e); if (!r) return void (i && i({ result: 0, message: `失败，未找到 ${e} 路径段热力图。` })); let n = this.deepCopy(arguments[0]); n.dataAppend = t, this._convertLayer(n), this._drawLayer(r, i) } updateRoadSgHeatLayerStyle({ id: e, alpha: t }, i) { let r = this.getLayer(e); if (!r) return void (i && i({ result: 0, message: `失败，未找到 ${e} 路径段热力图。` })); let n = this.deepCopy(arguments[0]); this._convertLayer(n), this._drawLayer(r, i) } updateRoadSgHeatLayerSegment({ id: e, isAppend: t }, i) { let r = this.getLayer(e); if (!r) return void (i && i({ result: 0, message: `失败，未找到 ${e} 路径段热力图。` })); let n = this.deepCopy(arguments[0]); n.segmentAppend = t, this._convertLayer(n), this._drawLayer(r, i) } _convertLayer({ id: e, dataAppend: t = !0, segmentAppend: i = !0 } = {}) { let r = this.getLayer(e); if (r || (r = this.createLayer(e, arguments[0])), !i) { r.source.segments = []; for (const e of r.data) this.scene.removeDrawable(r.id, e.id); r.data = [] } if (!t) { r.source.data = []; for (const e of r.data) this.scene.removeDrawable(r.id, e.id); r.data = [] } return this._updateLayer(r, arguments[0]), this._updateData(r), r } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, alpha: n, width: a, colorMax: o, colorMin: s, valueMax: l, valueMin: c, segments: h = [], data: u = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r), null != n && (e.source.alpha = n), null != a && (e.source.width = a), null != o && (e.source.colorMax = o), null != s && (e.source.colorMin = s), null != l && (e.source.valueMax = l), null != c && (e.source.valueMin = c); for (const t of h) { let i = e.source.segments.findIndex((e => e.name == t.name)); -1 == i ? e.source.segments.push(t) : e.source.segments[i] = t } for (const t of u) { let i = e.source.data.findIndex((e => e.name === t.name)); -1 == i ? e.source.data.push(t) : e.source.data[i] = t } } _updateData(e) { for (const t of e.source.data) { let i = e.getData(t.name); i ? i.setSource(t) : i = this.createData(t.name, t, e); let r = e.source.segments.find((e => e.name == t.name)); if (r) { i.segment = r.name; let t = 0 == e.source.coordType ? "lla" : "xyz"; i.positions = r.points.map((e => { let i = new Position(t); return "lla" === t ? i.set(e.coord[0], e.coord[1], e.coordZ) : "xyz" === t && i.set(e.coord[0], e.coordZ, e.coord[1]), i })) } else i.segment = void 0, i.positions = []; i.color = this._getColorByRatio(e.source, t.value), i.width = e.source.width, i.alpha = e.source.alpha } } _drawLayer(e, t) { if (!this.scene) return; let i = []; for (const t of e.data) { if (!t.segment) { i.push(t.id); continue } let r = {}; r.name = t.id, r.points = t.positions, r.color = t.color, r.colorPass = t.color, r.width = t.width, r.alpha = t.alpha, r.isShow = e.isShow, r.zLevel = e.zLevel, t.inView ? this.scene.updatePath(e.id, t.id, r) : (this.scene.addPath(e.id, r), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } _getColorByRatio(e, t) { let i = this._colorToRgba(e.colorMax), r = this._colorToRgba(e.colorMin), n = e.valueMax, a = e.valueMin; if (t < a) return "rgba(" + r.join(",") + ")"; if (t > n) return "rgba(" + i.join(",") + ")"; let o = (t - a) / (n - a), s = this._subtraction(i, r), l = this._multiplication(s, o); return "rgba(" + this._multiply(r, l).join(",") + ")" } _colorToRgba(e) { var t = e.toLowerCase(), i = 1; if (t && /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(t)) { if (4 === t.length || 5 === t.length) { for (var r = "#", n = 1; n < t.length; n += 1)r += t.slice(n, n + 1).concat(t.slice(n, n + 1)); t = r } 9 === t.length && (i = (parseInt("0x" + t.slice(7, 9)) / 255).toFixed(2)); var a = []; for (n = 1; n < 7; n += 2)a.push(parseInt("0x" + t.slice(n, n + 2))); return [...a, i] } return t } _subtraction(e, t) { return [e[0] - t[0], e[1] - t[1], e[2] - t[2], e[3] - t[3]] } _multiplication(e, t) { return [Math.round(e[0] * t), Math.round(e[1] * t), Math.round(e[2] * t), Math.round(e[3] * t)] } _multiply(e, t) { return [e[0] + t[0], e[1] + t[1], e[2] + t[2], e[3] + t[3]] } addSceneEventListener(e) { "onRoadSgHeatLayerHover" !== e && "onRoadSgHeatLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onRoadSgHeatLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onRoadSgHeatLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onRoadSgHeatLayerHover" !== e && "onRoadSgHeatLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onRoadSgHeatLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onRoadSgHeatLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected && this.scene.tgapp.triggerEvent.onRoadSgHeatLayerClick({ nameSegment: i.id, idLayer: t.id, selected: i.isSelected, coord: [r.longitude, r.latitude], label: i.label, type: i.source.type }), "hover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onRoadSgHeatLayerHover({ nameSegment: i.id, idLayer: t.id, coord: [r.longitude, r.latitude] }), "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onRoadSgHeatLayerUnhover({ nameSegment: i.id, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t, dataId: i } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e ? "focusLayerStart" !== e ? "focusLayerEnd" !== e || this.scene.tgapp.triggerEvent.onFocusRoadSgHeatEnd({ idLayer: t, nameSegment: i }) : this.scene.tgapp.triggerEvent.onFocusRoadSgHeatStart({ idLayer: t, nameSegment: i }) : this.scene.tgapp.triggerEvent.onFocusAllRoadSgHeatLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllRoadSgHeatLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusRoadSgHeatLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusRoadSgHeatLayerStart({ idLayer: t }) } } const roadSgHeatLayer = new RoadSgHeatLayer; class RoadPtHeatLayer extends BaseOverlay { constructor() { super(), this.type = "roadPtHeatLayer", this.interfaceList = ["addRoadPtHeatLayer", "updateRoadPtHeatLayerCoord", "updateRoadPtHeatLayerStyle"] } addRoadPtHeatLayer({ id: e, alpha: t, data: i = [] }, r) { if (this.layerIdIsUsed(e)) return void (r && r({ result: 0, message: `失败，${e} 已存在。` })); if (i.length <= 1) return void (r && r({ result: 0, message: "失败，点数据太少,无法绘制路径。" })); let n = this.deepCopy(arguments[0]), a = this._convertLayer(n); a.zLevel = store.zLevel++, this._drawLayer(a, r) } updateRoadPtHeatLayerCoord({ id: e, isAppend: t }, i) { let r = this.getLayer(e); if (!r) return void (i && i({ result: 0, message: `失败，未找到 ${e} 路径点热力图。` })); let n = this.deepCopy(arguments[0]); n.dataAppend = t, this._convertLayer(n), this._drawLayer(r, i) } updateRoadPtHeatLayerStyle({ id: e, alpha: t }, i) { let r = this.getLayer(e); if (!r) return void (i && i({ result: 0, message: `失败，未找到 ${e} 路径点热力图。` })); let n = this.deepCopy(arguments[0]); this._convertLayer(n), this._drawLayer(r, i) } _convertLayer({ id: e, dataAppend: t = !0 } = {}) { let i = this.getLayer(e); if (i || (i = this.createLayer(e, arguments[0]), i.source.data = []), !t) { i.source.data = []; for (const e of i.data) this.scene.removeDrawable(i.id, e.id); i.data = [] } return this._updateLayer(i, arguments[0]), this._updateData(i), i } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, alpha: n, width: a, colorMax: o, colorMin: s, valueMax: l, valueMin: c, data: h = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r), null != n && (e.source.alpha = n), null != a && (e.source.width = a), null != o && (e.source.colorMax = o), null != s && (e.source.colorMin = s), null != l && (e.source.valueMax = l), null != c && (e.source.valueMin = c); let u = 0 == e.source.coordType ? "lla" : "xyz"; h.forEach((t => { t.position = new Position(u), "lla" === u ? t.position.set(t.coord[0], t.coord[1], t.coordZ) : "xyz" === u && t.position.set(t.coord[0], t.coordZ, t.coord[1]), e.source.data.push(t) })) } _updateData(e) { e.source.data.forEach(((t, i) => { if (i < e.source.data.length - 1) { let r = e.getData(e.source.id + i); r ? r.setSource(e.source.data) : r = this.createData(e.source.id + i, e.source.data, e); let n = e.source.data[i + 1]; r.positions = [t.position, n.position], r.color = this._getColorByRatio(e.source, t.value), r.colorPass = this._getColorByRatio(e.source, e.source.data[i + 1].value), r.passRange = .5, r.pass = .5, r.width = e.source.width, r.alpha = e.source.alpha } })) } _drawLayer(e, t) { this.scene && (e.data.forEach(((t, i) => { let r = {}; r.name = e.id + i, r.points = t.positions, r.color = t.color, r.colorPass = t.colorPass, r.width = t.width, r.alpha = t.alpha, r.isShow = e.isShow, r.zLevel = e.zLevel, r.pass = t.pass, r.passRange = t.passRange, t.inView ? this.scene.updatePath(e.id, t.id, r) : (this.scene.addPath(e.id, r), t.inView = !0) })), t && t({ result: 1, message: "成功。" })) } _getColorByRatio(e, t) { let i = this._colorToRgba(e.colorMax), r = this._colorToRgba(e.colorMin), n = e.valueMax, a = e.valueMin; if (t < a) return "rgba(" + r.join(",") + ")"; if (t > n) return "rgba(" + i.join(",") + ")"; let o = (t - a) / (n - a), s = this._subtraction(i, r), l = this._multiplication(s, o); return "rgba(" + this._multiply(r, l).join(",") + ")" } _colorToRgba(e) { var t = e.toLowerCase(), i = 1; if (t && /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(t)) { if (4 === t.length || 5 === t.length) { for (var r = "#", n = 1; n < t.length; n += 1)r += t.slice(n, n + 1).concat(t.slice(n, n + 1)); t = r } 9 === t.length && (i = (parseInt("0x" + t.slice(7, 9)) / 255).toFixed(2)); var a = []; for (n = 1; n < 7; n += 2)a.push(parseInt("0x" + t.slice(n, n + 2))); return [...a, i] } return t } _subtraction(e, t) { return [e[0] - t[0], e[1] - t[1], e[2] - t[2], e[3] - t[3]] } _multiplication(e, t) { return [Math.round(e[0] * t), Math.round(e[1] * t), Math.round(e[2] * t), Math.round(e[3] * t)] } _multiply(e, t) { return [e[0] + t[0], e[1] + t[1], e[2] + t[2], e[3] + t[3]] } addSceneEventListener(e) { "onRoadPtHeatLayerHover" !== e && "onRoadPtHeatLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onRoadPtHeatLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onRoadPtHeatLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onRoadPtHeatLayerHover" !== e && "onRoadPtHeatLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onRoadPtHeatLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onRoadPtHeatLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected && this.scene.tgapp.triggerEvent.onRoadPtHeatLayerClick({ idLayer: t.id, selected: i.isSelected, coord: [r.longitude, r.latitude] }), "hover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onRoadPtHeatLayerHover({ idLayer: t.id, coord: [r.longitude, r.latitude] }), "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onRoadPtHeatLayerUnhover({ idLayer: t.id }) } onFocusEvent({ type: e, layerId: t } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e || this.scene.tgapp.triggerEvent.onFocusAllRoadPtHeatLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllRoadPtHeatLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusRoadPtHeatLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusRoadPtHeatLayerStart({ idLayer: t }) } } var roadPtHeatLayer = new RoadPtHeatLayer; class TypeAreaLayer extends BaseOverlay { constructor() { super(), this.type = "typeAreaLayer", this.interfaceList = ["addTypeAreaLayer", "updateTypeAreaLayerCoord", "updateTypeAreaLayerStyle", "updateTypeAreaLayerArea"] } addTypeAreaLayer({ id: e, alpha: t } = {}, i) { if (this.layerIdIsUsed(e)) return void (i && i({ result: 0, message: `失败，${e} 已存在。` })); let r = this.deepCopy(arguments[0]), n = this._convertLayer(r); n.zLevel = store.zLevel++, this._drawLayer(n, i) } updateTypeAreaLayerCoord({ id: e, isAppend: t = !0 } = {}, i) { if (!this.getLayer(e)) return void (i && i({ result: 0, message: `失败，未找到 ${e} 类型区域图。` })); let r = this.deepCopy(arguments[0]); r.dataAppend = t; let n = this._convertLayer(r); this._drawLayer(n, i) } updateTypeAreaLayerStyle({ id: e, alpha: t, isAppend: i = !0 } = {}, r) { if (!this.getLayer(e)) return void (r && r({ result: 0, message: `失败，未找到 ${e} 类型区域图。` })); let n = this.deepCopy(arguments[0]); n.legendAppend = i; let a = this._convertLayer(n); this._drawLayer(a, r) } updateTypeAreaLayerArea({ id: e, isAppend: t = !0 } = {}, i) { if (!this.getLayer(e)) return void (i && i({ result: 0, message: `失败，未找到 ${e} 类型区域图。` })); let r = this.deepCopy(arguments[0]); r.areaAppend = t; let n = this._convertLayer(r); this._drawLayer(n, i) } _convertLayer({ id: e, dataAppend: t = !0, areaAppend: i = !0, legendAppend: r = !0 } = {}) { let n = this.getLayer(e); return n || (n = this.createLayer(e, arguments[0]), n.source.areas = [], n.source.legends = [], n.source.data = []), i || (n.source.areas = [], n.data.forEach((e => this.scene.removeDrawable(n.id, e.id))), n.data = []), r || (n.source.legends = [], n.data.forEach((e => this.scene.removeDrawable(n.id, e.id))), n.data = []), t || (n.source.data = [], n.data.forEach((e => this.scene.removeDrawable(n.id, e.id))), n.data = []), this._updateLayer(n, arguments[0]), this._updateData(n), n } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, coordZ: n, alpha: a, areas: o = [], legends: s = [], data: l = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r), null != n && (e.source.coordZ = n), null != a && (e.source.alpha = a); for (let t of s) { let i = e.source.legends.findIndex((e => e.name == t.name)); -1 == i ? e.source.legends.push(t) : e.source.legends[i] = t } for (let t of o) { null == t.name && (t.name = t.areaName); let i = e.source.areas.findIndex((e => e.name == t.name)); -1 == i ? e.source.areas.push(t) : e.source.areas[i].points.push(...t.points) } for (const t of l) { let i = e.source.data.findIndex((e => e.areaName == t.areaName)); -1 == i ? e.source.data.push(t) : e.source.data[i] = t } } _updateData(e) { let t = 0 == e.source.coordType ? "lla" : "xyz"; for (const i of e.source.data) { let r = e.data.find((e => e.id == i.areaName)); r ? r.setSource(i) : r = this.createData(i.areaName, i, e); let n = e.source.areas.find((e => e.name == i.areaName)); n ? (r.area = n.name, r.positions = n.points.map((i => { let r = new Position(t); return "lla" === t ? r.set(i.coord[0], i.coord[1], e.source.coordZ) : r.set(i.coord[0], e.source.coordZ, i.coord[1]), r }))) : (r.area = void 0, r.positions = []); let a = e.source.legends.find((e => e.name == i.legendName)); a ? (r.legend = a.name, r.fillArea = a.fillArea, r.areaType = a.type, r.lineColor = a.color, r.color = a.color, r.depth = a.areaHeight, r.fillType = a.fillPosition) : (r.legend = void 0, r.fillArea = void 0, r.areaType = void 0, r.lineColor = void 0, r.color = void 0, r.depth = void 0, r.fillType = void 0), r.alpha = e.source.alpha } } _drawLayer(e, t) { if (!this.scene) return; let i = [], r = [], n = []; for (const t of e.data) { if (null == t.area) { i.push(t.source.areaName), this.scene.removeDrawable(e.id, t.id); continue } if (null == t.legend) { r.push(t.source.legendName), this.scene.removeDrawable(e.id, t.id); continue } if (!this.isContainAreaType(t.areaType)) { this.scene.removeDrawable(e.id, t.id), n.push(t.source.type); continue } let a = {}; a.name = t.id, a.fillArea = t.fillArea, a.alpha = t.alpha, a.points = t.positions, a.areaType = t.areaType, a.lineColor = t.lineColor, a.color = t.color, a.depth = t.depth, a.fillType = t.fillType, a.label = !1, a.isShow = e.isShow, a.zLevel = e.zLevel, t.inView ? this.scene.updateArea(e.id, t.id, a) : (this.scene.addArea(e.id, a), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } addSceneEventListener(e) { "onTypeAreaLayerHover" !== e && "onTypeAreaLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onTypeAreaLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onTypeAreaLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onTypeAreaLayerHover" !== e && "onTypeAreaLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onTypeAreaLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onTypeAreaLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected && this.scene.tgapp.triggerEvent.onTypeAreaLayerClick({ nameArea: i.area, idLayer: t.id, selected: i.isSelected, coord: [r.longitude, r.latitude], label: void 0 === i.label ? null : i.label, type: void 0 === i.type ? null : i.type }), "hover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onTypeAreaLayerHover({ nameArea: i.area, idLayer: t.id, coord: [r.longitude, r.latitude] }), "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onTypeAreaLayerUnhover({ nameArea: i.area, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t, dataId: i, legend: r } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e ? "focusLayerStart" !== e ? "focusLayerEnd" !== e ? "focusLegendStart" !== e ? "focusLegendEnd" !== e || this.scene.tgapp.triggerEvent.onFocusTypeAreaLayerLegendEnd({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusTypeAreaLayerLegendStart({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusTypeAreaEnd({ idLayer: t, nameArea: i }) : this.scene.tgapp.triggerEvent.onFocusTypeAreaStart({ idLayer: t, nameArea: i }) : this.scene.tgapp.triggerEvent.onFocusAllTypeAreaLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllTypeAreaLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusTypeAreaLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusTypeAreaLayerStart({ idLayer: t }) } } const typeAreaLayer = new TypeAreaLayer; class ColorAreaLayer extends BaseOverlay { constructor() { super(), this.type = "colorAreaLayer", this.interfaceList = ["addColorAreaLayer", "updateColorAreaLayerCoord", "updateColorAreaLayerStyle", "updateColorAreaLayerArea"] } addColorAreaLayer({ id: e, alpha: t } = {}, i) { if (this.layerIdIsUsed(e)) return void (i && i({ result: 0, message: `失败，${e} 已存在。` })); let r = this.deepCopy(arguments[0]), n = this._convertLayer(r); n.zLevel = store.zLevel++, this._drawLayer(n, i) } updateColorAreaLayerCoord({ id: e, isAppend: t = !0 } = {}, i) { if (!this.getLayer(e)) return void (i && i({ result: 0, message: `失败，未找到 ${e} 数值区域图。` })); let r = this.deepCopy(arguments[0]); r.dataAppend = t; let n = this._convertLayer(r); this._drawLayer(n, i) } updateColorAreaLayerStyle({ id: e, alpha: t } = {}, i) { if (!this.getLayer(e)) return void (i && i({ result: 0, message: `失败，未找到 ${e} 类型区域图。` })); let r = this.deepCopy(arguments[0]), n = this._convertLayer(r); this._drawLayer(n, i) } updateColorAreaLayerArea({ id: e, isAppend: t = !0 } = {}, i) { if (!this.getLayer(e)) return void (i && i({ result: 0, message: `失败，未找到 ${e} 类型区域图。` })); let r = this.deepCopy(arguments[0]); r.areaAppend = t; let n = this._convertLayer(r); this._drawLayer(n, i) } _convertLayer({ id: e, dataAppend: t = !0, areaAppend: i = !0 } = {}) { let r = this.getLayer(e); return r || (r = this.createLayer(e, arguments[0]), r.source.areas = [], r.source.data = []), i || (r.source.areas = [], r.data.forEach((e => this.scene.removeDrawable(r.id, e.id))), r.data = []), t || (r.source.data = [], r.data.forEach((e => this.scene.removeDrawable(r.id, e.id))), r.data = []), this._updateLayer(r, arguments[0]), this._updateData(r), r } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, coordZ: n, alpha: a, type: o, areaHeight: s, fillArea: l, fillPosition: c, colorMax: h, colorMin: u, valueMax: d, valueMin: p, areas: f = [], data: m = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r), null != n && (e.source.coordZ = n), null != a && (e.source.alpha = a), null != o && (e.source.type = o), null != s && (e.source.areaHeight = s), null != l && (e.source.fillArea = l), null != c && (e.source.fillPosition = c), null != h && (e.source.colorMax = h), null != u && (e.source.colorMin = u), null != d && (e.source.valueMax = d), null != p && (e.source.valueMin = p); for (const t of f) { let i = e.source.areas.findIndex((e => e.name == t.name)); -1 == i ? e.source.areas.push(t) : e.source.areas[i].points.push(...t.points) } for (const t of m) { let i = e.source.data.findIndex((e => e.areaName == t.areaName)); -1 == i ? e.source.data.push(t) : e.source.data[i] = t } } _updateData(e) { let t = 0 == e.source.coordType ? "lla" : "xyz"; for (const i of e.source.data) { let r = e.data.find((e => e.id == i.areaName)); r ? r.setSource(i) : r = this.createData(i.areaName, i, e); let n = e.source.areas.find((e => e.name == i.areaName)); n ? (r.area = n.name, r.positions = n.points.map((i => { let r = new Position(t); return "lla" === t ? r.set(i.coord[0], i.coord[1], e.source.coordZ) : r.set(i.coord[0], e.source.coordZ, i.coord[1]), r }))) : (r.area = void 0, r.positions = []), r.fillArea = e.source.fillArea, r.alpha = e.source.alpha, r.type = e.source.type, r.lineColor = this._getColorByRatio(e.source, r.source.value), r.color = this._getColorByRatio(e.source, r.source.value), r.areaHeight = e.source.areaHeight, r.fillPosition = e.source.fillPosition } } _drawLayer(e, t) { if (!this.scene) return; let i = [], r = []; for (const t of e.data) { if (null == t.area) { i.push(t.source.areaName), this.scene.removeDrawable(e.id, t.id); continue } if (!this.isContainAreaType(t.type)) { r.push(t.source.type), this.scene.removeDrawable(e.id, t.id); continue } let n = {}; n.name = t.id, n.fillArea = t.fillArea, n.areaType = t.type, n.alpha = t.alpha, n.points = t.positions, n.lineColor = t.lineColor, n.color = t.color, n.depth = t.areaHeight, n.fillType = t.fillPosition, n.label = !1, n.isShow = e.isShow, n.zLevel = e.zLevel, t.inView ? this.scene.updateArea(e.id, t.id, n) : (this.scene.addArea(e.id, n), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } _getColorByRatio(e, t) { let i = this._colorToRgba(e.colorMax), r = this._colorToRgba(e.colorMin), n = e.valueMax, a = e.valueMin; if (t < a) return "rgba(" + r.join(",") + ")"; if (t > n) return "rgba(" + i.join(",") + ")"; let o = (t - a) / (n - a), s = this._subtraction(i, r), l = this._multiplication(s, o); return "rgba(" + this._multiply(r, l).join(",") + ")" } _colorToRgba(e) { var t = e.toLowerCase(), i = 1; if (t && /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(t)) { if (4 === t.length || 5 === t.length) { for (var r = "#", n = 1; n < t.length; n += 1)r += t.slice(n, n + 1).concat(t.slice(n, n + 1)); t = r } 9 === t.length && (i = (parseInt("0x" + t.slice(7, 9)) / 255).toFixed(2)); var a = []; for (n = 1; n < 7; n += 2)a.push(parseInt("0x" + t.slice(n, n + 2))); return [...a, i] } return t } _subtraction(e, t) { return [e[0] - t[0], e[1] - t[1], e[2] - t[2], e[3] - t[3]] } _multiplication(e, t) { return [Math.round(e[0] * t), Math.round(e[1] * t), Math.round(e[2] * t), Math.round(e[3] * t)] } _multiply(e, t) { return [e[0] + t[0], e[1] + t[1], e[2] + t[2], e[3] + t[3]] } addSceneEventListener(e) { "onColorAreaLayerHover" !== e && "onColorAreaLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onColorAreaLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onColorAreaLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onColorAreaLayerHover" !== e && "onColorAreaLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onColorAreaLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onColorAreaLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected && this.scene.tgapp.triggerEvent.onColorAreaLayerClick({ nameArea: i.id, idLayer: t.id, selected: i.isSelected, coord: [r.longitude, r.latitude], label: i.label, type: i.source.type }), "hover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onColorAreaLayerHover({ nameArea: i.id, idLayer: t.id, coord: [r.longitude, r.latitude] }), "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onColorAreaLayerUnhover({ nameArea: i.id, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t, dataId: i } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e ? "focusLayerStart" !== e ? "focusLayerEnd" !== e || this.scene.tgapp.triggerEvent.onFocusColorAreaEnd({ idLayer: t, nameArea: i }) : this.scene.tgapp.triggerEvent.onFocusColorAreaStart({ idLayer: t, nameArea: i }) : this.scene.tgapp.triggerEvent.onFocusAllColorAreaLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllColorAreaLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusColorAreaLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusColorAreaLayerStart({ idLayer: t }) } } const colorAreaLayer = new ColorAreaLayer; class CircularArea extends BaseOverlay { constructor() { super(), this.type = "circularArea", this.interfaceList = ["addCircularArea", "updateCircularAreaCoord", "updateCircularAreaStyle"] } addCircularArea({ id: e, type: t, fillArea: i, radius: r, fillPosition: n, areaHeight: a } = {}, o) { if (!this.isContainAreaFillType(i)) return o && o({ result: 0, message: `失败，不存在 ${i} 区域填充类型。` }), !1; if (!this.isContainAreaType(t)) return o && o({ result: 0, message: `失败，不存在 ${t} 区域类型。` }), !1; if (this.layerIdIsUsed(e)) return void (o && o({ result: 0, message: `失败，${e} 已存在。` })); let s = this.deepCopy(arguments[0]), l = this._getPositions(s); s.data = [{ id: e, positions: l }]; let c = this._convertLayer(s); c.zLevel = store.zLevel++, this._drawLayer(c, o) } updateCircularAreaCoord({ id: e, radius: t } = {}, i) { if (!this.getLayer(e)) return void (i && i({ result: 0, message: `失败，未找到 ${e} 圆形区域。` })); let r = this.deepCopy(arguments[0]), n = this._getPositions(r); r.data = [{ id: e, positions: n }]; let a = this._convertLayer(r); this._drawLayer(a, i) } updateCircularAreaStyle({ id: e, type: t, fillArea: i, fillPosition: r, areaHeight: n } = {}, a) { if (void 0 !== i && !this.isContainAreaFillType(i)) return a && a({ result: 0, message: `失败，不存在 ${i} 区域填充类型。` }), !1; if (void 0 !== t && !this.isContainAreaType(t)) return a && a({ result: 0, message: `失败，不存在 ${t} 区域类型。` }), !1; if (!this.getLayer(e)) return void (a && a({ result: 0, message: `失败，未找到 ${e} 圆形区域。` })); let o = this.deepCopy(arguments[0]), s = this._convertLayer(o); this._drawLayer(s, a) } _getPositions({ coordType: e, center: t, coordZ: i, radius: r, density: n = 1 } = {}) { r *= this.scene.getWorldScale(), t = 0 == e ? this.scene.convertLLAToXYZ({ lon: t[0], lat: t[1], alt: i }) : { x: t[0], y: i, z: t[1] }; let a = []; for (let e = 0; e <= 360; e += n) { let i = Math.PI / 180 * e, n = r * Math.cos(i), o = r * Math.sin(i), s = new Position; s.set(t.x + n, t.y, t.z - o), a.push(s) } return a } _convertLayer({ id: e } = {}) { let t = this.getLayer(e); return t || (t = this.createLayer(e, arguments[0])), this._updateLayer(t, arguments[0]), this._updateData(t), t } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, coordZ: n, type: a, color: o, areaHeight: s, fillArea: l, fillPosition: c, tag: h, data: u = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r), null != n && (e.source.coordZ = n), null != a && (e.source.type = a), null != o && (e.source.color = o), null != s && (e.source.areaHeight = s), null != l && (e.source.fillArea = l), null != c && (e.source.fillPosition = c), void 0 !== h && (e.source.tag = h); for (const t of u) { t.coordType = e.source.coordType; let i = e.source.data.findIndex((e => e.id === t.id)); -1 == i ? e.source.data.push(t) : e.source.data[i] = t } } _updateData(e) { for (const t of e.source.data) { let i = e.getData(t.id); i ? i.setSource(t) : i = this.createData(t.id, t, e), i.positions = i.source.positions, i.fillArea = e.source.fillArea, i.type = e.source.type, i.areaHeight = e.source.areaHeight, i.color = e.source.color, i.fillPosition = e.source.fillPosition } } async _drawLayer(e, t) { if (this.scene) { for (const t of e.data) { let i = {}; i.name = t.id, i.points = t.positions, i.fillArea = t.fillArea, i.areaType = t.type, i.depth = t.areaHeight, i.lineColor = t.color, i.color = t.color, i.fillType = t.fillPosition, i.label = !1, i.isShow = e.isShow, i.zLevel = e.zLevel, t.inView ? await this.scene.updateArea(e.id, t.id, i) : (await this.scene.addArea(e.id, i), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } } addSceneEventListener(e) { "onCircularAreaHover" !== e && "onCircularAreaUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onCircularAreaHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onCircularAreaUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onCircularAreaHover" !== e && "onCircularAreaUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onCircularAreaHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onCircularAreaUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.onCircularAreaClick({ id: i.id, selected: i.isSelected, tag: void 0 === t.source.tag ? "" : t.source.tag, coord: [r.longitude, r.latitude], label: i.label, type: i.source.type }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.onCircularAreaHover({ id: i.id, tag: void 0 === t.source.tag ? "" : t.source.tag, coord: [r.longitude, r.latitude] }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onCircularAreaUnhover({ id: i.id, tag: void 0 === t.source.tag ? "" : t.source.tag }) } onFocusEvent({ type: e, layerId: t } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e || this.scene.tgapp.triggerEvent.onFocusAllCircularAreaEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllCircularAreaStart({}) : this.scene.tgapp.triggerEvent.onFocusCircularAreaEnd({ id: t }) : this.scene.tgapp.triggerEvent.onFocusCircularAreaStart({ id: t }) } } const circularArea = new CircularArea; class Grid3DLayer extends BaseOverlay { constructor() { super(), this.type = "3DGridLayer", this.interfaceList = ["add3DGridLayer", "update3DGridLayerCoord", "update3DGridLayerStyle"] } add3DGridLayer({ id: e, coordType: t, gridHeight: i, gridWidth: r, gridType: n, gridAlpha: a, data: o } = {}, s) { if (this.layerIdIsUsed(e)) return void (s && s({ result: 0, message: `失败，${e} 已存在。` })); let l = this.deepCopy(arguments[0]), c = this._convertLayer(l); c.zLevel = store.zLevel++, this._drawLayer(c, s) } update3DGridLayerCoord({ id: e, coordType: t, data: i } = {}, r) { if (!this.getLayer(e)) return void (r && r({ result: 0, message: `失败，未找到 ${e} 栅格图。` })); let n = this.deepCopy(arguments[0]), a = this._convertLayer(n); this._drawLayer(a, r) } update3DGridLayerStyle({ id: e, gridType: t, gridHeight: i, gridWidth: r, gridAlpha: n } = {}, a) { if (!this.getLayer(e)) return void (a && a({ result: 0, message: `失败，未找到 ${e} 栅格图。` })); let o = this.deepCopy(arguments[0]), s = this._convertLayer(o); this._drawLayer(s, a) } _convertLayer({ id: e, isAppend: t = !0 } = {}) { let i = this.getLayer(e); if (i || (i = this.createLayer(e, arguments[0])), !t) { i.source.data = []; for (const e of i.data) this.scene.removeDrawable(i.id, e.id); i.data = [] } return this._updateLayer(i, arguments[0]), this._updateData(i), i } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, coordZ: n, gridType: a, gridHeight: o, gridAlpha: s, gridGap: l, gridWidth: c, colorMax: h, colorMin: u, valueMax: d, valueMin: p, data: f = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r), null != n && (e.source.coordZ = n), null != a && (e.source.gridType = a), null != o && (e.source.gridHeight = o), null != s && (e.source.gridAlpha = s), null != l && (e.source.gridGap = l), null != c && (e.source.gridWidth = c), null != h && (e.source.colorMax = h), null != u && (e.source.colorMin = u), null != d && (e.source.valueMax = d), null != p && (e.source.valueMin = p); for (const t of f) { let i = e.source.data.findIndex((e => e.id === t.id)); -1 == i ? e.source.data.push(t) : e.source.data[i] = t } } _updateData(e) { this._maxWidth(e.source); for (const t of e.source.data) { let i = e.getData(t.id); i ? i.setSource(t) : i = this.createData(t.id, t, e), i.positions = [i.source.position], i.gridHeight = e.source.gridHeight, i.gridWidth = e.source.gridWidth, i.color = this._getColorByRatio(e.source, i.source.value), i.gridType = "grid" == e.source.gridType ? "矩形" : "cylinder", i.gridAlpha = e.source.gridAlpha, i.maxWidth = e.source.maxWidth } } _maxWidth({ coordType: e, coordZ: t, gridWidth: i, data: r } = {}) { let n = 0 == e ? "lla" : "xyz"; for (const e of r) e.position = new Position(n), "lla" === n ? e.position.set(e.coord[0], e.coord[1], t) : e.position.set(e.coord[0], t, e.coord[1]); let a = i; for (const e of r) for (const t of r) { if (e.id === t.id) continue; let i = this.scene.getDistanceByPositions(e.position, t.position); i < a && (a = i) } arguments[0].maxWidth = a } _getColorByRatio(e, t) { let i = this._colorToRgba(e.colorMax), r = this._colorToRgba(e.colorMin), n = e.valueMax, a = e.valueMin; if (t < a) return "rgba(" + r.join(",") + ")"; if (t > n) return "rgba(" + i.join(",") + ")"; let o = (t - a) / (n - a), s = this._subtraction(i, r), l = this._multiplication(s, o); return "rgba(" + this._multiply(r, l).join(",") + ")" } _colorToRgba(e) { var t = e.toLowerCase(), i = 1; if (t && /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(t)) { if (4 === t.length || 5 === t.length) { for (var r = "#", n = 1; n < t.length; n += 1)r += t.slice(n, n + 1).concat(t.slice(n, n + 1)); t = r } 9 === t.length && (i = (parseInt("0x" + t.slice(7, 9)) / 255).toFixed(2)); var a = []; for (n = 1; n < 7; n += 2)a.push(parseInt("0x" + t.slice(n, n + 2))); return [...a, i] } return t } _subtraction(e, t) { return [e[0] - t[0], e[1] - t[1], e[2] - t[2], e[3] - t[3]] } _multiplication(e, t) { return [Math.round(e[0] * t), Math.round(e[1] * t), Math.round(e[2] * t), Math.round(e[3] * t)] } _multiply(e, t) { return [e[0] + t[0], e[1] + t[1], e[2] + t[2], e[3] + t[3]] } async _drawLayer(e, t) { if (this.scene) { for (const t of e.data) { let i = {}; i.name = t.id, i.position = t.positions[0], i.value = t.gridHeight, i.color = t.color, i.barStyle = t.gridType, i.alpha = t.gridAlpha, i.widthRatio = t.gridWidth, i.isShow = e.isShow, i.zLevel = e.zLevel, t.inView ? await this.scene.updateBar(e.id, t.id, i) : (await this.scene.addBar(e.id, i), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } } addSceneEventListener(e) { "on3DGridLayerHover" !== e && "on3DGridLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("on3DGridLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "on3DGridLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "on3DGridLayerHover" !== e && "on3DGridLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("on3DGridLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "on3DGridLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected && this.scene.tgapp.triggerEvent.on3DGridLayerClick({ idObj: i.id, idLayer: t.id, selected: i.isSelected, coord: [r.longitude, r.latitude], label: i.label, type: i.source.type }), "hover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.on3DGridLayerHover({ idObj: i.id, idLayer: t.id, coord: [r.longitude, r.latitude] }), "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.on3DGridLayerUnhover({ idObj: i.id, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e || this.scene.tgapp.triggerEvent.onFocusAll3DGridLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAll3DGridLayerStart({}) : this.scene.tgapp.triggerEvent.onFocus3DGridLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocus3DGridLayerStart({ idLayer: t }) } } const grid3DLayer = new Grid3DLayer; class HeatMapLayer extends BaseOverlay { constructor() { super(), this.type = "heatMapLayer", this.interfaceList = ["addHeatMapLayer", "updateHeatMapLayerCoord", "updateHeatMapLayerStyle"] } addHeatMapLayer({ id: e, alpha: t, type: i } = {}, r) { if (this.layerIdIsUsed(e)) return void (r && r({ result: 0, message: `失败，${e} 已存在。` })); let n = this.deepCopy(arguments[0]), a = this._convertLayer(n); a.zLevel = store.zLevel++, this._drawLayer(a, r) } updateHeatMapLayerCoord({ id: e } = {}, t) { if (!this.getLayer(e)) return void (t && t({ result: 0, message: `失败，未找到 ${e} 地标图。` })); let i = this.deepCopy(arguments[0]), r = this._convertLayer(i); this._drawLayer(r, t) } updateHeatMapLayerStyle({ id: e, alpha: t, type: i } = {}, r) { if (!this.getLayer(e)) return void (r && r({ result: 0, message: `失败，未找到 ${e} 地标图。` })); let n = this.deepCopy(arguments[0]); n.isAppend = !0; let a = this._convertLayer(n); this._drawLayer(a, r) } _convertLayer({ id: e, isAppend: t = !1 } = {}) { let i = this.getLayer(e); if (i || (i = this.createLayer(e, arguments[0])), !t) { i.source.data = []; for (const e of i.data) this.scene.removeDrawable(i.id, e.id); i.data = [] } return this._updateLayer(i, arguments[0]), this._updateData(i), i } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, coordZ: n, type: a, alpha: o, colorMax: s, colorMin: l, valueMax: c, valueMin: h, radius: u, data: d = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r), null != n && (e.source.coordZ = n), null != a && (e.source.type = a), null != o && (e.source.alpha = o), null != s && (e.source.colorMax = s), null != l && (e.source.colorMin = l), null != c && (e.source.valueMax = c), null != h && (e.source.valueMin = h), null != u && (e.source.radius = u); for (const t of d) e.source.data.push(t) } _updateData(e) { let t = e.getData(e.source.id); t ? t.setSource(e.source) : t = this.createData(e.source.id, e.source, e); let i = 0 == e.source.coordType ? "lla" : "xyz", r = []; for (const t of e.source.data) { let n = new Position(i); "lla" === i ? n.set(t.coord[0], t.coord[1], e.source.coordZ) : n.set(t.coord[0], e.source.coordZ, t.coord[1]), n.value = this._getValueByRatio(e.source, t.value), r.push(n) } if ("lla" === i) for (const e of r) { let t = this.scene.convertLLAToXYZ(e); e.x = t.x, e.y = t.y, e.z = t.z } t.positions = r, t.alpha = e.source.alpha, t.type = "dot" != e.source.type ? "none" : "dot", t.radius = e.source.radius, t.valueMax = e.source.valueMax, t.valueMin = e.source.valueMin, t.gradient = { 0: e.source.colorMin, .33: "#00ff00", .66: "#ffff00", 1: e.source.colorMax }, t.points = r.map((e => ({ value: e.value, x: e.x, y: e.y, z: e.z }))) } async _drawLayer(e, t) { if (this.scene) { for (const t of e.data) { let i = {}; i.name = t.id, i.opacity = t.alpha, i.style = t.type, i.radius = Math.ceil(t.radius), i.valueMax = t.valueMax, i.valueMin = t.valueMin, i.gradient = t.gradient, i.points = t.points, i.enableAutoHidebyDistance = !1, i.pointsType = "xyz", i.isShow = e.isShow, i.zLevel = e.zLevel, t.inView ? await this.scene.updateHeatMapData(e.id, t.id, i) : (await this.scene.addHeatMap(e.id, i), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } } _getValueByRatio(e, t) { let i = e.valueMax, r = e.valueMin; return t < r ? r : t > i ? i : t } addSceneEventListener(e) { "onHeatmapLayerHover" !== e && "onHeatmapLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onHeatmapLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onHeatmapLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onHeatmapLayerHover" !== e && "onHeatmapLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onHeatmapLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onHeatmapLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.onHeatmapLayerClick({ idLayer: t.id, coord: [r.longitude, r.latitude], selected: i.isSelected, label: i.label, type: i.source.type }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.onHeatmapLayerHover({ idLayer: t.id, coord: [r.longitude, r.latitude] }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onHeatmapLayerUnhover({ idLayer: t.id }) } onFocusEvent({ type: e, layerId: t } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e || this.scene.tgapp.triggerEvent.onFocusAllHeatmapLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllHeatmapLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusHeatmapLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusHeatmapLayerStart({ idLayer: t }) } } const heatMapLayer = new HeatMapLayer; class BubbleLayer extends BaseOverlay { constructor() { super(), this.type = "bubbleLayer", this.interfaceList = ["addBubbleLayer", "updateBubbleLayerCoord", "updateBubbleLayerStyle"] } addBubbleLayer({ id: e, fillArea: t } = {}, i) { if (this.layerIdIsUsed(e)) return void (i && i({ result: 0, message: `失败，${e} 已存在。` })); let r = this.deepCopy(arguments[0]), n = this._convertLayer(r); n.zLevel = store.zLevel++, this._drawLayer(n, i) } updateBubbleLayerCoord({ id: e } = {}, t) { let i = this.getLayer(e); if (!i) return void (t && t({ result: 0, message: `失败，未找到 ${e} 气泡图。` })); let r = this.deepCopy(arguments[0]); this._convertLayer(r), this._drawLayer(i, t) } updateBubbleLayerStyle({ id: e, fillArea: t } = {}, i) { let r = this.getLayer(e); if (!r) return void (i && i({ result: 0, message: `失败，未找到 ${e} 气泡图。` })); let n = this.deepCopy(arguments[0]); this._convertLayer(n), this._drawLayer(r, i) } _convertLayer({ id: e, isAppend: t = !0 } = {}) { let i = this.getLayer(e); return i || (i = this.createLayer(e, arguments[0])), t || (i.source.data = [], this.scene.removeLayer(i.id), i.data = []), this._updateLayer(i, arguments[0]), this._updateData(i), i } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, fillArea: n, speed: a, radiusMax: o, radiusMin: s, valueMax: l, valueMin: c, legends: h = [], data: u = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r), null != n && (e.source.fillArea = n), null != a && (e.source.speed = a), null != o && (e.source.radiusMax = o), null != s && (e.source.radiusMin = s), null != l && (e.source.valueMax = l), null != c && (e.source.valueMin = c); for (const t of h) { let i = e.source.legends.findIndex((e => e.name == t.name)); -1 == i ? e.source.legends.push(t) : e.source.legends[i] = t } for (const t of u) { let i = e.source.data.findIndex((e => e.id === t.id)); -1 == i ? e.source.data.push(t) : e.source.data[i] = t } } _updateData(e) { let t = 0 == e.source.coordType ? "lla" : "xyz"; for (const i of e.source.data) { let r = e.getData(i.id); r ? r.setSource(i) : r = this.createData(i.id, i, e); let n = e.source.legends.find((e => e.name == r.source.type)); n ? (r.legend = n.name, r.color = n.color) : (r.legend = void 0, r.color = void 0); let a = new Position(t); "lla" === t ? a.set(i.coord[0], i.coord[1], i.coordZ) : a.set(i.coord[0], i.coordZ, i.coord[1]), r.positions = [a], r.value = this._getValueByRatio(e.source, i.value), r.speed = e.source.speed } } _getValueByRatio(e, t) { let i = e.radiusMax, r = e.radiusMin, n = e.valueMax, a = e.valueMin, o = i - r, s = n - a; return 0 == o || 0 == s ? i : t < a ? r : t > n ? i : (t - a) * (o / s) + r } async _drawLayer(e, t) { if (!this.scene) return; let i = [], r = !1, n = []; for (const t of e.data) { if (null == t.legend) { i.push(t.source.type); continue } let a = {}; a.name = t.id, a.position = t.positions[0], a.value = t.value, a.bubbleColor = t.color, a.animationSpeed = t.speed, a.isShow = e.isShow, a.zLevel = e.zLevel, n.push(a), r = r || t.inView } if (n.length > 0) { r ? this.scene.updateInstancedBubble(e.id, { isShow: e.isShow, points: n, fillArea: e.source.fillArea || "none" }) : await this.scene.addInstancedBubble(e.id, { isShow: e.isShow, points: n, fillArea: e.source.fillArea || "none" }); for (const t of e.data) t.inView = !0 } t && t({ result: 1, message: "成功。" }) } asyncSelectionState() { for (const e of this.getLayers()) for (const t of e.data) t.isSelected && this.isShowDecorator ? this.scene.selectInstancedBubble(e.id, e.id, t.id) : this.scene.deselectInstancedBubble(e.id, e.id, t.id) } addSceneEventListener(e) { "onBubbleLayerHover" !== e && "onBubbleLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onBubbleLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onBubbleLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onBubbleLayerHover" !== e && "onBubbleLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onBubbleLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onBubbleLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i } = {}) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.onBubbleLayerClick({ idObj: i.id, idLayer: t.id, selected: i.isSelected, label: i.label, type: i.source.type }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.onBubbleLayerHover({ idObj: i.id, idLayer: t.id }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onBubbleLayerUnhover({ idObj: i.id, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t, dataId: i, legend: r } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e ? "focusLayerStart" !== e ? "focusLayerEnd" !== e ? "focusLegendStart" !== e ? "focusLegendEnd" !== e || this.scene.tgapp.triggerEvent.onFocusBubbleLayerLegendEnd({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusBubbleLayerLegendStart({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusBubbleLayerObjEnd({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusBubbleLayerObjStart({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusAllBubbleLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllBubbleLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusBubbleLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusBubbleLayerStart({ idLayer: t }) } } const bubbleLayer = new BubbleLayer; class Column3DLayer extends BaseOverlay { constructor() { super(), this.type = "3DColumnLayer", this.interfaceList = ["add3DColumnLayer", "update3DColumnLayerCoord", "update3DColumnLayerStyle"] } add3DColumnLayer({ id: e, name: t, columnType: i, columnPaint: r, colorMax: n, colorMin: a, labelColor: o, labelBackgroundColor: s, legends: l, columnAlpha: c } = {}, h) { if (this.layerIdIsUsed(e)) return void (h && h({ result: 0, message: `失败，${e} 已存在。` })); let u = this.deepCopy(arguments[0]), d = this._convertLayer(u); d.zLevel = store.zLevel++, this._drawLayer(d, h) } update3DColumnLayerCoord({ id: e } = {}, t) { let i = this.getLayer(e); if (!i) return void (t && t({ result: 0, message: `失败，未找到 ${e} 柱图。` })); let r = this.deepCopy(arguments[0]); this._convertLayer(r), this._drawLayer(i, t) } update3DColumnLayerStyle({ id: e, columnAlpha: t, columnMaxHeight: i, columnMinHeight: r, valueMin: n, valueMax: a, legends: o } = {}, s) { let l = this.getLayer(e); if (!l) return void (s && s({ result: 0, message: `失败，未找到 ${e} 柱图。` })); let c = this.deepCopy(arguments[0]); l = this._convertLayer(c), this._drawLayer(l, s) } _convertLayer({ id: e, isAppend: t = !0 } = {}) { let i = this.getLayer(e); if (i || (i = this.createLayer(e, arguments[0])), !t) { i.source.data = []; for (const e of i.data) this.scene.removeDrawable(i.id, e.id); i.data = [] } return this._updateLayer(i, arguments[0]), this._updateData(i), i } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, coordZ: n, columnType: a, columnMinHeight: o, columnMaxHeight: s, columnAlpha: l, columnPaint: c, columnGap: h, columnWidth: u, colorMax: d, colorMin: p, valueMax: f, valueMin: m, labelColor: g, labelBackgroundColor: y, legends: v = [], data: _ = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r), null != n && (e.source.coordZ = n), null != a && (e.source.columnType = a), null != o && (e.source.columnMinHeight = o), null != s && (e.source.columnMaxHeight = s), null != l && (e.source.columnAlpha = l), null != c && (e.source.columnPaint = c), null != h && (e.source.columnGap = h), null != u && (e.source.columnWidth = u), null != d && (e.source.colorMax = d), null != p && (e.source.colorMin = p), null != f && (e.source.valueMax = f), null != m && (e.source.valueMin = m), null != g && (e.source.labelColor = g), null != y && (e.source.labelBackgroundColor = y); for (const t of _) { let i = e.source.data.findIndex((e => e.id === t.id)); -1 == i ? e.source.data.push(t) : e.source.data[i] = t } for (const t of v) { let i = e.source.legends.findIndex((e => e.name === t.name)); -1 == i ? e.source.legends.push(t) : e.source.legends[i] = t } } _updateData(e) { this._maxWidth(e.source); for (const t of e.source.data) { let i = e.getData(t.id); i ? i.setSource(t) : i = this.createData(t.id, t, e), i.positions = [i.source.position], i.value = this._getValueByRatio(e.source, i.source.value), "solid" === e.source.columnPaint || "linear" === e.source.columnPaint ? i.color = this._getColorByRatio(e.source, i.source.value) : "legend" === e.source.columnPaint && (i.color = this._getColorByLegend(e.source, i.source.value)), void 0 === i.enableLabel && (i.enableLabel = !1), i.labelText = i.source.label, i.labelColor = e.source.labelColor, i.labelBackgroundColor = e.source.labelBackgroundColor, i.columnType = "cube" == e.source.columnType ? "矩形" : "cylinder", i.columnAlpha = e.source.columnAlpha, i.columnWidth = e.source.columnWidth, i.columnPaint = e.source.columnPaint, i.colorMax = e.source.colorMax, i.colorMin = e.source.colorMin } } _maxWidth({ coordType: e, coordZ: t, columnWidth: i, data: r } = {}) { let n = 0 == e ? "lla" : "xyz"; for (const e of r) e.position = new Position(n), "lla" === n ? e.position.set(e.coord[0], e.coord[1], t) : e.position.set(e.coord[0], t, e.coord[1]); let a = i; for (const e of r) for (const t of r) { if (e.id === t.id) continue; let i = this.scene.getDistanceByPositions(e.position, t.position); i < a && (a = i) } arguments[0].maxWidth = a } _getValueByRatio(e, t) { let i = e.columnMaxHeight, r = e.columnMinHeight, n = e.valueMax, a = e.valueMin, o = i - r, s = n - a; return 0 == o || 0 == s ? i : t < a ? r : t > n ? i : (t - a) * (o / s) + r } _getColorByLegend(e, t) { let i = e.legends.find((e => e.minValue < t && e.maxValue >= t)); return i ? i.color : "#ffffff" } _getColorByRatio(e, t) { let i = this._colorToRgba(e.colorMax), r = this._colorToRgba(e.colorMin), n = e.valueMax, a = e.valueMin; if (t < a) return "rgba(" + r.join(",") + ")"; if (t > n) return "rgba(" + i.join(",") + ")"; let o = (t - a) / (n - a), s = this._subtraction(i, r), l = this._multiplication(s, o); return "rgba(" + this._multiply(r, l).join(",") + ")" } _colorToRgba(e) { var t = e.toLowerCase(), i = 1; if (t && /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(t)) { if (4 === t.length || 5 === t.length) { for (var r = "#", n = 1; n < t.length; n += 1)r += t.slice(n, n + 1).concat(t.slice(n, n + 1)); t = r } 9 === t.length && (i = (parseInt("0x" + t.slice(7, 9)) / 255).toFixed(2)); var a = []; for (n = 1; n < 7; n += 2)a.push(parseInt("0x" + t.slice(n, n + 2))); return [...a, i] } return t } _subtraction(e, t) { return [e[0] - t[0], e[1] - t[1], e[2] - t[2], e[3] - t[3]] } _multiplication(e, t) { return [Math.round(e[0] * t), Math.round(e[1] * t), Math.round(e[2] * t), Math.round(e[3] * t)] } _multiply(e, t) { return [e[0] + t[0], e[1] + t[1], e[2] + t[2], e[3] + t[3]] } async _drawLayer(e, t) { if (this.scene) { for (const t of e.data) { let i = {}; i.name = t.id, i.position = t.positions[0], i.value = t.value, i.color = t.color, i.barStyle = t.columnType, i.alpha = t.columnAlpha, i.widthRatio = t.columnWidth, i.label = t.enableLabel, i.labelText = t.labelText, i.labelColor = t.labelColor, i.labelBackground = t.labelBackgroundColor, i.isShow = e.isShow, i.columnPaint = t.columnPaint, i.colorMax = t.colorMax, i.colorMin = t.colorMin, i.zLevel = e.zLevel, t.inView ? await this.scene.updateBar(e.id, t.id, i) : (await this.scene.addBar(e.id, i), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } } addSceneEventListener(e) { "on3DColumnLayerHover" !== e && "on3DColumnLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("on3DColumnLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "on3DColumnLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "on3DColumnLayerHover" !== e && "on3DColumnLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("on3DColumnLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "on3DColumnLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected && this.scene.tgapp.triggerEvent.on3DColumnLayerClick({ idObj: i.id, idLayer: t.id, selected: i.isSelected, coord: [r.longitude, r.latitude], label: i.label, type: i.source.type }), "hover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.on3DColumnLayerHover({ idObj: i.id, idLayer: t.id, coord: [r.longitude, r.latitude] }), "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.on3DColumnLayerUnhover({ idObj: i.id, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e || this.scene.tgapp.triggerEvent.onFocusAll3DColumnLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAll3DColumnLayerStart({}) : this.scene.tgapp.triggerEvent.onFocus3DColumnLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocus3DColumnLayerStart({ idLayer: t }) } } const column3DLayer = new Column3DLayer; class TrailLayer extends BaseOverlay { constructor() { super(), this.type = "trailLayer", this.interfaceList = ["addTrailLayer", "updateTrailLayerCoord", "updateTrailLayerStyle"], this.objLifeTimer = null } setScene(e) { super.setScene(e), null !== this.objLifeTimer && clearInterval(this.objLifeTimer), this.objLifeTimer = setInterval(this._objLifeTest.bind(this), 1e3) } _objLifeTest() { if (!this.layers || this.layers.length <= 0) return; let e = new Date; for (let t = this.layers.length - 1; t >= 0; t--) { const i = this.layers[t]; if (void 0 === i) continue; if (!i.data || i.data.length <= 0) { this.removeLayer(i.id); continue } for (let t = i.data.length - 1; t >= 0; t--) { const r = i.data[t]; if (!r.timestamp) continue; if ((e - r.timestamp - 1e3) / 1e3 >= i.source.objLife) { let e = i.source.data.findIndex((e => e.id === r.id)); i.source.data.splice(e, 1), i.data.splice(t, 1), this.scene.removeDrawable(i.id, r.id) } } } } addTrailLayer({ id: e, trackStyle: t } = {}, i) { if (this.layerIdIsUsed(e)) return void (i && i({ result: 0, message: `失败，${e} 已存在。` })); let r = this.deepCopy(arguments[0]), n = this._convertLayer(r); n.zLevel = store.zLevel++, this._drawLayer(n, i) } updateTrailLayerCoord({ id: e, isAppend: t = !0 } = {}, i) { let r = this.getLayer(e); if (!r) return void (i && i({ result: 0, message: `失败，未找到 ${e} 轨迹图。` })); let n = this.deepCopy(arguments[0]); n.dataAppend = t, this._convertLayer(n), this._drawLayer(r, i) } updateTrailLayerStyle({ id: e, trackStyle: t, isAppend: i = !0 } = {}, r) { let n = this.getLayer(e); if (!n) return void (r && r({ result: 0, message: `失败，未找到 ${e} 轨迹图。` })); let a = this.deepCopy(arguments[0]); a.legendAppend = i, this._convertLayer(a), this._drawLayer(n, r) } _convertLayer({ id: e, dataAppend: t = !0, legendAppend: i = !0 } = {}) { let r = this.getLayer(e); if (r || (r = this.createLayer(e, arguments[0])), !t) { r.source.data = []; for (const e of r.data) this.scene.removeDrawable(r.id, e.id); r.data = [] } if (!i) { r.source.legends = []; for (const e of r.data) this.scene.removeDrawable(r.id, e.id); r.data = [] } return this._updateLayer(r, arguments[0]), this._updateData(r), r } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, trackStyle: n, trackDuration: a, trackWidth: o, objLife: s, time: l, legends: c = [], data: h = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r), null != n && (e.source.trackStyle = n), null != a && (e.source.trackDuration = a), null != o && (e.source.trackWidth = o), null != s && (e.source.objLife = s), null != l && (e.source.time = l); for (const t of c) { let i = e.source.legends.findIndex((e => e.name == t.name)); -1 == i ? e.source.legends.push(t) : e.source.legends[i] = t } for (const t of h) { let i = e.source.data.findIndex((e => e.id === t.id)); -1 == i ? e.source.data.push(t) : e.source.data[i] = t } } _updateData(e) { let t = 0 == e.source.coordType ? "lla" : "xyz"; for (const i of e.source.data) { let r = e.getData(i.id); r ? r.setSource(i) : r = this.createData(i.id, i, e); let n = e.source.legends.find((e => e.name == r.source.type)); n ? (r.legend = n.name, r.trackColor = n.trackColor, r.iconName = n.iconName) : (r.legend = void 0, r.trackColor = void 0, r.iconName = void 0); let a = new Position(t); "lla" === t ? a.set(r.source.coord[0], r.source.coord[1], r.source.coordZ) : "xyz" === t && a.set(r.source.coord[0], r.source.coordZ, r.source.coord[1]), r.positions = [a], r.label = r.source.label, r.trackDuration = e.source.trackDuration, r.trackWidth = e.source.trackWidth, r.time = e.source.duration || 1 } } async _drawLayer(e, t) { if (!this.scene) return; let i = [], r = []; for (const t of e.data) { if (null == t.legend) { i.push(t.source.type), this.scene.removeDrawable(e.id, t.id); continue } if (!this.isContainIconAsset(t.iconName)) { r.push(t.iconName), this.scene.removeDrawable(e.id, t.id); continue } let n = await this.getIconAsset(t.iconName); n.labelText = t.label, n.label = !!t.label, n.name = t.id, n.position = t.positions[0], n.duration = t.trackDuration, n.lineWidth = t.trackWidth, n.color = t.trackColor, n.travelingTime = t.time, n.zLevel = e.zLevel, n.isShow = e.isShow, t.inView ? await this.scene.updateTrail(e.id, t.id, n) : (await this.scene.addTrail(e.id, n), t.inView = !0), t.timestamp = new Date } if (t) if (r.length > 0 || i.length > 0) { let e = "错误，"; i.length > 0 && (e += `图例 ${i.join("、")} 不存在。`), r.length > 0 && (e += `图标 ${r.join("、")} 不存在。`), t({ result: 0, message: e }) } else t({ result: 1, message: "成功。" }) } addSceneEventListener(e) { "onTrailLayerHover" !== e && "onTrailLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onTrailLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onTrailLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onTrailLayerHover" !== e && "onTrailLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onTrailLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onTrailLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i } = {}) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.onTrailLayerClick({ idObj: i.id, idLayer: t.id, selected: i.isSelected, label: i.label, type: i.source.type }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.onTrailLayerHover({ idObj: i.id, idLayer: t.id }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onTrailLayerUnhover({ idObj: i.id, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t, dataId: i, legend: r } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e ? "focusLayerStart" !== e ? "focusLayerEnd" !== e ? "focusLegendStart" !== e ? "focusLegendEnd" !== e || this.scene.tgapp.triggerEvent.onFocusTrailLayerLegendEnd({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusTrailLayerLegendStart({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusTrailLayerObjEnd({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusTrailLayerObjStart({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusAllTrailLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllTrailLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusTrailLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusTrailLayerStart({ idLayer: t }) } } const trailLayer = new TrailLayer; class ODLineLayer extends BaseOverlay { constructor() { super(), this.type = "ODLineLayer", this.interfaceList = ["addODLineLayer", "updateODLineLayerCoord", "updateODLineLayerStyle"] } addODLineLayer({ id: e, lineSpeed: t, curvature: i } = {}, r) { let n = this.getLayer(e); if (this.layerIdIsUsed(e)) return void (r && r({ result: 0, message: `失败，${e} 已存在。` })); let a = this.deepCopy(arguments[0]); n = this._convertLayer(a), n.zLevel = store.zLevel++, this._drawLayer(n, r), this.dispatchEvent({ type: "addODLineLayer", layer: n }) } updateODLineLayerCoord({ id: e, isAppend: t = !0 } = {}, i) { let r = this.getLayer(e); if (!r) return void (i && i({ result: 0, message: `失败，未找到 ${e} 关系图。` })); let n = this.deepCopy(arguments[0]); n.dataAppend = t, this._convertLayer(n), this._drawLayer(r, i), this.dispatchEvent({ type: "updateODLineLayerCoord", layer: r }) } updateODLineLayerStyle({ id: e, lineSpeed: t, curvature: i, isAppend: r = !0 } = {}, n) { let a = this.getLayer(e); if (!a) return void (n && n({ result: 0, message: `失败，未找到 ${e} 气泡图。` })); let o = this.deepCopy(arguments[0]); o.legendAppend = r, this._convertLayer(o), this._drawLayer(a, n), this.dispatchEvent({ type: "updateODLineLayerStyle", layer: a }) } _convertLayer({ id: e, dataAppend: t = !0, legendAppend: i = !0 } = {}) { let r = this.getLayer(e); return r || (r = this.createLayer(e, arguments[0])), t || (r.source.data = [], this.scene.removeLayer(r.id), r.data = []), i || (r.source.legends = [], this.scene.removeLayer(r.id), r.data = []), this._updateLayer(r, arguments[0]), this._updateData(r), r } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, valueMax: n, valueMin: a, isShowBubble: o, bubbleRadiusMax: s, bubbleRadiusMin: l, bubbleSpeed: c, lineWidthMax: h, lineWidthMin: u, lineSpeed: d, curvature: p, legends: f = [], data: m = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r), null != n && (e.source.valueMax = n), null != a && (e.source.valueMin = a), null != o && (e.source.isShowBubble = o), null != s && (e.source.bubbleRadiusMax = s), null != l && (e.source.bubbleRadiusMin = l), null != c && (e.source.bubbleSpeed = c), null != h && (e.source.lineWidthMax = h), null != u && (e.source.lineWidthMin = u), null != d && (e.source.lineSpeed = d), null != p && (e.source.curvature = p); for (const t of f) { let i = e.source.legends.findIndex((e => e.name == t.name)); -1 == i ? e.source.legends.push(t) : e.source.legends[i] = t } for (const t of m) { let i = e.source.data.findIndex((e => e.id === t.id)); -1 == i ? e.source.data.push(t) : e.source.data[i] = t } } _updateData(e) { let t = 0 == e.source.coordType ? "lla" : "xyz"; for (const i of e.source.data) { let r = e.getData(i.id); r ? r.setSource(i) : r = this.createData(i.id, i, e); let n = e.source.legends.find((e => e.name == r.source.type)); n ? (r.legend = n.name, r.lineColor = n.lineColor, r.type = n.type, r.bubbleColor = n.bubbleColor, r.labelColor = n.labelColor, r.labelBackgroundColor = n.labelBackgroundColor, r.labelFontSize = n.labelFontSize) : (r.legend = void 0, r.lineColor = void 0, r.type = void 0, r.bubbleColor = void 0, r.labelColor = void 0, r.labelBackgroundColor = void 0); let a = new Position(t); "lla" === t ? a.set(r.source.startCoord[0], r.source.startCoord[1], r.source.startCoordZ) : a.set(r.source.startCoord[0], r.source.startCoordZ, r.source.startCoord[1]); let o = new Position(t); "lla" === t ? o.set(r.source.targetCoord[0], r.source.targetCoord[1], r.source.targetCoordZ) : o.set(r.source.targetCoord[0], r.source.targetCoordZ, r.source.targetCoord[1]), r.positions = [a, o], r.lineSpeed = e.source.lineSpeed, r.curvature = e.source.curvature, r.bubbleSpeed = e.source.bubbleSpeed, r.lineWidth = this._getLineWidthByRatio(e.source, r.source.value), r.value = this._getBubbleRadiusByRatio(e.source, r.source.value), r.isShowBubble = e.source.isShowBubble, r.label = r.source.label } } _getLineWidthByRatio(e, t) { let i = e.lineWidthMax, r = e.lineWidthMin, n = e.valueMax, a = e.valueMin, o = i - r, s = n - a; return 0 == o || 0 == s ? i : t < a ? r : t > n ? i : (t - a) * (o / s) + r } _getBubbleRadiusByRatio(e, t) { let i = e.bubbleRadiusMax, r = e.bubbleRadiusMin, n = e.valueMax, a = e.valueMin, o = i - r, s = n - a; return 0 == o || 0 == s ? i : t < a ? r : t > n ? i : (t - a) * (o / s) + r } async _drawLayer(e, t) { if (!this.scene) return; let i = [], r = !1, n = !1; const a = [], o = [], s = []; for (const t of e.data) { if (null == t.legend) { i.push(t.source.type), this.scene.removeDrawable(e.id, t.id), this.scene.removeDrawable(e.id, t.id + "-start"), this.scene.removeDrawable(e.id, t.id + "-end"); continue } n = n || !!t.inView; const l = {}; l.name = t.id, l.startPos = t.positions[0], l.endPos = t.positions[1], l.color = t.lineColor, l.animationSpeed = t.lineSpeed, l.curvatureCoefficient = 50 * t.curvature, l.imageType = t.type.toLowerCase(), l.lineWidth = t.lineWidth, l.label = !!t.label, l.labelText = t.label, l.labelBackground = t.labelBackgroundColor, l.labelColor = t.labelColor, l.labelFontSize = t.labelFontSize, l.sizeAttenuation = !1, l.isShow = e.isShow, t.inView ? o.push(l) : (a.push(l), t.inView = !0); const c = {}; c.name = t.id + "-start", c.position = t.positions[0], c.value = t.value, c.bubbleColor = t.bubbleColor, c.animationSpeed = t.bubbleSpeed, c.isShow = e.isShow && t.isShowBubble; const h = {}; h.name = t.id + "-end", h.position = t.positions[1], h.value = t.value, h.bubbleColor = t.bubbleColor, h.animationSpeed = t.bubbleSpeed, h.isShow = e.isShow && t.isShowBubble, s.push(c, h), r = c.isShow && h.isShow } s.length > 0 && (n ? await this.scene.updateInstancedBubble(e.id, { isShow: r, points: s }) : await this.scene.addInstancedBubble(e.id, { isShow: r, points: s })); for (const t of a) await this.scene.addODLine(e.id, t); for (const t of o) await this.scene.updateODLine(e.id, t.name, t); t && t({ result: 1, message: "成功。" }) } _onDrawableMouseEvent(e, t, i, r) { if (!i) return; let n, a = this.layers.find((e => e.id == i.parent)); a && (r ? (n = a.data.find((e => e.id == r)), n || (n = a.data.find((e => e.id + "-start" == r)), n || (n = a.data.find((e => e.id + "-end" == r))))) : n = a.data.find((e => e.id == i.name)), n && (this.dispatchEvent({ type: "mouseEvent", option: e, layer: a, data: n, event: t, obj: i }), this.onMouseSelection(e, n), this.onMouseEvent({ type: e, layer: a, data: n, event: t, obj: i }))) } asyncSelectionState() { for (const e of this.getLayers()) for (const t of e.data) t.isSelected && this.isShowDecorator ? (this.scene.selectDrawable(e.id, t.id), this.scene.selectInstancedBubble(e.id, e.id, t.id + "-start"), this.scene.selectInstancedBubble(e.id, e.id, t.id + "-end")) : (this.scene.deselectDrawable(e.id, t.id), this.scene.deselectInstancedBubble(e.id, e.id, t.id + "-start"), this.scene.deselectInstancedBubble(e.id, e.id, t.id + "-end")) } addSceneEventListener(e) { "onODLineLayerHover" !== e && "onODLineLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onODLineLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onODLineLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onODLineLayerHover" !== e && "onODLineLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onODLineLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onODLineLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i, event: r, obj: n }) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.onODLineLayerClick({ idObj: i.id, idLayer: t.id, selected: i.isSelected, label: i.label, type: i.source.type }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.onODLineLayerHover({ idObj: i.id, idLayer: t.id }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onODLineLayerUnhover({ idObj: i.id, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t, dataId: i, legend: r } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e ? "focusLayerStart" !== e ? "focusLayerEnd" !== e ? "focusLegendStart" !== e ? "focusLegendEnd" !== e || this.scene.tgapp.triggerEvent.onFocusODLineLayerLegendEnd({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusODLineLayerLegendStart({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusODLineLayerObjEnd({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusODLineLayerobjStart({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusAllODLineLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllODLineLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusODLineLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusODLineLayerStart({ idLayer: t }) } } const odLineLayer = new ODLineLayer; class Marker3D extends BaseOverlay { constructor() { super(), this.type = "3DMarker", this.interfaceList = ["add3DMarker", "update3DMarkerCoord", "update3DMarkerStyle"] } add3DMarker({ id: e, type: t } = {}, i) { if (this.layerIdIsUsed(e)) return void (i && i({ result: 0, message: `失败，${e} 已存在。` })); let r = this.getMarkerAsset(t); if (!r) return void (i && i({ result: 0, message: `失败，不存在 ${t} 特效类型。` })); let n = this.deepCopy(arguments[0]); n.asset = r; let a = this._convertLayer(n); a.zLevel = store.zLevel++, this._drawLayer(a, i) } update3DMarkerCoord({ id: e } = {}, t) { let i = this.getLayer(e); if (!i) return void (t && t({ result: 0, message: `失败，未找到 ${e} 特效。` })); let r = this.deepCopy(arguments[0]); i = this._convertLayer(r), this._drawLayer(i, t) } update3DMarkerStyle({ id: e, alpha: t, type: i } = {}, r) { let n = this.getLayer(e), a = this.getMarkerAsset(i); if (!n) return void (r && r({ result: 0, message: `失败，未找到 ${e} 特效。` })); if (!a) return void (r && r({ result: 0, message: `失败，不存在 ${i} 特效类型。` })); let o = this.deepCopy(arguments[0]); o.asset = a, n = this._convertLayer(o), this._drawLayer(n, r) } _convertLayer({ id: e, coordType: t, coordTypeZ: i, alpha: r, scale: n, type: a, titleText: o, titleColor: s, titleBackgroundColor: l, coord: c, coordZ: h, tag: u, asset: d } = {}) { let p = this.getLayer(e); p || (p = this.createLayer(e, arguments[0])), null != t && (p.source.coordType = t), null != i && (p.source.coordTypeZ = i), null != r && (p.source.alpha = r), null != n && (p.source.scale = n), null != a && (p.source.type = a), null != o && (p.source.titleText = o), null != s && (p.source.titleColor = s), null != l && (p.source.titleBackgroundColor = l), null != c && (p.source.coord = c), null != h && (p.source.coordZ = h), null != d && (p.source.asset = d), void 0 !== u && (p.source.tag = u); let f = p.getData(e); f ? f.setSource(p.source) : f = this.createData(e, p.source, p); const m = 0 == f.source.coordType ? "lla" : "xyz", g = new Position(m); return g.set(f.source.coord[0], f.source.coord[1], f.source.coordZ), "xyz" === m && g.set(f.source.coord[0], f.source.coordZ, f.source.coord[1]), f.positions = [g], f.asset = f.source.asset, f.alpha = f.source.alpha, f.scale = f.source.scale, f.titleText = f.source.titleText, f.titleColor = f.source.titleColor, f.titleBackgroundColor = f.source.titleBackgroundColor, p } async _drawLayer(e, t) { if (this.scene) { for (const t of e.data) { let i = {}; Object.assign(i, t.asset), i.name = t.id, i.opacity = t.alpha, i.size = t.scale, i.position = t.positions[0], i.titleText = t.titleText, i.titleColor = t.titleColor, i.titleBackgroundColor = t.titleBackgroundColor, i.isShow = e.isShow, i.zLevel = e.zLevel, i.isExplosion = !!t.asset.isExplosion, t.inView ? await this.scene.update3DMarker(e.id, i.name, i) : (await this.scene.add3DMarker(e.id, i), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } } addSceneEventListener(e) { "on3DMarkerHover" !== e && "on3DMarkerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("on3DMarkerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "on3DMarkerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "on3DMarkerHover" !== e && "on3DMarkerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("on3DMarkerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "on3DMarkerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i } = {}) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.on3DMarkerClick({ id: i.id, tag: void 0 === t.source.tag ? "" : t.source.tag, selected: i.isSelected }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.on3DMarkerHover({ id: i.id, tag: void 0 === t.source.tag ? "" : t.source.tag }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.on3DMarkerUnhover({ id: i.id, tag: void 0 === t.source.tag ? "" : t.source.tag }) } onFocusEvent({ type: e, layerId: t } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e || this.scene.tgapp.triggerEvent.onFocusAll3DMarkerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAll3DMarkerStart({}) : this.scene.tgapp.triggerEvent.onFocus3DMarkerEnd({ id: t }) : this.scene.tgapp.triggerEvent.onFocus3DMarkerStart({ id: t }) } } const marker3D = new Marker3D; class Models extends BaseComponent { constructor() { super(), this.type = "Models", this.interfaceList = ["getModelsByType", "setModelTransform", "setModelTransform2", "setModelCoord", "setModelStyle", "setModelVisibility", "showBuildingFloor", "resetBuildingFloor", "addModelTip", "removeModelTip", "rotatingModel", "setModelRotationState", "blinkingModel", "setModelBlinkState", "movingModel", "setModelMoveState", "pathingModel", "setModelPathingState", "selectModel", "endSelectModel", "pickModel", "endPickModel", "clickModel", "clickModelType", "clearModelSelected", "getModelArticulation", "setModelArticulation", "playModelAnimation", "getModelAnimation", "setModelAnimation", "highlightBuilding", "highlightFloor", "highlightRoom", "getBuildings", "addModel", "removeModel", "setModelMaterial"], this.onModelMouseHover = this._onModelMouseHover.bind(this), this.unModelMouseHover = this._unModelMouseHover.bind(this), this.onBuildingMouseHover = this._onBuildingMouseHover.bind(this), this.unBuildingMouseHover = this._unBuildingMouseHover.bind(this), this.ctrlPress = !1, document.addEventListener("keydown", (e => { "Control" === e.key && (this.ctrlPress = !0), e.cancelBubble = !0 })), document.addEventListener("keyup", (e => { "Control" === e.key && (this.ctrlPress = !1), e.cancelBubble = !0 })) } setScene(e) { super.setScene(e), this.scene.on("click", "model", ((e, t) => this._onModelMouseClick(e, t))), this.scene.on("click", "building", ((e, t) => this._onBuildingMouseClick(e, t))), this.scene.addEventListener("modelSelection", "onTranslate", (e => this.onDrawableTransform(e, "translate"))), this.scene.addEventListener("modelSelection", "onRotate", (e => this.onDrawableTransform(e, "rotate"))), this.scene.addEventListener("modelSelection", "onScale", (e => this.onDrawableTransform(e, "scale"))), this.selectModelObj = {}, this.selectBuildingObj = {}, this.selectedModels = {}, this.selectedBuildings = {}, this.allowModelClick = !1, this.allowModelHover = !1, this.allowBuildingClick = !1, this.allowBuildingHover = !1, this.transformModel = null; const t = this.scene.tgapp.events; for (const e in t) { t[e].length > 0 && this.addSceneEventListener(e) } } setModelMaterial(e, t) { this.scene.setModelMaterial(e, t) } onDrawableTransform(e, t) { const i = { idLayer: "", idObj: "", overlayType: "model", coordType: 1, data: [] }; for (const r of e) if (r.name == this.transformModel && (i.idObj = r.name), "translate" === t) i.data.push({ name: r.name, coord: [r.position.x, r.position.z], coordZ: r.position.y }); else if ("rotate" === t) { const e = r.rotation.x / Math.PI * 180, t = r.rotation.y / Math.PI * 180, n = 180 - r.rotation.z / Math.PI * 180; i.data.push({ rotation: [e, t, n], name: r.name }) } else "scale" === t && i.data.push({ scale: [r.scale.x, r.scale.y, r.scale.z], name: r.name }); "translate" === t ? this.scene.tgapp.triggerEvent.onTransformAxisDrag(i) : "rotate" === t ? this.scene.tgapp.triggerEvent.onRotationAxisDrag(i) : "scale" === t && this.scene.tgapp.triggerEvent.onScaleAxisDrag(i) } showModelAxis(e, t) { const { axisType: i } = e; if ("transform" === i || "scale" === i || "rotation" === i) { let { id: r, ids: n = [], relative: a = "centre", unit: o, directionType: s } = e; this.transformModel = r, n.push(r), "group" === a ? a = "centre" : "self" === a && (a = "oneself"), this.scene.enableTransformOnModel(n, i, a, o, s), t && t({ result: 1, message: "成功。" }) } else "none" === i ? this.scene.disableTransformOnModel() : t && t({ result: 0, message: "失败，不支持的操作类型。" }) } addSceneEventListener(e) { if ("onModelHover" === e || "onModelUnhover" === e) { if (this.scene.tgapp.events[e].length <= 0) return; if (this.scene.tgapp.events[e].length > 1) return; "onModelHover" === e && this.scene.on("mousehover", "model", this.onModelMouseHover), "onModelUnhover" === e && this.scene.on("unmousehover", "model", this.unModelMouseHover) } if ("onBuildingHover" === e || "onFloorHover" === e) { if (this.scene.tgapp.events.onBuildingHover.length > 1) return; if (this.scene.tgapp.events.onFloorHover.length > 1) return; this.scene.off("mousehover", "building", this.onBuildingMouseHover), this.scene.on("mousehover", "building", this.onBuildingMouseHover) } if ("onBuildingUnhover" === e || "onFloorUnhover" === e) { if (this.scene.tgapp.events.onBuildingUnhover.length > 1) return; if (this.scene.tgapp.events.onFloorUnhover.length > 1) return; this.scene.off("unmousehover", "building", this.unBuildingMouseHover), this.scene.on("unmousehover", "building", this.unBuildingMouseHover) } } removeSceneEventListener(e) { if ("onModelHover" === e || "onModelUnhover" === e) { if (this.scene.tgapp.events[e].length <= 0) return; if (this.scene.tgapp.events[e].length > 1) return; "onModelHover" === e && this.scene.off("mousehover", "drawable", this.onModelMouseHover), "onModelUnhover" === e && this.scene.off("unmousehover", "drawable", this.unModelMouseHover) } if ("onBuildingHover" === e || "onFloorHover" === e) { if (this.scene.tgapp.events.onBuildingHover.length > 0) return; if (this.scene.tgapp.events.onFloorHover.length > 0) return; this.scene.off("mousehover", "building", this.onBuildingMouseHover) } if ("onBuildingUnhover" === e || "onFloorUnhover" === e) { if (this.scene.tgapp.events.onBuildingUnhover.length > 0) return; if (this.scene.tgapp.events.onFloorUnhover.length > 0) return; this.scene.off("unmousehover", "building", this.unBuildingMouseHover) } } _onModelMouseClick(e, t) { const { _name: i, type: r } = t; if ("model" !== r) return; if (!0 !== this.allowModelClick) return; void 0 !== this.selectedModels[i] ? (this.selectedModels[i].selected = !1, this.scene.cancleHighlightModel(i)) : (!1 === this.ctrlPress && (this.scene.highlightModel(), this.selectedModels = {}), this.selectedModels[i] = { selected: !0 }, this.scene.highlightModel(i)); { const e = { id: i, selected: this.selectedModels[i] && this.selectedModels[i].selected, meta: [], data: [] }; for (const t in this.selectedModels) { const i = this.selectedModels[t]; e.data.push({ id: t, selected: i.selected, meta: [] }) } this.scene.tgapp.triggerEvent.onModelClick(e) } { const e = { type: "model", id: void 0, selected: "", data: [] }; for (const t in this.selectedModels) { const i = this.selectedModels[t]; void 0 === e.id && (e.id = t, e.selected = i.selected), e.data.push({ type: "model", id: t, selected: i.selected }) } for (const t in this.selectedBuildings) { const i = this.selectedBuildings[t]; void 0 === e.id && (e.id = t, e.selected = i.selected), e.data.push({ type: "building", id: t, selected: i.selected }) } this.scene.tgapp.triggerEvent.onClickModelResult(e) } const n = this.selectedModels; this.selectedModels = {}; for (const e in n) { const t = n[e]; t.selected && (this.selectedModels[e] = t) } } _onModelMouseHover(e, t) { const { name: i, type: r } = t; if ("model" !== r) return; if (!0 !== this.allowModelHover) return; void 0 !== this.selectedModels[i] ? (this.selectedModels[i].selected = !1, this.scene.cancleHighlightModel(i)) : (!1 === this.ctrlPress && (this.scene.highlightModel(), this.selectedModels = {}), this.selectedModels[i] = { selected: !0 }, this.scene.highlightModel(i)); { const e = { id: i, selected: this.selectedModels[i] && this.selectedModels[i].selected, meta: [], data: [] }; for (const t in this.selectedModels) { const i = this.selectedModels[t]; e.data.push({ id: t, selected: i.selected, meta: [] }) } this.scene.tgapp.triggerEvent.onModelClick(e) } { const e = { type: "model", id: void 0, selected: "", data: [] }; for (const t in this.selectedModels) { const i = this.selectedModels[t]; void 0 === e.id && (e.id = t, e.selected = i.selected), e.data.push({ type: "model", id: t, selected: i.selected }) } for (const t in this.selectedBuildings) { const i = this.selectedBuildings[t]; void 0 === e.id && (e.id = t, e.selected = i.selected), e.data.push({ type: "building", id: t, selected: i.selected }) } this.scene.tgapp.triggerEvent.onClickModelResult(e) } const n = this.selectedModels; this.selectedModels = {}; for (const e in n) { const t = n[e]; t.selected && (this.selectedModels[e] = t) } } _unModelMouseHover(e, t) { const { name: i, type: r } = t; if ("model" !== t.type) return; if (!0 !== this.allowModelHover) return; if (!1 !== this.ctrlPress) return; for (const e in this.selectedModels) { this.selectedModels[e].selected = !1 } this.scene.highlightModel(); { const e = { id: i, selected: !1, meta: [], data: [] }; for (const t in this.selectedModels) { const i = this.selectedModels[t]; e.data.push({ id: t, selected: i.selected, meta: [] }) } this.scene.tgapp.triggerEvent.onModelClick(e) } { const e = { type: "model", id: void 0, selected: "", data: [] }; for (const t in this.selectedModels) { const i = this.selectedModels[t]; void 0 === e.id && (e.id = t, e.selected = i.selected), e.data.push({ type: "model", id: t, selected: i.selected }) } for (const t in this.selectedBuildings) { const i = this.selectedBuildings[t]; void 0 === e.id && (e.id = t, e.selected = i.selected), e.data.push({ type: "building", id: t, selected: i.selected }) } this.scene.tgapp.triggerEvent.onClickModelResult(e) } const n = this.selectedModels; this.selectedModels = {}; for (const e in n) { const t = n[e]; t.selected && (this.selectedModels[e] = t) } } _onBuildingMouseClick(e, t) { const { name: i, type: r, level: n } = t; if ("building" === r && !0 === this.allowBuildingClick) if (void 0 !== this.selectedBuildings[i] ? (this.selectedBuildings[i].selected = !1, this.scene.cancleHighlightModel(i)) : (!1 === this.ctrlPress && (this.scene.highlightModel(), this.selectedBuildings = {}), this.selectedBuildings[i] = { selected: !0 }, this.scene.highlightModel(i)), "BuildingItem" === t.selectedType) { { const e = { id: i, selected: this.selectedBuildings[i] && this.selectedBuildings[i].selected, meta: [], data: [] }; for (const t in this.selectedBuildings) { const i = this.selectedBuildings[t]; e.data.push({ id: t, selected: i.selected }) } this.scene.tgapp.triggerEvent.onBuildingClick(e) } { const e = { type: "model", id: void 0, selected: "", data: [] }; for (const t in this.selectedBuildings) { const i = this.selectedBuildings[t]; void 0 === e.id && (e.id = t, e.selected = i.selected), e.data.push({ type: "building", id: t, selected: i.selected }) } for (const t in this.selectedModels) { const i = this.selectedModels[t]; void 0 === e.id && (e.id = t, e.selected = i.selected), e.data.push({ type: "model", id: t, selected: i.selected }) } this.scene.tgapp.triggerEvent.onClickModelResult(e) } const e = this.selectedBuildings; this.selectedBuildings = {}; for (const t in e) { const i = e[t]; i.selected && (this.selectedBuildings[t] = i) } } else "BuildingFloorItem" === t.selectedType && this.scene.tgapp.triggerEvent.onFloorClick({ id: i, floor: n }) } _onBuildingMouseHover(e, t) { const { name: i, type: r, level: n } = t; if ("building" === r && !0 === this.allowBuildingHover) if ("BuildingItem" === t.selectedType) { void 0 !== this.selectedBuildings[i] ? (this.selectedBuildings[i].selected = !1, this.scene.cancleHighlightModel(i)) : (!1 === this.ctrlPress && (this.scene.highlightModel(), this.selectedBuildings = {}), this.selectedBuildings[i] = { selected: !0 }, this.scene.highlightModel(i)); { const e = { id: i, selected: this.selectedBuildings[i] && this.selectedBuildings[i].selected, meta: [], data: [] }; for (const t in this.selectedBuildings) { const i = this.selectedBuildings[t]; e.data.push({ id: t, selected: i.selected, meta: [] }) } this.scene.tgapp.triggerEvent.onBuildingClick(e) } { const e = { type: "building", id: void 0, selected: "", data: [] }; for (const t in this.selectedBuildings) { const i = this.selectedBuildings[t]; void 0 === e.id && (e.id = t, e.selected = i.selected), e.data.push({ type: "building", id: t, selected: i.selected }) } for (const t in this.selectedModels) { const i = this.selectedModels[t]; void 0 === e.id && (e.id = t, e.selected = i.selected), e.data.push({ type: "model", id: t, selected: i.selected }) } this.scene.tgapp.triggerEvent.onClickModelResult(e) } const e = this.selectedBuildings; this.selectedBuildings = {}; for (const t in e) { const i = e[t]; i.selected && (this.selectedBuildings[t] = i) } } else "BuildingFloorItem" === t.selectedType && this.scene.tgapp.triggerEvent.onFloorHover({ id: i, floor: n }) } _unBuildingMouseHover(e, t) { const { name: i, type: r, level: n } = t; if ("building" === r && !0 === this.allowBuildingHover) if ("BuildingItem" === t.selectedType) { if (!1 !== this.ctrlPress) return; for (const e in this.selectedBuildings) { this.selectedBuildings[e].selected = !1 } this.scene.highlightModel(); { const e = { id: i, selected: !1, meta: [], data: [] }; for (const t in this.selectedBuildings) { const i = this.selectedBuildings[t]; e.data.push({ id: t, selected: i.selected, meta: [] }) } this.scene.tgapp.triggerEvent.onBuildingClick(e) } { const e = { type: "building", id: void 0, selected: "", data: [] }; for (const t in this.selectedBuildings) { const i = this.selectedBuildings[t]; void 0 === e.id && (e.id = t, e.selected = i.selected), e.data.push({ type: "building", id: t, selected: i.selected }) } for (const t in this.selectedModels) { const i = this.selectedModels[t]; void 0 === e.id && (e.id = t, e.selected = i.selected), e.data.push({ type: "model", id: t, selected: i.selected }) } this.scene.tgapp.triggerEvent.onClickModelResult(e) } const e = this.selectedBuildings; this.selectedBuildings = {}; for (const t in e) { const i = e[t]; i.selected && (this.selectedBuildings[t] = i) } } else "BuildingFloorItem" === t.selectedType && this.scene.tgapp.triggerEvent.onFloorUnhover({ id: i, floor: n }) } getModelsByType({ modelType: e }, t) { let i = e.toLowerCase(); if ("model" == i) i = "ModelItem"; else if ("building" == i) i = "BuildingItem"; else { if ("icon" != i) return void (t && t({ result: 0, message: `失败，未找到 ${e} 类型的模型。` })); i = "IconAsset" } let r = { type: e }, n = this.scene.getSceneObjects(); n = n.filter((e => e.type == i)), r = n.map((e => ({ id: e.name, isVisible: e.isVisible }))), t && t({ result: 1, message: "成功。", type: e, data: r }) } setModelTransform(e, t) { let i = {}, r = 0 == e.coordType ? "lla" : "xyz"; if (i.position = new Position(r), i.position.set(e.coord[0], e.coord[1], e.coordZ), "xyz" === r && i.position.set(e.coord[0], e.coordZ, e.coord[1]), r && e.rotation && (i.rotation = e.rotation, i.rotation[0] = -i.rotation[0], i.rotation[1] = -i.rotation[1], i.rotation[2] = 180 - i.rotation[2]), e.scale && (i.scale = e.scale, "xyz" === r)) { let e = i.scale[1]; i.scale[1] = i.scale[2], i.scale[2] = e } this.scene.setModelTransform(e.id, i, t) } setModelTransform2(e, t) { if (!e) return void (t && t({ result: 0, message: "参数异常！" })); if ((e = this.deepCopy(e)).isChangeCoordX = !0, e.isChangeCoordY = !0, e.isChangeCoordZ = !0, e.isChangeRotationX = !0, e.isChangeRotationY = !0, e.isChangeRotationZ = !0, e.isChangeScaleX = !0, e.isChangeScaleY = !0, e.isChangeScaleZ = !0, void 0 !== e.coordX && "" !== e.coordX && null !== e.coordX || (e.isChangeCoordX = !1, e.coordX = 0), 0 == e.coordType ? (void 0 !== e.coordY && "" !== e.coordY && null !== e.coordY || (e.isChangeCoordY = !1, e.coordY = 0), void 0 !== e.coordZ && "" !== e.coordZ && null !== e.coordZ || (e.isChangeCoordZ = !1, e.coordZ = 0)) : (void 0 !== e.coordY && "" !== e.coordY && null !== e.coordY || (e.isChangeCoordZ = !1, e.coordZ = 0), void 0 !== e.coordZ && "" !== e.coordZ && null !== e.coordZ || (e.isChangeCoordY = !1, e.coordY = 0)), void 0 !== e.rotationX && "" !== e.rotationX && null !== e.rotationX || (e.isChangeRotationX = !1), 0 == e.coordType ? (void 0 !== e.rotationY && "" !== e.rotationY && null !== e.rotationY || (e.isChangeRotationY = !1), void 0 !== e.rotationZ && "" !== e.rotationZ && null !== e.rotationZ || (e.isChangeRotationZ = !1)) : (void 0 !== e.rotationY && "" !== e.rotationY && null !== e.rotationY || (e.isChangeRotationZ = !1), void 0 !== e.rotationZ && "" !== e.rotationZ && null !== e.rotationZ || (e.isChangeRotationY = !1)), void 0 !== e.scaleX && "" !== e.scaleX && null !== e.scaleX || (e.isChangeScaleX = !1), 0 == e.coordType ? (void 0 !== e.scaleY && "" !== e.scaleY && null !== e.scaleY || (e.isChangeScaleY = !1), void 0 !== e.scaleZ && "" !== e.scaleZ && null !== e.scaleZ || (e.isChangeScaleZ = !1)) : (void 0 !== e.scaleY && "" !== e.scaleY && null !== e.scaleY || (e.isChangeScaleZ = !1), void 0 !== e.scaleZ && "" !== e.scaleZ && null !== e.scaleZ || (e.isChangeScaleY = !1)), e.isChangeScaleX && e.scaleX <= 0) return void (t && t({ result: 0, message: "模型缩放参数错误!" })); if (e.isChangeScaleY && e.scaleY <= 0) return void (t && t({ result: 0, message: "模型缩放参数错误!" })); if (e.isChangeScaleZ && e.scaleZ <= 0) return void (t && t({ result: 0, message: "模型缩放参数错误!" })); if (e.duration <= 0) return void (t && t({ result: 0, message: "基础变换持续时长参数错误!" })); e.rotationX = -e.rotationX, e.rotationY = -e.rotationY, e.rotationZ = 180 - e.rotationZ; let i = 0 == e.coordType ? "lla" : "xyz"; e.position = new Position(i), e.position.set(e.coordX, e.coordY, e.coordZ), "xyz" == i && e.position.set(e.coordX, e.coordZ, e.coordY), this.scene.setModelTransform2(e, t) } setModelCoord(e, t) { let i = {}, r = 0 == e.coordType ? "lla" : "xyz"; i.position = new Position(r), i.position.set(e.coord[0], e.coord[1], e.coordZ), "xyz" === r && i.position.set(e.coord[0], e.coordZ, e.coord[1]), this.scene.setModelTransform(e.id, i, t) } setModelStyle(e, t) { null != e.maskFlowDirection && (e.maskFlowDirection = e.maskFlowDirection > 360 ? 360 : e.maskFlowDirection < 0 ? 0 : e.maskFlowDirection), this.scene.setModelStyle(e.id, e, t) } setModelVisibility(e, t) { const { ids: i = [], visible: r = !0 } = e; for (const e of i) this.scene.setModelVisible(e, r); t && t({ result: 1, message: "成功。" }) } showBuildingFloor(e, t) { null == e.animation || 1 == e.animation ? this.scene.showBuildingFloor(e.id, e.animation, e.floor, ((e, i) => { t && t(e ? { result: 1, message: "成功。" } : { result: 0, message: `失败，${i}` }) })) : t && t({ result: 0, message: "失败，animation 属性值错误。" }) } resetBuildingFloor(e, t) { null == e.animation || 1 == e.animation ? this.scene.showBuildingFloor(e.id, e.animation, null, ((e, i) => { t && t(e ? { result: 1, message: "成功。" } : { result: 0, message: `失败，${i}` }) })) : t && t({ result: 0, message: "失败，animation 属性值错误。" }) } addModelTip(e, t) { this.scene.addModelTip(e, t) } removeModelTip(e, t) { this.scene.removeModelTip(e, t) } addModel(e, t) { let i = 0 == e.coordType ? "lla" : "xyz"; e.position = new Position(i), e.position.set(e.coord[0], e.coord[1], e.coordZ), "xyz" == i && e.position.set(e.coord[0], e.coordZ, e.coord[1]), e.rotation = { x: e.rotation[0], y: -e.rotation[1], z: 180 - e.rotation[2] }, Array.isArray(e.scale) ? e.scale = { x: e.scale[0], y: e.scale[1], z: e.scale[2] } : e.scale = { x: e.scale, y: e.scale, z: e.scale }, this.scene.addModelForApi(e, t) } removeModel(e, t) { this.scene.removeModelForApi(e, t) } rotatingModel(e, t) { e.durationX < 0 || e.durationY < 0 || e.durationZ < 0 ? t && t({ result: 0, message: "旋转周期应为非负数。" }) : this.scene.rotatingModel(e, t) } setModelRotationState(e, t) { ["pause", "continue", "stop"].includes(e.state) ? this.scene.setModelRotationState(e, t) : t && t({ result: 0, message: "参数错误" }) } blinkingModel(e, t) { e.duration <= 0 ? t && t({ result: 0, message: "闪烁周期应为正数。" }) : "default" == e.type ? this.scene.blinkingModel(e, t) : t && t({ result: 0, message: "闪烁风格目前只支持default" }) } setModelBlinkState(e, t) { ["pause", "continue", "stop"].includes(e.state) ? this.scene.setModelBlinkState(e, t) : t && t({ result: 0, message: "参数错误" }) } movingModel(e, t) { let i = 0 == e.coordType ? "lla" : "xyz", r = []; e.points && e.points.forEach((e => { let t = new Position(i); t.set(e.coord[0], e.coord[1], e.coordZ), "xyz" === i && t.set(e.coord[0], e.coordZ, e.coord[1]), t.speed = e.speed, r.push(t) })), e.points = r, this.scene.movingModel(e, t) } setModelMoveState(e, t) { ["pause", "continue", "stop"].includes(e.state) ? this.scene.setModelMoveState(e, t) : t && t({ result: 0, message: "参数错误" }) } pathingModel(e, t) { let i = path.getLayer(e.pathId); i || t && t({ result: 0, message: `失败，不存在 ${e.pathId} 路径。` }); let r = i.getPositions(); if (!r || r.length <= 0) return t && t({ result: 0, message: `失败，不存在 ${e.pathId} 路径点。` }), !1; e.points = r, e.passChange = path.setPathPass, this.scene.pathingModel(e, t), path.removeEventListener("updatePathCoord", this.scene.updatePathingModel), path.removeEventListener("removeLayer", this.scene.deletePathingModel), path.addEventListener("updatePathCoord", this.scene.updatePathingModel), path.addEventListener("removeLayer", this.scene.deletePathingModel) } setModelPathingState(e, t) { ["pause", "continue", "stop"].includes(e.state) ? (e.passChange = path.setPathPass, this.scene.setModelPathingState(e, t), "stop" == e.state && (path.removeEventListener("updatePathCoord", this.scene.updatePathingModel), path.removeEventListener("removeLayer", this.scene.deletePathingModel))) : t && t({ result: 0, message: "参数错误" }) } selectModel(e, t) { if (!["building", "model"].includes(e.modelType.toLowerCase()) || !["rect", "circle", "polygon"].includes(e.type.toLowerCase())) return void (t && t({ result: 0, message: "参数错误!" })); let i = this.scene.tgapp.triggerEvent.onRectModelSelectionResult; switch (e.type) { case "rect": i = this.scene.tgapp.triggerEvent.onRectModelSelectionResult; break; case "circle": i = this.scene.tgapp.triggerEvent.onCircleModelSelectionResult; break; case "polygon": i = this.scene.tgapp.triggerEvent.onPolygonModelSelectionResult }this.scene.selectModel(e, i), t && t({ result: 1, message: "成功。" }) } endSelectModel(e, t) { this.scene.endSelectModel(e), t && t({ result: 1, message: "成功。" }) } pickModel(e, t) { ["building", "model"].includes(e.modelType.toLowerCase()) && ["click", "hover"].includes(e.type.toLowerCase()) ? ("model" === e.modelType.toLowerCase() && "click" === e.type.toLowerCase() && (this.allowModelClick = !0), "model" === e.modelType.toLowerCase() && "hover" === e.type.toLowerCase() && (this.allowModelHover = !0), "building" === e.modelType.toLowerCase() && "click" === e.type.toLowerCase() && (this.allowBuildingClick = !0), "building" === e.modelType.toLowerCase() && "hover" === e.type.toLowerCase() && (this.allowBuildingHover = !0), t && t({ result: 1, message: "成功。" })) : t && t({ result: 0, message: "参数错误!" }) } endPickModel(e, t) { this.allowModelClick = !1, this.allowModelHover = !1, this.allowBuildingClick = !1, this.allowBuildingHover = !1; for (const e in this.selectedModels) this.scene.cancleHighlightModel(e); this.selectedModels = {}, t && t({ result: 1, message: "成功。" }) } clickModel(e, t) { this.scene.clickModel(e, t, this.scene.tgapp.triggerEvent.onClickModelResult) } clickModelType(e, t) { this.scene.clickModelType(e, (e => { e.data.length <= 0 ? t && t({ result: 0, message: "失败，没有模型或建筑。" }) : (t && t({ result: 1, message: "成功。" }), this.scene.tgapp.triggerEvent.onClickModelTypeResult(e)) })) } clearModelSelected(e, t) { this.scene.clearModelSelected(e), t && t({ result: 1, message: "成功。" }) } getModelArticulation(e, t) { this.scene.getModelArticulation(e, t) } setModelArticulation(e, t) { this.scene.setModelArticulation(e, t) } getModelAnimation(e, t) { this.scene.getModelAnimation(e, t) } setModelAnimation(e, t) { this.scene.setModelAnimation(e, t) } playModelAnimation(e, t) { this.scene.playModelAnimation(e, t) } highlightBuilding(e, t) { "style1" == e.type ? this.scene.highlightBuilding(e, t) : t && t({ result: 0, message: "高亮风格目前只支持style1" }) } highlightFloor(e, t) { "style1" == e.type ? this.scene.highlightFloor(e, t) : t && t({ result: 0, message: "高亮风格目前只支持style1" }) } highlightRoom(e, t) { this.scene.highlightRoom(e, t) } getBuildings(e, t) { this.scene.getBuildings(e, t) } } const models = new Models; class Controller extends BaseComponent { constructor() { super(), this.type = "Controller", this.interfaceList = ["showObjectAxis", "setOverlayVisibility", "setOverlayTypeVisibility", "removeOverlay", "clearOverlayType", "addOverlayTip", "removeOverlayTip", "getOverlaysByType", "getOverlaysByLayer", "getOverlaysOrder", "moveOverlayForward", "moveOverlayBackward", "selectOverlay", "endSelectOverlay", "pickOverlay", "endPickOverlay", "clickOverlay", "clickOverlayType", "clearOverlaySelected", "add3DTile", "remove3DTile", "clear3DTiles", "update3DTile", "update3DTileStyle"] } setScene(e) { super.setScene(e), this.selectOverlayParam = null } showObjectAxis(e = {}, t) { Array.isArray(e.directionType) && (e.directionType = e.directionType.join()), void 0 !== e.directionType && "" !== e.directionType || (e.directionType = "xyz"); const { overlayType: i } = e; if ("model" === i) return void models.showModelAxis(e, t); const { axisType: r } = e; if ("none" !== r) if (void 0 !== overlays[i]) { if ("transform" === r) { let { idLayer: i, id: r, unit: n, directionType: a } = e; "" !== r && void 0 !== r || (r = i), this.scene.transformDrawable(i, r, n, a, t) } void 0 !== r || t && t({ result: 0, message: `失败，${r} 类型暂未实现。` }) } else t && t({ result: 0, message: "失败，类型错误。" }); else this.scene.untransformDrawable(t) } setOverlayVisibility({ overlayType: e, visible: t, id: i } = {}, r) { if (void 0 === t && (t = !1), "boolean" != typeof t) return void (r && r({ result: 0, message: "失败，visible 属性类型错误。" })); if (!overlays[e]) return void (r && r({ result: 0, message: `失败，不存在 ${e} 覆盖物类型。` })); let n = !1; n = t ? overlays[e].showLayer(i) : overlays[e].hideLayer(i), r && r(n ? { result: 1, message: "成功。" } : { result: 0, message: `失败，未找到 ${i} 覆盖物。` }) } setOverlayTypeVisibility({ overlayType: e, visible: t } = {}, i) { overlays[e] ? (t ? overlays[e].showAllLayer() : overlays[e].hideAllLayer(), i && i({ result: 1, message: "成功。" })) : i && i({ result: 0, message: `失败，不存在 ${e} 覆盖物类型。` }) } removeOverlay({ id: e, overlayType: t } = {}, i) { if ("3dtile" == t.toLowerCase()) return void this.scene.remove3DTileByID(e, i); if (!overlays[t]) return void (i && i({ result: 0, message: `失败，不存在 ${t} 覆盖物类型。` })); let r = overlays[t].removeLayer(e); i && i(r ? { result: 1, message: "成功。" } : { result: 0, message: `失败，未找到 ${e} 覆盖物。` }) } clearOverlayType({ overlayType: e } = {}, t) { if ("all" == e) { for (const e in overlays) overlays[e].removeAllLayer(); this.scene.clear3DTileSets() } else if ("3dtile" == e.toLowerCase()) this.scene.clear3DTileSets(); else { if (!overlays[e]) return void (t && t({ result: 0, message: `失败，不存在 ${e} 覆盖物类型。` })); if (!overlays[e].removeAllLayer()) return void t({ result: 0, message: `失败，未找到 ${e} 类型覆盖物。` }) } t && t({ result: 1, message: "成功。" }) } addOverlayTip({ id: e, overlayType: t, url: i, divId: r, isShowClose: n, size: a, offset: o } = {}, s) { if (!overlays[t]) return void (s && s({ result: 0, message: `失败，不存在 ${t} 覆盖物类型。` })); let l = overlays[t].getLayerByDataId(e); if (!l) return void (s && s({ result: 0, message: `失败，未找到 ${t} 类型的 ${e} 绘制物。` })); if ("" == i && "" == r) return void (s && s({ result: 0, message: "参数url和divId不能同时为空!" })); if ("" !== r && void 0 !== r && !document.getElementById(r)) return void (s && s({ result: 0, message: `${r}不存在!` })); let c = {}; c.url = i, c.divId = r, c.isShowClose = n, c.size = a, c.offset = o, c.layer = l.id, c.id = e, this.scene.addOverlayTip(c, ((e, t) => { s && s(e ? { result: 1, message: "成功。" } : { result: 0, message: `失败。${t}` }) })) } removeOverlayTip({ id: e, overlayType: t } = {}, i) { if (!overlays[t]) return void (i && i({ result: 0, message: `失败，不存在 ${t} 覆盖物类型。` })); let r = overlays[t].getLayerByDataId(e); if (r) { let e = this.deepCopy(arguments[0]); return e.layer = r.id, void this.scene.removeOverlayTip(e, i) } i && i({ result: 0, message: `失败，未找到 ${t} 类型的 ${e} 绘制物。` }) } getOverlaysByType({ overlayType: e } = {}, t) { if (!overlays[e]) return void (t && t({ result: 0, message: `失败，不存在 ${e} 覆盖物类型。` })); let i = overlays[e].getLayers(), r = []; for (const e of i) for (const t of e.data) r.push({ id: t.id, name: t.name || "" }); t && t({ result: 1, message: "成功。", type: e, data: r }) } getOverlaysByLayer({ idLayer: e, layerType: t } = {}, i) { if (!overlays[t]) return void (i && i({ result: 0, message: `失败，不存在 ${t} 类型覆盖物。` })); let r = overlays[t].getLayer(e); if (!r) return void (i && i({ result: 0, message: `失败，不存在 ${e} 覆盖物。` })); let n = []; for (const e of r.data) n.push({ id: e.id }); i && i({ result: 1, message: "成功。", type: t, data: n }) } getOverlaysOrder({ } = {}, e) { let t = []; for (let e of this.scene.getLayers()) t.push({ id: e.name, zLevel: e.zLevel }); t.sort(((e, t) => e.zLevel - t.zLevel)), t.filter(((e, t) => { e.index = t + 1, delete e.zLevel })), e && e({ result: 1, message: "成功。", data: t }) } moveOverlayForward({ idLayer: e, offset: t } = {}, i) { if ("number" != typeof t || t < 0) return void (i && i({ result: 0, message: `失败，offset（偏移量）${t} 无效，取值应当为数字，且大于等于零。` })); let r = []; for (let e of this.scene.getLayers()) r.push({ id: e.name, zLevel: e.zLevel }); r.sort(((e, t) => e.zLevel - t.zLevel)), r.filter(((e, t) => { e.index = t + 1 })); let n, a = r.find((t => t.id === e)); if (!a) return void (i && i({ result: 0, message: `失败，不存在 ${e} 覆盖物。` })); let o = a.index + t; n = o >= r.length || 0 === t ? (r[r.length - 1].zLevel + Math.floor(r[r.length - 1].zLevel + 1)) / 2 : (r[o - 1].zLevel + r[o].zLevel) / 2, this.scene.getLayer(e).updateZLevel(n) ? i && i({ result: 1, message: "成功。" }) : i && i({ result: 0, message: `失败，前移 ${e} 时发生未知错误。` }) } moveOverlayBackward({ idLayer: e, offset: t } = {}, i) { if ("number" != typeof t || t < 0) return void (i && i({ result: 0, message: `失败，offset（偏移量）${t} 无效，取值应当为数字，且大于等于零。` })); let r = []; for (let e of this.scene.getLayers()) r.push({ id: e.name, zLevel: e.zLevel }); r.sort(((e, t) => e.zLevel - t.zLevel)), r.filter(((e, t) => { e.index = t + 1 })); let n, a = r.find((t => t.id === e)); if (!a) return void (i && i({ result: 0, message: `失败，不存在 ${e} 覆盖物。` })); let o = a.index - t; n = o <= 1 || 0 === t ? (r[0].zLevel + Math.ceil(r[0].zLevel - 1)) / 2 : (r[o - 2].zLevel + r[o - 1].zLevel) / 2, this.scene.getLayer(e).updateZLevel(n) ? i && i({ result: 1, message: "成功。" }) : i && i({ result: 0, message: `失败，后移 ${e} 时发生未知错误。` }) } pickOverlay({ overlayType: e, idLayer: t, type: i, allowMultiple: r, isShowDecorator: n } = {}, a) { "" === i && (i = void 0), "" === t && (t = void 0), "click" === i || "hover" === i ? overlays[e] ? (overlays[e].openMouseSelection(t, i, r, n), a && a({ result: 1, message: "成功。" })) : a && a({ result: 0, message: `失败。不存在 ${e} 类型的绘制物。` }) : a && a({ result: 0, message: "失败。type 属性值错误。" }) } endPickOverlay({ overlayType: e, idLayer: t, type: i } = {}, r) { if ("" === i && (i = void 0), "" === t && (t = void 0), "" === e && (e = void 0), "click" === i || "hover" === i || void 0 === i) if (null == e || overlays[e]) { if (void 0 === e) for (const e in overlays) overlays[e].closeMouseSelection(t, i); else overlays[e].closeMouseSelection(t, i); r && r({ result: 1, message: "成功。" }) } else r && r({ result: 0, message: `失败。不存在 ${e} 类型的绘制物。` }); else r && r({ result: 0, message: "失败。type 属性值错误。" }) } clickOverlay({ id: e, ids: t = [], overlayType: i, idLayer: r, selected: n } = {}, a) { if ("" === r && (r = void 0), void 0 === r && (r = e), Array.isArray(t) || (t = []), e && t.push(e), !overlays[i]) return void (a && a({ result: 0, message: `失败，不存在 ${i} 覆盖物类型。` })); const o = overlays[i].getLayer(r); if (!o) return void (a && a({ result: 0, message: `失败，不存在 ${r} ID的覆盖物。` })); const s = []; for (const e of t) { const t = o.data.find((t => t.id == e)); s.push(t) } s.length <= 0 ? a && a({ result: 0, message: `失败，不存在 ${t.join("，")} ID的覆盖物。` }) : (overlays[i].selectionData(s, n), a && a({ result: 1, message: "成功。" })) } clickOverlayType({ overlayType: e, idLayer: t, selected: i } = {}, r) { if ("" === t && (t = void 0), !overlays[e]) return void (r && r({ result: 0, message: `失败，不存在 ${e} 覆盖物类型。` })); let n = []; if (t) { let i = overlays[e].getLayer(t); i && n.push(...i.data) } else for (const t of overlays[e].getLayers()) n.push(...t.data); overlays[e].selectionData(n, i), this.scene.tgapp.triggerEvent.onClickOverlayTypeResult({ type: e, selected: i, data: n.map((e => ({ id: e.id }))) }), r && r({ result: 1, message: "成功。" }) } clearOverlaySelected({ }, e) { for (const e in overlays) { let t = []; for (const i of overlays[e].getLayers()) t.push(...i.data); overlays[e].selectionData(t, !1) } e && e({ result: 1, message: "成功。" }) } selectOverlay({ type: e, overlayType: t } = {}, i) { overlays[t] ? "rect" === e || "circle" === e || "polygon" === e ? (this.selectOverlayParam = this.deepCopy(arguments[0]), this.scene.selectOverlay({ type: e }, (e => { let t = this.selectOverlayParam.overlayType, i = e.filter((e => !!overlays[t].getLayer(e.parent))); null != this.selectOverlayParam.idLayer && "" != this.selectOverlayParam.idLayer && (i = i.filter((e => e.parent == this.selectOverlayParam.idLayer))); let r = []; for (const e of i) { let i = overlays[t].getLayer(e.parent); r.push(i.getData(e.name)) } overlays[t].selectionData(r, !0), i = { type: t, data: i.map((e => ({ id: e.name }))) }, "rect" == this.selectOverlayParam.type && this.scene.tgapp.triggerEvent.onRectOverlaySelectionResult(i), "circle" == this.selectOverlayParam.type && this.scene.tgapp.triggerEvent.onCircleOverlaySelectionResult(i), "polygon" == this.selectOverlayParam.type && this.scene.tgapp.triggerEvent.onPolygonOverlaySelectionResult(i) })), i && i({ result: 1, message: "成功。" })) : i && i({ result: 0, message: `失败，不存在 ${e} 选择类型。` }) : i && i({ result: 0, message: `失败，不存在 ${t} 覆盖物类型。` }) } endSelectOverlay({ }, e) { this.scene.endSelectOverlay(), this.selectOverlayParam = null, e && e({ result: 1, message: "成功。" }) } add3DTile(e, t) { e.isVisible = e.visible, e.isApi = !0, this.scene.add3DTile(e, t) } remove3DTile(e, t) { this.scene.remove3DTileSet(e), t && t({ result: 1, message: "成功!" }) } clear3DTiles(e) { this.scene.clear3DTileSets(), e && e({ result: 1, message: "成功!" }) } update3DTile(e, t) { this.scene.update3DTile(e, t) } update3DTileStyle(e, t) { this.scene.update3DTileStyle(e, t) } } const controller = new Controller; class AggLandmarkLayer extends BaseOverlay { constructor() { super(), this.type = "aggLandmarkLayer", this.interfaceList = ["addAggLandmarkLayer", "updateAggLandmarkLayerStyle"] } setScene(e) { super.setScene(e), this._registerMouseEvent() } addAggLandmarkLayer({ id: e, aggDataId: t, aggRadius: i, aggType: r } = {}, n) { let a = this.getLayer(e); if (a) return void (n && n({ result: 0, message: `失败，已存在 ${e} 聚合地标图。` })); let o = this.deepCopy(arguments[0]); a = this.createLayer(e, o), agg.postRequest("AddAggLayerData", { aggDataId: t, aggRadius: i, aggType: r }, (({ code: e, message: t }) => { 1 === e ? this._updateLayer(a, n) : n && n({ result: 0, message: `失败，${t}` }) })) } updateAggLandmarkLayerStyle({ id: e, iconName: t, clusters: i } = {}, r) { let n = this.getLayer(e); n ? (void 0 !== t && (n.source.iconName = t), void 0 !== i && (n.source.clusters = i), this._updateLayer(n, r)) : r && r({ result: 0, message: `失败，未找到 ${e} 聚合地标图。` }) } _registerMouseEvent() { this.scene.domElement.addEventListener("pointerdown", (() => { this._isPress = !0 })), document.addEventListener("pointerup", (() => { this._isPress && this._onMouseUp() })) } _onMouseUp() { if (this._isPress = !1, !controller.selectOverlayParam) for (const e of this.getLayers()) this._updateLayer(e) } async _updateLayer(e, t) { let i = await agg.postRequest("queryAggLandmarkLayer", { aggDataId: e.source.aggDataId, aggRadius: e.source.aggRadius, aggType: e.source.aggType, maxCount: e.source.drawMax, range: this.getSceneRange(), mapLevel: this.getMapLevelByResolution() }); i ? 1 === i.code ? (this._updateData(e, i.data), this._drawLayer(e, t)) : t && t({ result: 0, message: `失败，${i.message}` }) : t && t({ result: 0, message: "失败，服务连接超时。" }) } _updateData(e, t) { for (const t of e.data) this.scene.removeDrawable(e.id, t.id); e.data = []; for (const i of t) { let t = new Position("lla"); t.set(i.coord[0], i.coord[1], e.source.coordZ), i.isCluster && (t.alt = i.coordZ); let r = e.source.iconName, n = 1; if (i.isCluster) { let t = e.source.clusters.find((e => { let t = i.label >= e.value_range_min, r = i.label <= e.value_range_max; return t && r })); t && (r = t.clustersIcon), t && (n = t.size) } let a = this.createData(i.id, i, e); a.positions = [t], a.iconName = r, a.scale = n / 10, a.label = i.label } } async _drawLayer(e, t) { let i = []; for (const t of e.data) { if (!this.isContainIconAsset(t.iconName)) { i.push(t.iconName); continue } let r = await this.getIconAsset(t.iconName); r.name = t.id, r.position = t.positions[0], r.label = !!t.label, r.labelText = t.label, r.isShow = e.isShow, r.width *= t.scale, r.height *= t.scale, await this.scene.addLandmark(e.id, r), t.inView = !0 } t && (i.length > 0 ? t({ result: 1, message: `错误，图标 ${i.join("、")} 不存在。` }) : t({ result: 1, message: "成功。" })) } getMapLevelByResolution() { const e = this.scene.tgapp.container.scrollWidth, t = this.scene.tgapp.container.scrollHeight, i = this.scene.convertScreenToWorld({ x: 0, y: t / 2 }), r = this.scene.convertScreenToWorld({ x: e, y: t / 2 }), n = (new Position).set(i.x, i.y, i.z), a = (new Position).set(r.x, r.y, r.z), o = this.scene.getDistanceByPositions(n, a) / e, s = (i.lat + r.lat) / 2, l = 156543.03 * Math.cos(Math.PI / 180 * s) / o; return Math.floor(Math.log2(l)) } getSceneRange() { const e = this.scene.tgapp.container.scrollWidth, t = this.scene.tgapp.container.scrollHeight, i = this.scene.convertScreenToWorld({ x: 0, y: 0 }), r = this.scene.convertScreenToWorld({ x: 0, y: t }), n = this.scene.convertScreenToWorld({ x: e, y: 0 }), a = this.scene.convertScreenToWorld({ x: e, y: t }), o = [i.lon, r.lon, n.lon, a.lon], s = [i.lat, r.lat, n.lat, a.lat], l = Math.min(...o), c = Math.max(...o); return [l, Math.min(...s), c, Math.max(...s)] } } const aggLandmarkLayer = new AggLandmarkLayer; class EventLayer extends BaseOverlay { constructor() { super(), this.type = "eventLayer", this.interfaceList = ["addEventLayer", "updateEventLayerCoord", "updateEventLayerStyle"] } addEventLayer({ id: e } = {}, t) { if (this.layerIdIsUsed(e)) return void (t && t({ result: 0, message: `失败，${e} 已存在。` })); let i = this.deepCopy(arguments[0]), r = this._convertLayer(i); r.zLevel = store.zLevel++, this._drawLayer(r, t) } updateEventLayerCoord({ id: e } = {}, t) { if (!this.getLayer(e)) return void (t && t({ result: 0, message: `失败，未找到 ${e} 事件图。` })); let i = this.deepCopy(arguments[0]), r = this._convertLayer(i); this._drawLayer(r, t) } updateEventLayerStyle({ id: e } = {}, t) { if (!this.getLayer(e)) return void (t && t({ result: 0, message: `失败，未找到 ${e} 事件图。` })); let i = this.deepCopy(arguments[0]), r = this._convertLayer(i); this._drawLayer(r, t) } _convertLayer({ id: e, isAppend: t = !0 } = {}) { let i = this.getLayer(e); return i || (i = this.createLayer(e, arguments[0])), !0 !== t && (i.source.data = [], this.scene.removeLayer(i.id), i.data = []), this._updateLayer(i, arguments[0]), this._updateData(i), i } _updateLayer(e, { name: t, coordType: i, coordTypeZ: r, legends: n = [], data: a = [] } = {}) { null != t && (e.source.name = t), null != i && (e.source.coordType = i), null != r && (e.source.coordTypeZ = r); for (const t of n) { let i = e.source.legends.findIndex((e => e.name == t.name)); -1 == i ? e.source.legends.push(t) : e.source.legends[i] = t } for (const t of a) { let i = e.source.data.findIndex((e => e.id == t.id)); -1 == i ? e.source.data.push(t) : e.source.data[i] = t } } _updateData(e) { let t = 0 == e.source.coordType ? "lla" : "xyz"; for (const i of e.source.data) { let r = e.data.find((e => e.id == i.id)); r ? r.setSource(i) : r = this.createData(i.id, i, e); const n = new Position(t); n.set(i.coord[0], i.coord[1], i.coordZ), "xyz" === t && n.set(i.coord[0], i.coordZ, i.coord[1]), r.positions = [n]; let a = e.source.legends.find((e => e.name == r.source.type)); a ? (r.legend = a.name, r.icon = a.icon, r.type = a.type, r.color = a.color, r.fillArea = a.fillArea, r.speed = a.speed, r.radius = a.radius) : (r.legend = void 0, r.icon = void 0, r.type = void 0, r.color = void 0, r.fillArea = void 0, r.speed = void 0, r.radius = void 0), r.message = r.source.message } } async _drawLayer(e, t) { if (!this.scene) return; let i = [], r = []; const n = []; let a = !1; for (const t of e.data) { if (null == t.legend) { i.push(t.source.type); continue } if (!this.isContainIconAsset(t.icon)) { r.push(t.icon); continue } a = a || t.inView; let o = await this.getIconAsset(t.icon); o.name = t.id, o.position = t.positions[0], o.label = !!t.message, o.labelText = t.message, o.isShow = e.isShow, o.zLevel = e.zLevel, t.inView ? await this.scene.updateLandmark(e.id, t.id, o) : (await this.scene.addLandmark(e.id, o), t.inView = !0); let s = {}; s.name = t.id, s.position = t.positions[0], s.value = t.radius, s.bubbleColor = t.color, s.animationSpeed = t.speed, s.isShow = e.isShow, n.push(s) } n.length > 0 && (a ? this.scene.updateInstancedBubble(e.id, { isShow: e.isShow, points: n }) : await this.scene.addInstancedBubble(e.id, { isShow: e.isShow, points: n })), t && t({ result: 1, message: "成功。" }) } asyncSelectionState() { for (const e of this.getLayers()) for (const t of e.data) t.isSelected && this.isShowDecorator ? (this.scene.selectDrawable(e.id, t.id), this.scene.selectInstancedBubble(e.id, e.id, t.id)) : (this.scene.deselectDrawable(e.id, t.id), this.scene.deselectInstancedBubble(e.id, e.id, t.id)) } addSceneEventListener(e) { "onEventLayerHover" !== e && "onEventLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onEventLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onEventLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onEventLayerHover" !== e && "onEventLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onEventLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onEventLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } onMouseEvent({ type: e, layer: t, data: i } = {}) { "click" == e && t.allowClickSelected && this.scene.tgapp.triggerEvent.onEventLayerClick({ idObj: i.id, idLayer: t.id, selected: i.isSelected }), "hover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onEventLayerHover({ idObj: i.id, idLayer: t.id }), "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onEventLayerUnhover({ idObj: i.id, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t, dataId: i, legend: r } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e ? "focusLayerStart" !== e ? "focusLayerEnd" !== e ? "focusLegendStart" !== e ? "focusLegendEnd" !== e || this.scene.tgapp.triggerEvent.onFocusEventLayerLegendEnd({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusEventLayerLegendStart({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusEventLayerObjEnd({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusEventLayerObjStart({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusAllEventLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllEventLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusEventLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusEventLayerStart({ idLayer: t }) } } const eventLayer = new EventLayer; class MarkerLandmarkLayer extends BaseOverlay { constructor() { super(), this.type = "3DMarkerLandmarkLayer", this.interfaceList = ["add3DMarkerLandmarkLayer", "update3DMarkerLandmarkLayerCoord", "update3DMarkerLandmarkLayerStyle"] } add3DMarkerLandmarkLayer({ id: e, markerLandmarkDataId: t } = {}, i) { const r = this.deepCopy(arguments[0]); r.zLevel = store.zLevel++, "" === t && (t = void 0), this.layerIdIsUsed(e) ? i && i({ result: 0, message: `失败，${e} 已存在。` }) : this._updateLayer(r, i) } update3DMarkerLandmarkLayerCoord({ id: e } = {}, t) { const i = this.deepCopy(arguments[0]); void 0 !== this.getLayer(e) ? this._updateLayer(i, t) : t && t({ result: 0, message: `失败，未找到 ${e} 特效地标图。` }) } update3DMarkerLandmarkLayerStyle({ id: e } = {}, t) { const i = this.deepCopy(arguments[0]); void 0 !== this.getLayer(e) ? this._updateLayer(i, t) : t && t({ result: 0, message: `失败，未找到 ${e} 特效地标图。` }) } _updateLayer({ id: e, coordType: t, coordTypeZ: i, snapSurface: r, alpha: n, markerMaxDistance: a, iconMaxDistance: o, legends: s = [], data: l = [] }, c) { let h = this.getLayer(e); void 0 === h && (h = this.createLayer(e, arguments[0]), h.zLevel = h.source.zLevel), null != t && (h.source.coordType = t), null != i && (h.source.coordTypeZ = i), null != r && (h.source.snapSurface = r), null != n && (h.source.alpha = n), null != a && (h.source.markerMaxDistance = a), null != o && (h.source.iconMaxDistance = o); for (const e of s) { let t = h.source.legends.findIndex((t => t.name == e.name)); -1 == t ? h.source.legends.push(e) : h.source.legends[t] = e } for (const e of l) { let t = h.source.data.findIndex((t => t.id === e.id)); -1 == t ? h.source.data.push(e) : h.source.data[t] = e } for (const e of h.source.data) { let t = h.getData(e.id); void 0 === t ? t = this.createData(e.id, e, h) : t.setSource(e); const i = 0 == h.source.coordType ? "lla" : "xyz", r = new Position(i); r.set(e.coord[0], e.coord[1], e.coordZ), "xyz" === i && r.set(e.coord[0], e.coordZ, e.coord[1]), t.positions = [r]; let n = h.source.legends.find((e => e.name == t.source.type)); n ? (t.legend = n.name, t.modelType = n.markerType, t.scale = n.scale, t.iconName = n.iconName, t.labelColor = n.titleColor, t.labelBackgroundColor = n.titleBackgroundColor) : t.legend = void 0, t.snapSurface = h.source.snapSurface, t.alpha = h.source.alpha, t.modelMaxDistance = h.source.markerMaxDistance, t.iconMaxDistance = h.source.iconMaxDistance, t.label = e.titleText, t.rotation = e.rotation } this._drawData(h, c) } async _drawData(e, t) { if (!this.scene) return; let i = [], r = [], n = []; for (const t of e.data) { if (void 0 === t.legend) { i.push(t.source.type); continue } if (!this.isContainIconAsset(t.iconName)) { r.push(t.iconName); continue } let a = this.getMarkerAsset(t.modelType); if (!a) { n.push(t.modelType); continue } let o = await this.getIconAsset(t.iconName); o.name = t.id, o.position = t.positions[0], o.label = !!t.label, o.labelText = t.label, o.labelColor = t.labelColor, o.labelBackground = t.labelBackgroundColor, o.snapSurface = t.snapSurface, o.alpha = t.alpha, o.modelMaxDistance = t.modelMaxDistance, o.iconMaxDistance = t.iconMaxDistance, o.rotation = t.rotation, o.asset = a, o.scale = t.scale, o.isShow = e.isShow, o.zLevel = e.zLevel, t.inView ? await this.scene.updateMarkerLandmark(e.id, t.id, o) : (await this.scene.addMarkerLandmark(e.id, o), t.inView = !0) } t && t({ result: 1, message: "成功。" }) } onMouseEvent({ type: e, layer: t, data: i, event: r } = {}) { "click" == e && t.allowClickSelected ? this.scene.tgapp.triggerEvent.on3DMarkerLandmarkLayerClick({ idObj: i.id, idLayer: t.id, selected: i.isSelected }) : "hover" == e && t.allowHoverSelected ? this.scene.tgapp.triggerEvent.on3DMarkerLandmarkLayerHover({ idObj: i.id, idLayer: t.id }) : "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.on3DMarkerLandmarkLayerUnhover({ idObj: i.id, idLayer: t.id }) } onFocusEvent({ type: e, layerId: t, dataId: i, legend: r } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e ? "focusLayerStart" !== e ? "focusLayerEnd" !== e ? "focusLegendStart" !== e ? "focusLegendEnd" !== e || this.scene.tgapp.triggerEvent.onFocus3DMarkerLandmarkLayerLegendEnd({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocus3DMarkerLandmarkLayerLegendStart({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocus3DMarkerLandmarkLayerObjEnd({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocus3DMarkerLandmarkLayerObjStart({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusAll3DMarkerLandmarkLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAll3DMarkerLandmarkLayerStart({}) : this.scene.tgapp.triggerEvent.onFocus3DMarkerLandmarkLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocus3DMarkerLandmarkLayerStart({ idLayer: t }) } addSceneEventListener(e) { "on3DMarkerLandmarkLayerHover" !== e && "on3DMarkerLandmarkLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("on3DMarkerLandmarkLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "on3DMarkerLandmarkLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "on3DMarkerLandmarkLayerHover" !== e && "on3DMarkerLandmarkLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("on3DMarkerLandmarkLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "on3DMarkerLandmarkLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } } var markerLandmarkLayer = new MarkerLandmarkLayer; class TrackLayer extends BaseOverlay { constructor() { super(), this.type = "trackLayer", this.interfaceList = ["addTrackLayer", "updateTrackLayerCoord", "updateTrackLayerStyle"] } addTrackLayer(e, t) { const { id: i } = e; if (this.layerIdIsUsed(i)) return void (t && t({ result: 0, message: `失败，${i} 已存在。` })); const r = this.deepCopy(e); r.zLevel = store.zLevel++, this._updateLayer(r, t) } updateTrackLayerCoord(e, t) { const { id: i } = e; if (!this.getLayer(i)) return void (t && t({ result: 0, message: `失败，未找到 ${i} 点迹图。` })); const r = this.deepCopy(e); r.dataAppend = e.isAppend, this._updateLayer(r, t) } updateTrackLayerStyle(e, t) { const { id: i } = e; if (!this.getLayer(i)) return void (t && t({ result: 0, message: `失败，未找到 ${i} 点迹图。` })); const r = this.deepCopy(e); r.legendAppend = e.isAppend, this._updateLayer(r, t) } async _updateLayer(e, t) { const i = this._createOrGetLayer(e); this._updateLayerSourceParameters(i, e), i.data = [], this.scene.removeLayer(i.id); const r = this._updateDataParameters(i); await this._drawLayerByDataId(i), t && (r.length > 0 ? t({ result: 0, message: `错误，${r.join("、")} 失败。` }) : t({ result: 1, message: "成功。" })) } _createOrGetLayer(e) { const { id: t } = e; let i = this.getLayer(t); return void 0 === i && (i = this.createLayer(t, e), i.zLevel = i.source.zLevel), i } _updateLayerSourceParameters(e, t) { const i = e.source, { name: r, coordType: n, coordTypeZ: a } = t; null != r && (i.name = r), null != n && (i.coordType = n), null != a && (i.coordTypeZ = a); const { legendAppend: o = !0 } = t; o || (i.legends = []); const { legends: s = [] } = t; for (const e of s) { const t = i.legends.findIndex((t => t.name == e.name)); -1 == t ? i.legends.push(e) : i.legends[t] = e } const { dataAppend: l = !0 } = t; !0 !== l && (i.data = []); const { data: c = [] } = t; for (const e of c) { const t = i.data.findIndex((t => t.id === e.id && t.time === e.time)); -1 == t ? i.data.push(e) : i.data[t] = e } } _updateDataParameters(e) { const t = e.source, i = []; for (const r of t.data) { const n = t.legends.find((e => e.name == r.type)); if (void 0 === n) { i.push(r.id); continue } if (!this.isContainIconAsset(n.icon)) { i.push(r.id); continue } const a = new Data(r.id, r); e.addData(a, !0); const o = 0 == t.coordType ? "lla" : "xyz", s = r.coord[0], l = r.coord[1], c = r.coordZ, h = new Position(o); "lla" === o && h.set(s, l, c), "xyz" === o && h.set(s, c, l), a.position = h, a.label = r.label, a.timestamp = +new Date(r.time), a.legend = n.name, a.icon = n.icon, a.lineColor = n.lineColor, a.lineWidth = n.lineWidth, a.lineType = n.lineType, a.lineSpeed = n.lineSpeed, a.curvature = n.curvature } return i } async _drawLayerByDataId(e) { const t = {}; for (const i of e.data) void 0 === t[i.id] && (t[i.id] = []), t[i.id].push(i); for (const i in t) { const r = t[i]; if (1 === r.length) { await this._drawLandmark(r[0], e); continue } const n = [r[0].position]; r.sort((function (e, t) { return n.push(e.position), e.timestamp - t.timestamp })); const a = r.length; for (let t = 0; t < a - 1; t++) { const i = r[t], a = r[t + 1]; await this._drawLink(e, i, a), await this._drawLandmark(i, e), i.positions = n } await this._drawLandmark(r[a - 1], e), r[a - 1].positions = n } } async _drawLandmark(e, t) { const i = await this.getIconAsset(e.icon); i.name = `${e.id}:${e.timestamp}`, i.position = e.position, i.label = !!e.label, i.labelText = e.label, i.isShow = t.isShow, i.zLevel = t.zLevel, await this.scene.addLandmark(t.id, i) } async _drawLink(e, t, i) { const r = {}; r.name = `${t.id}:${t.timestamp}-line`, r.startPos = t.position, r.endPos = i.position, r.color = t.lineColor, r.lineWidth = t.lineWidth, r.imageType = t.lineType.toLowerCase(), r.animationSpeed = t.lineSpeed, r.curvatureCoefficient = 50 * t.curvature, r.label = !1, r.sizeAttenuation = !1, r.isShow = e.isShow, r.zLevel = e.zLevel, await this.scene.addODLine(e.id, r) } addSceneEventListener(e) { "onTrackLayerHover" !== e && "onTrackLayerUnhover" !== e || this.scene.tgapp.events[e].length <= 0 || this.scene.tgapp.events[e].length > 1 || ("onTrackLayerHover" === e && this.scene.on("mousehover", "drawable", this.onDrawableMouseHover), "onTrackLayerUnhover" === e && this.scene.on("unmousehover", "drawable", this.onDrawableUnmouseHover)) } removeSceneEventListener(e) { "onTrackLayerHover" !== e && "onTrackLayerUnhover" !== e || this.scene.tgapp.events[e].length > 0 || ("onTrackLayerHover" === e && this.scene.off("mousehover", "drawable", this.onDrawableMouseHover), "onTrackLayerUnhover" === e && this.scene.off("unmousehover", "drawable", this.onDrawableUnmouseHover)) } _onDrawableMouseEvent(e, t, i) { if (!i) return; let r = this.layers.find((e => e.id == i.parent)); if (!r) return; let n = r.data.find((e => { let t = e.id, r = e.id + "-line"; return t === i.name || r === i.name })); n && (this.onMouseSelection(e, n), "click" == e && r.allowClickSelected ? this.scene.tgapp.triggerEvent.onTrackLayerClick({ idObj: n.id, idLayer: r.id, selected: n.isSelected }) : "hover" == e && r.allowHoverSelected ? this.scene.tgapp.triggerEvent.onTrackLayerHover({ idObj: n.id, idLayer: r.id }) : "unhover" == e && r.allowHoverSelected && this.scene.tgapp.triggerEvent.onTrackLayerUnhover({ idObj: n.id, idLayer: r.id })) } onFocusEvent({ type: e, layerId: t, dataId: i, legend: r } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e ? "focusLayerStart" !== e ? "focusLayerEnd" !== e ? "focusLegendStart" !== e ? "focusLegendEnd" !== e || this.scene.tgapp.triggerEvent.onFocusTrackLayerLegendEnd({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusTrackLayerLegendStart({ idLayer: t, legend: r }) : this.scene.tgapp.triggerEvent.onFocusTrackLayerObjEnd({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusTrackLayerObjStart({ idLayer: t, idObj: i }) : this.scene.tgapp.triggerEvent.onFocusAllTrackLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllTrackLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusTrackLayerEnd({ idLayer: t }) : this.scene.tgapp.triggerEvent.onFocusTrackLayerStart({ idLayer: t }) } } const trackLayer = new TrackLayer; class GISMap extends BaseOverlay { constructor() { super(), this.type = "gisMap", this.interfaceList = ["addGISMap", "updateGISMap", "updateGISMapStyle"] } addGISMap(e, t) { const { id: i } = e; if (this.layerIdIsUsed(i)) return void (t && t({ result: 0, message: `失败，${i} 已存在。` })); const r = this.scene.getDatumShiftModel(); if (!r || !r.editor) return void (t && t({ result: 0, message: "失败，场景没有中心点。" })); const n = this.createLayer(i, this.deepCopy(e)); void 0 === n.source.flipY && (n.source.flipY = !0); const a = this.createData(e.id, {}, n); if (a.positions = [new Position("lla")], "surface" === r.type ? (a.positions[0].set(r.editor.mapCenter[0], r.editor.mapCenter[1], r.editor.alt), n.source.place = { longitude: r.editor.mapCenter[0], latitude: r.editor.mapCenter[1] }) : (a.positions[0].set(r.editor.lon, r.editor.lat, r.editor.alt), n.source.place = { longitude: r.editor.lon, latitude: r.editor.lat }), !0 == !!n.source.visible) { this.scene.addTerrain(n.source, t); for (const e of this.layers) e.source.visible = !1, e.isShow = !1; n.source.visible = !0, n.isShow = !0 } } updateGISMap(e, t) { const { id: i } = e, r = this.getLayer(i); if (!r) return void (t && t({ result: 0, message: `失败，未找到 ${i} GIS图。` })); const { name: n, mapIndex: a, mapUrl: o, mapTokenName: s, mapTokenValue: l, terrainUrl: c, terrainType: h, terrainToken: u, flipY: d } = e; void 0 !== n && (r.source.name = n), void 0 !== c && (r.source.terrainUrl = c), void 0 !== h && (r.source.terrainType = h), void 0 !== u && (r.source.terrainToken = u), void 0 !== d && (r.source.flipY = d), void 0 !== a && (void 0 !== o && (r.source.maps[a].mapUrl = o), void 0 !== s && (r.source.maps[a].mapTokenName = s), void 0 !== l && (r.source.maps[a].mapTokenValue = l)), !0 === r.source.visible && this.scene.addTerrain(r.source, t) } updateGISMapStyle(e, t) { const { id: i } = e, r = this.getLayer(i); if (!r) return void (t && t({ result: 0, message: `失败，未找到 ${i} GIS图。` })); const { mapIndex: n, mapLOD: a } = e; void 0 !== n && void 0 !== a && (r.source.maps[n].mapLOD = a); const { visible: o } = e; if (void 0 !== o) if (!0 == !!o && !1 === r.source.visible) { this.scene.addTerrain(r.source, t); for (const e of this.layers) e.source.visible = !1, e.isShow = !1; r.source.visible = !0, r.isShow = !0 } else !1 == !!o && !0 === r.source.visible && (this.scene.removeTerrain(t), r.source.visible = !1, r.isShow = !1); const { alpha: s } = e; void 0 !== s && !0 === r.source.visible && (void 0 !== s && (r.source.alpha = s), this.scene.updateTerrainStyle(r.source)) } showLayer(e) { let t = this.getLayer(e); if (!t) return !1; this.scene.addTerrain(t.source, callback); for (const e of this.layers) e.source.visible = !1, e.isShow = !1; return t.source.visible = !0, t.isShow = !0, this.scene.showLayer(e), this.dispatchEvent({ type: "showLayer", layerIds: [e] }), !0 } hideLayer(e) { let t = this.getLayer(e); return !!t && (this.scene.removeTerrain(callback), t.source.visible = !1, t.isShow = !1, this.dispatchEvent({ type: "hideLayer", layerIds: [e] }), !0) } showAllLayer() { let e = []; const t = this.layers.length; if (t > 0) { for (const e of this.layers) e.source.visible = !1, e.isShow = !1; const i = this.layers[t - 1]; i.source.visible = !0, i.isShow = !0, this.scene.addTerrain(i.source), e.push(i.id) } return this.dispatchEvent({ type: "showLayer", layerIds: e }), !0 } hideAllLayer() { let e = []; for (const t of this.layers) !0 !== t.isPlot && t.isShow && (t.isShow = !1, t.source.visible = !1, this.scene.removeTerrain(), e.push(t.id)); return this.dispatchEvent({ type: "hideLayer", layerIds: e }), !0 } removeLayer(e) { let t = this.layers.findIndex((t => t.id == e)); return -1 != t && (this.layers.splice(t, 1), delete _layers[e], this.scene.removeLayer(e), this.dispatchEvent({ type: "removeLayer", layerIds: [e] }), !0) } removeAllLayer() { if (this.layers.length <= 0) return !1; let e = []; for (let t = this.layers.length - 1; t >= 0; t--) { const i = this.layers[t]; !0 !== i.isPlot && (this.layers.splice(t, 1), delete _layers[i.id], this.scene.removeLayer(i.id), e.push(i.id)) } return this.dispatchEvent({ type: "removeLayer", layerIds: e }), !0 } onMouseEvent({ type: e, layer: t, data: i } = {}) { "click" == e && t.allowClickSelected && this.scene.tgapp.triggerEvent.onGISMapClick({ id: i.id, selected: i.isSelected, coord: [] }), "hover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onGISMapHover({ id: i.id, coord: [] }), "unhover" == e && t.allowHoverSelected && this.scene.tgapp.triggerEvent.onGISMapUnhover({ id: i.id }) } onFocusEvent({ type: e, layerId: t, dataId: i, legend: r } = {}) { "focusStart" !== e ? "focusEnd" !== e ? "focusAllStart" !== e ? "focusAllEnd" !== e || this.scene.tgapp.triggerEvent.onFocusAllEventLayerEnd({}) : this.scene.tgapp.triggerEvent.onFocusAllEventLayerStart({}) : this.scene.tgapp.triggerEvent.onFocusGISMapEnd({ id: t }) : this.scene.tgapp.triggerEvent.onFocusGISMapStart({ id: t }) } } const gisMap = new GISMap, overlays = {}; overlays[landmark.type] = landmark, overlays[path.type] = path, overlays[area.type] = area, overlays[landmarkLayer.type] = landmarkLayer, overlays[roadSgHeatLayer.type] = roadSgHeatLayer, overlays[roadPtHeatLayer.type] = roadPtHeatLayer, overlays[typeAreaLayer.type] = typeAreaLayer, overlays[colorAreaLayer.type] = colorAreaLayer, overlays[circularArea.type] = circularArea, overlays[grid3DLayer.type] = grid3DLayer, overlays[heatMapLayer.type] = heatMapLayer, overlays[bubbleLayer.type] = bubbleLayer, overlays[column3DLayer.type] = column3DLayer, overlays[trailLayer.type] = trailLayer, overlays[odLineLayer.type] = odLineLayer, overlays[marker3D.type] = marker3D, overlays[eventLayer.type] = eventLayer, overlays[modelLandmarkLayer.type] = modelLandmarkLayer, overlays[modelTrailLayer.type] = modelTrailLayer, overlays[aggLandmarkLayer.type] = aggLandmarkLayer, overlays[markerLandmarkLayer.type] = markerLandmarkLayer, overlays[trackLayer.type] = trackLayer, overlays[gisMap.type] = gisMap; class Focus extends BaseComponent { constructor() { super(), this.type = "focus", this.interfaceList = ["focusById", "focusByType", "focusByLayer", "focusByLegend", "focusModel", "focusModelByType", "focusFloor", "focusRoom", "focusBuilding"] } focusById({ id: e, overlayType: t, distance: i } = {}, r) { if ("3dtile" == t.toLowerCase()) return this.scene.setCameraTo3DTile(e, .5, { distance: i }), void (r && r({ result: 1, message: "成功。" })); if (!overlays[t]) return void (r && r({ result: 0, message: `失败，不存在 ${t} 类型覆盖物。` })); let n = overlays[t].getLayer(e); if (!n) return void (r && r({ result: 0, message: `失败，不存在 ${e} 覆盖物。` })); let a = n.getPositions(); if (0 == a.length) return void (r && r({ result: 0, message: "失败，未找到覆盖物。" })); overlays[t].onFocusEvent({ type: "focusStart", layerId: e }); let { center: o, distance: s } = this._boxVisualCalc(a); void 0 === i && (i = s); let l = new Camera$1({ target: o, posture: [0, -45, 0], distance: i }); this.scene.setCamera(l, .5, (() => { overlays[t].onFocusEvent({ type: "focusEnd", layerId: e }) })), r && r({ result: 1, message: "成功。" }) } focusByType({ overlayType: e } = {}, t) { if (!overlays[e]) return void (t && t({ result: 0, message: `失败，不存在 ${e} 类型覆盖物。` })); let i = [], r = overlays[e].getLayers(); for (const e of r) i.push(...e.getPositions()); if (0 == i.length) return void (t && t({ result: 0, message: "失败，未找到覆盖物。" })); overlays[e].onFocusEvent({ type: "focusAllStart" }); let { center: n, distance: a } = this._boxVisualCalc(i), o = new Camera$1({ target: n, posture: [0, -45, 0], distance: a }); this.scene.setCamera(o, 0, (() => { overlays[e].onFocusEvent({ type: "focusAllEnd" }) })), t && t({ result: 1, message: "成功。" }) } focusByLayer({ id: e, idLayer: t, layerType: i, distance: r } = {}, n) { if (!overlays[i]) return void (n && n({ result: 0, message: `失败，不存在 ${i} 类型覆盖物。` })); let a = overlays[i].getLayer(t); if (!a) return void (n && n({ result: 0, message: `失败，不存在 ${t} 覆盖物图层。` })); let o = a.getPositionsByDataId(e); if (0 == o.length) return void (n && n({ result: 0, message: "失败，未找到覆盖物。" })); overlays[i].onFocusEvent({ type: "focusLayerStart", layerId: t, dataId: e }); let { center: s } = this._boxVisualCalc(o), l = new Camera$1({ target: s, posture: [0, -45, 0], distance: r }); this.scene.setCamera(l, 0, (() => { overlays[i].onFocusEvent({ type: "focusLayerEnd", layerId: t, dataId: e }) })), n && n({ result: 1, message: "成功。" }) } focusByLegend({ legend: e, idLayer: t, layerType: i } = {}, r) { if (!overlays[i]) return void (r && r({ result: 0, message: `失败，不存在 ${i} 类型覆盖物。` })); let n = overlays[i].getLayer(t); if (!n) return void (r && r({ result: 0, message: `失败，不存在 ${t} 覆盖物图层。` })); let a = n.getPositionsByLegend(e); if (0 == a.length) return void (r && r({ result: 0, message: "失败，未找到覆盖物。" })); overlays[i].onFocusEvent({ type: "focusLegendStart", layerId: t, legend: e }); let { center: o, distance: s } = this._boxVisualCalc(a), l = new Camera$1({ target: o, posture: [0, -45, 0], distance: s }); this.scene.setCamera(l, 0, (() => { overlays[i].onFocusEvent({ type: "focusLegendEnd", layerId: t, legend: e }) })), r && r({ result: 1, message: "成功。" }) } focusModel({ id: e, modelType: t, distance: i }, r) { let n = t.toLowerCase(); if ("model" == n) n = "ModelItem"; else { if ("building" != n) return void (r && r({ result: 0, message: `失败，不支持 ${t} 类型。` })); n = "BuildingItem" } let a = { id: e }, o = this.scene.getSceneObjects().find((t => t.name == e)); o && o.type === n ? (this.scene.tgapp.triggerEvent.onFocusModelStart && this.scene.tgapp.triggerEvent.onFocusModelStart(a), this.scene.setCameraToModel(o.name, 0, { distance: i }), this.scene.tgapp.triggerEvent.onFocusModelEnd && this.scene.tgapp.triggerEvent.onFocusModelEnd(a), r && r({ result: 1, message: "成功。" })) : r && r({ result: 0, message: `失败，未找到 ${t} 类型的 ${e}。` }) } focusModelByType({ modelType: e }, t) { let i = e.toLowerCase(); if ("model" == i) i = "ModelItem"; else { if ("building" != i) return void (t && t({ result: 0, message: `失败，不支持 ${e} 类型。` })); i = "BuildingItem" } let r = this.scene.getSceneObjects(); r = r.filter((e => e.type == i)); let n = []; if (r.map((e => { let t = this.scene.getModelBox(e.name); n.push((new Position).set(t.max.x, t.max.y, t.max.z)), n.push((new Position).set(t.min.x, t.min.y, t.min.z)) })), 0 == n.length) return void (t && t({ result: 0, message: "失败，未找到模型。" })); "ModelItem" === i ? this.scene.tgapp.triggerEvent.onFocusAllModelStart && this.scene.tgapp.triggerEvent.onFocusAllModelStart({}) : "BuildingItem" === i && this.scene.tgapp.triggerEvent.onFocusAllBuildingStart && this.scene.tgapp.triggerEvent.onFocusAllBuildingStart({}); let { center: a, distance: o } = this._boxVisualCalc(n), s = new Camera$1({ target: a, posture: [0, -45, 0], distance: o }); this.scene.setCamera(s, 0), "ModelItem" === i ? this.scene.tgapp.triggerEvent.onFocusAllModelEnd && this.scene.tgapp.triggerEvent.onFocusAllModelEnd({}) : "BuildingItem" === i && this.scene.tgapp.triggerEvent.onFocusAllBuildingEnd && this.scene.tgapp.triggerEvent.onFocusAllBuildingEnd({}), t && t({ result: 1, message: "成功。" }) } focusBuilding(e, t) { if (!e) return void (t && t({ result: 0, message: "参数异常" })); let i = this.scene.getSceneObjects().find((t => t.name == e.buildingId && "BuildingItem" == t.type)); if (!i) return void (t && t({ result: 0, message: `失败，未找到id为的${e.buildingId}建筑。` })); let r = { id: e.buildingId }; this.scene.tgapp.triggerEvent.onFocusBuildingStart && this.scene.tgapp.triggerEvent.onFocusBuildingStart(r), this.scene.setCameraToModel(i.name, 0, { distance: e.distance }), this.scene.tgapp.triggerEvent.onFocusBuildingEnd && this.scene.tgapp.triggerEvent.onFocusBuildingEnd(r), t && t({ result: 1, message: "成功。" }) } focusFloor(e, t) { this.scene.focusFloor(e, t, { onFocusFloorStart: this.scene.tgapp.triggerEvent.onFocusFloorStart, onFocusFloorEnd: this.scene.tgapp.triggerEvent.onFocusFloorEnd }) } focusRoom(e, t) { t && t({ result: 0, message: "工程师小哥努力实现中..." }) } _boxVisualCalc(e) { for (let t of e) if ("lla" === t.type) { let e = this.scene.convertLLAToXYZ(t); t.x = e.x, t.y = e.y, t.z = e.z } let t = e[0], i = 100; if (1 != e.length) { let r = e.sort(((e, t) => e.x - t.x)), n = (r[0].x + r[r.length - 1].x) / 2, a = r[0].x, o = e.sort(((e, t) => e.y - t.y)), s = (o[0].y + o[o.length - 1].y) / 2, l = o[0].y, c = e.sort(((e, t) => e.z - t.z)), h = (c[0].z + c[c.length - 1].z) / 2, u = c[0].z; t = (new Position).set(n, s, h); let d = (new Position).set(a, l, u); i = this.scene.getDistanceByPositions(t, d) / this.scene.getWorldScale(), i < 100 && (i = 100) } return { center: t, distance: 3 * i } } } const focus = new Focus; class Other extends BaseComponent { constructor() { super(), this.type = "Other", this.interfaceList = ["getStates", "switchState", "setEnvTime", "setEnvWeather", "takeSnapshot", "getScenesInfo", "showSceneInfo", "setResolution", "getAppInfo", "addWatermark", "removeWatermark", "setLogMode", "setCompass", "setSceneEffect", "switchService", "loadService", "getServicesInfo"] } getStates({ }, e) { let t = this.scene.getStates(); e && e({ result: 1, message: "成功。", states: t }) } switchState(e, t) { null == e.duration && (e.duration = 1), this.scene.switchState(e.name, ((e, i) => { e ? t && t({ result: 1, message: "成功。" }) : t && t({ result: 0, message: `失败，${i}` }) }), this.scene.tgapp.triggerEvent.onStateSwitch) } setEnvTime(e, t) { let i = this.scene.setEnvTime(e); t && t({ result: i.result, message: 0 === i.result ? i.message : "成功。" }) } setEnvWeather({ envWeather: e }, t) { this.scene.removeRain("lightrain"), this.scene.removeRain("lightsnow"), this.scene.removeRain("moderaterain"), this.scene.removeRain("moderatesnow"), this.scene.removeRain("heavyrain"), this.scene.removeRain("heavysnow"); let i = e.toLowerCase(), r = 10, n = 100, a = "snow"; switch (i) { case "lightrain": r = 5, n = 16e3, a = "rain"; break; case "lightsnow": r = 3, n = 1e4; break; case "moderaterain": r = 10, n = 2e4, a = "rain"; break; case "moderatesnow": r = 5, n = 16e3; break; case "heavyrain": r = 15, n = 5e4, a = "rain"; break; case "heavysnow": r = 10, n = 2e4; break; case "sunny": return void (t && t({ result: 1, message: "成功。" })); default: return void (t && t({ result: 0, message: `失败，天气 ${e} 暂不支持。` })) }this.scene.setWeather({ name: i, size: r, density: n, type: a, direction: 0, followCamera: !0, typeOnly: !0 }, t) } async getScenesInfo({ }, e) { let t = { result: 1, message: "成功。", mode: "scene", scenes: {} }; t.scenes.name = this.scene.getSceneName(), t.scenes.default = !0, t.scenes.url = this.scene.tgapp.url, t.scenes.token = this.scene.tgapp.token; let i = await this.scene.getSceneIconAssets(); t.customIcons = i.map((e => ({ name: `custom-${e.name}`, url: "", bitmap: e.src }))); let r = this.scene.getSceneModelAssets(); r = r.filter((e => !0 === e.isCustom)), t.customModels = r.map((e => e.name)), e && e(t) } getAppInfo({ }, e) { e && e({ result: 1, message: "成功。", tgApiSdkVer: "3.3", tgApiDocUrl: "https://www.tuguan.net/doc/tg-api/", sceneSdkVer: "3.3.3", clientWidth: this.scene.tgapp.container.scrollWidth, clientHeight: this.scene.tgapp.container.scrollHeight }) } showSceneInfo({ isOpen: e = !1 }, t) { this.scene.showFPSPanel(e), t && t({ result: 1, message: "成功。" }) } async addWatermark(e, t) { if (e.scale < .01 || e.scale > 100) return void (t && t({ result: 0, message: "失败，scale 属性值错误。" })); if (e.alpha < 0 || e.alpha > 1) return void (t && t({ result: 0, message: "失败，alpha 属性值错误。" })); "middle" === (e = this.deepCopy(e)).dockVertical && (e.dockVertical = "center"), "middle" === e.dockHorizontal && (e.dockHorizontal = "center"); let i = await this.scene.addWatermark(e.watermarkId, e); 1 === i.result ? t && t({ result: 1, message: "成功。" }) : t && t({ result: 0, message: `失败，${i.message}` }) } async removeWatermark(e, t) { let i = await this.scene.removeWatermark(e.watermarkId); 1 === i.result ? t && t({ result: 1, message: "成功。" }) : t && t({ result: 0, message: `失败，${i.message}` }) } takeSnapshot({ width: e, height: t, encoder: i } = {}, r) { let n = this.scene.takeSnapshot(e, t, i); r && r({ result: 1, message: "成功。", snapshot: n }) } setResolution(e, t) { e.width > this.scene.tgapp.container.scrollWidth && (e.width = this.scene.tgapp.container.scrollWidth), e.height > this.scene.tgapp.container.scrollHeight && (e.height = this.scene.tgapp.container.scrollHeight - 4), this.scene.setResolution(e), this.scene.tgapp.triggerEvent.onResolutionChange({ width: e.width, height: e.height }), t && t({ result: 1, message: "成功。" }) } setLogMode({ mode: e = !1 }, t) { debug(e), t && t({ result: 1, message: "成功。" }) } async setCompass(e, t) { "middle" === (e = this.deepCopy(e)).dockHorizontal && (e.dockHorizontal = "center"), "middle" === e.dockVertical && (e.dockVertical = "center"), await this.scene.setCompass(e), t && t({ result: 1, message: "成功。" }) } setSceneEffect(e, t) { this.scene.setSceneEffect(e), t && t({ result: 1, message: "成功。" }) } switchService(e, t) { this.scene.switchService(e, (e => { if (1 !== e.result) return void (t && t(e)); const i = this.scene.getStates(); this.scene.switchState(i[0].name, (async () => { t && t(e) })) }), this.scene.tgapp.triggerEvent.onServiceSwitch) } loadService(e, t) { "scene" !== e.mode.toLowerCase() && t && t({ result: 0, message: "暂不支持流渲染模式" }), this.scene.loadService(e, t, this.scene.tgapp.triggerEvent.onServiceLoad) } getServicesInfo(e, t) { this.scene.getServicesInfo(t) } } const other = new Other; class Datum extends BaseComponent { constructor() { super(), this.type = "Datum", this.interfaceList = ["getBaseCenter", "setBaseCenter", "getDefaultBaseCenter", "resetDefaultBaseCenter", "pickScreen"] } pickScreen(e, t) { this.scene.pickScreenToWorld(e, t) } setScene(e) { super.setScene(e), this.defaultDatum = this.scene.getDatumShiftModel(), this.currentOrigin = this._getDefaultOrigin() } getBaseCenter({ }, e) { this.defaultDatum ? e && e({ result: 1, message: "成功。", ...this.currentOrigin }) : e && e({ result: 0, message: "失败，没有基准设置。" }) } setBaseCenter({ originLon: e, originLat: t, originHeight: i }, r) { this.defaultDatum && "none" != this.defaultDatum.editor.mode || (this.defaultDatum = { alt: 0, lat: 0, lon: 0, positionType: "basepoint", scaleX: 1, scaleY: 1, scaleZ: 1, type: "surface" }); let n = JSON.parse(JSON.stringify(this.defaultDatum)); if ("mercator" === n.type) { let r = this._lonLatToWebMercator(e, t); n.lon = -r.x, n.lat = r.y, n.alt = -i } else n.lon = e, n.lat = t, n.alt = i; this.currentOrigin.originLon = e, this.currentOrigin.originLat = t, this.currentOrigin.originHeight = i, this.scene.setDatumShiftModel(n), r && r({ result: 1, message: "成功。" }) } getDefaultBaseCenter({ }, e) { this.defaultDatum ? e && e({ result: 1, message: "成功。", ...this._getDefaultOrigin() }) : e && e({ result: 0, message: "失败，没有基准设置。" }) } resetDefaultBaseCenter({ }, e) { this.defaultDatum ? (this.currentOrigin = this._getDefaultOrigin(), this.scene.setDatumShiftModel(this.defaultDatum), e && e({ result: 1, message: "成功。" })) : e && e({ result: 0, message: "失败，没有基准设置。" }) } _getDefaultOrigin() { let e = { originLon: 0, originLat: 0, originHeight: 0 }; return this.defaultDatum ? ("surface" === this.defaultDatum.type ? (e.originLon = this.defaultDatum.lon, e.originLat = this.defaultDatum.lat, e.originHeight = this.defaultDatum.alt) : "mercator" === this.defaultDatum.type && (e.originLon = this.defaultDatum.origin[0], e.originLat = this.defaultDatum.origin[1], e.originHeight = -this.defaultDatum.alt), e) : e } _lonLatToWebMercator(e, t) { if ("number" != typeof e || "number" != typeof t) return { x: 0, y: 0 }; let i = 20037508.34 * e / 180, r = Math.log(Math.tan((90 + t) * Math.PI / 360)) / (Math.PI / 180); return r = 20037508.34 * r / 180, { x: i, y: r } } } const datum = new Datum; class EventListener extends BaseComponent { constructor() { super(), this.type = "eventListener", this.interfaceList = ["addEventListener", "removeEventListener"] } setScene(e) { super.setScene(e) } addEventListener(e, t) { for (const t in overlays) { const i = overlays[t]; i.addSceneEventListener && i.addSceneEventListener(e.eventName) } models.addSceneEventListener(e.eventName), t && t({ result: 1, message: "成功。" }) } removeEventListener(e, t) { for (const t in overlays) { const i = overlays[t]; i.removeSceneEventListener && i.removeSceneEventListener(e.eventName) } models.removeSceneEventListener(e.eventName), t && t({ result: 1, message: "成功。" }) } } const eventListener = new EventListener, TERRAIN_DATA_ID = "_terrain_data_id_"; class Terrain extends BaseComponent { constructor() { super(), this.type = "terrain", this.interfaceList = ["switchChinaMap", "highlightProvince", "setProvinceNameVisible", "focusChinaMap", "focusProvince"] } setScene(e) { const t = this; super.setScene(e), this.preloadScene = {}, this.defaultScene = "", this.currentScene = "", this.scene.getServicesInfo((function ({ services: e = [] } = {}) { t.defaultScene = e[0].name, async function () { const e = resource.getTerrains(); if (!Array.isArray(e)) return; const i = e.filter((e => !0 === e.commonProperty)), r = i[i.length - 1] || {}, n = e.filter((e => !0 === e.preload)); for (const i of n) { if (!0 === i.commonProperty) { logger.warn("预加载场景：公共属性无需执行预加载。"); continue } if (!i.url) { logger.warn(`预加载场景：${i.name} 的链接无效。`); continue } let n = ""; !i.tokenUrl || (n = await a(i.tokenUrl), n) ? t.scene.loadService({ name: i.name, url: i.url, token: n }, (function ({ result: n } = {}) { if (1 !== n) return void logger.warn(`预加载场景：${i.name}，的 token 获取错误。`); const a = { terrain: i, landmarks: {}, areas: {}, common: r }, o = e.filter((e => e.parent === i.name)); for (const e of o) a.landmarks[e.name] = { coord: e.center }, a.areas[e.name] = { coords: e.boundary }; t.preloadScene[i.name] = a })) : logger.error(`预加载场景：${i.name} 的 token 获取错误。`) } function a(e) { return new Promise(((t, i) => { try { const i = new XMLHttpRequest; i.open("post", e, !0), i.setRequestHeader("Content-Type", "application/json charset=utf-8"), i.timeout = 1e3, i.onreadystatechange = function () { if (4 == i.readyState && 200 == i.status) { const e = JSON.parse(i.responseText); t(e.accessToken) } }, i.ontimeout = function () { t() }, i.send(JSON.stringify({ password: "sfasds" })) } catch (e) { t() } })) } }() })) } switchChinaMap({ visible: e }, t) { const i = this; if (!0 == !!e) { const e = "中国"; if (this.currentScene === e) return void (t && t({ result: 0, message: `失败，当前已经在 ${this.currentScene} 地块。` })); this.scene.switchService({ name: e }, (async function ({ result: t } = {}) { 1 === t && void 0 !== i.preloadScene[e] && (i.currentScene = e, async function (e) { const t = e.common, r = e.landmarks, n = 1 === t.coordType ? "xyz" : "lla"; for (const e in r) { const a = r[e], o = await resource.getIconAsset(t.iconName); o.name = e, o.label = !0, o.labelText = e, void 0 === a.coord[2] && (a.coord[2] = t.coordZ), o.position = new Position(n), "lla" === n ? o.position.set(a.coord[0], a.coord[1], a.coord[2]) : "xyz" === n && o.position.set(a.coord[0], a.coord[2], a.coord[1]), await i.scene.addLandmark(TERRAIN_DATA_ID, o), a.visible = function (t) { t ? i.scene.showDrawable(TERRAIN_DATA_ID, e) : i.scene.hideDrawable(TERRAIN_DATA_ID, e) } } }(i.preloadScene[e]), async function (e) { const t = e.common, r = e.areas, n = 1 === t.coordType ? "xyz" : "lla"; for (const e in r) { const a = r[e], o = JSON.parse(a.coords); a.positions = []; const s = o.length; for (let r = 0; r < s; r++) { const s = o[r]; if (s.length <= 0) continue; const l = { label: !1, isShow: !1 }; l.name = `${e}-${r}`, l.areaType = t.areaType, l.color = t.areaColor, l.depth = t.areaHeight, l.fillArea = t.fillArea, l.fillType = t.fillPosition, l.lineColor = t.color, l.isShow = !1, l.points = []; for (const e of s) { void 0 === e[2] && (e[2] = t.coordZ); const i = new Position(n); "lla" === n ? i.set(e[0], e[1], e[2]) : "xyz" === n && i.set(e[0], e[2], e[1]), l.points.push(i) } a.positions.push(...l.points), i.scene.addArea(TERRAIN_DATA_ID, l) } a.visible = function (t, r) { const n = a.coords.length; for (let a = 0; a < n; a++) { const n = { isShow: t }; void 0 !== r && (n.color = r, n.lineColor = r), i.scene.updateArea(TERRAIN_DATA_ID, `${e}-${a}`, n) } } } }(i.preloadScene[e])) })) } else i.scene.removeLayer(TERRAIN_DATA_ID), this.scene.switchService({ name: this.defaultScene }, (() => { })), this.currentScene = ""; t && t({ result: 1, message: "成功。" }) } highlightProvince({ province: e, type: t, color: i }, r) { if (void 0 === this.preloadScene[this.currentScene]) return void (r && r({ result: 0, message: "失败，当前没有应用内置地块。" })); const n = this.preloadScene[this.currentScene]; for (const r in n.areas) "all" !== t && e !== r ? n.areas[r].visible && n.areas[r].visible(!1) : n.areas[r].visible && n.areas[r].visible(!0, i) } setProvinceNameVisible({ province: e, visible: t }, i) { if (void 0 === this.preloadScene[this.currentScene]) return void (i && i({ result: 0, message: "失败，当前没有应用内置地块。" })); const r = this.preloadScene[this.currentScene]; if ("all" === e) for (const e in r.landmarks) r.landmarks[e].visible && r.landmarks[e].visible(t); else { if (void 0 === r.landmarks[e]) return void (i && i({ result: 0, message: `失败，没有 ${e} 名称地标。` })); r.landmarks[e].visible && r.landmarks[e].visible(t) } i && i({ result: 0, message: "成功。" }) } focusChinaMap({ style: e }, t) { if (void 0 === this.preloadScene[this.currentScene]) return void (t && t({ result: 0, message: "失败，当前没有应用内置地块。" })); const i = this.preloadScene[this.currentScene].terrain, r = this.preloadScene[this.currentScene].common; void 0 === i.center[2] && (i.center[2] = r.coordZ); const n = 1 === r.coordType ? "xyz" : "lla", a = new Position(n); "lla" === n ? a.set(i.center[0], i.center[1], i.center[2]) : "xyz" === n && a.set(i.center[0], i.center[2], i.center[1]); let o = new Camera$1({ target: a, posture: [0, -45, 0], distance: 6e6 }); this.scene.tgapp.triggerEvent.onFocusChinaMapStart({}), this.scene.setCamera(o, .5, (() => { this.scene.tgapp.triggerEvent.onFocusChinaMapEnd({}) })), t && t({ result: 1, message: "成功。" }) } focusProvince({ province: e, distance: t }, i) { const r = this; if (void 0 === this.preloadScene[this.currentScene]) return void (i && i({ result: 0, message: "失败，当前没有应用内置地块。" })); const n = this.preloadScene[this.currentScene].areas; if (void 0 === n[e]) return void (i && i({ result: 0, message: `失败，没有 ${e} 地块。` })); const { center: a, distance: o } = function (e) { for (let t of e) if ("lla" === t.type) { let e = r.scene.convertLLAToXYZ(t); t.x = e.x, t.y = e.y, t.z = e.z } let t = e[0], i = 100; if (1 != e.length) { let n = e.sort(((e, t) => e.x - t.x)), a = (n[0].x + n[n.length - 1].x) / 2, o = n[0].x, s = e.sort(((e, t) => e.y - t.y)), l = (s[0].y + s[s.length - 1].y) / 2, c = s[0].y, h = e.sort(((e, t) => e.z - t.z)), u = (h[0].z + h[h.length - 1].z) / 2, d = h[0].z; t = (new Position).set(a, l, u); let p = (new Position).set(o, c, d); i = r.scene.getDistanceByPositions(t, p) / r.scene.getWorldScale(), i < 100 && (i = 100) } return { center: t, distance: 3 * i } }(n[e].positions); void 0 === t && (t = o); let s = new Camera$1({ target: a, posture: [0, -45, 0], distance: t }); this.scene.tgapp.triggerEvent.onFocustProvinceStart({ name: e }), this.scene.setCamera(s, .5, (() => { this.scene.tgapp.triggerEvent.onFocustProvinceEnd({ name: e }) })), i && i({ result: 1, message: "成功。" }) } } const terrain = new Terrain; class Protects extends BaseComponent { constructor() { super(), this.type = "protects", this.interfaceList = ["invokeCore"] } invokeCore(e, t) { const i = []; for (const t in e) i.push(e[t]); const r = this.scene.invokeCore(...i); t && t({ result: 1, message: "成功。", data: r }) } } const protects = new Protects, components = {}; components[resource.type] = resource, components[camera.type] = camera, components[focus.type] = focus, components[controller.type] = controller, components[datum.type] = datum, components[other.type] = other, components[models.type] = models, components[agg.type] = agg, components[eventListener.type] = eventListener, components[terrain.type] = terrain, Object.assign(components, overlays), components[protects.type] = protects; class TGScene2Renderer { constructor() { this.container = null, this.url = "", this.token = "", this.resourceBasePath = "", this.resolution = null, this.events = null, this.serviceName = "", this.scene = null } init(e, t, i) { const { container: r, url: n, token: a, resourceBasePath: o, resolution: s, events: l, name: c, editMode: h, performanceSuggest: u } = e || {}; if (this.container = r, this.url = n, this.token = a, this.resourceBasePath = o, this.resolution = s, this.events = l, this.editMode = h, this.serviceName = c, this.performanceSuggest = u, !this.resourceBasePath) { this.resourceBasePath = "./scene"; const e = document.querySelector("script[tgapp]"); if (null !== e) { const t = e.src.lastIndexOf("/"); this.resourceBasePath = e.src.substring(0, t), this.resourceBasePath += "/scene" } } this._loadScene(t, i) } _loadScene(e, t) { this.scene = scene$1({ url: this.url, additionalInfo: { resourceBasePath: this.resourceBasePath } }), this._initEventFrame(), this.scene.tgapp.triggerEvent.onServiceConnected({}); let i = { container: this.container, accessToken: this.token, editMode: this.editMode, performanceSuggest: this.performanceSuggest }; this.resolution && (i.width = this.resolution[0] > 4096 ? 4096 : this.resolution[0], i.height = this.resolution[1] > 2160 ? 2160 : this.resolution[1]), "" != this.serviceName && (i.serviceName = this.serviceName), this.scene.init(i, (t => this._sceneLoaded(t, e)), t), this.scene.setMark(!0) } _initEventFrame() { this.scene.tgapp = { container: this.container, url: this.url, token: this.token, resourceBasePath: this.resourceBasePath, resolution: this.resolution }, this.scene.tgapp.events = this.events, this.scene.tgapp.oldEvents = {}; for (const e in this.events) this[e] = (t, i) => { this.scene.tgapp.oldEvents[e] = i }; this.scene.tgapp.triggerEvent = {}; for (const e in this.events) this.scene.tgapp.triggerEvent[e] = t => { this.scene.tgapp.events[e].map((e => e(t))), this.scene.tgapp.oldEvents[e] && this.scene.tgapp.oldEvents[e](t) } } async _sceneLoaded(e, t) { if (1 != e) return void (t && t({ result: 0, message: "失败，场景未能正常加载。" })); this.scene.on("click", "scene", (e => { const t = { data: [{ coord: [e.longitude, e.latitude], coordZ: e.altitude, coordType: 0 }, { coord: [e.clickX, e.clickZ], coordZ: e.clickY, coordType: 1 }] }; !0 === e.upFlag && (t.source = 0 === e.button ? "leftButtonUp" : "rightButtonUp"), this.scene.tgapp.triggerEvent.onSceneClick(t) })); for (const e in components) { let t = components[e]; if (t.isComponent) { t.setScene(this.scene); let e = t.getInterface(); for (const i of e) this[i] = t[i].bind(t) } t.isResource && await t.setResourcePath(`${this.resourceBasePath}/resource`) } const i = this.scene.getStates(); this.scene.switchState(i[0].name, (async () => { this.scene.setMark(!1), this.scene.tgapp.triggerEvent.onServiceInit({ name: this.serviceName, default: !0 }), t && t({ result: 1, message: "成功。" }) })) } destroy({ }, e) { this.scene ? (this.scene.off("click", "scene"), this.scene.destroy(), this.scene = null, e && e({ result: 1, message: "成功。" })) : e && e({ result: 0, message: "失败，试图销毁已经销毁的场景。" }) } _debug() { console.log({ scene: this.scene, components: components, core: this.scene._debugCore(), context: this.scene._debugCore()._debug().context }) } } class TGRendererFactory { constructor() { this.getRenderer = ({ mode: e = "", url: t = "", container: i } = {}) => { switch (e.toLowerCase()) { case "streaming3": return new TGStreaming3Renderer({ url: t, container: i }); case "scene2": return new TGScene2Renderer({ container: i }) } } } } class EventRegister { constructor(e) { this.events = e } register() { let e = this; Object.keys(eventMap).forEach((t => { e.events[t] || (e.events[t] = []) })) } } class App { constructor() { const e = {}; let t = function (t, i) { let r = t.eventName; e[r] || (r = "on" + r.replace(r[0], r[0].toUpperCase()), e[r]) ? t.callback ? -1 == e[r].findIndex((e => e == t.callback)) ? (e[r].push(t.callback), this.renderer && this.renderer.addEventListener ? this.renderer.addEventListener(t, i) : i && i({ result: 1, message: "成功。" })) : i && i({ result: 0, message: `失败，事件 ${t.eventName} 已注册此回调。` }) : i && i({ result: 0, message: "失败，添加事件监听的回调函数不应为空。" }) : i && i({ result: 0, message: `失败，事件 ${t.eventName} 不存在。` }) }, i = function (t, i) { let r = t.eventName; if (!e[t.eventName] && (r = "on" + r.replace(r[0], r[0].toUpperCase()), !e[r])) return void (i && i({ result: 0, message: `失败，事件 ${t.eventName} 不存在。` })); if (!t.callback) return e[r] = [], void (this.renderer && this.renderer.removeEventListener ? this.renderer.removeEventListener(t, i) : i && i({ result: 1, message: "成功。" })); let n = e[r].findIndex((e => e == t.callback)); -1 != n ? (e[r].splice(n, 1), this.renderer && this.renderer.removeEventListener ? this.renderer.removeEventListener(t, i) : i && i({ result: 1, message: "成功。" })) : i && i({ result: 0, message: `失败，事件 ${t.eventName} 未注册此回调。` }) }; new EventRegister(e).register(), window.onbeforeunload = function () { for (const t of e.onBrowserClose) t({}) }, document.addEventListener("visibilitychange", (function () { if (document.hidden) for (const t of e.onBrowserMinimize) t({}) })), this.about = new About, this.about.print(); var r = new TGRendererFactory; this.initScene = (e, t, i) => { this.initService(e, (function ({ result: e }) { t && t({ result: e, message: "此接口已过期，请使用 initService 接口。" }) }), i) }, this.initService = ({ container: t, mode: i = "", url: n = "", token: a = "", resourceBasePath: o, resolution: s, isShareToken: l = !1, showDefaultLoading: c = !0, name: h, editMode: u = !1, useTCP: d = !0, performanceSuggest: p } = {}, f, m) => { if (logger.debug({ url: n, token: a, mode: i }), "scene" === i ? i = "scene2" : "streaming" === i && (i = "streaming3"), this.renderer = r.getRenderer({ mode: i }), !this.renderer) return logger.error("初始化失败：未初始化渲染器。"), void (Util.isFunction(f) && f({ result: 0, message: "初始化失败：未初始化渲染器。" })); TGInterface.ensureImplements(this.renderer, TGRendererInterface), this.renderer.init({ container: t, url: n, token: a, resourceBasePath: o, resolution: s, isShareToken: l, events: e, showDefaultLoading: c, name: h, editMode: u, useTCP: d, performanceSuggest: p }, f, m), this.container = t }, this.uniCall = (r = "", n = {}, a) => { if (logger.debug({ method: r, params: n }), "addEventListener" !== r) if ("removeEventListener" !== r) { if (!this.renderer) return logger.error("调用接口失败：未初始化渲染器。"), void (Util.isFunction(a) && a({ result: 0, message: "调用接口失败：未初始化渲染器。" })); if (!Util.isStringNotEmpty(r)) return logger.warn("调用接口失败：必须提供接口名称。"), void (Util.isFunction(a) && a({ result: 0, message: "调用接口失败：必须提供接口名称。" })); if ("function" != typeof this.renderer[r]) return window.notArr || (window.notArr = []), notArr.push(r), logger.warn(`调用接口失败：请求的接口（${r}）不存在。`), void (Util.isFunction(a) && a({ result: 0, message: `调用接口失败：请求的接口（${r}）不存在。` })); if ("destroy" === r) for (const t in e) e[t] = []; this.renderer[r](n, a) } else i.call(this, n, a); else t.call(this, n, a) } } } exports.App = App, Object.defineProperty(exports, "__esModule", { value: !0 })
}));
